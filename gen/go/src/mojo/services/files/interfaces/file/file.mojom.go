// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/services/files/interfaces/file.mojom
//

package file

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	types "mojo/services/files/interfaces/types"
	fmt "fmt"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
)


type File interface {
	Close() (outErr types.Error, err error)
	Read(inNumBytesToRead uint32, inOffset int64, inWhence types.Whence) (outError types.Error, outBytesRead *[]uint8, err error)
	Write(inBytesToWrite []uint8, inOffset int64, inWhence types.Whence) (outError types.Error, outNumBytesWritten uint32, err error)
	ReadToStream(inSource system.ProducerHandle, inOffset int64, inWhence types.Whence, inNumBytesToRead int64) (outError types.Error, err error)
	WriteFromStream(inSink system.ConsumerHandle, inOffset int64, inWhence types.Whence) (outError types.Error, err error)
	Tell() (outError types.Error, outPosition int64, err error)
	Seek(inOffset int64, inWhence types.Whence) (outError types.Error, outPosition int64, err error)
	Stat() (outError types.Error, outFileInformation *types.FileInformation, err error)
	Truncate(inSize int64) (outError types.Error, err error)
	Touch(inAtime *types.TimespecOrNow, inMtime *types.TimespecOrNow) (outError types.Error, err error)
	Dup(inFile File_Request) (outError types.Error, err error)
	Reopen(inFile File_Request, inOpenFlags uint32) (outError types.Error, err error)
	AsBuffer() (outError types.Error, outBuffer *system.SharedBufferHandle, err error)
	Ioctl(inRequest uint32, inInValues *[]uint32) (outError types.Error, outOutValues *[]uint32, err error)
}




type File_Request bindings.InterfaceRequest



type File_Pointer bindings.InterfacePointer


type File_ServiceFactory struct{
	Delegate File_Factory
}

type File_Factory interface {
	Create(request File_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *File_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &File_ServiceDescription{}
}

func (f *File_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := File_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForFile creates a message pipe for use with the
// File interface with a File_Request on one end and a File_Pointer on the other.
func CreateMessagePipeForFile() (File_Request, File_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return File_Request(r), File_Pointer(p)
}

const file_Close_Name uint32 = 0
const file_Read_Name uint32 = 1
const file_Write_Name uint32 = 2
const file_ReadToStream_Name uint32 = 3
const file_WriteFromStream_Name uint32 = 4
const file_Tell_Name uint32 = 5
const file_Seek_Name uint32 = 6
const file_Stat_Name uint32 = 7
const file_Truncate_Name uint32 = 8
const file_Touch_Name uint32 = 9
const file_Dup_Name uint32 = 10
const file_Reopen_Name uint32 = 11
const file_AsBuffer_Name uint32 = 12
const file_Ioctl_Name uint32 = 13

type File_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewFileProxy(p File_Pointer, waiter bindings.AsyncWaiter) *File_Proxy {
	return &File_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *File_Proxy) Close_Proxy() {
	p.router.Close()
}

type file_Close_Params struct {
}


func (s *file_Close_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Close_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *file_Close_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Close_Params_Versions), func(i int) bool {
		return file_Close_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Close_Params_Versions) {
		if file_Close_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Close_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_Close_ResponseParams struct {
	outErr types.Error
}


func (s *file_Close_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.outErr)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Close_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *file_Close_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Close_ResponseParams_Versions), func(i int) bool {
		return file_Close_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Close_ResponseParams_Versions) {
		if file_Close_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Close_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outErr = types.Error(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) Close() (outErr types.Error, err error) {
	payload := &file_Close_Params{
	}
	header := bindings.MessageHeader{
		Type: file_Close_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_Close_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_Close_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outErr = response.outErr
	return
}

type file_Read_Params struct {
	inNumBytesToRead uint32
	inOffset int64
	inWhence types.Whence
}


func (s *file_Read_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteUint32(s.inNumBytesToRead); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.inWhence)); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.inOffset); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Read_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *file_Read_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Read_Params_Versions), func(i int) bool {
		return file_Read_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Read_Params_Versions) {
		if file_Read_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Read_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.inNumBytesToRead = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inWhence = types.Whence(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.inOffset = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_Read_ResponseParams struct {
	outError types.Error
	outBytesRead *[]uint8
}


func (s *file_Read_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInt32(int32(s.outError)); err != nil {
		return err
	}
	if s.outBytesRead == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.outBytesRead))), 8)
		for _, elem0 := range (*s.outBytesRead) {
			if err := encoder.WriteUint8(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Read_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *file_Read_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Read_ResponseParams_Versions), func(i int) bool {
		return file_Read_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Read_ResponseParams_Versions) {
		if file_Read_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Read_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outError = types.Error(value0)
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.outBytesRead = nil
		} else {
			s.outBytesRead = new([]uint8)
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			(*s.outBytesRead) = make([]uint8, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadUint8()
				if err != nil {
					return err
				}
				(*s.outBytesRead)[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) Read(inNumBytesToRead uint32, inOffset int64, inWhence types.Whence) (outError types.Error, outBytesRead *[]uint8, err error) {
	payload := &file_Read_Params{
		inNumBytesToRead,
		inOffset,
		inWhence,
	}
	header := bindings.MessageHeader{
		Type: file_Read_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_Read_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_Read_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outError = response.outError
	outBytesRead = response.outBytesRead
	return
}

type file_Write_Params struct {
	inBytesToWrite []uint8
	inOffset int64
	inWhence types.Whence
}


func (s *file_Write_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.inBytesToWrite)), 8)
	for _, elem0 := range s.inBytesToWrite {
		if err := encoder.WriteUint8(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.inOffset); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.inWhence)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Write_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *file_Write_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Write_Params_Versions), func(i int) bool {
		return file_Write_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Write_Params_Versions) {
		if file_Write_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Write_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			s.inBytesToWrite = make([]uint8, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadUint8()
				if err != nil {
					return err
				}
				s.inBytesToWrite[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.inOffset = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inWhence = types.Whence(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_Write_ResponseParams struct {
	outError types.Error
	outNumBytesWritten uint32
}


func (s *file_Write_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.outError)); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.outNumBytesWritten); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Write_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *file_Write_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Write_ResponseParams_Versions), func(i int) bool {
		return file_Write_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Write_ResponseParams_Versions) {
		if file_Write_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Write_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outError = types.Error(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.outNumBytesWritten = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) Write(inBytesToWrite []uint8, inOffset int64, inWhence types.Whence) (outError types.Error, outNumBytesWritten uint32, err error) {
	payload := &file_Write_Params{
		inBytesToWrite,
		inOffset,
		inWhence,
	}
	header := bindings.MessageHeader{
		Type: file_Write_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_Write_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_Write_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outError = response.outError
	outNumBytesWritten = response.outNumBytesWritten
	return
}

type file_ReadToStream_Params struct {
	inSource system.ProducerHandle
	inOffset int64
	inWhence types.Whence
	inNumBytesToRead int64
}


func (s *file_ReadToStream_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if err := encoder.WriteHandle(s.inSource); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.inWhence)); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.inOffset); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.inNumBytesToRead); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_ReadToStream_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *file_ReadToStream_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_ReadToStream_Params_Versions), func(i int) bool {
		return file_ReadToStream_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_ReadToStream_Params_Versions) {
		if file_ReadToStream_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_ReadToStream_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadProducerHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.inSource = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inWhence = types.Whence(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.inOffset = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.inNumBytesToRead = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_ReadToStream_ResponseParams struct {
	outError types.Error
}


func (s *file_ReadToStream_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.outError)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_ReadToStream_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *file_ReadToStream_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_ReadToStream_ResponseParams_Versions), func(i int) bool {
		return file_ReadToStream_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_ReadToStream_ResponseParams_Versions) {
		if file_ReadToStream_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_ReadToStream_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outError = types.Error(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) ReadToStream(inSource system.ProducerHandle, inOffset int64, inWhence types.Whence, inNumBytesToRead int64) (outError types.Error, err error) {
	payload := &file_ReadToStream_Params{
		inSource,
		inOffset,
		inWhence,
		inNumBytesToRead,
	}
	header := bindings.MessageHeader{
		Type: file_ReadToStream_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_ReadToStream_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_ReadToStream_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outError = response.outError
	return
}

type file_WriteFromStream_Params struct {
	inSink system.ConsumerHandle
	inOffset int64
	inWhence types.Whence
}


func (s *file_WriteFromStream_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteHandle(s.inSink); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.inWhence)); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.inOffset); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_WriteFromStream_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *file_WriteFromStream_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_WriteFromStream_Params_Versions), func(i int) bool {
		return file_WriteFromStream_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_WriteFromStream_Params_Versions) {
		if file_WriteFromStream_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_WriteFromStream_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadConsumerHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.inSink = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inWhence = types.Whence(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.inOffset = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_WriteFromStream_ResponseParams struct {
	outError types.Error
}


func (s *file_WriteFromStream_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.outError)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_WriteFromStream_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *file_WriteFromStream_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_WriteFromStream_ResponseParams_Versions), func(i int) bool {
		return file_WriteFromStream_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_WriteFromStream_ResponseParams_Versions) {
		if file_WriteFromStream_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_WriteFromStream_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outError = types.Error(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) WriteFromStream(inSink system.ConsumerHandle, inOffset int64, inWhence types.Whence) (outError types.Error, err error) {
	payload := &file_WriteFromStream_Params{
		inSink,
		inOffset,
		inWhence,
	}
	header := bindings.MessageHeader{
		Type: file_WriteFromStream_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_WriteFromStream_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_WriteFromStream_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outError = response.outError
	return
}

type file_Tell_Params struct {
}


func (s *file_Tell_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Tell_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *file_Tell_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Tell_Params_Versions), func(i int) bool {
		return file_Tell_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Tell_Params_Versions) {
		if file_Tell_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Tell_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_Tell_ResponseParams struct {
	outError types.Error
	outPosition int64
}


func (s *file_Tell_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInt32(int32(s.outError)); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.outPosition); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Tell_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *file_Tell_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Tell_ResponseParams_Versions), func(i int) bool {
		return file_Tell_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Tell_ResponseParams_Versions) {
		if file_Tell_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Tell_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outError = types.Error(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.outPosition = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) Tell() (outError types.Error, outPosition int64, err error) {
	payload := &file_Tell_Params{
	}
	header := bindings.MessageHeader{
		Type: file_Tell_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_Tell_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_Tell_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outError = response.outError
	outPosition = response.outPosition
	return
}

type file_Seek_Params struct {
	inOffset int64
	inWhence types.Whence
}


func (s *file_Seek_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInt64(s.inOffset); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.inWhence)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Seek_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *file_Seek_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Seek_Params_Versions), func(i int) bool {
		return file_Seek_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Seek_Params_Versions) {
		if file_Seek_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Seek_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.inOffset = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inWhence = types.Whence(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_Seek_ResponseParams struct {
	outError types.Error
	outPosition int64
}


func (s *file_Seek_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInt32(int32(s.outError)); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.outPosition); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Seek_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *file_Seek_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Seek_ResponseParams_Versions), func(i int) bool {
		return file_Seek_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Seek_ResponseParams_Versions) {
		if file_Seek_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Seek_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outError = types.Error(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.outPosition = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) Seek(inOffset int64, inWhence types.Whence) (outError types.Error, outPosition int64, err error) {
	payload := &file_Seek_Params{
		inOffset,
		inWhence,
	}
	header := bindings.MessageHeader{
		Type: file_Seek_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_Seek_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_Seek_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outError = response.outError
	outPosition = response.outPosition
	return
}

type file_Stat_Params struct {
}


func (s *file_Stat_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Stat_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *file_Stat_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Stat_Params_Versions), func(i int) bool {
		return file_Stat_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Stat_Params_Versions) {
		if file_Stat_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Stat_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_Stat_ResponseParams struct {
	outError types.Error
	outFileInformation *types.FileInformation
}


func (s *file_Stat_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInt32(int32(s.outError)); err != nil {
		return err
	}
	if s.outFileInformation == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.outFileInformation).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Stat_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *file_Stat_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Stat_ResponseParams_Versions), func(i int) bool {
		return file_Stat_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Stat_ResponseParams_Versions) {
		if file_Stat_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Stat_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outError = types.Error(value0)
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.outFileInformation = nil
		} else {
			s.outFileInformation = new(types.FileInformation)
			if err := (*s.outFileInformation).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) Stat() (outError types.Error, outFileInformation *types.FileInformation, err error) {
	payload := &file_Stat_Params{
	}
	header := bindings.MessageHeader{
		Type: file_Stat_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_Stat_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_Stat_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outError = response.outError
	outFileInformation = response.outFileInformation
	return
}

type file_Truncate_Params struct {
	inSize int64
}


func (s *file_Truncate_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt64(s.inSize); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Truncate_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *file_Truncate_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Truncate_Params_Versions), func(i int) bool {
		return file_Truncate_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Truncate_Params_Versions) {
		if file_Truncate_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Truncate_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.inSize = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_Truncate_ResponseParams struct {
	outError types.Error
}


func (s *file_Truncate_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.outError)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Truncate_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *file_Truncate_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Truncate_ResponseParams_Versions), func(i int) bool {
		return file_Truncate_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Truncate_ResponseParams_Versions) {
		if file_Truncate_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Truncate_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outError = types.Error(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) Truncate(inSize int64) (outError types.Error, err error) {
	payload := &file_Truncate_Params{
		inSize,
	}
	header := bindings.MessageHeader{
		Type: file_Truncate_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_Truncate_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_Truncate_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outError = response.outError
	return
}

type file_Touch_Params struct {
	inAtime *types.TimespecOrNow
	inMtime *types.TimespecOrNow
}


func (s *file_Touch_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.inAtime == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.inAtime).Encode(encoder); err != nil {
			return err
		}
	}
	if s.inMtime == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.inMtime).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Touch_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *file_Touch_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Touch_Params_Versions), func(i int) bool {
		return file_Touch_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Touch_Params_Versions) {
		if file_Touch_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Touch_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.inAtime = nil
		} else {
			s.inAtime = new(types.TimespecOrNow)
			if err := (*s.inAtime).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.inMtime = nil
		} else {
			s.inMtime = new(types.TimespecOrNow)
			if err := (*s.inMtime).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_Touch_ResponseParams struct {
	outError types.Error
}


func (s *file_Touch_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.outError)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Touch_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *file_Touch_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Touch_ResponseParams_Versions), func(i int) bool {
		return file_Touch_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Touch_ResponseParams_Versions) {
		if file_Touch_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Touch_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outError = types.Error(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) Touch(inAtime *types.TimespecOrNow, inMtime *types.TimespecOrNow) (outError types.Error, err error) {
	payload := &file_Touch_Params{
		inAtime,
		inMtime,
	}
	header := bindings.MessageHeader{
		Type: file_Touch_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_Touch_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_Touch_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outError = response.outError
	return
}

type file_Dup_Params struct {
	inFile File_Request
}


func (s *file_Dup_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteHandle(s.inFile.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Dup_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *file_Dup_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Dup_Params_Versions), func(i int) bool {
		return file_Dup_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Dup_Params_Versions) {
		if file_Dup_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Dup_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inFile = File_Request{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_Dup_ResponseParams struct {
	outError types.Error
}


func (s *file_Dup_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.outError)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Dup_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *file_Dup_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Dup_ResponseParams_Versions), func(i int) bool {
		return file_Dup_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Dup_ResponseParams_Versions) {
		if file_Dup_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Dup_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outError = types.Error(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) Dup(inFile File_Request) (outError types.Error, err error) {
	payload := &file_Dup_Params{
		inFile,
	}
	header := bindings.MessageHeader{
		Type: file_Dup_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_Dup_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_Dup_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outError = response.outError
	return
}

type file_Reopen_Params struct {
	inFile File_Request
	inOpenFlags uint32
}


func (s *file_Reopen_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteHandle(s.inFile.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.inOpenFlags); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Reopen_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *file_Reopen_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Reopen_Params_Versions), func(i int) bool {
		return file_Reopen_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Reopen_Params_Versions) {
		if file_Reopen_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Reopen_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inFile = File_Request{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.inOpenFlags = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_Reopen_ResponseParams struct {
	outError types.Error
}


func (s *file_Reopen_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.outError)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Reopen_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *file_Reopen_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Reopen_ResponseParams_Versions), func(i int) bool {
		return file_Reopen_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Reopen_ResponseParams_Versions) {
		if file_Reopen_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Reopen_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outError = types.Error(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) Reopen(inFile File_Request, inOpenFlags uint32) (outError types.Error, err error) {
	payload := &file_Reopen_Params{
		inFile,
		inOpenFlags,
	}
	header := bindings.MessageHeader{
		Type: file_Reopen_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_Reopen_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_Reopen_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outError = response.outError
	return
}

type file_AsBuffer_Params struct {
}


func (s *file_AsBuffer_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_AsBuffer_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *file_AsBuffer_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_AsBuffer_Params_Versions), func(i int) bool {
		return file_AsBuffer_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_AsBuffer_Params_Versions) {
		if file_AsBuffer_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_AsBuffer_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_AsBuffer_ResponseParams struct {
	outError types.Error
	outBuffer *system.SharedBufferHandle
}


func (s *file_AsBuffer_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.outError)); err != nil {
		return err
	}
	if s.outBuffer == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.outBuffer)); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_AsBuffer_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *file_AsBuffer_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_AsBuffer_ResponseParams_Versions), func(i int) bool {
		return file_AsBuffer_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_AsBuffer_ResponseParams_Versions) {
		if file_AsBuffer_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_AsBuffer_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outError = types.Error(value0)
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadSharedBufferHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.outBuffer = &handle0
		} else {
			s.outBuffer = nil
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) AsBuffer() (outError types.Error, outBuffer *system.SharedBufferHandle, err error) {
	payload := &file_AsBuffer_Params{
	}
	header := bindings.MessageHeader{
		Type: file_AsBuffer_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_AsBuffer_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_AsBuffer_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outError = response.outError
	outBuffer = response.outBuffer
	return
}

type file_Ioctl_Params struct {
	inRequest uint32
	inInValues *[]uint32
}


func (s *file_Ioctl_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteUint32(s.inRequest); err != nil {
		return err
	}
	if s.inInValues == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.inInValues))), 32)
		for _, elem0 := range (*s.inInValues) {
			if err := encoder.WriteUint32(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Ioctl_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *file_Ioctl_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Ioctl_Params_Versions), func(i int) bool {
		return file_Ioctl_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Ioctl_Params_Versions) {
		if file_Ioctl_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Ioctl_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.inRequest = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.inInValues = nil
		} else {
			s.inInValues = new([]uint32)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.inInValues) = make([]uint32, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadUint32()
				if err != nil {
					return err
				}
				(*s.inInValues)[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type file_Ioctl_ResponseParams struct {
	outError types.Error
	outOutValues *[]uint32
}


func (s *file_Ioctl_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInt32(int32(s.outError)); err != nil {
		return err
	}
	if s.outOutValues == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.outOutValues))), 32)
		for _, elem0 := range (*s.outOutValues) {
			if err := encoder.WriteUint32(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var file_Ioctl_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *file_Ioctl_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(file_Ioctl_ResponseParams_Versions), func(i int) bool {
		return file_Ioctl_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(file_Ioctl_ResponseParams_Versions) {
		if file_Ioctl_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := file_Ioctl_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outError = types.Error(value0)
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.outOutValues = nil
		} else {
			s.outOutValues = new([]uint32)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.outOutValues) = make([]uint32, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadUint32()
				if err != nil {
					return err
				}
				(*s.outOutValues)[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *File_Proxy) Ioctl(inRequest uint32, inInValues *[]uint32) (outError types.Error, outOutValues *[]uint32, err error) {
	payload := &file_Ioctl_Params{
		inRequest,
		inInValues,
	}
	header := bindings.MessageHeader{
		Type: file_Ioctl_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, file_Ioctl_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response file_Ioctl_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outError = response.outError
	outOutValues = response.outOutValues
	return
}

type file_Stub struct {
	connector *bindings.Connector
	impl File
}

func NewFileStub(r File_Request, impl File, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &file_Stub{connector, impl})
}


func (f *File_Request) ServiceDescription() service_describer.ServiceDescription {
	return &File_ServiceDescription{}
}


type File_ServiceDescription struct{}

func (sd *File_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *File_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *File_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*File_ServiceDescription)(nil)


func (s *file_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case file_Close_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_Close_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_Close_ResponseParams
		response.outErr, err = s.impl.Close()
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_Close_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case file_Read_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_Read_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_Read_ResponseParams
		response.outError, 		response.outBytesRead, err = s.impl.Read(request.inNumBytesToRead, request.inOffset, request.inWhence)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_Read_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case file_Write_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_Write_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_Write_ResponseParams
		response.outError, 		response.outNumBytesWritten, err = s.impl.Write(request.inBytesToWrite, request.inOffset, request.inWhence)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_Write_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case file_ReadToStream_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_ReadToStream_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_ReadToStream_ResponseParams
		response.outError, err = s.impl.ReadToStream(request.inSource, request.inOffset, request.inWhence, request.inNumBytesToRead)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_ReadToStream_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case file_WriteFromStream_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_WriteFromStream_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_WriteFromStream_ResponseParams
		response.outError, err = s.impl.WriteFromStream(request.inSink, request.inOffset, request.inWhence)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_WriteFromStream_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case file_Tell_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_Tell_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_Tell_ResponseParams
		response.outError, 		response.outPosition, err = s.impl.Tell()
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_Tell_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case file_Seek_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_Seek_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_Seek_ResponseParams
		response.outError, 		response.outPosition, err = s.impl.Seek(request.inOffset, request.inWhence)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_Seek_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case file_Stat_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_Stat_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_Stat_ResponseParams
		response.outError, 		response.outFileInformation, err = s.impl.Stat()
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_Stat_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case file_Truncate_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_Truncate_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_Truncate_ResponseParams
		response.outError, err = s.impl.Truncate(request.inSize)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_Truncate_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case file_Touch_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_Touch_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_Touch_ResponseParams
		response.outError, err = s.impl.Touch(request.inAtime, request.inMtime)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_Touch_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case file_Dup_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_Dup_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_Dup_ResponseParams
		response.outError, err = s.impl.Dup(request.inFile)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_Dup_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case file_Reopen_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_Reopen_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_Reopen_ResponseParams
		response.outError, err = s.impl.Reopen(request.inFile, request.inOpenFlags)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_Reopen_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case file_AsBuffer_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_AsBuffer_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_AsBuffer_ResponseParams
		response.outError, 		response.outBuffer, err = s.impl.AsBuffer()
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_AsBuffer_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case file_Ioctl_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request file_Ioctl_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response file_Ioctl_ResponseParams
		response.outError, 		response.outOutValues, err = s.impl.Ioctl(request.inRequest, request.inInValues)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: file_Ioctl_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

