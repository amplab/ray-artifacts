// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library test_mojom;
import 'dart:async';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;



class _TestServiceTestParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String testString = null;

  _TestServiceTestParams() : super(kVersions.last.size);

  _TestServiceTestParams.init(
    String this.testString
  ) : super(kVersions.last.size);

  static _TestServiceTestParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestServiceTestParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestServiceTestParams result = new _TestServiceTestParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.testString = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestServiceTestParams";
    String fieldName;
    try {
      fieldName = "testString";
      encoder0.encodeString(testString, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestServiceTestParams("
           "testString: $testString" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["testString"] = testString;
    return map;
  }
}


class TestServiceTestResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  TestServiceTestResponseParams() : super(kVersions.last.size);

  TestServiceTestResponseParams.init(
  ) : super(kVersions.last.size);

  static TestServiceTestResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static TestServiceTestResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    TestServiceTestResponseParams result = new TestServiceTestResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "TestServiceTestResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "TestServiceTestResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _TestACallBParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _TestACallBParams() : super(kVersions.last.size);

  _TestACallBParams.init(
  ) : super(kVersions.last.size);

  static _TestACallBParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestACallBParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestACallBParams result = new _TestACallBParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestACallBParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestACallBParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _TestBBParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _TestBBParams() : super(kVersions.last.size);

  _TestBBParams.init(
  ) : super(kVersions.last.size);

  static _TestBBParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestBBParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestBBParams result = new _TestBBParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestBBParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestBBParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class TestBBResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  TestBBResponseParams() : super(kVersions.last.size);

  TestBBResponseParams.init(
  ) : super(kVersions.last.size);

  static TestBBResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static TestBBResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    TestBBResponseParams result = new TestBBResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "TestBBResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "TestBBResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _TestCCParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _TestCCParams() : super(kVersions.last.size);

  _TestCCParams.init(
  ) : super(kVersions.last.size);

  static _TestCCParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestCCParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestCCParams result = new _TestCCParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestCCParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestCCParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class TestCCResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  TestCCResponseParams() : super(kVersions.last.size);

  TestCCResponseParams.init(
  ) : super(kVersions.last.size);

  static TestCCResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static TestCCResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    TestCCResponseParams result = new TestCCResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "TestCCResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "TestCCResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}

const int _testServiceMethodTestName = 0;

class _TestServiceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class TestService {
  static const String serviceName = "shell.TestService";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _TestServiceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static TestServiceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    TestServiceProxy p = new TestServiceProxy.unbound();
    String name = serviceName ?? TestService.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void test(String testString,void callback());
}

abstract class TestServiceInterface
    implements bindings.MojoInterface<TestService>,
               TestService {
  factory TestServiceInterface([TestService impl]) =>
      new TestServiceStub.unbound(impl);

  factory TestServiceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [TestService impl]) =>
      new TestServiceStub.fromEndpoint(endpoint, impl);

  factory TestServiceInterface.fromMock(
      TestService mock) =>
      new TestServiceProxy.fromMock(mock);
}

abstract class TestServiceInterfaceRequest
    implements bindings.MojoInterface<TestService>,
               TestService {
  factory TestServiceInterfaceRequest() =>
      new TestServiceProxy.unbound();
}

class _TestServiceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<TestService> {
  TestService impl;

  _TestServiceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _TestServiceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _TestServiceProxyControl.unbound() : super.unbound();

  String get serviceName => TestService.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _testServiceMethodTestName:
        var r = TestServiceTestResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback();
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestServiceProxyControl($superString)";
  }
}

class TestServiceProxy
    extends bindings.Proxy<TestService>
    implements TestService,
               TestServiceInterface,
               TestServiceInterfaceRequest {
  TestServiceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _TestServiceProxyControl.fromEndpoint(endpoint));

  TestServiceProxy.fromHandle(core.MojoHandle handle)
      : super(new _TestServiceProxyControl.fromHandle(handle));

  TestServiceProxy.unbound()
      : super(new _TestServiceProxyControl.unbound());

  factory TestServiceProxy.fromMock(TestService mock) {
    TestServiceProxy newMockedProxy =
        new TestServiceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static TestServiceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestServiceProxy"));
    return new TestServiceProxy.fromEndpoint(endpoint);
  }


  void test(String testString,void callback()) {
    if (impl != null) {
      impl.test(testString,callback);
      return;
    }
    var params = new _TestServiceTestParams();
    params.testString = testString;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _testServiceMethodTestName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _TestServiceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<TestService> {
  TestService _impl;

  _TestServiceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestService impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestServiceStubControl.fromHandle(
      core.MojoHandle handle, [TestService impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestServiceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => TestService.serviceName;


  Function _testServiceTestResponseParamsResponder(
      int requestId) {
  return () {
      var result = new TestServiceTestResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _testServiceMethodTestName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _testServiceMethodTestName:
        var params = _TestServiceTestParams.deserialize(
            message.payload);
        _impl.test(params.testString, _testServiceTestResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  TestService get impl => _impl;
  set impl(TestService d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestServiceStubControl($superString)";
  }

  int get version => 0;
}

class TestServiceStub
    extends bindings.Stub<TestService>
    implements TestService,
               TestServiceInterface,
               TestServiceInterfaceRequest {
  TestServiceStub.unbound([TestService impl])
      : super(new _TestServiceStubControl.unbound(impl));

  TestServiceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestService impl])
      : super(new _TestServiceStubControl.fromEndpoint(endpoint, impl));

  TestServiceStub.fromHandle(
      core.MojoHandle handle, [TestService impl])
      : super(new _TestServiceStubControl.fromHandle(handle, impl));

  static TestServiceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestServiceStub"));
    return new TestServiceStub.fromEndpoint(endpoint);
  }


  void test(String testString,void callback()) {
    return impl.test(testString,callback);
  }
}

const int _testAMethodCallBName = 0;

class _TestAServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class TestA {
  static const String serviceName = "shell.TestA";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _TestAServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static TestAProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    TestAProxy p = new TestAProxy.unbound();
    String name = serviceName ?? TestA.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void callB();
}

abstract class TestAInterface
    implements bindings.MojoInterface<TestA>,
               TestA {
  factory TestAInterface([TestA impl]) =>
      new TestAStub.unbound(impl);

  factory TestAInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [TestA impl]) =>
      new TestAStub.fromEndpoint(endpoint, impl);

  factory TestAInterface.fromMock(
      TestA mock) =>
      new TestAProxy.fromMock(mock);
}

abstract class TestAInterfaceRequest
    implements bindings.MojoInterface<TestA>,
               TestA {
  factory TestAInterfaceRequest() =>
      new TestAProxy.unbound();
}

class _TestAProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<TestA> {
  TestA impl;

  _TestAProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _TestAProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _TestAProxyControl.unbound() : super.unbound();

  String get serviceName => TestA.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestAProxyControl($superString)";
  }
}

class TestAProxy
    extends bindings.Proxy<TestA>
    implements TestA,
               TestAInterface,
               TestAInterfaceRequest {
  TestAProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _TestAProxyControl.fromEndpoint(endpoint));

  TestAProxy.fromHandle(core.MojoHandle handle)
      : super(new _TestAProxyControl.fromHandle(handle));

  TestAProxy.unbound()
      : super(new _TestAProxyControl.unbound());

  factory TestAProxy.fromMock(TestA mock) {
    TestAProxy newMockedProxy =
        new TestAProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static TestAProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestAProxy"));
    return new TestAProxy.fromEndpoint(endpoint);
  }


  void callB() {
    if (impl != null) {
      impl.callB();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _TestACallBParams();
    ctrl.sendMessage(params,
        _testAMethodCallBName);
  }
}

class _TestAStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<TestA> {
  TestA _impl;

  _TestAStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestA impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestAStubControl.fromHandle(
      core.MojoHandle handle, [TestA impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestAStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => TestA.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _testAMethodCallBName:
        _impl.callB();
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  TestA get impl => _impl;
  set impl(TestA d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestAStubControl($superString)";
  }

  int get version => 0;
}

class TestAStub
    extends bindings.Stub<TestA>
    implements TestA,
               TestAInterface,
               TestAInterfaceRequest {
  TestAStub.unbound([TestA impl])
      : super(new _TestAStubControl.unbound(impl));

  TestAStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestA impl])
      : super(new _TestAStubControl.fromEndpoint(endpoint, impl));

  TestAStub.fromHandle(
      core.MojoHandle handle, [TestA impl])
      : super(new _TestAStubControl.fromHandle(handle, impl));

  static TestAStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestAStub"));
    return new TestAStub.fromEndpoint(endpoint);
  }


  void callB() {
    return impl.callB();
  }
}

const int _testBMethodBName = 0;

class _TestBServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class TestB {
  static const String serviceName = "shell.TestB";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _TestBServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static TestBProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    TestBProxy p = new TestBProxy.unbound();
    String name = serviceName ?? TestB.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void b(void callback());
}

abstract class TestBInterface
    implements bindings.MojoInterface<TestB>,
               TestB {
  factory TestBInterface([TestB impl]) =>
      new TestBStub.unbound(impl);

  factory TestBInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [TestB impl]) =>
      new TestBStub.fromEndpoint(endpoint, impl);

  factory TestBInterface.fromMock(
      TestB mock) =>
      new TestBProxy.fromMock(mock);
}

abstract class TestBInterfaceRequest
    implements bindings.MojoInterface<TestB>,
               TestB {
  factory TestBInterfaceRequest() =>
      new TestBProxy.unbound();
}

class _TestBProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<TestB> {
  TestB impl;

  _TestBProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _TestBProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _TestBProxyControl.unbound() : super.unbound();

  String get serviceName => TestB.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _testBMethodBName:
        var r = TestBBResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback();
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestBProxyControl($superString)";
  }
}

class TestBProxy
    extends bindings.Proxy<TestB>
    implements TestB,
               TestBInterface,
               TestBInterfaceRequest {
  TestBProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _TestBProxyControl.fromEndpoint(endpoint));

  TestBProxy.fromHandle(core.MojoHandle handle)
      : super(new _TestBProxyControl.fromHandle(handle));

  TestBProxy.unbound()
      : super(new _TestBProxyControl.unbound());

  factory TestBProxy.fromMock(TestB mock) {
    TestBProxy newMockedProxy =
        new TestBProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static TestBProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestBProxy"));
    return new TestBProxy.fromEndpoint(endpoint);
  }


  void b(void callback()) {
    if (impl != null) {
      impl.b(callback);
      return;
    }
    var params = new _TestBBParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _testBMethodBName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _TestBStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<TestB> {
  TestB _impl;

  _TestBStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestB impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestBStubControl.fromHandle(
      core.MojoHandle handle, [TestB impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestBStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => TestB.serviceName;


  Function _testBbResponseParamsResponder(
      int requestId) {
  return () {
      var result = new TestBBResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _testBMethodBName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _testBMethodBName:
        _impl.b(_testBbResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  TestB get impl => _impl;
  set impl(TestB d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestBStubControl($superString)";
  }

  int get version => 0;
}

class TestBStub
    extends bindings.Stub<TestB>
    implements TestB,
               TestBInterface,
               TestBInterfaceRequest {
  TestBStub.unbound([TestB impl])
      : super(new _TestBStubControl.unbound(impl));

  TestBStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestB impl])
      : super(new _TestBStubControl.fromEndpoint(endpoint, impl));

  TestBStub.fromHandle(
      core.MojoHandle handle, [TestB impl])
      : super(new _TestBStubControl.fromHandle(handle, impl));

  static TestBStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestBStub"));
    return new TestBStub.fromEndpoint(endpoint);
  }


  void b(void callback()) {
    return impl.b(callback);
  }
}

const int _testCMethodCName = 0;

class _TestCServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class TestC {
  static const String serviceName = "shell.TestC";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _TestCServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static TestCProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    TestCProxy p = new TestCProxy.unbound();
    String name = serviceName ?? TestC.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void c(void callback());
}

abstract class TestCInterface
    implements bindings.MojoInterface<TestC>,
               TestC {
  factory TestCInterface([TestC impl]) =>
      new TestCStub.unbound(impl);

  factory TestCInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [TestC impl]) =>
      new TestCStub.fromEndpoint(endpoint, impl);

  factory TestCInterface.fromMock(
      TestC mock) =>
      new TestCProxy.fromMock(mock);
}

abstract class TestCInterfaceRequest
    implements bindings.MojoInterface<TestC>,
               TestC {
  factory TestCInterfaceRequest() =>
      new TestCProxy.unbound();
}

class _TestCProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<TestC> {
  TestC impl;

  _TestCProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _TestCProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _TestCProxyControl.unbound() : super.unbound();

  String get serviceName => TestC.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _testCMethodCName:
        var r = TestCCResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback();
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestCProxyControl($superString)";
  }
}

class TestCProxy
    extends bindings.Proxy<TestC>
    implements TestC,
               TestCInterface,
               TestCInterfaceRequest {
  TestCProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _TestCProxyControl.fromEndpoint(endpoint));

  TestCProxy.fromHandle(core.MojoHandle handle)
      : super(new _TestCProxyControl.fromHandle(handle));

  TestCProxy.unbound()
      : super(new _TestCProxyControl.unbound());

  factory TestCProxy.fromMock(TestC mock) {
    TestCProxy newMockedProxy =
        new TestCProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static TestCProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestCProxy"));
    return new TestCProxy.fromEndpoint(endpoint);
  }


  void c(void callback()) {
    if (impl != null) {
      impl.c(callback);
      return;
    }
    var params = new _TestCCParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _testCMethodCName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _TestCStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<TestC> {
  TestC _impl;

  _TestCStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestC impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestCStubControl.fromHandle(
      core.MojoHandle handle, [TestC impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestCStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => TestC.serviceName;


  Function _testCcResponseParamsResponder(
      int requestId) {
  return () {
      var result = new TestCCResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _testCMethodCName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _testCMethodCName:
        _impl.c(_testCcResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  TestC get impl => _impl;
  set impl(TestC d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestCStubControl($superString)";
  }

  int get version => 0;
}

class TestCStub
    extends bindings.Stub<TestC>
    implements TestC,
               TestCInterface,
               TestCInterfaceRequest {
  TestCStub.unbound([TestC impl])
      : super(new _TestCStubControl.unbound(impl));

  TestCStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestC impl])
      : super(new _TestCStubControl.fromEndpoint(endpoint, impl));

  TestCStub.fromHandle(
      core.MojoHandle handle, [TestC impl])
      : super(new _TestCStubControl.fromHandle(handle, impl));

  static TestCStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestCStub"));
    return new TestCStub.fromEndpoint(endpoint);
  }


  void c(void callback()) {
    return impl.c(callback);
  }
}



