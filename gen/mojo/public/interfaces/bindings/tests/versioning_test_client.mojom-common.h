// NOTE: This file was generated by the Mojo bindings generator.
#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_VERSIONING_TEST_CLIENT_MOJOM_COMMON_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_VERSIONING_TEST_CLIENT_MOJOM_COMMON_H_

#include <stdint.h>
#include <iosfwd>

#include "mojo/public/cpp/bindings/array.h"
#include "mojo/public/cpp/bindings/callback.h"
#include "mojo/public/cpp/bindings/interface_handle.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/map.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/bindings/string.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/system/buffer.h"
#include "mojo/public/cpp/system/data_pipe.h"
#include "mojo/public/cpp/system/handle.h"
#include "mojo/public/cpp/system/message_pipe.h"
#include "mojo/public/interfaces/bindings/tests/versioning_test_client.mojom-internal.h"
namespace mojo {
namespace test {
namespace versioning {

// --- Interface Forward Declarations ---
class HumanResourceDatabase;
class HumanResourceDatabaseRequestValidator;
class HumanResourceDatabaseResponseValidator;
class HumanResourceDatabase_Synchronous;

// --- Struct Forward Declarations ---
class Employee;

using EmployeePtr = mojo::InlinedStructPtr<Employee>;



// --- Union Forward Declarations ---

// --- Enums Declarations ---
  
enum class Department : int32_t {
  SALES,
  DEV,
};

bool Department_IsValidValue(Department value);
  
std::ostream& operator<<(std::ostream& stream, const Department& val);

// --- Constants ---

// --- Interface declarations ---
namespace internal {
class HumanResourceDatabase_Base {
 public:
  static const char Name_[];
  static const uint32_t Version_ = 2;

  using RequestValidator_ = HumanResourceDatabaseRequestValidator;
  using ResponseValidator_ = HumanResourceDatabaseResponseValidator;
  using Synchronous_ = HumanResourceDatabase_Synchronous;
  enum class MessageOrdinals : uint32_t {
    AddEmployee = 0,
    QueryEmployee = 1,
    AttachFingerPrint = 2,
    ListEmployeeIds = 3,
  };


  virtual ~HumanResourceDatabase_Base() {}
};

}  // namespace internal

// Async interface declaration

class HumanResourceDatabaseProxy;
class HumanResourceDatabaseStub;
class HumanResourceDatabase_Synchronous;

class HumanResourceDatabaseRequestValidator;
class HumanResourceDatabaseResponseValidator;

class HumanResourceDatabase : public internal::HumanResourceDatabase_Base {
 public:
  virtual ~HumanResourceDatabase() override {}

  using Proxy_ = HumanResourceDatabaseProxy;
  using Stub_ = HumanResourceDatabaseStub;
  using AddEmployeeCallback = mojo::Callback<void(bool)>;
  virtual void AddEmployee(EmployeePtr employee, const AddEmployeeCallback& callback) = 0;
  using QueryEmployeeCallback = mojo::Callback<void(EmployeePtr, mojo::Array<uint8_t>)>;
  virtual void QueryEmployee(uint64_t id, bool retrieve_finger_print, const QueryEmployeeCallback& callback) = 0;
  using AttachFingerPrintCallback = mojo::Callback<void(bool)>;
  virtual void AttachFingerPrint(uint64_t id, mojo::Array<uint8_t> finger_print, const AttachFingerPrintCallback& callback) = 0;
  using ListEmployeeIdsCallback = mojo::Callback<void(mojo::Array<uint64_t>)>;
  virtual void ListEmployeeIds(const ListEmployeeIdsCallback& callback) = 0;
};

}  // namespace versioning
}  // namespace test
}  // namespace mojo

// --- Internal Template Specializations ---

namespace mojo {
namespace internal {
template <>
struct WrapperTraits<mojo::test::versioning::EmployeePtr, true, false> {
  using DataType = mojo::test::versioning::internal::Employee_Data*;
};

}  // internal
}  // mojo
namespace mojo {
namespace test {
namespace versioning {

// --- Interface Request Validators ---
class HumanResourceDatabaseRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface Response Validators ---
class HumanResourceDatabaseResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface enum operators ---

// --- Unions ---
// Unions must be declared first because they can be members of structs.

// --- Inlined structs ---
class Employee {
 public:
  using Data_ = internal::Employee_Data;

  static EmployeePtr New();

  template <typename U>
  static EmployeePtr From(const U& u) {
    return mojo::TypeConverter<EmployeePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Employee>::Convert(*this);
  }

  Employee();
  ~Employee();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  EmployeePtr Clone() const;
  bool Equals(const Employee& other) const;

  uint64_t employee_id;
  mojo::String name;
  Department department;
};



// --- Non-inlined structs ---

// --- Struct serialization helpers ---
size_t GetSerializedSize_(const Employee& input);
mojo::internal::ValidationError Serialize_(
    Employee* input,
    mojo::internal::Buffer* buffer,
    internal::Employee_Data** output);
void Deserialize_(internal::Employee_Data* input,
                  Employee* output);


// --- Union serialization helpers ---

// --- Request and response parameter structs for Interface methods ---
      

class HumanResourceDatabase_AddEmployee_Params;

using HumanResourceDatabase_AddEmployee_ParamsPtr = mojo::StructPtr<HumanResourceDatabase_AddEmployee_Params>;


size_t GetSerializedSize_(const HumanResourceDatabase_AddEmployee_Params& input);
mojo::internal::ValidationError Serialize_(
    HumanResourceDatabase_AddEmployee_Params* input,
    mojo::internal::Buffer* buffer,
    internal::HumanResourceDatabase_AddEmployee_Params_Data** output);
void Deserialize_(internal::HumanResourceDatabase_AddEmployee_Params_Data* input,
                  HumanResourceDatabase_AddEmployee_Params* output);

class HumanResourceDatabase_AddEmployee_Params {
 public:
  using Data_ = internal::HumanResourceDatabase_AddEmployee_Params_Data;

  static HumanResourceDatabase_AddEmployee_ParamsPtr New();

  template <typename U>
  static HumanResourceDatabase_AddEmployee_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<HumanResourceDatabase_AddEmployee_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HumanResourceDatabase_AddEmployee_Params>::Convert(*this);
  }

  HumanResourceDatabase_AddEmployee_Params();
  ~HumanResourceDatabase_AddEmployee_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  HumanResourceDatabase_AddEmployee_ParamsPtr Clone() const;
  bool Equals(const HumanResourceDatabase_AddEmployee_Params& other) const;

  EmployeePtr employee;
};



class HumanResourceDatabase_AddEmployee_ResponseParams;

using HumanResourceDatabase_AddEmployee_ResponseParamsPtr = mojo::InlinedStructPtr<HumanResourceDatabase_AddEmployee_ResponseParams>;


size_t GetSerializedSize_(const HumanResourceDatabase_AddEmployee_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    HumanResourceDatabase_AddEmployee_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::HumanResourceDatabase_AddEmployee_ResponseParams_Data** output);
void Deserialize_(internal::HumanResourceDatabase_AddEmployee_ResponseParams_Data* input,
                  HumanResourceDatabase_AddEmployee_ResponseParams* output);

class HumanResourceDatabase_AddEmployee_ResponseParams {
 public:
  using Data_ = internal::HumanResourceDatabase_AddEmployee_ResponseParams_Data;

  static HumanResourceDatabase_AddEmployee_ResponseParamsPtr New();

  template <typename U>
  static HumanResourceDatabase_AddEmployee_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<HumanResourceDatabase_AddEmployee_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HumanResourceDatabase_AddEmployee_ResponseParams>::Convert(*this);
  }

  HumanResourceDatabase_AddEmployee_ResponseParams();
  ~HumanResourceDatabase_AddEmployee_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  HumanResourceDatabase_AddEmployee_ResponseParamsPtr Clone() const;
  bool Equals(const HumanResourceDatabase_AddEmployee_ResponseParams& other) const;

  bool success;
};



class HumanResourceDatabase_QueryEmployee_Params;

using HumanResourceDatabase_QueryEmployee_ParamsPtr = mojo::InlinedStructPtr<HumanResourceDatabase_QueryEmployee_Params>;


size_t GetSerializedSize_(const HumanResourceDatabase_QueryEmployee_Params& input);
mojo::internal::ValidationError Serialize_(
    HumanResourceDatabase_QueryEmployee_Params* input,
    mojo::internal::Buffer* buffer,
    internal::HumanResourceDatabase_QueryEmployee_Params_Data** output);
void Deserialize_(internal::HumanResourceDatabase_QueryEmployee_Params_Data* input,
                  HumanResourceDatabase_QueryEmployee_Params* output);

class HumanResourceDatabase_QueryEmployee_Params {
 public:
  using Data_ = internal::HumanResourceDatabase_QueryEmployee_Params_Data;

  static HumanResourceDatabase_QueryEmployee_ParamsPtr New();

  template <typename U>
  static HumanResourceDatabase_QueryEmployee_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<HumanResourceDatabase_QueryEmployee_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HumanResourceDatabase_QueryEmployee_Params>::Convert(*this);
  }

  HumanResourceDatabase_QueryEmployee_Params();
  ~HumanResourceDatabase_QueryEmployee_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  HumanResourceDatabase_QueryEmployee_ParamsPtr Clone() const;
  bool Equals(const HumanResourceDatabase_QueryEmployee_Params& other) const;

  uint64_t id;
  bool retrieve_finger_print;
};



class HumanResourceDatabase_QueryEmployee_ResponseParams;

using HumanResourceDatabase_QueryEmployee_ResponseParamsPtr = mojo::StructPtr<HumanResourceDatabase_QueryEmployee_ResponseParams>;


size_t GetSerializedSize_(const HumanResourceDatabase_QueryEmployee_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    HumanResourceDatabase_QueryEmployee_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::HumanResourceDatabase_QueryEmployee_ResponseParams_Data** output);
void Deserialize_(internal::HumanResourceDatabase_QueryEmployee_ResponseParams_Data* input,
                  HumanResourceDatabase_QueryEmployee_ResponseParams* output);

class HumanResourceDatabase_QueryEmployee_ResponseParams {
 public:
  using Data_ = internal::HumanResourceDatabase_QueryEmployee_ResponseParams_Data;

  static HumanResourceDatabase_QueryEmployee_ResponseParamsPtr New();

  template <typename U>
  static HumanResourceDatabase_QueryEmployee_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<HumanResourceDatabase_QueryEmployee_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HumanResourceDatabase_QueryEmployee_ResponseParams>::Convert(*this);
  }

  HumanResourceDatabase_QueryEmployee_ResponseParams();
  ~HumanResourceDatabase_QueryEmployee_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  HumanResourceDatabase_QueryEmployee_ResponseParamsPtr Clone() const;
  bool Equals(const HumanResourceDatabase_QueryEmployee_ResponseParams& other) const;

  EmployeePtr employee;
  mojo::Array<uint8_t> finger_print;
};



class HumanResourceDatabase_AttachFingerPrint_Params;

using HumanResourceDatabase_AttachFingerPrint_ParamsPtr = mojo::StructPtr<HumanResourceDatabase_AttachFingerPrint_Params>;


size_t GetSerializedSize_(const HumanResourceDatabase_AttachFingerPrint_Params& input);
mojo::internal::ValidationError Serialize_(
    HumanResourceDatabase_AttachFingerPrint_Params* input,
    mojo::internal::Buffer* buffer,
    internal::HumanResourceDatabase_AttachFingerPrint_Params_Data** output);
void Deserialize_(internal::HumanResourceDatabase_AttachFingerPrint_Params_Data* input,
                  HumanResourceDatabase_AttachFingerPrint_Params* output);

class HumanResourceDatabase_AttachFingerPrint_Params {
 public:
  using Data_ = internal::HumanResourceDatabase_AttachFingerPrint_Params_Data;

  static HumanResourceDatabase_AttachFingerPrint_ParamsPtr New();

  template <typename U>
  static HumanResourceDatabase_AttachFingerPrint_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<HumanResourceDatabase_AttachFingerPrint_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HumanResourceDatabase_AttachFingerPrint_Params>::Convert(*this);
  }

  HumanResourceDatabase_AttachFingerPrint_Params();
  ~HumanResourceDatabase_AttachFingerPrint_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  HumanResourceDatabase_AttachFingerPrint_ParamsPtr Clone() const;
  bool Equals(const HumanResourceDatabase_AttachFingerPrint_Params& other) const;

  uint64_t id;
  mojo::Array<uint8_t> finger_print;
};



class HumanResourceDatabase_AttachFingerPrint_ResponseParams;

using HumanResourceDatabase_AttachFingerPrint_ResponseParamsPtr = mojo::InlinedStructPtr<HumanResourceDatabase_AttachFingerPrint_ResponseParams>;


size_t GetSerializedSize_(const HumanResourceDatabase_AttachFingerPrint_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    HumanResourceDatabase_AttachFingerPrint_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::HumanResourceDatabase_AttachFingerPrint_ResponseParams_Data** output);
void Deserialize_(internal::HumanResourceDatabase_AttachFingerPrint_ResponseParams_Data* input,
                  HumanResourceDatabase_AttachFingerPrint_ResponseParams* output);

class HumanResourceDatabase_AttachFingerPrint_ResponseParams {
 public:
  using Data_ = internal::HumanResourceDatabase_AttachFingerPrint_ResponseParams_Data;

  static HumanResourceDatabase_AttachFingerPrint_ResponseParamsPtr New();

  template <typename U>
  static HumanResourceDatabase_AttachFingerPrint_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<HumanResourceDatabase_AttachFingerPrint_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HumanResourceDatabase_AttachFingerPrint_ResponseParams>::Convert(*this);
  }

  HumanResourceDatabase_AttachFingerPrint_ResponseParams();
  ~HumanResourceDatabase_AttachFingerPrint_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  HumanResourceDatabase_AttachFingerPrint_ResponseParamsPtr Clone() const;
  bool Equals(const HumanResourceDatabase_AttachFingerPrint_ResponseParams& other) const;

  bool success;
};



class HumanResourceDatabase_ListEmployeeIds_Params;

using HumanResourceDatabase_ListEmployeeIds_ParamsPtr = mojo::InlinedStructPtr<HumanResourceDatabase_ListEmployeeIds_Params>;


size_t GetSerializedSize_(const HumanResourceDatabase_ListEmployeeIds_Params& input);
mojo::internal::ValidationError Serialize_(
    HumanResourceDatabase_ListEmployeeIds_Params* input,
    mojo::internal::Buffer* buffer,
    internal::HumanResourceDatabase_ListEmployeeIds_Params_Data** output);
void Deserialize_(internal::HumanResourceDatabase_ListEmployeeIds_Params_Data* input,
                  HumanResourceDatabase_ListEmployeeIds_Params* output);

class HumanResourceDatabase_ListEmployeeIds_Params {
 public:
  using Data_ = internal::HumanResourceDatabase_ListEmployeeIds_Params_Data;

  static HumanResourceDatabase_ListEmployeeIds_ParamsPtr New();

  template <typename U>
  static HumanResourceDatabase_ListEmployeeIds_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<HumanResourceDatabase_ListEmployeeIds_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HumanResourceDatabase_ListEmployeeIds_Params>::Convert(*this);
  }

  HumanResourceDatabase_ListEmployeeIds_Params();
  ~HumanResourceDatabase_ListEmployeeIds_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  HumanResourceDatabase_ListEmployeeIds_ParamsPtr Clone() const;
  bool Equals(const HumanResourceDatabase_ListEmployeeIds_Params& other) const;

};



class HumanResourceDatabase_ListEmployeeIds_ResponseParams;

using HumanResourceDatabase_ListEmployeeIds_ResponseParamsPtr = mojo::StructPtr<HumanResourceDatabase_ListEmployeeIds_ResponseParams>;


size_t GetSerializedSize_(const HumanResourceDatabase_ListEmployeeIds_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    HumanResourceDatabase_ListEmployeeIds_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::HumanResourceDatabase_ListEmployeeIds_ResponseParams_Data** output);
void Deserialize_(internal::HumanResourceDatabase_ListEmployeeIds_ResponseParams_Data* input,
                  HumanResourceDatabase_ListEmployeeIds_ResponseParams* output);

class HumanResourceDatabase_ListEmployeeIds_ResponseParams {
 public:
  using Data_ = internal::HumanResourceDatabase_ListEmployeeIds_ResponseParams_Data;

  static HumanResourceDatabase_ListEmployeeIds_ResponseParamsPtr New();

  template <typename U>
  static HumanResourceDatabase_ListEmployeeIds_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<HumanResourceDatabase_ListEmployeeIds_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HumanResourceDatabase_ListEmployeeIds_ResponseParams>::Convert(*this);
  }

  HumanResourceDatabase_ListEmployeeIds_ResponseParams();
  ~HumanResourceDatabase_ListEmployeeIds_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  HumanResourceDatabase_ListEmployeeIds_ResponseParamsPtr Clone() const;
  bool Equals(const HumanResourceDatabase_ListEmployeeIds_ResponseParams& other) const;

  mojo::Array<uint64_t> ids;
};


}  // namespace versioning
}  // namespace test
}  // namespace mojo

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_VERSIONING_TEST_CLIENT_MOJOM_COMMON_H_
