// NOTE: This file was generated by the Mojo bindings generator.
#ifndef MOJO_SERVICES_FILES_INTERFACES_FILE_MOJOM_COMMON_H_
#define MOJO_SERVICES_FILES_INTERFACES_FILE_MOJOM_COMMON_H_

#include <stdint.h>
#include <iosfwd>

#include "mojo/public/cpp/bindings/array.h"
#include "mojo/public/cpp/bindings/callback.h"
#include "mojo/public/cpp/bindings/interface_handle.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/map.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/bindings/string.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/system/buffer.h"
#include "mojo/public/cpp/system/data_pipe.h"
#include "mojo/public/cpp/system/handle.h"
#include "mojo/public/cpp/system/message_pipe.h"
#include "mojo/services/files/interfaces/file.mojom-internal.h"
#include "mojo/services/files/interfaces/types.mojom-common.h"
namespace mojo {
namespace files {

// --- Interface Forward Declarations ---
class File;
class FileRequestValidator;
class FileResponseValidator;
class File_Synchronous;

// --- Struct Forward Declarations ---

// --- Union Forward Declarations ---

// --- Enums Declarations ---

// --- Constants ---

// --- Interface declarations ---
namespace internal {
class File_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = FileRequestValidator;
  using ResponseValidator_ = FileResponseValidator;
  using Synchronous_ = File_Synchronous;
  enum class MessageOrdinals : uint32_t {
    Close = 0,
    Read = 1,
    Write = 2,
    ReadToStream = 3,
    WriteFromStream = 4,
    Tell = 5,
    Seek = 6,
    Stat = 7,
    Truncate = 8,
    Touch = 9,
    Dup = 10,
    Reopen = 11,
    AsBuffer = 12,
    Ioctl = 13,
  };


  virtual ~File_Base() {}
};

}  // namespace internal

// Async interface declaration

class FileProxy;
class FileStub;
class File_Synchronous;

class FileRequestValidator;
class FileResponseValidator;

class File : public internal::File_Base {
 public:
  virtual ~File() override {}

  using Proxy_ = FileProxy;
  using Stub_ = FileStub;
  using CloseCallback = mojo::Callback<void(mojo::files::Error)>;
  virtual void Close(const CloseCallback& callback) = 0;
  using ReadCallback = mojo::Callback<void(mojo::files::Error, mojo::Array<uint8_t>)>;
  virtual void Read(uint32_t num_bytes_to_read, int64_t offset, mojo::files::Whence whence, const ReadCallback& callback) = 0;
  using WriteCallback = mojo::Callback<void(mojo::files::Error, uint32_t)>;
  virtual void Write(mojo::Array<uint8_t> bytes_to_write, int64_t offset, mojo::files::Whence whence, const WriteCallback& callback) = 0;
  using ReadToStreamCallback = mojo::Callback<void(mojo::files::Error)>;
  virtual void ReadToStream(mojo::ScopedDataPipeProducerHandle source, int64_t offset, mojo::files::Whence whence, int64_t num_bytes_to_read, const ReadToStreamCallback& callback) = 0;
  using WriteFromStreamCallback = mojo::Callback<void(mojo::files::Error)>;
  virtual void WriteFromStream(mojo::ScopedDataPipeConsumerHandle sink, int64_t offset, mojo::files::Whence whence, const WriteFromStreamCallback& callback) = 0;
  using TellCallback = mojo::Callback<void(mojo::files::Error, int64_t)>;
  virtual void Tell(const TellCallback& callback) = 0;
  using SeekCallback = mojo::Callback<void(mojo::files::Error, int64_t)>;
  virtual void Seek(int64_t offset, mojo::files::Whence whence, const SeekCallback& callback) = 0;
  using StatCallback = mojo::Callback<void(mojo::files::Error, mojo::files::FileInformationPtr)>;
  virtual void Stat(const StatCallback& callback) = 0;
  using TruncateCallback = mojo::Callback<void(mojo::files::Error)>;
  virtual void Truncate(int64_t size, const TruncateCallback& callback) = 0;
  using TouchCallback = mojo::Callback<void(mojo::files::Error)>;
  virtual void Touch(mojo::files::TimespecOrNowPtr atime, mojo::files::TimespecOrNowPtr mtime, const TouchCallback& callback) = 0;
  using DupCallback = mojo::Callback<void(mojo::files::Error)>;
  virtual void Dup(mojo::InterfaceRequest<File> file, const DupCallback& callback) = 0;
  using ReopenCallback = mojo::Callback<void(mojo::files::Error)>;
  virtual void Reopen(mojo::InterfaceRequest<File> file, uint32_t open_flags, const ReopenCallback& callback) = 0;
  using AsBufferCallback = mojo::Callback<void(mojo::files::Error, mojo::ScopedSharedBufferHandle)>;
  virtual void AsBuffer(const AsBufferCallback& callback) = 0;
  using IoctlCallback = mojo::Callback<void(mojo::files::Error, mojo::Array<uint32_t>)>;
  virtual void Ioctl(uint32_t request, mojo::Array<uint32_t> in_values, const IoctlCallback& callback) = 0;
};

}  // namespace files
}  // namespace mojo

// --- Internal Template Specializations ---

namespace mojo {
namespace internal {

}  // internal
}  // mojo
namespace mojo {
namespace files {

// --- Interface Request Validators ---
class FileRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface Response Validators ---
class FileResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface enum operators ---

// --- Unions ---
// Unions must be declared first because they can be members of structs.

// --- Inlined structs ---

// --- Non-inlined structs ---

// --- Struct serialization helpers ---

// --- Union serialization helpers ---

// --- Request and response parameter structs for Interface methods ---
      

class File_Close_Params;

using File_Close_ParamsPtr = mojo::InlinedStructPtr<File_Close_Params>;


size_t GetSerializedSize_(const File_Close_Params& input);
mojo::internal::ValidationError Serialize_(
    File_Close_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_Close_Params_Data** output);
void Deserialize_(internal::File_Close_Params_Data* input,
                  File_Close_Params* output);

class File_Close_Params {
 public:
  using Data_ = internal::File_Close_Params_Data;

  static File_Close_ParamsPtr New();

  template <typename U>
  static File_Close_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Close_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Close_Params>::Convert(*this);
  }

  File_Close_Params();
  ~File_Close_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Close_ParamsPtr Clone() const;
  bool Equals(const File_Close_Params& other) const;

};



class File_Close_ResponseParams;

using File_Close_ResponseParamsPtr = mojo::InlinedStructPtr<File_Close_ResponseParams>;


size_t GetSerializedSize_(const File_Close_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_Close_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_Close_ResponseParams_Data** output);
void Deserialize_(internal::File_Close_ResponseParams_Data* input,
                  File_Close_ResponseParams* output);

class File_Close_ResponseParams {
 public:
  using Data_ = internal::File_Close_ResponseParams_Data;

  static File_Close_ResponseParamsPtr New();

  template <typename U>
  static File_Close_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Close_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Close_ResponseParams>::Convert(*this);
  }

  File_Close_ResponseParams();
  ~File_Close_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Close_ResponseParamsPtr Clone() const;
  bool Equals(const File_Close_ResponseParams& other) const;

  mojo::files::Error err;
};



class File_Read_Params;

using File_Read_ParamsPtr = mojo::InlinedStructPtr<File_Read_Params>;


size_t GetSerializedSize_(const File_Read_Params& input);
mojo::internal::ValidationError Serialize_(
    File_Read_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_Read_Params_Data** output);
void Deserialize_(internal::File_Read_Params_Data* input,
                  File_Read_Params* output);

class File_Read_Params {
 public:
  using Data_ = internal::File_Read_Params_Data;

  static File_Read_ParamsPtr New();

  template <typename U>
  static File_Read_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Read_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Read_Params>::Convert(*this);
  }

  File_Read_Params();
  ~File_Read_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Read_ParamsPtr Clone() const;
  bool Equals(const File_Read_Params& other) const;

  uint32_t num_bytes_to_read;
  int64_t offset;
  mojo::files::Whence whence;
};



class File_Read_ResponseParams;

using File_Read_ResponseParamsPtr = mojo::StructPtr<File_Read_ResponseParams>;


size_t GetSerializedSize_(const File_Read_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_Read_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_Read_ResponseParams_Data** output);
void Deserialize_(internal::File_Read_ResponseParams_Data* input,
                  File_Read_ResponseParams* output);

class File_Read_ResponseParams {
 public:
  using Data_ = internal::File_Read_ResponseParams_Data;

  static File_Read_ResponseParamsPtr New();

  template <typename U>
  static File_Read_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Read_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Read_ResponseParams>::Convert(*this);
  }

  File_Read_ResponseParams();
  ~File_Read_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Read_ResponseParamsPtr Clone() const;
  bool Equals(const File_Read_ResponseParams& other) const;

  mojo::files::Error error;
  mojo::Array<uint8_t> bytes_read;
};



class File_Write_Params;

using File_Write_ParamsPtr = mojo::StructPtr<File_Write_Params>;


size_t GetSerializedSize_(const File_Write_Params& input);
mojo::internal::ValidationError Serialize_(
    File_Write_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_Write_Params_Data** output);
void Deserialize_(internal::File_Write_Params_Data* input,
                  File_Write_Params* output);

class File_Write_Params {
 public:
  using Data_ = internal::File_Write_Params_Data;

  static File_Write_ParamsPtr New();

  template <typename U>
  static File_Write_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Write_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Write_Params>::Convert(*this);
  }

  File_Write_Params();
  ~File_Write_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Write_ParamsPtr Clone() const;
  bool Equals(const File_Write_Params& other) const;

  mojo::Array<uint8_t> bytes_to_write;
  int64_t offset;
  mojo::files::Whence whence;
};



class File_Write_ResponseParams;

using File_Write_ResponseParamsPtr = mojo::InlinedStructPtr<File_Write_ResponseParams>;


size_t GetSerializedSize_(const File_Write_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_Write_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_Write_ResponseParams_Data** output);
void Deserialize_(internal::File_Write_ResponseParams_Data* input,
                  File_Write_ResponseParams* output);

class File_Write_ResponseParams {
 public:
  using Data_ = internal::File_Write_ResponseParams_Data;

  static File_Write_ResponseParamsPtr New();

  template <typename U>
  static File_Write_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Write_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Write_ResponseParams>::Convert(*this);
  }

  File_Write_ResponseParams();
  ~File_Write_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Write_ResponseParamsPtr Clone() const;
  bool Equals(const File_Write_ResponseParams& other) const;

  mojo::files::Error error;
  uint32_t num_bytes_written;
};



class File_ReadToStream_Params;

using File_ReadToStream_ParamsPtr = mojo::StructPtr<File_ReadToStream_Params>;


size_t GetSerializedSize_(const File_ReadToStream_Params& input);
mojo::internal::ValidationError Serialize_(
    File_ReadToStream_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_ReadToStream_Params_Data** output);
void Deserialize_(internal::File_ReadToStream_Params_Data* input,
                  File_ReadToStream_Params* output);

class File_ReadToStream_Params {
 public:
  using Data_ = internal::File_ReadToStream_Params_Data;

  static File_ReadToStream_ParamsPtr New();

  template <typename U>
  static File_ReadToStream_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_ReadToStream_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_ReadToStream_Params>::Convert(*this);
  }

  File_ReadToStream_Params();
  ~File_ReadToStream_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const File_ReadToStream_Params& other) const;

  mojo::ScopedDataPipeProducerHandle source;
  int64_t offset;
  mojo::files::Whence whence;
  int64_t num_bytes_to_read;
};



class File_ReadToStream_ResponseParams;

using File_ReadToStream_ResponseParamsPtr = mojo::InlinedStructPtr<File_ReadToStream_ResponseParams>;


size_t GetSerializedSize_(const File_ReadToStream_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_ReadToStream_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_ReadToStream_ResponseParams_Data** output);
void Deserialize_(internal::File_ReadToStream_ResponseParams_Data* input,
                  File_ReadToStream_ResponseParams* output);

class File_ReadToStream_ResponseParams {
 public:
  using Data_ = internal::File_ReadToStream_ResponseParams_Data;

  static File_ReadToStream_ResponseParamsPtr New();

  template <typename U>
  static File_ReadToStream_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_ReadToStream_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_ReadToStream_ResponseParams>::Convert(*this);
  }

  File_ReadToStream_ResponseParams();
  ~File_ReadToStream_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_ReadToStream_ResponseParamsPtr Clone() const;
  bool Equals(const File_ReadToStream_ResponseParams& other) const;

  mojo::files::Error error;
};



class File_WriteFromStream_Params;

using File_WriteFromStream_ParamsPtr = mojo::StructPtr<File_WriteFromStream_Params>;


size_t GetSerializedSize_(const File_WriteFromStream_Params& input);
mojo::internal::ValidationError Serialize_(
    File_WriteFromStream_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_WriteFromStream_Params_Data** output);
void Deserialize_(internal::File_WriteFromStream_Params_Data* input,
                  File_WriteFromStream_Params* output);

class File_WriteFromStream_Params {
 public:
  using Data_ = internal::File_WriteFromStream_Params_Data;

  static File_WriteFromStream_ParamsPtr New();

  template <typename U>
  static File_WriteFromStream_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_WriteFromStream_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_WriteFromStream_Params>::Convert(*this);
  }

  File_WriteFromStream_Params();
  ~File_WriteFromStream_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const File_WriteFromStream_Params& other) const;

  mojo::ScopedDataPipeConsumerHandle sink;
  int64_t offset;
  mojo::files::Whence whence;
};



class File_WriteFromStream_ResponseParams;

using File_WriteFromStream_ResponseParamsPtr = mojo::InlinedStructPtr<File_WriteFromStream_ResponseParams>;


size_t GetSerializedSize_(const File_WriteFromStream_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_WriteFromStream_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_WriteFromStream_ResponseParams_Data** output);
void Deserialize_(internal::File_WriteFromStream_ResponseParams_Data* input,
                  File_WriteFromStream_ResponseParams* output);

class File_WriteFromStream_ResponseParams {
 public:
  using Data_ = internal::File_WriteFromStream_ResponseParams_Data;

  static File_WriteFromStream_ResponseParamsPtr New();

  template <typename U>
  static File_WriteFromStream_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_WriteFromStream_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_WriteFromStream_ResponseParams>::Convert(*this);
  }

  File_WriteFromStream_ResponseParams();
  ~File_WriteFromStream_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_WriteFromStream_ResponseParamsPtr Clone() const;
  bool Equals(const File_WriteFromStream_ResponseParams& other) const;

  mojo::files::Error error;
};



class File_Tell_Params;

using File_Tell_ParamsPtr = mojo::InlinedStructPtr<File_Tell_Params>;


size_t GetSerializedSize_(const File_Tell_Params& input);
mojo::internal::ValidationError Serialize_(
    File_Tell_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_Tell_Params_Data** output);
void Deserialize_(internal::File_Tell_Params_Data* input,
                  File_Tell_Params* output);

class File_Tell_Params {
 public:
  using Data_ = internal::File_Tell_Params_Data;

  static File_Tell_ParamsPtr New();

  template <typename U>
  static File_Tell_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Tell_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Tell_Params>::Convert(*this);
  }

  File_Tell_Params();
  ~File_Tell_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Tell_ParamsPtr Clone() const;
  bool Equals(const File_Tell_Params& other) const;

};



class File_Tell_ResponseParams;

using File_Tell_ResponseParamsPtr = mojo::InlinedStructPtr<File_Tell_ResponseParams>;


size_t GetSerializedSize_(const File_Tell_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_Tell_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_Tell_ResponseParams_Data** output);
void Deserialize_(internal::File_Tell_ResponseParams_Data* input,
                  File_Tell_ResponseParams* output);

class File_Tell_ResponseParams {
 public:
  using Data_ = internal::File_Tell_ResponseParams_Data;

  static File_Tell_ResponseParamsPtr New();

  template <typename U>
  static File_Tell_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Tell_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Tell_ResponseParams>::Convert(*this);
  }

  File_Tell_ResponseParams();
  ~File_Tell_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Tell_ResponseParamsPtr Clone() const;
  bool Equals(const File_Tell_ResponseParams& other) const;

  mojo::files::Error error;
  int64_t position;
};



class File_Seek_Params;

using File_Seek_ParamsPtr = mojo::InlinedStructPtr<File_Seek_Params>;


size_t GetSerializedSize_(const File_Seek_Params& input);
mojo::internal::ValidationError Serialize_(
    File_Seek_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_Seek_Params_Data** output);
void Deserialize_(internal::File_Seek_Params_Data* input,
                  File_Seek_Params* output);

class File_Seek_Params {
 public:
  using Data_ = internal::File_Seek_Params_Data;

  static File_Seek_ParamsPtr New();

  template <typename U>
  static File_Seek_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Seek_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Seek_Params>::Convert(*this);
  }

  File_Seek_Params();
  ~File_Seek_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Seek_ParamsPtr Clone() const;
  bool Equals(const File_Seek_Params& other) const;

  int64_t offset;
  mojo::files::Whence whence;
};



class File_Seek_ResponseParams;

using File_Seek_ResponseParamsPtr = mojo::InlinedStructPtr<File_Seek_ResponseParams>;


size_t GetSerializedSize_(const File_Seek_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_Seek_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_Seek_ResponseParams_Data** output);
void Deserialize_(internal::File_Seek_ResponseParams_Data* input,
                  File_Seek_ResponseParams* output);

class File_Seek_ResponseParams {
 public:
  using Data_ = internal::File_Seek_ResponseParams_Data;

  static File_Seek_ResponseParamsPtr New();

  template <typename U>
  static File_Seek_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Seek_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Seek_ResponseParams>::Convert(*this);
  }

  File_Seek_ResponseParams();
  ~File_Seek_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Seek_ResponseParamsPtr Clone() const;
  bool Equals(const File_Seek_ResponseParams& other) const;

  mojo::files::Error error;
  int64_t position;
};



class File_Stat_Params;

using File_Stat_ParamsPtr = mojo::InlinedStructPtr<File_Stat_Params>;


size_t GetSerializedSize_(const File_Stat_Params& input);
mojo::internal::ValidationError Serialize_(
    File_Stat_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_Stat_Params_Data** output);
void Deserialize_(internal::File_Stat_Params_Data* input,
                  File_Stat_Params* output);

class File_Stat_Params {
 public:
  using Data_ = internal::File_Stat_Params_Data;

  static File_Stat_ParamsPtr New();

  template <typename U>
  static File_Stat_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Stat_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Stat_Params>::Convert(*this);
  }

  File_Stat_Params();
  ~File_Stat_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Stat_ParamsPtr Clone() const;
  bool Equals(const File_Stat_Params& other) const;

};



class File_Stat_ResponseParams;

using File_Stat_ResponseParamsPtr = mojo::StructPtr<File_Stat_ResponseParams>;


size_t GetSerializedSize_(const File_Stat_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_Stat_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_Stat_ResponseParams_Data** output);
void Deserialize_(internal::File_Stat_ResponseParams_Data* input,
                  File_Stat_ResponseParams* output);

class File_Stat_ResponseParams {
 public:
  using Data_ = internal::File_Stat_ResponseParams_Data;

  static File_Stat_ResponseParamsPtr New();

  template <typename U>
  static File_Stat_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Stat_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Stat_ResponseParams>::Convert(*this);
  }

  File_Stat_ResponseParams();
  ~File_Stat_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Stat_ResponseParamsPtr Clone() const;
  bool Equals(const File_Stat_ResponseParams& other) const;

  mojo::files::Error error;
  mojo::files::FileInformationPtr file_information;
};



class File_Truncate_Params;

using File_Truncate_ParamsPtr = mojo::InlinedStructPtr<File_Truncate_Params>;


size_t GetSerializedSize_(const File_Truncate_Params& input);
mojo::internal::ValidationError Serialize_(
    File_Truncate_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_Truncate_Params_Data** output);
void Deserialize_(internal::File_Truncate_Params_Data* input,
                  File_Truncate_Params* output);

class File_Truncate_Params {
 public:
  using Data_ = internal::File_Truncate_Params_Data;

  static File_Truncate_ParamsPtr New();

  template <typename U>
  static File_Truncate_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Truncate_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Truncate_Params>::Convert(*this);
  }

  File_Truncate_Params();
  ~File_Truncate_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Truncate_ParamsPtr Clone() const;
  bool Equals(const File_Truncate_Params& other) const;

  int64_t size;
};



class File_Truncate_ResponseParams;

using File_Truncate_ResponseParamsPtr = mojo::InlinedStructPtr<File_Truncate_ResponseParams>;


size_t GetSerializedSize_(const File_Truncate_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_Truncate_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_Truncate_ResponseParams_Data** output);
void Deserialize_(internal::File_Truncate_ResponseParams_Data* input,
                  File_Truncate_ResponseParams* output);

class File_Truncate_ResponseParams {
 public:
  using Data_ = internal::File_Truncate_ResponseParams_Data;

  static File_Truncate_ResponseParamsPtr New();

  template <typename U>
  static File_Truncate_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Truncate_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Truncate_ResponseParams>::Convert(*this);
  }

  File_Truncate_ResponseParams();
  ~File_Truncate_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Truncate_ResponseParamsPtr Clone() const;
  bool Equals(const File_Truncate_ResponseParams& other) const;

  mojo::files::Error error;
};



class File_Touch_Params;

using File_Touch_ParamsPtr = mojo::StructPtr<File_Touch_Params>;


size_t GetSerializedSize_(const File_Touch_Params& input);
mojo::internal::ValidationError Serialize_(
    File_Touch_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_Touch_Params_Data** output);
void Deserialize_(internal::File_Touch_Params_Data* input,
                  File_Touch_Params* output);

class File_Touch_Params {
 public:
  using Data_ = internal::File_Touch_Params_Data;

  static File_Touch_ParamsPtr New();

  template <typename U>
  static File_Touch_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Touch_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Touch_Params>::Convert(*this);
  }

  File_Touch_Params();
  ~File_Touch_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Touch_ParamsPtr Clone() const;
  bool Equals(const File_Touch_Params& other) const;

  mojo::files::TimespecOrNowPtr atime;
  mojo::files::TimespecOrNowPtr mtime;
};



class File_Touch_ResponseParams;

using File_Touch_ResponseParamsPtr = mojo::InlinedStructPtr<File_Touch_ResponseParams>;


size_t GetSerializedSize_(const File_Touch_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_Touch_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_Touch_ResponseParams_Data** output);
void Deserialize_(internal::File_Touch_ResponseParams_Data* input,
                  File_Touch_ResponseParams* output);

class File_Touch_ResponseParams {
 public:
  using Data_ = internal::File_Touch_ResponseParams_Data;

  static File_Touch_ResponseParamsPtr New();

  template <typename U>
  static File_Touch_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Touch_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Touch_ResponseParams>::Convert(*this);
  }

  File_Touch_ResponseParams();
  ~File_Touch_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Touch_ResponseParamsPtr Clone() const;
  bool Equals(const File_Touch_ResponseParams& other) const;

  mojo::files::Error error;
};



class File_Dup_Params;

using File_Dup_ParamsPtr = mojo::StructPtr<File_Dup_Params>;


size_t GetSerializedSize_(const File_Dup_Params& input);
mojo::internal::ValidationError Serialize_(
    File_Dup_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_Dup_Params_Data** output);
void Deserialize_(internal::File_Dup_Params_Data* input,
                  File_Dup_Params* output);

class File_Dup_Params {
 public:
  using Data_ = internal::File_Dup_Params_Data;

  static File_Dup_ParamsPtr New();

  template <typename U>
  static File_Dup_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Dup_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Dup_Params>::Convert(*this);
  }

  File_Dup_Params();
  ~File_Dup_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const File_Dup_Params& other) const;

  mojo::InterfaceRequest<File> file;
};



class File_Dup_ResponseParams;

using File_Dup_ResponseParamsPtr = mojo::InlinedStructPtr<File_Dup_ResponseParams>;


size_t GetSerializedSize_(const File_Dup_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_Dup_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_Dup_ResponseParams_Data** output);
void Deserialize_(internal::File_Dup_ResponseParams_Data* input,
                  File_Dup_ResponseParams* output);

class File_Dup_ResponseParams {
 public:
  using Data_ = internal::File_Dup_ResponseParams_Data;

  static File_Dup_ResponseParamsPtr New();

  template <typename U>
  static File_Dup_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Dup_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Dup_ResponseParams>::Convert(*this);
  }

  File_Dup_ResponseParams();
  ~File_Dup_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Dup_ResponseParamsPtr Clone() const;
  bool Equals(const File_Dup_ResponseParams& other) const;

  mojo::files::Error error;
};



class File_Reopen_Params;

using File_Reopen_ParamsPtr = mojo::StructPtr<File_Reopen_Params>;


size_t GetSerializedSize_(const File_Reopen_Params& input);
mojo::internal::ValidationError Serialize_(
    File_Reopen_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_Reopen_Params_Data** output);
void Deserialize_(internal::File_Reopen_Params_Data* input,
                  File_Reopen_Params* output);

class File_Reopen_Params {
 public:
  using Data_ = internal::File_Reopen_Params_Data;

  static File_Reopen_ParamsPtr New();

  template <typename U>
  static File_Reopen_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Reopen_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Reopen_Params>::Convert(*this);
  }

  File_Reopen_Params();
  ~File_Reopen_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const File_Reopen_Params& other) const;

  mojo::InterfaceRequest<File> file;
  uint32_t open_flags;
};



class File_Reopen_ResponseParams;

using File_Reopen_ResponseParamsPtr = mojo::InlinedStructPtr<File_Reopen_ResponseParams>;


size_t GetSerializedSize_(const File_Reopen_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_Reopen_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_Reopen_ResponseParams_Data** output);
void Deserialize_(internal::File_Reopen_ResponseParams_Data* input,
                  File_Reopen_ResponseParams* output);

class File_Reopen_ResponseParams {
 public:
  using Data_ = internal::File_Reopen_ResponseParams_Data;

  static File_Reopen_ResponseParamsPtr New();

  template <typename U>
  static File_Reopen_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Reopen_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Reopen_ResponseParams>::Convert(*this);
  }

  File_Reopen_ResponseParams();
  ~File_Reopen_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Reopen_ResponseParamsPtr Clone() const;
  bool Equals(const File_Reopen_ResponseParams& other) const;

  mojo::files::Error error;
};



class File_AsBuffer_Params;

using File_AsBuffer_ParamsPtr = mojo::InlinedStructPtr<File_AsBuffer_Params>;


size_t GetSerializedSize_(const File_AsBuffer_Params& input);
mojo::internal::ValidationError Serialize_(
    File_AsBuffer_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_AsBuffer_Params_Data** output);
void Deserialize_(internal::File_AsBuffer_Params_Data* input,
                  File_AsBuffer_Params* output);

class File_AsBuffer_Params {
 public:
  using Data_ = internal::File_AsBuffer_Params_Data;

  static File_AsBuffer_ParamsPtr New();

  template <typename U>
  static File_AsBuffer_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_AsBuffer_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_AsBuffer_Params>::Convert(*this);
  }

  File_AsBuffer_Params();
  ~File_AsBuffer_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_AsBuffer_ParamsPtr Clone() const;
  bool Equals(const File_AsBuffer_Params& other) const;

};



class File_AsBuffer_ResponseParams;

using File_AsBuffer_ResponseParamsPtr = mojo::StructPtr<File_AsBuffer_ResponseParams>;


size_t GetSerializedSize_(const File_AsBuffer_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_AsBuffer_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_AsBuffer_ResponseParams_Data** output);
void Deserialize_(internal::File_AsBuffer_ResponseParams_Data* input,
                  File_AsBuffer_ResponseParams* output);

class File_AsBuffer_ResponseParams {
 public:
  using Data_ = internal::File_AsBuffer_ResponseParams_Data;

  static File_AsBuffer_ResponseParamsPtr New();

  template <typename U>
  static File_AsBuffer_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_AsBuffer_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_AsBuffer_ResponseParams>::Convert(*this);
  }

  File_AsBuffer_ResponseParams();
  ~File_AsBuffer_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const File_AsBuffer_ResponseParams& other) const;

  mojo::files::Error error;
  mojo::ScopedSharedBufferHandle buffer;
};



class File_Ioctl_Params;

using File_Ioctl_ParamsPtr = mojo::StructPtr<File_Ioctl_Params>;


size_t GetSerializedSize_(const File_Ioctl_Params& input);
mojo::internal::ValidationError Serialize_(
    File_Ioctl_Params* input,
    mojo::internal::Buffer* buffer,
    internal::File_Ioctl_Params_Data** output);
void Deserialize_(internal::File_Ioctl_Params_Data* input,
                  File_Ioctl_Params* output);

class File_Ioctl_Params {
 public:
  using Data_ = internal::File_Ioctl_Params_Data;

  static File_Ioctl_ParamsPtr New();

  template <typename U>
  static File_Ioctl_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Ioctl_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Ioctl_Params>::Convert(*this);
  }

  File_Ioctl_Params();
  ~File_Ioctl_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Ioctl_ParamsPtr Clone() const;
  bool Equals(const File_Ioctl_Params& other) const;

  uint32_t request;
  mojo::Array<uint32_t> in_values;
};



class File_Ioctl_ResponseParams;

using File_Ioctl_ResponseParamsPtr = mojo::StructPtr<File_Ioctl_ResponseParams>;


size_t GetSerializedSize_(const File_Ioctl_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    File_Ioctl_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::File_Ioctl_ResponseParams_Data** output);
void Deserialize_(internal::File_Ioctl_ResponseParams_Data* input,
                  File_Ioctl_ResponseParams* output);

class File_Ioctl_ResponseParams {
 public:
  using Data_ = internal::File_Ioctl_ResponseParams_Data;

  static File_Ioctl_ResponseParamsPtr New();

  template <typename U>
  static File_Ioctl_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<File_Ioctl_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, File_Ioctl_ResponseParams>::Convert(*this);
  }

  File_Ioctl_ResponseParams();
  ~File_Ioctl_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  File_Ioctl_ResponseParamsPtr Clone() const;
  bool Equals(const File_Ioctl_ResponseParams& other) const;

  mojo::files::Error error;
  mojo::Array<uint32_t> out_values;
};


}  // namespace files
}  // namespace mojo

#endif  // MOJO_SERVICES_FILES_INTERFACES_FILE_MOJOM_COMMON_H_
