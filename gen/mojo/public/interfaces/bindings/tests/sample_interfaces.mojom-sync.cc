// NOTE: This file was generated by the Mojo bindings generator.
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "mojo/public/interfaces/bindings/tests/sample_interfaces.mojom-sync.h"

#include <math.h>
#include <ostream>
#include <string>
#include <utility>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/synchronous_connector.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/bindings/message.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "mojo/public/interfaces/bindings/tests/sample_interfaces.mojom-internal.h"
#include "mojo/public/interfaces/bindings/tests/sample_interfaces.mojom-common.h"
namespace sample {

// --- Interface definitions ---
Provider_SynchronousProxy::Provider_SynchronousProxy(
      mojo::internal::SynchronousConnector* connector,
      mojo::internal::MessageValidatorList&& validators)
          : connector_(connector), validators_(std::move(validators)) {
}


bool Provider_SynchronousProxy::EchoString(const mojo::String& in_a, mojo::String* out_a) {
  size_t size = sizeof(internal::Provider_EchoString_Params_Data);
  size += GetSerializedSize_(in_a);

  auto msg_name = static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoString);
  mojo::RequestMessageBuilder builder(msg_name, size);

  internal::Provider_EchoString_Params_Data* out_params =
      internal::Provider_EchoString_Params_Data::New(builder.buffer());
  SerializeString_(in_a, builder.buffer(), &out_params->a.ptr);
  if (!out_params->a.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a in {{interface.name}}::{{method.name}}");
  }
  out_params->EncodePointersAndHandles(builder.message()->mutable_handles());
  
  if (!connector_->Write(builder.message()))
    return false;
  mojo::Message response_msg;
  if (!connector_->BlockingRead(&response_msg))
    return false; 
  
  // Validate the incoming message.
  std::string response_err;
  if (mojo::internal::RunValidatorsOnMessage(validators_, &response_msg,
                                             &response_err)
        != mojo::internal::ValidationError::NONE) {
    MOJO_LOG(WARNING) << response_err;
    return false;
  } 
  if (mojo::internal::ControlMessageHandler::IsControlMessage(&response_msg)) {
    MOJO_LOG(ERROR) << "Synchronous interface bindings currently don't support "
                       "interface control messages.";
    return false;
  }
  if (response_msg.name() != msg_name) {
    MOJO_LOG(ERROR) << "Expecting response for message = " << msg_name <<
                       ", but received message = " << response_msg.name();
    return false;
  }
  
  internal::Provider_EchoString_ResponseParams_Data*
      response_params = reinterpret_cast<internal::Provider_EchoString_ResponseParams_Data*>(
          response_msg.mutable_payload());
  response_params->DecodePointersAndHandles(response_msg.mutable_handles());
  
  do {
    // NOTE: The memory backing |response_params| may has be smaller than
    // |sizeof(*response_params)| if the message comes from an older version.
    Deserialize_(response_params->a.ptr, &(*out_a));
  } while (false);
  return true;
}
bool Provider_SynchronousProxy::EchoStrings(const mojo::String& in_a, const mojo::String& in_b, mojo::String* out_a, mojo::String* out_b) {
  size_t size = sizeof(internal::Provider_EchoStrings_Params_Data);
  size += GetSerializedSize_(in_a);
  size += GetSerializedSize_(in_b);

  auto msg_name = static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoStrings);
  mojo::RequestMessageBuilder builder(msg_name, size);

  internal::Provider_EchoStrings_Params_Data* out_params =
      internal::Provider_EchoStrings_Params_Data::New(builder.buffer());
  SerializeString_(in_a, builder.buffer(), &out_params->a.ptr);
  if (!out_params->a.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a in {{interface.name}}::{{method.name}}");
  }
  SerializeString_(in_b, builder.buffer(), &out_params->b.ptr);
  if (!out_params->b.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null b in {{interface.name}}::{{method.name}}");
  }
  out_params->EncodePointersAndHandles(builder.message()->mutable_handles());
  
  if (!connector_->Write(builder.message()))
    return false;
  mojo::Message response_msg;
  if (!connector_->BlockingRead(&response_msg))
    return false; 
  
  // Validate the incoming message.
  std::string response_err;
  if (mojo::internal::RunValidatorsOnMessage(validators_, &response_msg,
                                             &response_err)
        != mojo::internal::ValidationError::NONE) {
    MOJO_LOG(WARNING) << response_err;
    return false;
  } 
  if (mojo::internal::ControlMessageHandler::IsControlMessage(&response_msg)) {
    MOJO_LOG(ERROR) << "Synchronous interface bindings currently don't support "
                       "interface control messages.";
    return false;
  }
  if (response_msg.name() != msg_name) {
    MOJO_LOG(ERROR) << "Expecting response for message = " << msg_name <<
                       ", but received message = " << response_msg.name();
    return false;
  }
  
  internal::Provider_EchoStrings_ResponseParams_Data*
      response_params = reinterpret_cast<internal::Provider_EchoStrings_ResponseParams_Data*>(
          response_msg.mutable_payload());
  response_params->DecodePointersAndHandles(response_msg.mutable_handles());
  
  do {
    // NOTE: The memory backing |response_params| may has be smaller than
    // |sizeof(*response_params)| if the message comes from an older version.
    Deserialize_(response_params->a.ptr, &(*out_a));
    Deserialize_(response_params->b.ptr, &(*out_b));
  } while (false);
  return true;
}
bool Provider_SynchronousProxy::EchoMessagePipeHandle(mojo::ScopedMessagePipeHandle in_a, mojo::ScopedMessagePipeHandle* out_a) {
  size_t size = sizeof(internal::Provider_EchoMessagePipeHandle_Params_Data);

  auto msg_name = static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoMessagePipeHandle);
  mojo::RequestMessageBuilder builder(msg_name, size);

  internal::Provider_EchoMessagePipeHandle_Params_Data* out_params =
      internal::Provider_EchoMessagePipeHandle_Params_Data::New(builder.buffer());
  out_params->a = in_a.release();
  if (!out_params->a.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid a in {{interface.name}}::{{method.name}}");
  }
  out_params->EncodePointersAndHandles(builder.message()->mutable_handles());
  
  if (!connector_->Write(builder.message()))
    return false;
  mojo::Message response_msg;
  if (!connector_->BlockingRead(&response_msg))
    return false; 
  
  // Validate the incoming message.
  std::string response_err;
  if (mojo::internal::RunValidatorsOnMessage(validators_, &response_msg,
                                             &response_err)
        != mojo::internal::ValidationError::NONE) {
    MOJO_LOG(WARNING) << response_err;
    return false;
  } 
  if (mojo::internal::ControlMessageHandler::IsControlMessage(&response_msg)) {
    MOJO_LOG(ERROR) << "Synchronous interface bindings currently don't support "
                       "interface control messages.";
    return false;
  }
  if (response_msg.name() != msg_name) {
    MOJO_LOG(ERROR) << "Expecting response for message = " << msg_name <<
                       ", but received message = " << response_msg.name();
    return false;
  }
  
  internal::Provider_EchoMessagePipeHandle_ResponseParams_Data*
      response_params = reinterpret_cast<internal::Provider_EchoMessagePipeHandle_ResponseParams_Data*>(
          response_msg.mutable_payload());
  response_params->DecodePointersAndHandles(response_msg.mutable_handles());
  
  do {
    // NOTE: The memory backing |response_params| may has be smaller than
    // |sizeof(*response_params)| if the message comes from an older version.
    (*out_a).reset(mojo::internal::FetchAndReset(&response_params->a));
  } while (false);
  return true;
}
bool Provider_SynchronousProxy::EchoEnum(Enum in_a, Enum* out_a) {
  size_t size = sizeof(internal::Provider_EchoEnum_Params_Data);

  auto msg_name = static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoEnum);
  mojo::RequestMessageBuilder builder(msg_name, size);

  internal::Provider_EchoEnum_Params_Data* out_params =
      internal::Provider_EchoEnum_Params_Data::New(builder.buffer());
  out_params->a =
    static_cast<int32_t>(in_a);
  out_params->EncodePointersAndHandles(builder.message()->mutable_handles());
  
  if (!connector_->Write(builder.message()))
    return false;
  mojo::Message response_msg;
  if (!connector_->BlockingRead(&response_msg))
    return false; 
  
  // Validate the incoming message.
  std::string response_err;
  if (mojo::internal::RunValidatorsOnMessage(validators_, &response_msg,
                                             &response_err)
        != mojo::internal::ValidationError::NONE) {
    MOJO_LOG(WARNING) << response_err;
    return false;
  } 
  if (mojo::internal::ControlMessageHandler::IsControlMessage(&response_msg)) {
    MOJO_LOG(ERROR) << "Synchronous interface bindings currently don't support "
                       "interface control messages.";
    return false;
  }
  if (response_msg.name() != msg_name) {
    MOJO_LOG(ERROR) << "Expecting response for message = " << msg_name <<
                       ", but received message = " << response_msg.name();
    return false;
  }
  
  internal::Provider_EchoEnum_ResponseParams_Data*
      response_params = reinterpret_cast<internal::Provider_EchoEnum_ResponseParams_Data*>(
          response_msg.mutable_payload());
  response_params->DecodePointersAndHandles(response_msg.mutable_handles());
  
  do {
    // NOTE: The memory backing |response_params| may has be smaller than
    // |sizeof(*response_params)| if the message comes from an older version.
    (*out_a) = static_cast<Enum>(response_params->a);
  } while (false);
  return true;
}
bool Provider_SynchronousProxy::EchoInt(int32_t in_a, int32_t* out_a) {
  size_t size = sizeof(internal::Provider_EchoInt_Params_Data);

  auto msg_name = static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoInt);
  mojo::RequestMessageBuilder builder(msg_name, size);

  internal::Provider_EchoInt_Params_Data* out_params =
      internal::Provider_EchoInt_Params_Data::New(builder.buffer());
  out_params->a = in_a;
  out_params->EncodePointersAndHandles(builder.message()->mutable_handles());
  
  if (!connector_->Write(builder.message()))
    return false;
  mojo::Message response_msg;
  if (!connector_->BlockingRead(&response_msg))
    return false; 
  
  // Validate the incoming message.
  std::string response_err;
  if (mojo::internal::RunValidatorsOnMessage(validators_, &response_msg,
                                             &response_err)
        != mojo::internal::ValidationError::NONE) {
    MOJO_LOG(WARNING) << response_err;
    return false;
  } 
  if (mojo::internal::ControlMessageHandler::IsControlMessage(&response_msg)) {
    MOJO_LOG(ERROR) << "Synchronous interface bindings currently don't support "
                       "interface control messages.";
    return false;
  }
  if (response_msg.name() != msg_name) {
    MOJO_LOG(ERROR) << "Expecting response for message = " << msg_name <<
                       ", but received message = " << response_msg.name();
    return false;
  }
  
  internal::Provider_EchoInt_ResponseParams_Data*
      response_params = reinterpret_cast<internal::Provider_EchoInt_ResponseParams_Data*>(
          response_msg.mutable_payload());
  response_params->DecodePointersAndHandles(response_msg.mutable_handles());
  
  do {
    // NOTE: The memory backing |response_params| may has be smaller than
    // |sizeof(*response_params)| if the message comes from an older version.
    (*out_a) = response_params->a;
  } while (false);
  return true;
}IntegerAccessor_SynchronousProxy::IntegerAccessor_SynchronousProxy(
      mojo::internal::SynchronousConnector* connector,
      mojo::internal::MessageValidatorList&& validators)
          : connector_(connector), validators_(std::move(validators)) {
}


bool IntegerAccessor_SynchronousProxy::GetInteger(int64_t* out_data, Enum* out_type) {
  size_t size = sizeof(internal::IntegerAccessor_GetInteger_Params_Data);

  auto msg_name = static_cast<uint32_t>(internal::IntegerAccessor_Base::MessageOrdinals::GetInteger);
  mojo::RequestMessageBuilder builder(msg_name, size);

  internal::IntegerAccessor_GetInteger_Params_Data* out_params =
      internal::IntegerAccessor_GetInteger_Params_Data::New(builder.buffer());
  out_params->EncodePointersAndHandles(builder.message()->mutable_handles());
  
  if (!connector_->Write(builder.message()))
    return false;
  mojo::Message response_msg;
  if (!connector_->BlockingRead(&response_msg))
    return false; 
  
  // Validate the incoming message.
  std::string response_err;
  if (mojo::internal::RunValidatorsOnMessage(validators_, &response_msg,
                                             &response_err)
        != mojo::internal::ValidationError::NONE) {
    MOJO_LOG(WARNING) << response_err;
    return false;
  } 
  if (mojo::internal::ControlMessageHandler::IsControlMessage(&response_msg)) {
    MOJO_LOG(ERROR) << "Synchronous interface bindings currently don't support "
                       "interface control messages.";
    return false;
  }
  if (response_msg.name() != msg_name) {
    MOJO_LOG(ERROR) << "Expecting response for message = " << msg_name <<
                       ", but received message = " << response_msg.name();
    return false;
  }
  
  internal::IntegerAccessor_GetInteger_ResponseParams_Data*
      response_params = reinterpret_cast<internal::IntegerAccessor_GetInteger_ResponseParams_Data*>(
          response_msg.mutable_payload());
  response_params->DecodePointersAndHandles(response_msg.mutable_handles());
  
  do {
    // NOTE: The memory backing |response_params| may has be smaller than
    // |sizeof(*response_params)| if the message comes from an older version.
    (*out_data) = response_params->data;
    if (response_params->header_.version < 2)
      break;
    (*out_type) = static_cast<Enum>(response_params->type);
  } while (false);
  return true;
}
bool IntegerAccessor_SynchronousProxy::SetInteger(int64_t in_data, Enum in_type) const  {
  size_t size = sizeof(internal::IntegerAccessor_SetInteger_Params_Data);

  auto msg_name = static_cast<uint32_t>(internal::IntegerAccessor_Base::MessageOrdinals::SetInteger);
  mojo::MessageBuilder builder(msg_name, size);

  internal::IntegerAccessor_SetInteger_Params_Data* out_params =
      internal::IntegerAccessor_SetInteger_Params_Data::New(builder.buffer());
  out_params->data = in_data;
  out_params->type =
    static_cast<int32_t>(in_type);
  out_params->EncodePointersAndHandles(builder.message()->mutable_handles());
  
  if (!connector_->Write(builder.message()))
    return false;
  return true;
}SampleInterface_SynchronousProxy::SampleInterface_SynchronousProxy(
      mojo::internal::SynchronousConnector* connector,
      mojo::internal::MessageValidatorList&& validators)
          : connector_(connector), validators_(std::move(validators)) {
}


bool SampleInterface_SynchronousProxy::SampleMethod1(int32_t in_in1, const mojo::String& in_in2, mojo::String* out_out1, Enum* out_out2) {
  size_t size = sizeof(internal::SampleInterface_SampleMethod1_Params_Data);
  size += GetSerializedSize_(in_in2);

  auto msg_name = static_cast<uint32_t>(internal::SampleInterface_Base::MessageOrdinals::SampleMethod1);
  mojo::RequestMessageBuilder builder(msg_name, size);

  internal::SampleInterface_SampleMethod1_Params_Data* out_params =
      internal::SampleInterface_SampleMethod1_Params_Data::New(builder.buffer());
  out_params->in1 = in_in1;
  SerializeString_(in_in2, builder.buffer(), &out_params->in2.ptr);
  out_params->EncodePointersAndHandles(builder.message()->mutable_handles());
  
  if (!connector_->Write(builder.message()))
    return false;
  mojo::Message response_msg;
  if (!connector_->BlockingRead(&response_msg))
    return false; 
  
  // Validate the incoming message.
  std::string response_err;
  if (mojo::internal::RunValidatorsOnMessage(validators_, &response_msg,
                                             &response_err)
        != mojo::internal::ValidationError::NONE) {
    MOJO_LOG(WARNING) << response_err;
    return false;
  } 
  if (mojo::internal::ControlMessageHandler::IsControlMessage(&response_msg)) {
    MOJO_LOG(ERROR) << "Synchronous interface bindings currently don't support "
                       "interface control messages.";
    return false;
  }
  if (response_msg.name() != msg_name) {
    MOJO_LOG(ERROR) << "Expecting response for message = " << msg_name <<
                       ", but received message = " << response_msg.name();
    return false;
  }
  
  internal::SampleInterface_SampleMethod1_ResponseParams_Data*
      response_params = reinterpret_cast<internal::SampleInterface_SampleMethod1_ResponseParams_Data*>(
          response_msg.mutable_payload());
  response_params->DecodePointersAndHandles(response_msg.mutable_handles());
  
  do {
    // NOTE: The memory backing |response_params| may has be smaller than
    // |sizeof(*response_params)| if the message comes from an older version.
    Deserialize_(response_params->out1.ptr, &(*out_out1));
    (*out_out2) = static_cast<Enum>(response_params->out2);
  } while (false);
  return true;
}
bool SampleInterface_SynchronousProxy::SampleMethod0() const  {
  size_t size = sizeof(internal::SampleInterface_SampleMethod0_Params_Data);

  auto msg_name = static_cast<uint32_t>(internal::SampleInterface_Base::MessageOrdinals::SampleMethod0);
  mojo::MessageBuilder builder(msg_name, size);

  internal::SampleInterface_SampleMethod0_Params_Data* out_params =
      internal::SampleInterface_SampleMethod0_Params_Data::New(builder.buffer());
  out_params->EncodePointersAndHandles(builder.message()->mutable_handles());
  
  if (!connector_->Write(builder.message()))
    return false;
  return true;
}
bool SampleInterface_SynchronousProxy::SampleMethod2() const  {
  size_t size = sizeof(internal::SampleInterface_SampleMethod2_Params_Data);

  auto msg_name = static_cast<uint32_t>(internal::SampleInterface_Base::MessageOrdinals::SampleMethod2);
  mojo::MessageBuilder builder(msg_name, size);

  internal::SampleInterface_SampleMethod2_Params_Data* out_params =
      internal::SampleInterface_SampleMethod2_Params_Data::New(builder.buffer());
  out_params->EncodePointersAndHandles(builder.message()->mutable_handles());
  
  if (!connector_->Write(builder.message()))
    return false;
  return true;
}
}  // namespace sample

#if defined(__clang__)
#pragma clang diagnostic pop
#endif
