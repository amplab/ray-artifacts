// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/services/tracing/interfaces/tracing.mojom
//

package tracing

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	fmt "fmt"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
)


type TraceProvider interface {
	StartTracing(inCategories string, inRecorder TraceRecorder_Pointer) (err error)
	StopTracing() (err error)
}



var traceProvider_Name = "tracing::TraceProvider"

type TraceProvider_Request bindings.InterfaceRequest

func (r *TraceProvider_Request) Name() string {
	return traceProvider_Name
}


type TraceProvider_Pointer bindings.InterfacePointer

func (p *TraceProvider_Pointer) Name() string {
	return traceProvider_Name
}

type TraceProvider_ServiceFactory struct{
	Delegate TraceProvider_Factory
}

type TraceProvider_Factory interface {
	Create(request TraceProvider_Request)
}

func (f *TraceProvider_ServiceFactory) Name() string {
	return traceProvider_Name
}

// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *TraceProvider_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &TraceProvider_ServiceDescription{}
}

func (f *TraceProvider_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := TraceProvider_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForTraceProvider creates a message pipe for use with the
// TraceProvider interface with a TraceProvider_Request on one end and a TraceProvider_Pointer on the other.
func CreateMessagePipeForTraceProvider() (TraceProvider_Request, TraceProvider_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return TraceProvider_Request(r), TraceProvider_Pointer(p)
}

const traceProvider_StartTracing_Name uint32 = 0
const traceProvider_StopTracing_Name uint32 = 1

type TraceProvider_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewTraceProviderProxy(p TraceProvider_Pointer, waiter bindings.AsyncWaiter) *TraceProvider_Proxy {
	return &TraceProvider_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *TraceProvider_Proxy) Close_Proxy() {
	p.router.Close()
}

type traceProvider_StartTracing_Params struct {
	inCategories string
	inRecorder TraceRecorder_Pointer
}


func (s *traceProvider_StartTracing_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inCategories); err != nil {
		return err
	}
	if err := encoder.WriteInterface(s.inRecorder.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var traceProvider_StartTracing_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *traceProvider_StartTracing_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(traceProvider_StartTracing_Params_Versions), func(i int) bool {
		return traceProvider_StartTracing_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(traceProvider_StartTracing_Params_Versions) {
		if traceProvider_StartTracing_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := traceProvider_StartTracing_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inCategories = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadInterface()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inRecorder = TraceRecorder_Pointer{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *TraceProvider_Proxy) StartTracing(inCategories string, inRecorder TraceRecorder_Pointer) (err error) {
	payload := &traceProvider_StartTracing_Params{
		inCategories,
		inRecorder,
	}
	header := bindings.MessageHeader{
		Type: traceProvider_StartTracing_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type traceProvider_StopTracing_Params struct {
}


func (s *traceProvider_StopTracing_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var traceProvider_StopTracing_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *traceProvider_StopTracing_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(traceProvider_StopTracing_Params_Versions), func(i int) bool {
		return traceProvider_StopTracing_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(traceProvider_StopTracing_Params_Versions) {
		if traceProvider_StopTracing_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := traceProvider_StopTracing_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *TraceProvider_Proxy) StopTracing() (err error) {
	payload := &traceProvider_StopTracing_Params{
	}
	header := bindings.MessageHeader{
		Type: traceProvider_StopTracing_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type traceProvider_Stub struct {
	connector *bindings.Connector
	impl TraceProvider
}

func NewTraceProviderStub(r TraceProvider_Request, impl TraceProvider, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &traceProvider_Stub{connector, impl})
}


func (f *TraceProvider_Request) ServiceDescription() service_describer.ServiceDescription {
	return &TraceProvider_ServiceDescription{}
}


type TraceProvider_ServiceDescription struct{}

func (sd *TraceProvider_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *TraceProvider_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *TraceProvider_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*TraceProvider_ServiceDescription)(nil)


func (s *traceProvider_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case traceProvider_StartTracing_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request traceProvider_StartTracing_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.StartTracing(request.inCategories, request.inRecorder)
		if err != nil {
			return
		}
	case traceProvider_StopTracing_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request traceProvider_StopTracing_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.StopTracing()
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type TraceRecorder interface {
	Record(inJson string) (err error)
}




type TraceRecorder_Request bindings.InterfaceRequest



type TraceRecorder_Pointer bindings.InterfacePointer


type TraceRecorder_ServiceFactory struct{
	Delegate TraceRecorder_Factory
}

type TraceRecorder_Factory interface {
	Create(request TraceRecorder_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *TraceRecorder_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &TraceRecorder_ServiceDescription{}
}

func (f *TraceRecorder_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := TraceRecorder_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForTraceRecorder creates a message pipe for use with the
// TraceRecorder interface with a TraceRecorder_Request on one end and a TraceRecorder_Pointer on the other.
func CreateMessagePipeForTraceRecorder() (TraceRecorder_Request, TraceRecorder_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return TraceRecorder_Request(r), TraceRecorder_Pointer(p)
}

const traceRecorder_Record_Name uint32 = 0

type TraceRecorder_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewTraceRecorderProxy(p TraceRecorder_Pointer, waiter bindings.AsyncWaiter) *TraceRecorder_Proxy {
	return &TraceRecorder_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *TraceRecorder_Proxy) Close_Proxy() {
	p.router.Close()
}

type traceRecorder_Record_Params struct {
	inJson string
}


func (s *traceRecorder_Record_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inJson); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var traceRecorder_Record_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *traceRecorder_Record_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(traceRecorder_Record_Params_Versions), func(i int) bool {
		return traceRecorder_Record_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(traceRecorder_Record_Params_Versions) {
		if traceRecorder_Record_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := traceRecorder_Record_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inJson = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *TraceRecorder_Proxy) Record(inJson string) (err error) {
	payload := &traceRecorder_Record_Params{
		inJson,
	}
	header := bindings.MessageHeader{
		Type: traceRecorder_Record_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type traceRecorder_Stub struct {
	connector *bindings.Connector
	impl TraceRecorder
}

func NewTraceRecorderStub(r TraceRecorder_Request, impl TraceRecorder, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &traceRecorder_Stub{connector, impl})
}


func (f *TraceRecorder_Request) ServiceDescription() service_describer.ServiceDescription {
	return &TraceRecorder_ServiceDescription{}
}


type TraceRecorder_ServiceDescription struct{}

func (sd *TraceRecorder_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *TraceRecorder_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *TraceRecorder_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*TraceRecorder_ServiceDescription)(nil)


func (s *traceRecorder_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case traceRecorder_Record_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request traceRecorder_Record_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Record(request.inJson)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type TraceCollector interface {
	Start(inStream system.ProducerHandle, inCategories string) (err error)
	StopAndFlush() (err error)
}



var traceCollector_Name = "tracing::TraceCollector"

type TraceCollector_Request bindings.InterfaceRequest

func (r *TraceCollector_Request) Name() string {
	return traceCollector_Name
}


type TraceCollector_Pointer bindings.InterfacePointer

func (p *TraceCollector_Pointer) Name() string {
	return traceCollector_Name
}

type TraceCollector_ServiceFactory struct{
	Delegate TraceCollector_Factory
}

type TraceCollector_Factory interface {
	Create(request TraceCollector_Request)
}

func (f *TraceCollector_ServiceFactory) Name() string {
	return traceCollector_Name
}

// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *TraceCollector_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &TraceCollector_ServiceDescription{}
}

func (f *TraceCollector_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := TraceCollector_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForTraceCollector creates a message pipe for use with the
// TraceCollector interface with a TraceCollector_Request on one end and a TraceCollector_Pointer on the other.
func CreateMessagePipeForTraceCollector() (TraceCollector_Request, TraceCollector_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return TraceCollector_Request(r), TraceCollector_Pointer(p)
}

const traceCollector_Start_Name uint32 = 0
const traceCollector_StopAndFlush_Name uint32 = 1

type TraceCollector_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewTraceCollectorProxy(p TraceCollector_Pointer, waiter bindings.AsyncWaiter) *TraceCollector_Proxy {
	return &TraceCollector_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *TraceCollector_Proxy) Close_Proxy() {
	p.router.Close()
}

type traceCollector_Start_Params struct {
	inStream system.ProducerHandle
	inCategories string
}


func (s *traceCollector_Start_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteHandle(s.inStream); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inCategories); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var traceCollector_Start_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *traceCollector_Start_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(traceCollector_Start_Params_Versions), func(i int) bool {
		return traceCollector_Start_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(traceCollector_Start_Params_Versions) {
		if traceCollector_Start_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := traceCollector_Start_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadProducerHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.inStream = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inCategories = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *TraceCollector_Proxy) Start(inStream system.ProducerHandle, inCategories string) (err error) {
	payload := &traceCollector_Start_Params{
		inStream,
		inCategories,
	}
	header := bindings.MessageHeader{
		Type: traceCollector_Start_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type traceCollector_StopAndFlush_Params struct {
}


func (s *traceCollector_StopAndFlush_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var traceCollector_StopAndFlush_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *traceCollector_StopAndFlush_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(traceCollector_StopAndFlush_Params_Versions), func(i int) bool {
		return traceCollector_StopAndFlush_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(traceCollector_StopAndFlush_Params_Versions) {
		if traceCollector_StopAndFlush_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := traceCollector_StopAndFlush_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *TraceCollector_Proxy) StopAndFlush() (err error) {
	payload := &traceCollector_StopAndFlush_Params{
	}
	header := bindings.MessageHeader{
		Type: traceCollector_StopAndFlush_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type traceCollector_Stub struct {
	connector *bindings.Connector
	impl TraceCollector
}

func NewTraceCollectorStub(r TraceCollector_Request, impl TraceCollector, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &traceCollector_Stub{connector, impl})
}


func (f *TraceCollector_Request) ServiceDescription() service_describer.ServiceDescription {
	return &TraceCollector_ServiceDescription{}
}


type TraceCollector_ServiceDescription struct{}

func (sd *TraceCollector_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *TraceCollector_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *TraceCollector_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*TraceCollector_ServiceDescription)(nil)


func (s *traceCollector_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case traceCollector_Start_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request traceCollector_Start_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Start(request.inStream, request.inCategories)
		if err != nil {
			return
		}
	case traceCollector_StopAndFlush_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request traceCollector_StopAndFlush_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.StopAndFlush()
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

