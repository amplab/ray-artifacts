// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/public/interfaces/bindings/tests/validation_test_interfaces.mojom
//

package validation_test_interfaces

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	ioutil "io/ioutil"
	base64 "encoding/base64"
	fmt "fmt"
	bytes "bytes"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
	gzip "compress/gzip"
)

// This global variable contains a mojom_types.RuntimeTypeInfo struct
// describing the types defined in this file and all of its imports as
// well as the top-level interfaces defined in this file.
var runtimeTypeInfo__ = mojom_types.RuntimeTypeInfo{}

func getRuntimeTypeInfo() mojom_types.RuntimeTypeInfo {
  if runtimeTypeInfo__.TypeMap == nil {
    initRuntimeTypeInfo()
  }
  return runtimeTypeInfo__
}

func initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this file.
  // The string contains the base64 encoding of the gzip-compressed bytes.
  serializedRuntimeTypeInfo := "H4sIAAAJbogC/+xdTXQTxx0ffVm2MSASoIIWnjAhNQlI8hcIXtPakg3qS+lzwpcpbWQhr60l0UckOXVoDj607+XQQ47urUcfc+SYo48cc+SYo49ceO2s9R+8OzujnZV2tbO29jHMm/WsduY3/+/52DhqXzHIX0JO31/WlQM4DUP5E5xmcWqV1WYS/2uVlWRTaXyjlpRktVhRkmu1RjJb26iuNnNlpfTlA6XZ+mO1pTTWiiWF8XvTOH2M04MnS4uFTxef3K7UnteSLfxUp18xt/dlqJ1v4/QeTj/A/R8hfwX5/svxlYZ8BfItyP8L+U+Qv4YcBdtZAvI5yFcg34J8B/KfIX8D+Qc4/YbTz2JTLS1WNypavQ9xutih3v1WY6PU6h63Ds/lalU8eJVitaTYek6ruN4ottRa1fzcFZwu8J/brziP/z6O03l2vXaX59s4WtbLCtbLCdZbEKy3KFjvjmC9u4L18u16V3G61KneY7VVJkSGrxmcronUT2r/aQW1iuAd59jPPaxiCoBhsqwHw4QmAm1+JXwcDxjlTnn4oKyx+O6osbx3xljeeWosp0vG36uvGsu7a8bypmos731pLG9Vqd9rUPVbxvLEd8by8j+NcuvNvw7KmqiY+LexvP0ftnweBpzmkPFKI+P9/8G1hNjXKZxGcDIIIXz9Gqf3ceKIKVN7tLsRnJ7j9AynVLlWUVL1UqXWUFsvUo3it9dLtYaSajZKKe03U/WNZ1+ppZRKhEAz9UytrqrV9WZKe10z9U3xK3V1X6oUtBuFg5pJ7QcqB/3V3jtB+g24LIPc3QW9sBcGeoN6CdT54uGaoXDNc54fgfEm/KDJwDNsPJPzDDyrMP79xtMKn4DD+GQF8Mky8KlJgg/hU8KPTtNPTgCfHAOfukf4JCh7MmHBF6J2EQt3vRx8i7F0EvcFAdwXGLh/7RHuRN+9RXw61eM16jCdLgrgtcjAq+ExXqOITbcx4icEndGzmi49RvQsMeL5eL2rQeOlmTNRj/DS+21zFJ2Q9kWQ2MXDE+nw1NMxj+6KHP91FdrqNU5xSnfGOPz5Euhtj6NHMpS//oqiuz0OTnR7Egy8orr7hE7vt336P2OX3hG/PwHv5FX5CHwdQTfWNN6fAi/3e7x7xYXuR5yyKwjdxKFM6u1E2HRE6CATcpbfTgKd3FNa5dpq2tTuP0lib5D+x4Li/dauNKffv4K+Q7+vN5SvN3BrTP0nl6xyOdonuXwCpyHN/iw2ipU0YtJJTGK57DY9xeFdB/TUrNeqTWVAT93T07iP9PyeTX9aj1NAWD5PmnC6dyTk8+RAPvfIT/ckl8+8+NSEYPwlT9FVmYMTsVd5kyJme7Xj9IkJ5yWP7FVWOwguMR3eQfCPw+DTDQGNDoPvNQp+whhOx4GuND78Hn5nCxnjr2Ug8K2xdv7LSfj7aZi3Owe4X4B8HPydK9DOqzCvdq2db8KAxm/APNzvjANvJXf7ZRd/NrCLpZa7QUnk7mc+k7te2TGfS8ZP5YEd8+7vET0heMxPn8M6EK/oBHHiOoS+yaIG0XUPTvFp0Ab+QWE+nTLhf18yPn0dcoNPp6TjUzpOuBnwB7/e9wW/ZoXXH9nFe7gLvAOieE+y8R4/IvIxqCtbyceQDfxDwvJx2oT/A8nkY9oVO2bal3ZMUCK5qNHJWY/5VOtDzGJesVt7JGwDx7Awv82YcHwoGb/tuGKPzAzsEYf47qEv7JGc8Dpnu3Ku3/aIhvdvJZJzUeSsXRGxgWNEWM7NmnB8JJmc23ZFzs0O5JxDcu6RL+TcovD+CxbeYYnk3CNYL+SF3av3cZySa0M2cBsSlms3TLg9lkyuLbniL90Y+Es9yjONTi5KYkcEkXndZTd2hh1/KmoD56gwP95k7g+ViR93XbEzbg7sDIf4ctkXdsYd4f2bsvtTyx7ZGQnKjuDJwYDODnHD3xq2gfOwsBzMmHB+IpkcXHHFLskM7JIe5d8TGDNZ7ZKA7u96XN2K+47YwH1EmD9vmXD/y5Hgz1sD/uyRPzU6ueQhnQRs+A1hBn8GHObPURu4j3bAPQZtgXVNaRr3p4fUrzfu85h8t0DST/wZkog/n3rk16c5+o9uX9RlfXnMBs7HxPlxku7HX9HhXF9J8eOkH/lRJn9eo5P3pffn7wqfs9Qrn5L9tmM28B8T59MpGv+/ocO5r4Di0yk/8imJVcjApxqdnEL+2W/7hpRt0lOGg8856L+Ontobbqn3DujKPl1dRv7dr3LcBk7HxeX0NI3TF7LJ6YgrcnpaNjmdAP+FtOd7sJu2g/6wr76AGI+X8QjEkNPvQWzAcHgnEj/nkyfXRpAc8yYa7h96gLtdehzrApegKC5TbFxuH0J67KRPQrr3WOmTEzbG4YS4Ppmhx6FwNPzzmYF/3pv+KEg6307aTQ4LFj1P2MruE50XPmkD/5PifDpL479yNPh0dsCnvfHpii/iaHnhc8hlPceFd0i9+RyXjsfZm8ZvHclxjktcZxcGOsw/8OTjdp/PCyxLJh/rg3NRpJSPGp2clUg+kvu883xFv9/R63mE6cF5hFKuI9HoNYX8tY9NRC/HBPXyHEV3vPOweX67dhb8aZM+PqhB470gif6NUfEq3nnL5Pz1CQv+FT1/nT4vgcx3cI5JMH9HBMl9nvhon+Y7yHniKgenEUh+mUcjdLblCp1luXSW5eA3JjGd9dPeIXGD5j5ahSKN03GP5Jk9f9D5c6t49Jt3hX5zXPrNIb58jw7sn30+1taf4pYXWTidAqz9av/w6HDFFTpc4NLhAocOT0tOh8MO0yHPbzkDsrKiNJvFdaVQV+tKk4HXGSTPflDWum09/fVCnz+F3KDPRS59LiJ+HCqKBvsiOfp+lcbrnC/0/YLwdzJZeIcZ/mOv8/u89V7nwbfU9NO+UCiUatXmRkVpsOn1PMwTe3keQxCJ73vk8f+SK/rpDpf/73D4/8JAPxniamvqprJaaKovlEKxgXtP43VRgnlau/twRfTR7pAb9HiXS493OfR4ySN6nAC5R/Ah35t+DXyaD3eOe0QkiXuMI2++o8bT23kLPRLg8P8mR4/UO+htq++mhXTvI/HMe2r1kdJo4t6J+fuXQQfJsq6qV3+fNW6BDuMW08kg0XELOjBuIYtxOwZ18Lgx+eIDsN28shsCFnFT3hXuAu9QH/AmcugZRw5d8XAeMMRYX5Sx0Itx3T29/RbX4a/XDzw9SoB1Vo/muXo0z8F/wiM9Sn/fO0PFBX8EwspEuuMHt/Qp77ukVz3CkYcL77tTgS79MitcePz9kWR2hpPn+AQFcClxcPnY4/gAzz7odh2n3fh1vAu8QwJ4r3Lwvoa82S+nx5vECyOIfQ6E2+PRad9/oovxCAuMB28/3nWP9H6aQ/9RSk64PT6d/PCIrp20/VAPGHO76zVeUfXPQh/aVsJjtVVuf5k/Ae+k7QhSgx7Pv3sYH2bZAzS+MyADuH4O6VhS+08rqFVExfV544UY90l78jbHaYWq9zNlXxtb19YjlzuME9UdU/s2PRq3qxDDsRwPxI67EFzJ+k6yzpW3zknUHqTt7mUL+Tavk2dXxMYhOc8Yh2+hf17EszrhFXAYr2wXeGUZeL2QFK+gw3jlusArx8DrH5LiFXIYr4Uu8Fpg4PWdR3jR7XhjE585Dj60nULmMWjzhH5/Gp7rNw7LoO+WaD0KDPYDEM4OBL5eQ5wgTb5HCwp5GzYgvxpl02OsB/+vl3jBpEfrDnn9HxGU907FBaYk6r9GOr8Iym+n/P9piEUflvkBFq5BHa6hPvn5M8ib7+2y/Hy9X8nCJ6TDJ9wnv3tWIr/bznl7Vnzr1Hd4CH5rHPxu+CFul7WOQ2QFcXXqOyAE13UOrjfR4VofbSUPnfqeA8G1zME1g+Rct2slD506591qHcQt1F5L6rfzR6341qlzuAl+zzn43fbIjrMVl7UhD/vif2W5/leWfv8nHvlfdLwtDoqHnAc5HJLLn/r9Efen/iBZ/0f77E/NSTr+/fJ75j3q//8DAAD//52NbVR4pAAA"

  // Deserialize RuntimeTypeInfo
  compressedBytes, err := base64.StdEncoding.DecodeString(serializedRuntimeTypeInfo)
  if err != nil {
    panic(fmt.Sprintf("Error while base64Decoding runtimeTypeInfo: %s", err.Error()))
  }
  reader, err := gzip.NewReader(bytes.NewBuffer(compressedBytes))
  if err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  uncompressedBytes, err := ioutil.ReadAll(reader)
  if err != nil {
     panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  if err = reader.Close(); err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  decoder := bindings.NewDecoder(uncompressedBytes, nil)
  runtimeTypeInfo__.Decode(decoder)

}
func GetAllMojomTypeDefinitions() map[string]mojom_types.UserDefinedType {
  return getRuntimeTypeInfo().TypeMap
}

type BasicEnum int32

const (
	BasicEnum_A BasicEnum = 0
	BasicEnum_B = BasicEnum_A + 1;
	BasicEnum_C = BasicEnum_A
	BasicEnum_D = -3
	BasicEnum_E = 10
)
// BasicEnumMojomType returns the UserDefinedType that describes the Mojom
// type of BasicEnum. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func BasicEnumMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.BasicEnum"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*BasicEnum) MojomType() mojom_types.UserDefinedType {
	return BasicEnumMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*BasicEnum) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type StructWithEnum_EnumWithin int32

const (
	StructWithEnum_EnumWithin_A StructWithEnum_EnumWithin = 0
	StructWithEnum_EnumWithin_B = StructWithEnum_EnumWithin_A + 1;
	StructWithEnum_EnumWithin_C = StructWithEnum_EnumWithin_B + 1;
	StructWithEnum_EnumWithin_D = StructWithEnum_EnumWithin_C + 1;
)
// StructWithEnum_EnumWithinMojomType returns the UserDefinedType that describes the Mojom
// type of StructWithEnum_EnumWithin. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithEnum_EnumWithinMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructWithEnum.EnumWithin"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithEnum_EnumWithin) MojomType() mojom_types.UserDefinedType {
	return StructWithEnum_EnumWithinMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithEnum_EnumWithin) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type InterfaceA interface {
}


// InterfaceAMojomType returns the UserDefinedType that describes the Mojom
// type of InterfaceA. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func InterfaceAMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.InterfaceA"]
}




type InterfaceA_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*InterfaceA_Request) MojomType() mojom_types.UserDefinedType {
	return InterfaceAMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*InterfaceA_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type InterfaceA_Pointer bindings.InterfacePointer


type InterfaceA_ServiceFactory struct{
	Delegate InterfaceA_Factory
}

type InterfaceA_Factory interface {
	Create(request InterfaceA_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *InterfaceA_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &InterfaceA_ServiceDescription{}
}

func (f *InterfaceA_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := InterfaceA_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForInterfaceA creates a message pipe for use with the
// InterfaceA interface with a InterfaceA_Request on one end and a InterfaceA_Pointer on the other.
func CreateMessagePipeForInterfaceA() (InterfaceA_Request, InterfaceA_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return InterfaceA_Request(r), InterfaceA_Pointer(p)
}


type InterfaceA_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewInterfaceAProxy(p InterfaceA_Pointer, waiter bindings.AsyncWaiter) *InterfaceA_Proxy {
	return &InterfaceA_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *InterfaceA_Proxy) Close_Proxy() {
	p.router.Close()
}

type interfaceA_Stub struct {
	connector *bindings.Connector
	impl InterfaceA
}

func NewInterfaceAStub(r InterfaceA_Request, impl InterfaceA, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &interfaceA_Stub{connector, impl})
}


func (f *InterfaceA_Request) ServiceDescription() service_describer.ServiceDescription {
	return &InterfaceA_ServiceDescription{}
}


type InterfaceA_ServiceDescription struct{}

func (sd *InterfaceA_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *InterfaceA_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *InterfaceA_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*InterfaceA_ServiceDescription)(nil)


func (s *interfaceA_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type BoundsCheckTestInterface interface {
	Method0(inParam0 uint8) (outParam0 uint8, err error)
	Method1(inParam0 uint8) (err error)
}


// BoundsCheckTestInterfaceMojomType returns the UserDefinedType that describes the Mojom
// type of BoundsCheckTestInterface. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func BoundsCheckTestInterfaceMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.BoundsCheckTestInterface"]
}



var boundsCheckTestInterface_Name = "this.is.the.service.name.for.BoundsCheckTestInterface"

type BoundsCheckTestInterface_Request bindings.InterfaceRequest

func (r *BoundsCheckTestInterface_Request) Name() string {
	return boundsCheckTestInterface_Name
}

// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*BoundsCheckTestInterface_Request) MojomType() mojom_types.UserDefinedType {
	return BoundsCheckTestInterfaceMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*BoundsCheckTestInterface_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type BoundsCheckTestInterface_Pointer bindings.InterfacePointer

func (p *BoundsCheckTestInterface_Pointer) Name() string {
	return boundsCheckTestInterface_Name
}

type BoundsCheckTestInterface_ServiceFactory struct{
	Delegate BoundsCheckTestInterface_Factory
}

type BoundsCheckTestInterface_Factory interface {
	Create(request BoundsCheckTestInterface_Request)
}

func (f *BoundsCheckTestInterface_ServiceFactory) Name() string {
	return boundsCheckTestInterface_Name
}

// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *BoundsCheckTestInterface_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &BoundsCheckTestInterface_ServiceDescription{}
}

func (f *BoundsCheckTestInterface_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := BoundsCheckTestInterface_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForBoundsCheckTestInterface creates a message pipe for use with the
// BoundsCheckTestInterface interface with a BoundsCheckTestInterface_Request on one end and a BoundsCheckTestInterface_Pointer on the other.
func CreateMessagePipeForBoundsCheckTestInterface() (BoundsCheckTestInterface_Request, BoundsCheckTestInterface_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return BoundsCheckTestInterface_Request(r), BoundsCheckTestInterface_Pointer(p)
}

const boundsCheckTestInterface_Method0_Name uint32 = 0
const boundsCheckTestInterface_Method1_Name uint32 = 1

type BoundsCheckTestInterface_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewBoundsCheckTestInterfaceProxy(p BoundsCheckTestInterface_Pointer, waiter bindings.AsyncWaiter) *BoundsCheckTestInterface_Proxy {
	return &BoundsCheckTestInterface_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *BoundsCheckTestInterface_Proxy) Close_Proxy() {
	p.router.Close()
}

type boundsCheckTestInterface_Method0_Params struct {
	inParam0 uint8
}


func (s *boundsCheckTestInterface_Method0_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteUint8(s.inParam0); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var boundsCheckTestInterface_Method0_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *boundsCheckTestInterface_Method0_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(boundsCheckTestInterface_Method0_Params_Versions), func(i int) bool {
		return boundsCheckTestInterface_Method0_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(boundsCheckTestInterface_Method0_Params_Versions) {
		if boundsCheckTestInterface_Method0_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := boundsCheckTestInterface_Method0_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.inParam0 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type boundsCheckTestInterface_Method0_ResponseParams struct {
	outParam0 uint8
}


func (s *boundsCheckTestInterface_Method0_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteUint8(s.outParam0); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var boundsCheckTestInterface_Method0_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *boundsCheckTestInterface_Method0_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(boundsCheckTestInterface_Method0_ResponseParams_Versions), func(i int) bool {
		return boundsCheckTestInterface_Method0_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(boundsCheckTestInterface_Method0_ResponseParams_Versions) {
		if boundsCheckTestInterface_Method0_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := boundsCheckTestInterface_Method0_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.outParam0 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *BoundsCheckTestInterface_Proxy) Method0(inParam0 uint8) (outParam0 uint8, err error) {
	payload := &boundsCheckTestInterface_Method0_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: boundsCheckTestInterface_Method0_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, boundsCheckTestInterface_Method0_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response boundsCheckTestInterface_Method0_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outParam0 = response.outParam0
	return
}

type boundsCheckTestInterface_Method1_Params struct {
	inParam0 uint8
}


func (s *boundsCheckTestInterface_Method1_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteUint8(s.inParam0); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var boundsCheckTestInterface_Method1_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *boundsCheckTestInterface_Method1_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(boundsCheckTestInterface_Method1_Params_Versions), func(i int) bool {
		return boundsCheckTestInterface_Method1_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(boundsCheckTestInterface_Method1_Params_Versions) {
		if boundsCheckTestInterface_Method1_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := boundsCheckTestInterface_Method1_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.inParam0 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *BoundsCheckTestInterface_Proxy) Method1(inParam0 uint8) (err error) {
	payload := &boundsCheckTestInterface_Method1_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: boundsCheckTestInterface_Method1_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type boundsCheckTestInterface_Stub struct {
	connector *bindings.Connector
	impl BoundsCheckTestInterface
}

func NewBoundsCheckTestInterfaceStub(r BoundsCheckTestInterface_Request, impl BoundsCheckTestInterface, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &boundsCheckTestInterface_Stub{connector, impl})
}


func (f *BoundsCheckTestInterface_Request) ServiceDescription() service_describer.ServiceDescription {
	return &BoundsCheckTestInterface_ServiceDescription{}
}


type BoundsCheckTestInterface_ServiceDescription struct{}

func (sd *BoundsCheckTestInterface_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	interfaceTypeKey := getRuntimeTypeInfo().Services["this.is.the.service.name.for.BoundsCheckTestInterface"]
	userDefinedType := getRuntimeTypeInfo().TypeMap[interfaceTypeKey].(*mojom_types.UserDefinedTypeInterfaceType)
	return userDefinedType.Value, nil
}

func (sd *BoundsCheckTestInterface_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	if udt, ok := GetAllMojomTypeDefinitions()[inTypeKey]; ok {
		return udt, nil
	}
	return nil, fmt.Errorf("%s_ServiceDescription does not recognize %s", "BoundsCheckTestInterface", inTypeKey)
}

func (sd *BoundsCheckTestInterface_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	o := GetAllMojomTypeDefinitions()
	return &o, nil
}
var _ service_describer.ServiceDescription = (*BoundsCheckTestInterface_ServiceDescription)(nil)


func (s *boundsCheckTestInterface_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case boundsCheckTestInterface_Method0_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request boundsCheckTestInterface_Method0_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response boundsCheckTestInterface_Method0_ResponseParams
		response.outParam0, err = s.impl.Method0(request.inParam0)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: boundsCheckTestInterface_Method0_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case boundsCheckTestInterface_Method1_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request boundsCheckTestInterface_Method1_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method1(request.inParam0)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type ConformanceTestInterface interface {
	Method0(inParam0 float32) (err error)
	Method1(inParam0 StructA) (err error)
	Method2(inParam0 StructB, inParam1 StructA) (err error)
	Method3(inParam0 []bool) (err error)
	Method4(inParam0 StructC, inParam1 []uint8) (err error)
	Method5(inParam0 StructE, inParam1 system.ProducerHandle) (err error)
	Method6(inParam0 [][]uint8) (err error)
	Method7(inParam0 StructF, inParam1 [2]*[3]uint8) (err error)
	Method8(inParam0 []*[]string) (err error)
	Method9(inParam0 *[][]*system.Handle) (err error)
	Method10(inParam0 map[string]uint8) (err error)
	Method11(inParam0 StructG) (err error)
	Method12(inParam0 float32) (outParam0 float32, err error)
	Method13(inParam0 *InterfaceA_Pointer, inParam1 uint32, inParam2 *InterfaceA_Pointer) (err error)
	Method14(inParam0 UnionA) (err error)
	Method15(inParam0 StructH) (err error)
}


// ConformanceTestInterfaceMojomType returns the UserDefinedType that describes the Mojom
// type of ConformanceTestInterface. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func ConformanceTestInterfaceMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.ConformanceTestInterface"]
}




type ConformanceTestInterface_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ConformanceTestInterface_Request) MojomType() mojom_types.UserDefinedType {
	return ConformanceTestInterfaceMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ConformanceTestInterface_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type ConformanceTestInterface_Pointer bindings.InterfacePointer


type ConformanceTestInterface_ServiceFactory struct{
	Delegate ConformanceTestInterface_Factory
}

type ConformanceTestInterface_Factory interface {
	Create(request ConformanceTestInterface_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *ConformanceTestInterface_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &ConformanceTestInterface_ServiceDescription{}
}

func (f *ConformanceTestInterface_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := ConformanceTestInterface_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForConformanceTestInterface creates a message pipe for use with the
// ConformanceTestInterface interface with a ConformanceTestInterface_Request on one end and a ConformanceTestInterface_Pointer on the other.
func CreateMessagePipeForConformanceTestInterface() (ConformanceTestInterface_Request, ConformanceTestInterface_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return ConformanceTestInterface_Request(r), ConformanceTestInterface_Pointer(p)
}

const conformanceTestInterface_Method0_Name uint32 = 0
const conformanceTestInterface_Method1_Name uint32 = 1
const conformanceTestInterface_Method2_Name uint32 = 2
const conformanceTestInterface_Method3_Name uint32 = 3
const conformanceTestInterface_Method4_Name uint32 = 4
const conformanceTestInterface_Method5_Name uint32 = 5
const conformanceTestInterface_Method6_Name uint32 = 6
const conformanceTestInterface_Method7_Name uint32 = 7
const conformanceTestInterface_Method8_Name uint32 = 8
const conformanceTestInterface_Method9_Name uint32 = 9
const conformanceTestInterface_Method10_Name uint32 = 10
const conformanceTestInterface_Method11_Name uint32 = 11
const conformanceTestInterface_Method12_Name uint32 = 12
const conformanceTestInterface_Method13_Name uint32 = 13
const conformanceTestInterface_Method14_Name uint32 = 14
const conformanceTestInterface_Method15_Name uint32 = 15

type ConformanceTestInterface_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewConformanceTestInterfaceProxy(p ConformanceTestInterface_Pointer, waiter bindings.AsyncWaiter) *ConformanceTestInterface_Proxy {
	return &ConformanceTestInterface_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *ConformanceTestInterface_Proxy) Close_Proxy() {
	p.router.Close()
}

type conformanceTestInterface_Method0_Params struct {
	inParam0 float32
}


func (s *conformanceTestInterface_Method0_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteFloat32(s.inParam0); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method0_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *conformanceTestInterface_Method0_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method0_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method0_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method0_Params_Versions) {
		if conformanceTestInterface_Method0_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method0_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.inParam0 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method0(inParam0 float32) (err error) {
	payload := &conformanceTestInterface_Method0_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method0_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method1_Params struct {
	inParam0 StructA
}


func (s *conformanceTestInterface_Method1_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inParam0.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method1_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *conformanceTestInterface_Method1_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method1_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method1_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method1_Params_Versions) {
		if conformanceTestInterface_Method1_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method1_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inParam0.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method1(inParam0 StructA) (err error) {
	payload := &conformanceTestInterface_Method1_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method1_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method2_Params struct {
	inParam0 StructB
	inParam1 StructA
}


func (s *conformanceTestInterface_Method2_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inParam0.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inParam1.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method2_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *conformanceTestInterface_Method2_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method2_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method2_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method2_Params_Versions) {
		if conformanceTestInterface_Method2_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method2_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inParam0.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inParam1.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method2(inParam0 StructB, inParam1 StructA) (err error) {
	payload := &conformanceTestInterface_Method2_Params{
		inParam0,
		inParam1,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method2_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method3_Params struct {
	inParam0 []bool
}


func (s *conformanceTestInterface_Method3_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.inParam0)), 1)
	for _, elem0 := range s.inParam0 {
		if err := encoder.WriteBool(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method3_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *conformanceTestInterface_Method3_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method3_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method3_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method3_Params_Versions) {
		if conformanceTestInterface_Method3_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method3_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(1)
			if err != nil {
				return err
			}
			s.inParam0 = make([]bool, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadBool()
				if err != nil {
					return err
				}
				s.inParam0[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method3(inParam0 []bool) (err error) {
	payload := &conformanceTestInterface_Method3_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method3_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method4_Params struct {
	inParam0 StructC
	inParam1 []uint8
}


func (s *conformanceTestInterface_Method4_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inParam0.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.inParam1)), 8)
	for _, elem0 := range s.inParam1 {
		if err := encoder.WriteUint8(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method4_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *conformanceTestInterface_Method4_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method4_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method4_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method4_Params_Versions) {
		if conformanceTestInterface_Method4_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method4_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inParam0.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			s.inParam1 = make([]uint8, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadUint8()
				if err != nil {
					return err
				}
				s.inParam1[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method4(inParam0 StructC, inParam1 []uint8) (err error) {
	payload := &conformanceTestInterface_Method4_Params{
		inParam0,
		inParam1,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method4_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method5_Params struct {
	inParam0 StructE
	inParam1 system.ProducerHandle
}


func (s *conformanceTestInterface_Method5_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inParam0.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WriteHandle(s.inParam1); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method5_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *conformanceTestInterface_Method5_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method5_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method5_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method5_Params_Versions) {
		if conformanceTestInterface_Method5_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method5_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inParam0.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadProducerHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.inParam1 = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method5(inParam0 StructE, inParam1 system.ProducerHandle) (err error) {
	payload := &conformanceTestInterface_Method5_Params{
		inParam0,
		inParam1,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method5_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method6_Params struct {
	inParam0 [][]uint8
}


func (s *conformanceTestInterface_Method6_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.inParam0)), 64)
	for _, elem0 := range s.inParam0 {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(elem0)), 8)
		for _, elem1 := range elem0 {
			if err := encoder.WriteUint8(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method6_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *conformanceTestInterface_Method6_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method6_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method6_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method6_Params_Versions) {
		if conformanceTestInterface_Method6_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method6_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.inParam0 = make([][]uint8, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(8)
					if err != nil {
						return err
					}
					s.inParam0[i0] = make([]uint8, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadUint8()
						if err != nil {
							return err
						}
						s.inParam0[i0][i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method6(inParam0 [][]uint8) (err error) {
	payload := &conformanceTestInterface_Method6_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method6_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method7_Params struct {
	inParam0 StructF
	inParam1 [2]*[3]uint8
}


func (s *conformanceTestInterface_Method7_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inParam0.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.inParam1)), 64)
	for _, elem0 := range s.inParam1 {
		if elem0 == nil {
			encoder.WriteNullPointer()
		} else {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len((*elem0))), 8)
			for _, elem1 := range (*elem0) {
				if err := encoder.WriteUint8(elem1); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method7_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *conformanceTestInterface_Method7_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method7_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method7_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method7_Params_Versions) {
		if conformanceTestInterface_Method7_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method7_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inParam0.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			if len0 != 2 {
				return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
					fmt.Sprintf("invalid array length: expected %d, got %d", 2, len0),
				}
			}
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					s.inParam1[i0] = nil
				} else {
					s.inParam1[i0] = new([3]uint8)
					len1, err := decoder.StartArray(8)
					if err != nil {
						return err
					}
					if len1 != 3 {
						return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
							fmt.Sprintf("invalid array length: expected %d, got %d", 3, len1),
						}
					}
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadUint8()
						if err != nil {
							return err
						}
						(*s.inParam1[i0])[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method7(inParam0 StructF, inParam1 [2]*[3]uint8) (err error) {
	payload := &conformanceTestInterface_Method7_Params{
		inParam0,
		inParam1,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method7_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method8_Params struct {
	inParam0 []*[]string
}


func (s *conformanceTestInterface_Method8_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.inParam0)), 64)
	for _, elem0 := range s.inParam0 {
		if elem0 == nil {
			encoder.WriteNullPointer()
		} else {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len((*elem0))), 64)
			for _, elem1 := range (*elem0) {
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				if err := encoder.WriteString(elem1); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method8_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *conformanceTestInterface_Method8_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method8_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method8_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method8_Params_Versions) {
		if conformanceTestInterface_Method8_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method8_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.inParam0 = make([]*[]string, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					s.inParam0[i0] = nil
				} else {
					s.inParam0[i0] = new([]string)
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					(*s.inParam0[i0]) = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							(*s.inParam0[i0])[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method8(inParam0 []*[]string) (err error) {
	payload := &conformanceTestInterface_Method8_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method8_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method9_Params struct {
	inParam0 *[][]*system.Handle
}


func (s *conformanceTestInterface_Method9_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if s.inParam0 == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.inParam0))), 64)
		for _, elem0 := range (*s.inParam0) {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(elem0)), 32)
			for _, elem1 := range elem0 {
				if elem1 == nil {
					encoder.WriteInvalidHandle()
				} else {
					if err := encoder.WriteHandle((*elem1)); err != nil {
						return err
					}
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method9_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *conformanceTestInterface_Method9_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method9_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method9_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method9_Params_Versions) {
		if conformanceTestInterface_Method9_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method9_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.inParam0 = nil
		} else {
			s.inParam0 = new([][]*system.Handle)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.inParam0) = make([][]*system.Handle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(32)
					if err != nil {
						return err
					}
					(*s.inParam0)[i0] = make([]*system.Handle, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						handle2, err := decoder.ReadHandle()
						if err != nil {
							return err
						}
						if handle2.IsValid() {
							(*s.inParam0)[i0][i1] = &handle2
						} else {
							(*s.inParam0)[i0][i1] = nil
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method9(inParam0 *[][]*system.Handle) (err error) {
	payload := &conformanceTestInterface_Method9_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method9_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method10_Params struct {
	inParam0 map[string]uint8
}


func (s *conformanceTestInterface_Method10_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 []uint8
		if encoder.Deterministic() {
		  for key0, _ := range s.inParam0 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]uint8, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.inParam0[key]
		  }
		} else {
		  for key0, value0 := range s.inParam0 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 8)
		for _, elem1 := range values0 {
			if err := encoder.WriteUint8(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method10_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *conformanceTestInterface_Method10_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method10_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method10_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method10_Params_Versions) {
		if conformanceTestInterface_Method10_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method10_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []uint8
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(8)
					if err != nil {
						return err
					}
					values0 = make([]uint8, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadUint8()
						if err != nil {
							return err
						}
						values0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string]uint8)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.inParam0 = map0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method10(inParam0 map[string]uint8) (err error) {
	payload := &conformanceTestInterface_Method10_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method10_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method11_Params struct {
	inParam0 StructG
}


func (s *conformanceTestInterface_Method11_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inParam0.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method11_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *conformanceTestInterface_Method11_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method11_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method11_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method11_Params_Versions) {
		if conformanceTestInterface_Method11_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method11_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inParam0.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method11(inParam0 StructG) (err error) {
	payload := &conformanceTestInterface_Method11_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method11_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method12_Params struct {
	inParam0 float32
}


func (s *conformanceTestInterface_Method12_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteFloat32(s.inParam0); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method12_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *conformanceTestInterface_Method12_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method12_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method12_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method12_Params_Versions) {
		if conformanceTestInterface_Method12_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method12_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.inParam0 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type conformanceTestInterface_Method12_ResponseParams struct {
	outParam0 float32
}


func (s *conformanceTestInterface_Method12_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteFloat32(s.outParam0); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method12_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *conformanceTestInterface_Method12_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method12_ResponseParams_Versions), func(i int) bool {
		return conformanceTestInterface_Method12_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method12_ResponseParams_Versions) {
		if conformanceTestInterface_Method12_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method12_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.outParam0 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method12(inParam0 float32) (outParam0 float32, err error) {
	payload := &conformanceTestInterface_Method12_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method12_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, conformanceTestInterface_Method12_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response conformanceTestInterface_Method12_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outParam0 = response.outParam0
	return
}

type conformanceTestInterface_Method13_Params struct {
	inParam0 *InterfaceA_Pointer
	inParam1 uint32
	inParam2 *InterfaceA_Pointer
}


func (s *conformanceTestInterface_Method13_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if s.inParam0 == nil {
		encoder.WriteInvalidInterface()
	} else {
		if err := encoder.WriteInterface((*s.inParam0).PassMessagePipe()); err != nil {
			return err
		}
	}
	if err := encoder.WriteUint32(s.inParam1); err != nil {
		return err
	}
	if s.inParam2 == nil {
		encoder.WriteInvalidInterface()
	} else {
		if err := encoder.WriteInterface((*s.inParam2).PassMessagePipe()); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method13_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *conformanceTestInterface_Method13_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method13_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method13_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method13_Params_Versions) {
		if conformanceTestInterface_Method13_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method13_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadInterface()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inParam0 = &InterfaceA_Pointer{handleOwner}
		} else {
			s.inParam0 = nil
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.inParam1 = value0
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadInterface()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inParam2 = &InterfaceA_Pointer{handleOwner}
		} else {
			s.inParam2 = nil
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method13(inParam0 *InterfaceA_Pointer, inParam1 uint32, inParam2 *InterfaceA_Pointer) (err error) {
	payload := &conformanceTestInterface_Method13_Params{
		inParam0,
		inParam1,
		inParam2,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method13_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method14_Params struct {
	inParam0 UnionA
}


func (s *conformanceTestInterface_Method14_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.inParam0 == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.inParam0.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method14_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *conformanceTestInterface_Method14_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method14_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method14_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method14_Params_Versions) {
		if conformanceTestInterface_Method14_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method14_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.inParam0, err = DecodeUnionA(decoder)
		if err != nil {
			return err
		}
		if s.inParam0 == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method14(inParam0 UnionA) (err error) {
	payload := &conformanceTestInterface_Method14_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method14_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Method15_Params struct {
	inParam0 StructH
}


func (s *conformanceTestInterface_Method15_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inParam0.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var conformanceTestInterface_Method15_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *conformanceTestInterface_Method15_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(conformanceTestInterface_Method15_Params_Versions), func(i int) bool {
		return conformanceTestInterface_Method15_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(conformanceTestInterface_Method15_Params_Versions) {
		if conformanceTestInterface_Method15_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := conformanceTestInterface_Method15_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inParam0.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ConformanceTestInterface_Proxy) Method15(inParam0 StructH) (err error) {
	payload := &conformanceTestInterface_Method15_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: conformanceTestInterface_Method15_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type conformanceTestInterface_Stub struct {
	connector *bindings.Connector
	impl ConformanceTestInterface
}

func NewConformanceTestInterfaceStub(r ConformanceTestInterface_Request, impl ConformanceTestInterface, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &conformanceTestInterface_Stub{connector, impl})
}


func (f *ConformanceTestInterface_Request) ServiceDescription() service_describer.ServiceDescription {
	return &ConformanceTestInterface_ServiceDescription{}
}


type ConformanceTestInterface_ServiceDescription struct{}

func (sd *ConformanceTestInterface_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *ConformanceTestInterface_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *ConformanceTestInterface_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*ConformanceTestInterface_ServiceDescription)(nil)


func (s *conformanceTestInterface_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case conformanceTestInterface_Method0_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method0_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method0(request.inParam0)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method1_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method1_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method1(request.inParam0)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method2_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method2_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method2(request.inParam0, request.inParam1)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method3_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method3_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method3(request.inParam0)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method4_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method4_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method4(request.inParam0, request.inParam1)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method5_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method5_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method5(request.inParam0, request.inParam1)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method6_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method6_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method6(request.inParam0)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method7_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method7_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method7(request.inParam0, request.inParam1)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method8_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method8_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method8(request.inParam0)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method9_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method9_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method9(request.inParam0)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method10_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method10_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method10(request.inParam0)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method11_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method11_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method11(request.inParam0)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method12_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method12_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response conformanceTestInterface_Method12_ResponseParams
		response.outParam0, err = s.impl.Method12(request.inParam0)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: conformanceTestInterface_Method12_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case conformanceTestInterface_Method13_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method13_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method13(request.inParam0, request.inParam1, request.inParam2)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method14_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method14_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method14(request.inParam0)
		if err != nil {
			return
		}
	case conformanceTestInterface_Method15_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request conformanceTestInterface_Method15_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Method15(request.inParam0)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type IntegrationTestInterface interface {
	Method0(inParam0 BasicStruct) (outParam0 []uint8, err error)
}


// IntegrationTestInterfaceMojomType returns the UserDefinedType that describes the Mojom
// type of IntegrationTestInterface. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func IntegrationTestInterfaceMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.IntegrationTestInterface"]
}




type IntegrationTestInterface_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*IntegrationTestInterface_Request) MojomType() mojom_types.UserDefinedType {
	return IntegrationTestInterfaceMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*IntegrationTestInterface_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type IntegrationTestInterface_Pointer bindings.InterfacePointer


type IntegrationTestInterface_ServiceFactory struct{
	Delegate IntegrationTestInterface_Factory
}

type IntegrationTestInterface_Factory interface {
	Create(request IntegrationTestInterface_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *IntegrationTestInterface_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &IntegrationTestInterface_ServiceDescription{}
}

func (f *IntegrationTestInterface_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := IntegrationTestInterface_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForIntegrationTestInterface creates a message pipe for use with the
// IntegrationTestInterface interface with a IntegrationTestInterface_Request on one end and a IntegrationTestInterface_Pointer on the other.
func CreateMessagePipeForIntegrationTestInterface() (IntegrationTestInterface_Request, IntegrationTestInterface_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return IntegrationTestInterface_Request(r), IntegrationTestInterface_Pointer(p)
}

const integrationTestInterface_Method0_Name uint32 = 0

type IntegrationTestInterface_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewIntegrationTestInterfaceProxy(p IntegrationTestInterface_Pointer, waiter bindings.AsyncWaiter) *IntegrationTestInterface_Proxy {
	return &IntegrationTestInterface_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *IntegrationTestInterface_Proxy) Close_Proxy() {
	p.router.Close()
}

type integrationTestInterface_Method0_Params struct {
	inParam0 BasicStruct
}


func (s *integrationTestInterface_Method0_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inParam0.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var integrationTestInterface_Method0_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *integrationTestInterface_Method0_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(integrationTestInterface_Method0_Params_Versions), func(i int) bool {
		return integrationTestInterface_Method0_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(integrationTestInterface_Method0_Params_Versions) {
		if integrationTestInterface_Method0_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := integrationTestInterface_Method0_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inParam0.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type integrationTestInterface_Method0_ResponseParams struct {
	outParam0 []uint8
}


func (s *integrationTestInterface_Method0_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.outParam0)), 8)
	for _, elem0 := range s.outParam0 {
		if err := encoder.WriteUint8(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var integrationTestInterface_Method0_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *integrationTestInterface_Method0_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(integrationTestInterface_Method0_ResponseParams_Versions), func(i int) bool {
		return integrationTestInterface_Method0_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(integrationTestInterface_Method0_ResponseParams_Versions) {
		if integrationTestInterface_Method0_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := integrationTestInterface_Method0_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			s.outParam0 = make([]uint8, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadUint8()
				if err != nil {
					return err
				}
				s.outParam0[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *IntegrationTestInterface_Proxy) Method0(inParam0 BasicStruct) (outParam0 []uint8, err error) {
	payload := &integrationTestInterface_Method0_Params{
		inParam0,
	}
	header := bindings.MessageHeader{
		Type: integrationTestInterface_Method0_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, integrationTestInterface_Method0_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response integrationTestInterface_Method0_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outParam0 = response.outParam0
	return
}

type integrationTestInterface_Stub struct {
	connector *bindings.Connector
	impl IntegrationTestInterface
}

func NewIntegrationTestInterfaceStub(r IntegrationTestInterface_Request, impl IntegrationTestInterface, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &integrationTestInterface_Stub{connector, impl})
}


func (f *IntegrationTestInterface_Request) ServiceDescription() service_describer.ServiceDescription {
	return &IntegrationTestInterface_ServiceDescription{}
}


type IntegrationTestInterface_ServiceDescription struct{}

func (sd *IntegrationTestInterface_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *IntegrationTestInterface_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *IntegrationTestInterface_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*IntegrationTestInterface_ServiceDescription)(nil)


func (s *integrationTestInterface_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case integrationTestInterface_Method0_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request integrationTestInterface_Method0_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response integrationTestInterface_Method0_ResponseParams
		response.outParam0, err = s.impl.Method0(request.inParam0)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: integrationTestInterface_Method0_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type StructA struct {
	I uint64
}
// StructAMojomType returns the UserDefinedType that describes the Mojom
// type of StructA. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructAMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructA"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructA) MojomType() mojom_types.UserDefinedType {
	return StructAMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructA) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructA) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteUint64(s.I); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structA_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *StructA) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structA_Versions), func(i int) bool {
		return structA_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structA_Versions) {
		if structA_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structA_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint64()
		if err != nil {
			return err
		}
		s.I = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructB struct {
	StructA StructA
}
// StructBMojomType returns the UserDefinedType that describes the Mojom
// type of StructB. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructBMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructB"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructB) MojomType() mojom_types.UserDefinedType {
	return StructBMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructB) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructB) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.StructA.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structB_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *StructB) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structB_Versions), func(i int) bool {
		return structB_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structB_Versions) {
		if structB_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structB_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.StructA.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructC struct {
	Data []uint8
}
// StructCMojomType returns the UserDefinedType that describes the Mojom
// type of StructC. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructCMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructC"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructC) MojomType() mojom_types.UserDefinedType {
	return StructCMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructC) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructC) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.Data)), 8)
	for _, elem0 := range s.Data {
		if err := encoder.WriteUint8(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structC_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *StructC) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structC_Versions), func(i int) bool {
		return structC_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structC_Versions) {
		if structC_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structC_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			s.Data = make([]uint8, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadUint8()
				if err != nil {
					return err
				}
				s.Data[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructD struct {
	MessagePipes []system.MessagePipeHandle
}
// StructDMojomType returns the UserDefinedType that describes the Mojom
// type of StructD. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructDMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructD"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructD) MojomType() mojom_types.UserDefinedType {
	return StructDMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructD) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructD) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.MessagePipes)), 32)
	for _, elem0 := range s.MessagePipes {
		if err := encoder.WriteHandle(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structD_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *StructD) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structD_Versions), func(i int) bool {
		return structD_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structD_Versions) {
		if structD_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structD_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.MessagePipes = make([]system.MessagePipeHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadMessagePipeHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					s.MessagePipes[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructE struct {
	StructD StructD
	DataPipeConsumer system.ConsumerHandle
}
// StructEMojomType returns the UserDefinedType that describes the Mojom
// type of StructE. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructEMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructE"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructE) MojomType() mojom_types.UserDefinedType {
	return StructEMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructE) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructE) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.StructD.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WriteHandle(s.DataPipeConsumer); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structE_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *StructE) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structE_Versions), func(i int) bool {
		return structE_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structE_Versions) {
		if structE_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structE_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.StructD.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadConsumerHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.DataPipeConsumer = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructF struct {
	FixedSizeArray [3]uint8
}
// StructFMojomType returns the UserDefinedType that describes the Mojom
// type of StructF. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructFMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructF"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructF) MojomType() mojom_types.UserDefinedType {
	return StructFMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructF) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructF) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.FixedSizeArray)), 8)
	for _, elem0 := range s.FixedSizeArray {
		if err := encoder.WriteUint8(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structF_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *StructF) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structF_Versions), func(i int) bool {
		return structF_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structF_Versions) {
		if structF_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structF_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			if len0 != 3 {
				return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
					fmt.Sprintf("invalid array length: expected %d, got %d", 3, len0),
				}
			}
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadUint8()
				if err != nil {
					return err
				}
				s.FixedSizeArray[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructG struct {
	I int32
	StructA *StructA
	Str *string
	B bool
}
// StructGMojomType returns the UserDefinedType that describes the Mojom
// type of StructG. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructGMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructG"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructG) MojomType() mojom_types.UserDefinedType {
	return StructGMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructG) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructG) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 3)
	if err := encoder.WriteInt32(s.I); err != nil {
		return err
	}
	if err := encoder.WriteBool(s.B); err != nil {
		return err
	}
	if s.StructA == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.StructA).Encode(encoder); err != nil {
			return err
		}
	}
	if s.Str == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.Str)); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structG_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
	bindings.DataHeader{24, 1},
	bindings.DataHeader{32, 3},
}

func (s *StructG) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structG_Versions), func(i int) bool {
		return structG_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structG_Versions) {
		if structG_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structG_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.I = value0
	}
	if header.ElementsOrVersion >= 3 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.B = value0
	}
	if header.ElementsOrVersion >= 1 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.StructA = nil
		} else {
			s.StructA = new(StructA)
			if err := (*s.StructA).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 3 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Str = nil
		} else {
			s.Str = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.Str) = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructH struct {
	A bool
	B uint8
	C UnionA
	D *[]UnionA
	E *map[uint8]UnionA
}
// StructHMojomType returns the UserDefinedType that describes the Mojom
// type of StructH. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructHMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructH"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructH) MojomType() mojom_types.UserDefinedType {
	return StructHMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructH) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructH) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(40, 0)
	if err := encoder.WriteBool(s.A); err != nil {
		return err
	}
	if err := encoder.WriteUint8(s.B); err != nil {
		return err
	}
	if s.C == nil {
		encoder.WriteNullUnion()
	} else {
		if err := s.C.Encode(encoder); err != nil {
			return err
		}
	}
	if s.D == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.D))), 128)
		for _, elem0 := range (*s.D) {
			if elem0 == nil {
				return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
			}
			if err := elem0.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if s.E == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartMap()
		{
			var keys0 []uint8
			var values0 []UnionA
			if encoder.Deterministic() {
			  for key0, _ := range (*s.E) {
				keys0 = append(keys0, key0)
			  }
			  bindings.SortMapKeys(&keys0)
			  values0 = make([]UnionA, len(keys0))
			  for i, key := range keys0 {
			    values0[i] = (*s.E)[key]
			  }
			} else {
			  for key0, value0 := range (*s.E) {
				keys0 = append(keys0, key0)
				values0 = append(values0, value0)
			  }
			}
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(keys0)), 8)
			for _, elem1 := range keys0 {
				if err := encoder.WriteUint8(elem1); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(values0)), 128)
			for _, elem1 := range values0 {
				if elem1 == nil {
					return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
				}
				if err := elem1.Encode(encoder); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structH_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{48, 0},
}

func (s *StructH) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structH_Versions), func(i int) bool {
		return structH_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structH_Versions) {
		if structH_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structH_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.A = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.B = value0
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.C, err = DecodeUnionA(decoder)
		if err != nil {
			return err
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.D = nil
		} else {
			s.D = new([]UnionA)
			len0, err := decoder.StartArray(128)
			if err != nil {
				return err
			}
			(*s.D) = make([]UnionA, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				var err error
				(*s.D)[i0], err = DecodeUnionA(decoder)
				if err != nil {
					return err
				}
				if (*s.D)[i0] == nil {
					return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.E = nil
		} else {
			s.E = new(map[uint8]UnionA)
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []uint8
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(8)
					if err != nil {
						return err
					}
					keys0 = make([]uint8, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadUint8()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []UnionA
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(128)
					if err != nil {
						return err
					}
					values0 = make([]UnionA, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						var err error
						values0[i1], err = DecodeUnionA(decoder)
						if err != nil {
							return err
						}
						if values0[i1] == nil {
							return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[uint8]UnionA)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			(*s.E) = map0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type BasicStruct struct {
	A int32
}
// BasicStructMojomType returns the UserDefinedType that describes the Mojom
// type of BasicStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func BasicStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.BasicStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*BasicStruct) MojomType() mojom_types.UserDefinedType {
	return BasicStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*BasicStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *BasicStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.A); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var basicStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *BasicStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(basicStruct_Versions), func(i int) bool {
		return basicStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(basicStruct_Versions) {
		if basicStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := basicStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.A = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructWithEnum struct {
}
// StructWithEnumMojomType returns the UserDefinedType that describes the Mojom
// type of StructWithEnum. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithEnumMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructWithEnum"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithEnum) MojomType() mojom_types.UserDefinedType {
	return StructWithEnumMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithEnum) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithEnum) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithEnum_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *StructWithEnum) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithEnum_Versions), func(i int) bool {
		return structWithEnum_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithEnum_Versions) {
		if structWithEnum_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithEnum_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type UnionA interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__UnionAReflect)
	Encode(encoder *bindings.Encoder) error
}


// UnionAMojomType returns the UserDefinedType that describes the Mojom
// type of UnionA. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func UnionAMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.UnionA"]
}



type __UnionAReflect struct {
	A uint16
	B uint32
	C *StructA
	D *[]uint8
	E *map[string]uint8
	F UnionB
	G StructA
	H []uint8
	I map[string]uint8
	J UnionB
}

func DecodeUnionA(decoder *bindings.Decoder) (UnionA, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value UnionAA
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value UnionAB
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 2:
		var value UnionAC
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 3:
		var value UnionAD
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 4:
		var value UnionAE
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 5:
		var value UnionAF
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 6:
		var value UnionAG
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 7:
		var value UnionAH
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 8:
		var value UnionAI
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 9:
		var value UnionAJ
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &UnionAUnknown{tag: tag}, nil
}

type UnionAUnknown struct { tag uint32 }
func (u *UnionAUnknown) Tag() uint32 { return u.tag }
func (u *UnionAUnknown) Interface() interface{} { return nil }
func (u *UnionAUnknown) __Reflect(__UnionAReflect) {}

func (u *UnionAUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown UnionA. There is no sane way to do that!");
}

type UnionAA struct { Value uint16 }
func (u *UnionAA) Tag() uint32 { return 0 }
func (u *UnionAA) Interface() interface{} { return u.Value }
func (u *UnionAA) __Reflect(__UnionAReflect) {}

func (u *UnionAA) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint16(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionAA) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint16()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionAA) MojomType() mojom_types.UserDefinedType {
	return UnionAMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionAA) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionAB struct { Value uint32 }
func (u *UnionAB) Tag() uint32 { return 1 }
func (u *UnionAB) Interface() interface{} { return u.Value }
func (u *UnionAB) __Reflect(__UnionAReflect) {}

func (u *UnionAB) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint32(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionAB) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint32()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionAB) MojomType() mojom_types.UserDefinedType {
	return UnionAMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionAB) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionAC struct { Value *StructA }
func (u *UnionAC) Tag() uint32 { return 2 }
func (u *UnionAC) Interface() interface{} { return u.Value }
func (u *UnionAC) __Reflect(__UnionAReflect) {}

func (u *UnionAC) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if u.Value == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*u.Value).Encode(encoder); err != nil {
			return err
		}
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionAC) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		u.Value = nil
	} else {
		u.Value = new(StructA)
		if err := (*u.Value).Decode(decoder); err != nil {
			return err
		}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionAC) MojomType() mojom_types.UserDefinedType {
	return UnionAMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionAC) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionAD struct { Value *[]uint8 }
func (u *UnionAD) Tag() uint32 { return 3 }
func (u *UnionAD) Interface() interface{} { return u.Value }
func (u *UnionAD) __Reflect(__UnionAReflect) {}

func (u *UnionAD) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if u.Value == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*u.Value))), 8)
		for _, elem0 := range (*u.Value) {
			if err := encoder.WriteUint8(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionAD) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		u.Value = nil
	} else {
		u.Value = new([]uint8)
		len0, err := decoder.StartArray(8)
		if err != nil {
			return err
		}
		(*u.Value) = make([]uint8, len0)
		for i0 := uint32(0); i0 < len0; i0++ {
			value1, err := decoder.ReadUint8()
			if err != nil {
				return err
			}
			(*u.Value)[i0] = value1
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionAD) MojomType() mojom_types.UserDefinedType {
	return UnionAMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionAD) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionAE struct { Value *map[string]uint8 }
func (u *UnionAE) Tag() uint32 { return 4 }
func (u *UnionAE) Interface() interface{} { return u.Value }
func (u *UnionAE) __Reflect(__UnionAReflect) {}

func (u *UnionAE) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if u.Value == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartMap()
		{
			var keys0 []string
			var values0 []uint8
			if encoder.Deterministic() {
			  for key0, _ := range (*u.Value) {
				keys0 = append(keys0, key0)
			  }
			  bindings.SortMapKeys(&keys0)
			  values0 = make([]uint8, len(keys0))
			  for i, key := range keys0 {
			    values0[i] = (*u.Value)[key]
			  }
			} else {
			  for key0, value0 := range (*u.Value) {
				keys0 = append(keys0, key0)
				values0 = append(values0, value0)
			  }
			}
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(keys0)), 64)
			for _, elem1 := range keys0 {
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				if err := encoder.WriteString(elem1); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(values0)), 8)
			for _, elem1 := range values0 {
				if err := encoder.WriteUint8(elem1); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionAE) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		u.Value = nil
	} else {
		u.Value = new(map[string]uint8)
		if err := decoder.StartMap(); err != nil {
			return err
		}
		var keys0 []string
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(64)
				if err != nil {
					return err
				}
				keys0 = make([]string, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					pointer2, err := decoder.ReadPointer()
					if err != nil {
						return err
					}
					if pointer2 == 0 {
						return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
					} else {
						value2, err := decoder.ReadString()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		var values0 []uint8
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(8)
				if err != nil {
					return err
				}
				values0 = make([]uint8, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					value2, err := decoder.ReadUint8()
					if err != nil {
						return err
					}
					values0[i1] = value2
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		if len(keys0) != len(values0) {
			return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
				fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
			}
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
		len0 := len(keys0)
		map0 := make(map[string]uint8)
		for i0 := 0; i0 < len0; i0++ {
			map0[keys0[i0]] = values0[i0]
		}
		(*u.Value) = map0
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionAE) MojomType() mojom_types.UserDefinedType {
	return UnionAMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionAE) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionAF struct { Value UnionB }
func (u *UnionAF) Tag() uint32 { return 5 }
func (u *UnionAF) Interface() interface{} { return u.Value }
func (u *UnionAF) __Reflect(__UnionAReflect) {}

func (u *UnionAF) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	
	encoder.StartNestedUnion()
	if u.Value == nil {
		encoder.WriteNullUnion()
	} else {
		if err := u.Value.Encode(encoder); err != nil {
			return err
		}
	}
	
	encoder.Finish()
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionAF) decodeInternal(decoder *bindings.Decoder) error {
	if pointer, err := decoder.ReadPointer(); err != nil || pointer == 0 {
		if err != nil {
			return err
		}
		u.Value = nil
		return nil
	}
	
	if err := decoder.StartNestedUnion(); err != nil {
		return err
	}
	
	var err error
	u.Value, err = DecodeUnionB(decoder)
	if err != nil {
		return err
	}
	
	
	decoder.Finish()
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionAF) MojomType() mojom_types.UserDefinedType {
	return UnionAMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionAF) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionAG struct { Value StructA }
func (u *UnionAG) Tag() uint32 { return 6 }
func (u *UnionAG) Interface() interface{} { return u.Value }
func (u *UnionAG) __Reflect(__UnionAReflect) {}

func (u *UnionAG) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionAG) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionAG) MojomType() mojom_types.UserDefinedType {
	return UnionAMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionAG) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionAH struct { Value []uint8 }
func (u *UnionAH) Tag() uint32 { return 7 }
func (u *UnionAH) Interface() interface{} { return u.Value }
func (u *UnionAH) __Reflect(__UnionAReflect) {}

func (u *UnionAH) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(u.Value)), 8)
	for _, elem0 := range u.Value {
		if err := encoder.WriteUint8(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionAH) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		len0, err := decoder.StartArray(8)
		if err != nil {
			return err
		}
		u.Value = make([]uint8, len0)
		for i0 := uint32(0); i0 < len0; i0++ {
			value1, err := decoder.ReadUint8()
			if err != nil {
				return err
			}
			u.Value[i0] = value1
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionAH) MojomType() mojom_types.UserDefinedType {
	return UnionAMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionAH) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionAI struct { Value map[string]uint8 }
func (u *UnionAI) Tag() uint32 { return 8 }
func (u *UnionAI) Interface() interface{} { return u.Value }
func (u *UnionAI) __Reflect(__UnionAReflect) {}

func (u *UnionAI) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 []uint8
		if encoder.Deterministic() {
		  for key0, _ := range u.Value {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]uint8, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = u.Value[key]
		  }
		} else {
		  for key0, value0 := range u.Value {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 8)
		for _, elem1 := range values0 {
			if err := encoder.WriteUint8(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionAI) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := decoder.StartMap(); err != nil {
			return err
		}
		var keys0 []string
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(64)
				if err != nil {
					return err
				}
				keys0 = make([]string, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					pointer2, err := decoder.ReadPointer()
					if err != nil {
						return err
					}
					if pointer2 == 0 {
						return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
					} else {
						value2, err := decoder.ReadString()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		var values0 []uint8
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(8)
				if err != nil {
					return err
				}
				values0 = make([]uint8, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					value2, err := decoder.ReadUint8()
					if err != nil {
						return err
					}
					values0[i1] = value2
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		if len(keys0) != len(values0) {
			return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
				fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
			}
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
		len0 := len(keys0)
		map0 := make(map[string]uint8)
		for i0 := 0; i0 < len0; i0++ {
			map0[keys0[i0]] = values0[i0]
		}
		u.Value = map0
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionAI) MojomType() mojom_types.UserDefinedType {
	return UnionAMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionAI) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionAJ struct { Value UnionB }
func (u *UnionAJ) Tag() uint32 { return 9 }
func (u *UnionAJ) Interface() interface{} { return u.Value }
func (u *UnionAJ) __Reflect(__UnionAReflect) {}

func (u *UnionAJ) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	
	encoder.StartNestedUnion()
	if u.Value == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}
	
	encoder.Finish()
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionAJ) decodeInternal(decoder *bindings.Decoder) error {
	if pointer, err := decoder.ReadPointer(); err != nil || pointer == 0 {
		if err != nil {
			return err
		}
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null union pointer"}
	}
	
	if err := decoder.StartNestedUnion(); err != nil {
		return err
	}
	
	var err error
	u.Value, err = DecodeUnionB(decoder)
	if err != nil {
		return err
	}
	if u.Value == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	
	
	decoder.Finish()
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionAJ) MojomType() mojom_types.UserDefinedType {
	return UnionAMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionAJ) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}



type UnionB interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__UnionBReflect)
	Encode(encoder *bindings.Encoder) error
}


// UnionBMojomType returns the UserDefinedType that describes the Mojom
// type of UnionB. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func UnionBMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.UnionB"]
}



type __UnionBReflect struct {
	A uint16
	B uint32
	C uint64
	D uint32
}

func DecodeUnionB(decoder *bindings.Decoder) (UnionB, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value UnionBA
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value UnionBB
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 2:
		var value UnionBC
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 3:
		var value UnionBD
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &UnionBUnknown{tag: tag}, nil
}

type UnionBUnknown struct { tag uint32 }
func (u *UnionBUnknown) Tag() uint32 { return u.tag }
func (u *UnionBUnknown) Interface() interface{} { return nil }
func (u *UnionBUnknown) __Reflect(__UnionBReflect) {}

func (u *UnionBUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown UnionB. There is no sane way to do that!");
}

type UnionBA struct { Value uint16 }
func (u *UnionBA) Tag() uint32 { return 0 }
func (u *UnionBA) Interface() interface{} { return u.Value }
func (u *UnionBA) __Reflect(__UnionBReflect) {}

func (u *UnionBA) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint16(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionBA) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint16()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionBA) MojomType() mojom_types.UserDefinedType {
	return UnionBMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionBA) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionBB struct { Value uint32 }
func (u *UnionBB) Tag() uint32 { return 1 }
func (u *UnionBB) Interface() interface{} { return u.Value }
func (u *UnionBB) __Reflect(__UnionBReflect) {}

func (u *UnionBB) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint32(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionBB) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint32()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionBB) MojomType() mojom_types.UserDefinedType {
	return UnionBMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionBB) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionBC struct { Value uint64 }
func (u *UnionBC) Tag() uint32 { return 2 }
func (u *UnionBC) Interface() interface{} { return u.Value }
func (u *UnionBC) __Reflect(__UnionBReflect) {}

func (u *UnionBC) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint64(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionBC) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint64()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionBC) MojomType() mojom_types.UserDefinedType {
	return UnionBMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionBC) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionBD struct { Value uint32 }
func (u *UnionBD) Tag() uint32 { return 3 }
func (u *UnionBD) Interface() interface{} { return u.Value }
func (u *UnionBD) __Reflect(__UnionBReflect) {}

func (u *UnionBD) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint32(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionBD) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint32()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionBD) MojomType() mojom_types.UserDefinedType {
	return UnionBMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionBD) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}



