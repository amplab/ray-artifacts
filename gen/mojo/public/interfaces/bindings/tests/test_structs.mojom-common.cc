// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/public/interfaces/bindings/tests/test_structs.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace mojo {
namespace test {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// static
StructOfStructs_Data* StructOfStructs_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructOfStructs_Data))) StructOfStructs_Data();
}

// static
mojo::internal::ValidationError StructOfStructs_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructOfStructs_Data* object = static_cast<const StructOfStructs_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 48 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->nr.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null nr field in StructOfStructs struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->nr.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = NamedRegion::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->nr.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->a_nr.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null a_nr field in StructOfStructs struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->a_nr.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams a_nr_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<NamedRegionPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->a_nr.offset),
          bounds_checker, &a_nr_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->a_rp.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null a_rp field in StructOfStructs struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->a_rp.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams a_rp_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<RectPairPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->a_rp.offset),
          bounds_checker, &a_rp_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->m_ndfv.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null m_ndfv field in StructOfStructs struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->m_ndfv.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams m_ndfv_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<int64_t, NoDefaultFieldValuesPtr>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->m_ndfv.offset),
              bounds_checker, &m_ndfv_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->m_hs.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null m_hs field in StructOfStructs struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->m_hs.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams m_hs_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<int64_t, HandleStructPtr>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->m_hs.offset),
              bounds_checker, &m_hs_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructOfStructs_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->nr, handles);
  mojo::internal::Encode(&this->a_nr, handles);
  mojo::internal::Encode(&this->a_rp, handles);
  mojo::internal::Encode(&this->m_ndfv, handles);
  mojo::internal::Encode(&this->m_hs, handles);
}

void StructOfStructs_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->nr, handles);
  mojo::internal::Decode(&this->a_nr, handles);
  mojo::internal::Decode(&this->a_rp, handles);
  mojo::internal::Decode(&this->m_ndfv, handles);
  mojo::internal::Decode(&this->m_hs, handles);
}

StructOfStructs_Data::StructOfStructs_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
NamedRegion_Data* NamedRegion_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(NamedRegion_Data))) NamedRegion_Data();
}

// static
mojo::internal::ValidationError NamedRegion_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const NamedRegion_Data* object = static_cast<const NamedRegion_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->name.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams name_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->name.offset),
          bounds_checker, &name_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->rects.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams rects_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<mojo::test::RectPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->rects.offset),
          bounds_checker, &rects_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void NamedRegion_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->name, handles);
  mojo::internal::Encode(&this->rects, handles);
}

void NamedRegion_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->name, handles);
  mojo::internal::Decode(&this->rects, handles);
}

NamedRegion_Data::NamedRegion_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
RectPair_Data* RectPair_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(RectPair_Data))) RectPair_Data();
}

// static
mojo::internal::ValidationError RectPair_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const RectPair_Data* object = static_cast<const RectPair_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->first.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::test::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->first.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->second.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::test::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->second.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void RectPair_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->first, handles);
  mojo::internal::Encode(&this->second, handles);
}

void RectPair_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->first, handles);
  mojo::internal::Decode(&this->second, handles);
}

RectPair_Data::RectPair_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
EmptyStruct_Data* EmptyStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(EmptyStruct_Data))) EmptyStruct_Data();
}

// static
mojo::internal::ValidationError EmptyStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const EmptyStruct_Data* object = static_cast<const EmptyStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void EmptyStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void EmptyStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

EmptyStruct_Data::EmptyStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
HandleStruct_Data* HandleStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(HandleStruct_Data))) HandleStruct_Data();
}

// static
mojo::internal::ValidationError HandleStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const HandleStruct_Data* object = static_cast<const HandleStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle h_handle = object->h;
  if (!bounds_checker->ClaimHandle(h_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  if (!object->array_h.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null array_h field in HandleStruct struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->array_h.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams array_h_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<mojo::ScopedMessagePipeHandle>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->array_h.offset),
          bounds_checker, &array_h_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void HandleStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->h, handles);
  mojo::internal::Encode(&this->array_h, handles);
}

void HandleStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->h, handles);
  mojo::internal::Decode(&this->array_h, handles);
}

HandleStruct_Data::HandleStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
NullableHandleStruct_Data* NullableHandleStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(NullableHandleStruct_Data))) NullableHandleStruct_Data();
}

// static
mojo::internal::ValidationError NullableHandleStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const NullableHandleStruct_Data* object = static_cast<const NullableHandleStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle h_handle = object->h;
  if (!bounds_checker->ClaimHandle(h_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void NullableHandleStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->h, handles);
}

void NullableHandleStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->h, handles);
}

NullableHandleStruct_Data::NullableHandleStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
NoDefaultFieldValues_Data* NoDefaultFieldValues_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(NoDefaultFieldValues_Data))) NoDefaultFieldValues_Data();
}

// static
mojo::internal::ValidationError NoDefaultFieldValues_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const NoDefaultFieldValues_Data* object = static_cast<const NoDefaultFieldValues_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 160 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->f11.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f11 field in NoDefaultFieldValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f11.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f11_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f11.offset),
          bounds_checker, &f11_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f12.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f12_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f12.offset),
          bounds_checker, &f12_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  const mojo::Handle f13_handle = object->f13;
  if (f13_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid f13 field in NoDefaultFieldValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(f13_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  const mojo::Handle f14_handle = object->f14;
  if (f14_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid f14 field in NoDefaultFieldValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(f14_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  const mojo::Handle f15_handle = object->f15;
  if (f15_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid f15 field in NoDefaultFieldValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(f15_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  const mojo::Handle f16_handle = object->f16;
  if (!bounds_checker->ClaimHandle(f16_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  const mojo::Handle f17_handle = object->f17;
  if (!bounds_checker->ClaimHandle(f17_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  const mojo::Handle f18_handle = object->f18;
  if (!bounds_checker->ClaimHandle(f18_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  const mojo::Handle f19_handle = object->f19;
  if (f19_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid f19 field in NoDefaultFieldValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(f19_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  const mojo::Handle f20_handle = object->f20;
  if (!bounds_checker->ClaimHandle(f20_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  const mojo::Handle f21_handle = object->f21;
  if (f21_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid f21 field in NoDefaultFieldValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(f21_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  const mojo::Handle f22_handle = object->f22;
  if (!bounds_checker->ClaimHandle(f22_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  if (!object->f23.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f23 field in NoDefaultFieldValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f23.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f23_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f23.offset),
          bounds_checker, &f23_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f24.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f24 field in NoDefaultFieldValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f24.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f24_validate_params(
      0, true, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f24.offset),
          bounds_checker, &f24_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f25.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f25_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f25.offset),
          bounds_checker, &f25_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f26.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f26_validate_params(
      0, true, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f26.offset),
          bounds_checker, &f26_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f27.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f27 field in NoDefaultFieldValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f27.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = EmptyStruct::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f27.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f28.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = EmptyStruct::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f28.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void NoDefaultFieldValues_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->f11, handles);
  mojo::internal::Encode(&this->f12, handles);
  mojo::internal::EncodeHandle(&this->f13, handles);
  mojo::internal::EncodeHandle(&this->f14, handles);
  mojo::internal::EncodeHandle(&this->f15, handles);
  mojo::internal::EncodeHandle(&this->f16, handles);
  mojo::internal::EncodeHandle(&this->f17, handles);
  mojo::internal::EncodeHandle(&this->f18, handles);
  mojo::internal::EncodeHandle(&this->f19, handles);
  mojo::internal::EncodeHandle(&this->f20, handles);
  mojo::internal::EncodeHandle(&this->f21, handles);
  mojo::internal::EncodeHandle(&this->f22, handles);
  mojo::internal::Encode(&this->f23, handles);
  mojo::internal::Encode(&this->f24, handles);
  mojo::internal::Encode(&this->f25, handles);
  mojo::internal::Encode(&this->f26, handles);
  mojo::internal::Encode(&this->f27, handles);
  mojo::internal::Encode(&this->f28, handles);
}

void NoDefaultFieldValues_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->f11, handles);
  mojo::internal::Decode(&this->f12, handles);
  mojo::internal::DecodeHandle(&this->f13, handles);
  mojo::internal::DecodeHandle(&this->f14, handles);
  mojo::internal::DecodeHandle(&this->f15, handles);
  mojo::internal::DecodeHandle(&this->f16, handles);
  mojo::internal::DecodeHandle(&this->f17, handles);
  mojo::internal::DecodeHandle(&this->f18, handles);
  mojo::internal::DecodeHandle(&this->f19, handles);
  mojo::internal::DecodeHandle(&this->f20, handles);
  mojo::internal::DecodeHandle(&this->f21, handles);
  mojo::internal::DecodeHandle(&this->f22, handles);
  mojo::internal::Decode(&this->f23, handles);
  mojo::internal::Decode(&this->f24, handles);
  mojo::internal::Decode(&this->f25, handles);
  mojo::internal::Decode(&this->f26, handles);
  mojo::internal::Decode(&this->f27, handles);
  mojo::internal::Decode(&this->f28, handles);
}

NoDefaultFieldValues_Data::NoDefaultFieldValues_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
DefaultFieldValues_Data* DefaultFieldValues_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(DefaultFieldValues_Data))) DefaultFieldValues_Data();
}

// static
mojo::internal::ValidationError DefaultFieldValues_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const DefaultFieldValues_Data* object = static_cast<const DefaultFieldValues_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 96 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->f13.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f13 field in DefaultFieldValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f13.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f13_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f13.offset),
          bounds_checker, &f13_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f14.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f14_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f14.offset),
          bounds_checker, &f14_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f15.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f15 field in DefaultFieldValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f15.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::test::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f15.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f16.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::test::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f16.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void DefaultFieldValues_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->f13, handles);
  mojo::internal::Encode(&this->f14, handles);
  mojo::internal::Encode(&this->f15, handles);
  mojo::internal::Encode(&this->f16, handles);
}

void DefaultFieldValues_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->f13, handles);
  mojo::internal::Decode(&this->f14, handles);
  mojo::internal::Decode(&this->f15, handles);
  mojo::internal::Decode(&this->f16, handles);
}

DefaultFieldValues_Data::DefaultFieldValues_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
ScopedConstants_Data* ScopedConstants_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ScopedConstants_Data))) ScopedConstants_Data();
}

// static
mojo::internal::ValidationError ScopedConstants_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ScopedConstants_Data* object = static_cast<const ScopedConstants_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 40 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void ScopedConstants_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void ScopedConstants_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

ScopedConstants_Data::ScopedConstants_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
MapKeyTypes_Data* MapKeyTypes_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MapKeyTypes_Data))) MapKeyTypes_Data();
}

// static
mojo::internal::ValidationError MapKeyTypes_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MapKeyTypes_Data* object = static_cast<const MapKeyTypes_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 104 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->f0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f0 field in MapKeyTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f0_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<bool, bool>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f0.offset),
              bounds_checker, &f0_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f1.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f1 field in MapKeyTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f1.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f1_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<int8_t, int8_t>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f1.offset),
              bounds_checker, &f1_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f2.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f2 field in MapKeyTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f2.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f2_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<uint8_t, uint8_t>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f2.offset),
              bounds_checker, &f2_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f3.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f3 field in MapKeyTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f3.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f3_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<int16_t, int16_t>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f3.offset),
              bounds_checker, &f3_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f4.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f4 field in MapKeyTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f4.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f4_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<uint16_t, uint16_t>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f4.offset),
              bounds_checker, &f4_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f5.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f5 field in MapKeyTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f5.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f5_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<int32_t, int32_t>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f5.offset),
              bounds_checker, &f5_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f6.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f6 field in MapKeyTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f6.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f6_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<uint32_t, uint32_t>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f6.offset),
              bounds_checker, &f6_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f7.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f7 field in MapKeyTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f7.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f7_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<int64_t, int64_t>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f7.offset),
              bounds_checker, &f7_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f8.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f8 field in MapKeyTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f8.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f8_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<uint64_t, uint64_t>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f8.offset),
              bounds_checker, &f8_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f9.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f9 field in MapKeyTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f9.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f9_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<float, float>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f9.offset),
              bounds_checker, &f9_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f10.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f10 field in MapKeyTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f10.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f10_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<double, double>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f10.offset),
              bounds_checker, &f10_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f11.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f11 field in MapKeyTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f11.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f11_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval = mojo::Map<mojo::String, mojo::String>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f11.offset),
              bounds_checker, &f11_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MapKeyTypes_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->f0, handles);
  mojo::internal::Encode(&this->f1, handles);
  mojo::internal::Encode(&this->f2, handles);
  mojo::internal::Encode(&this->f3, handles);
  mojo::internal::Encode(&this->f4, handles);
  mojo::internal::Encode(&this->f5, handles);
  mojo::internal::Encode(&this->f6, handles);
  mojo::internal::Encode(&this->f7, handles);
  mojo::internal::Encode(&this->f8, handles);
  mojo::internal::Encode(&this->f9, handles);
  mojo::internal::Encode(&this->f10, handles);
  mojo::internal::Encode(&this->f11, handles);
}

void MapKeyTypes_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->f0, handles);
  mojo::internal::Decode(&this->f1, handles);
  mojo::internal::Decode(&this->f2, handles);
  mojo::internal::Decode(&this->f3, handles);
  mojo::internal::Decode(&this->f4, handles);
  mojo::internal::Decode(&this->f5, handles);
  mojo::internal::Decode(&this->f6, handles);
  mojo::internal::Decode(&this->f7, handles);
  mojo::internal::Decode(&this->f8, handles);
  mojo::internal::Decode(&this->f9, handles);
  mojo::internal::Decode(&this->f10, handles);
  mojo::internal::Decode(&this->f11, handles);
}

MapKeyTypes_Data::MapKeyTypes_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
MapValueTypes_Data* MapValueTypes_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MapValueTypes_Data))) MapValueTypes_Data();
}

// static
mojo::internal::ValidationError MapValueTypes_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MapValueTypes_Data* object = static_cast<const MapValueTypes_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 104 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->f0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f0 field in MapValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f0_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr)));
  auto validate_retval = mojo::Map<mojo::String, mojo::Array<mojo::String> >::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f0.offset),
              bounds_checker, &f0_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f1.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f1 field in MapValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f1.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f1_validate_params(
      0, true, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr)));
  auto validate_retval = mojo::Map<mojo::String, mojo::Array<mojo::String> >::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f1.offset),
              bounds_checker, &f1_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f2.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f2 field in MapValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f2.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f2_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, true, new mojo::internal::ArrayValidateParams(0, false, nullptr)));
  auto validate_retval = mojo::Map<mojo::String, mojo::Array<mojo::String> >::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f2.offset),
              bounds_checker, &f2_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f3.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f3 field in MapValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f3.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f3_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(2, false, new mojo::internal::ArrayValidateParams(0, false, nullptr)));
  auto validate_retval = mojo::Map<mojo::String, mojo::Array<mojo::String> >::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f3.offset),
              bounds_checker, &f3_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f4.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f4 field in MapValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f4.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f4_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, true, new mojo::internal::ArrayValidateParams(2, false, new mojo::internal::ArrayValidateParams(0, false, nullptr))));
  auto validate_retval = mojo::Map<mojo::String, mojo::Array<mojo::Array<mojo::String> > >::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f4.offset),
              bounds_checker, &f4_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f5.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f5 field in MapValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f5.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f5_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(1, false, new mojo::internal::ArrayValidateParams(2, false, new mojo::internal::ArrayValidateParams(0, false, nullptr))));
  auto validate_retval = mojo::Map<mojo::String, mojo::Array<mojo::Array<mojo::String> > >::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f5.offset),
              bounds_checker, &f5_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f6.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f6 field in MapValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f6.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f6_validate_params(
      0, true, nullptr);
  auto validate_retval = mojo::Map<mojo::String, mojo::test::RectPtr>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f6.offset),
              bounds_checker, &f6_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f7.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f7 field in MapValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f7.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f7_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr)));
  auto validate_retval = mojo::Map<mojo::String, mojo::Map<mojo::String, mojo::String> >::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f7.offset),
              bounds_checker, &f7_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f8.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f8 field in MapValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f8.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f8_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr))));
  auto validate_retval = mojo::Map<mojo::String, mojo::Array<mojo::Map<mojo::String, mojo::String> > >::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f8.offset),
              bounds_checker, &f8_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f9.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f9 field in MapValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f9.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f9_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<mojo::String, mojo::ScopedHandle>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f9.offset),
              bounds_checker, &f9_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f10.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f10 field in MapValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f10.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f10_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval = mojo::Map<mojo::String, mojo::Array<mojo::ScopedHandle> >::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f10.offset),
              bounds_checker, &f10_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f11.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f11 field in MapValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f11.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f11_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval = mojo::Map<mojo::String, mojo::Map<mojo::String, mojo::ScopedHandle> >::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->f11.offset),
              bounds_checker, &f11_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MapValueTypes_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->f0, handles);
  mojo::internal::Encode(&this->f1, handles);
  mojo::internal::Encode(&this->f2, handles);
  mojo::internal::Encode(&this->f3, handles);
  mojo::internal::Encode(&this->f4, handles);
  mojo::internal::Encode(&this->f5, handles);
  mojo::internal::Encode(&this->f6, handles);
  mojo::internal::Encode(&this->f7, handles);
  mojo::internal::Encode(&this->f8, handles);
  mojo::internal::Encode(&this->f9, handles);
  mojo::internal::Encode(&this->f10, handles);
  mojo::internal::Encode(&this->f11, handles);
}

void MapValueTypes_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->f0, handles);
  mojo::internal::Decode(&this->f1, handles);
  mojo::internal::Decode(&this->f2, handles);
  mojo::internal::Decode(&this->f3, handles);
  mojo::internal::Decode(&this->f4, handles);
  mojo::internal::Decode(&this->f5, handles);
  mojo::internal::Decode(&this->f6, handles);
  mojo::internal::Decode(&this->f7, handles);
  mojo::internal::Decode(&this->f8, handles);
  mojo::internal::Decode(&this->f9, handles);
  mojo::internal::Decode(&this->f10, handles);
  mojo::internal::Decode(&this->f11, handles);
}

MapValueTypes_Data::MapValueTypes_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
ArrayValueTypes_Data* ArrayValueTypes_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ArrayValueTypes_Data))) ArrayValueTypes_Data();
}

// static
mojo::internal::ValidationError ArrayValueTypes_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ArrayValueTypes_Data* object = static_cast<const ArrayValueTypes_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 56 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->f0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f0 field in ArrayValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f0_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<int8_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f0.offset),
          bounds_checker, &f0_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f1.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f1 field in ArrayValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f1.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f1_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<int16_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f1.offset),
          bounds_checker, &f1_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f2.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f2 field in ArrayValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f2.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f2_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<int32_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f2.offset),
          bounds_checker, &f2_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f3.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f3 field in ArrayValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f3.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f3_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<int64_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f3.offset),
          bounds_checker, &f3_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f4.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f4 field in ArrayValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f4.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f4_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<float>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f4.offset),
          bounds_checker, &f4_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f5.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f5 field in ArrayValueTypes struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f5.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f5_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<double>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f5.offset),
          bounds_checker, &f5_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ArrayValueTypes_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->f0, handles);
  mojo::internal::Encode(&this->f1, handles);
  mojo::internal::Encode(&this->f2, handles);
  mojo::internal::Encode(&this->f3, handles);
  mojo::internal::Encode(&this->f4, handles);
  mojo::internal::Encode(&this->f5, handles);
}

void ArrayValueTypes_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->f0, handles);
  mojo::internal::Decode(&this->f1, handles);
  mojo::internal::Decode(&this->f2, handles);
  mojo::internal::Decode(&this->f3, handles);
  mojo::internal::Decode(&this->f4, handles);
  mojo::internal::Decode(&this->f5, handles);
}

ArrayValueTypes_Data::ArrayValueTypes_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
FloatNumberValues_Data* FloatNumberValues_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FloatNumberValues_Data))) FloatNumberValues_Data();
}

// static
mojo::internal::ValidationError FloatNumberValues_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FloatNumberValues_Data* object = static_cast<const FloatNumberValues_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 72 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void FloatNumberValues_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void FloatNumberValues_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

FloatNumberValues_Data::FloatNumberValues_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
IntegerNumberValues_Data* IntegerNumberValues_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(IntegerNumberValues_Data))) IntegerNumberValues_Data();
}

// static
mojo::internal::ValidationError IntegerNumberValues_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const IntegerNumberValues_Data* object = static_cast<const IntegerNumberValues_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 88 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void IntegerNumberValues_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void IntegerNumberValues_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

IntegerNumberValues_Data::IntegerNumberValues_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
UnsignedNumberValues_Data* UnsignedNumberValues_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(UnsignedNumberValues_Data))) UnsignedNumberValues_Data();
}

// static
mojo::internal::ValidationError UnsignedNumberValues_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const UnsignedNumberValues_Data* object = static_cast<const UnsignedNumberValues_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 56 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void UnsignedNumberValues_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void UnsignedNumberValues_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

UnsignedNumberValues_Data::UnsignedNumberValues_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
BitArrayValues_Data* BitArrayValues_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(BitArrayValues_Data))) BitArrayValues_Data();
}

// static
mojo::internal::ValidationError BitArrayValues_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const BitArrayValues_Data* object = static_cast<const BitArrayValues_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 64 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->f0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f0 field in BitArrayValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f0_validate_params(
      1, false, nullptr);
  auto validate_retval =
      mojo::Array<bool>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f0.offset),
          bounds_checker, &f0_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f1.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f1 field in BitArrayValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f1.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f1_validate_params(
      7, false, nullptr);
  auto validate_retval =
      mojo::Array<bool>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f1.offset),
          bounds_checker, &f1_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f2.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f2 field in BitArrayValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f2.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f2_validate_params(
      9, false, nullptr);
  auto validate_retval =
      mojo::Array<bool>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f2.offset),
          bounds_checker, &f2_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f3.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f3 field in BitArrayValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f3.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f3_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<bool>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f3.offset),
          bounds_checker, &f3_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f4.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f4 field in BitArrayValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f4.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f4_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::Array<bool> >::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f4.offset),
          bounds_checker, &f4_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f5.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f5 field in BitArrayValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f5.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f5_validate_params(
      0, true, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::Array<bool> >::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f5.offset),
          bounds_checker, &f5_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->f6.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null f6 field in BitArrayValues struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->f6.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f6_validate_params(
      0, true, new mojo::internal::ArrayValidateParams(2, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::Array<bool> >::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f6.offset),
          bounds_checker, &f6_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void BitArrayValues_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->f0, handles);
  mojo::internal::Encode(&this->f1, handles);
  mojo::internal::Encode(&this->f2, handles);
  mojo::internal::Encode(&this->f3, handles);
  mojo::internal::Encode(&this->f4, handles);
  mojo::internal::Encode(&this->f5, handles);
  mojo::internal::Encode(&this->f6, handles);
}

void BitArrayValues_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->f0, handles);
  mojo::internal::Decode(&this->f1, handles);
  mojo::internal::Decode(&this->f2, handles);
  mojo::internal::Decode(&this->f3, handles);
  mojo::internal::Decode(&this->f4, handles);
  mojo::internal::Decode(&this->f5, handles);
  mojo::internal::Decode(&this->f6, handles);
}

BitArrayValues_Data::BitArrayValues_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
MultiVersionStruct_Data* MultiVersionStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MultiVersionStruct_Data))) MultiVersionStruct_Data();
}

// static
mojo::internal::ValidationError MultiVersionStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MultiVersionStruct_Data* object = static_cast<const MultiVersionStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }, { 1, 24 }, { 3, 32 }, { 5, 40 }, { 7, 48 }, { 9, 48 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  if (object->header_.version < 1)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f_rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::test::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f_rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  if (object->header_.version < 3)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f_string.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f_string_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f_string.offset),
          bounds_checker, &f_string_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  if (object->header_.version < 5)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f_array.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f_array_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<int8_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f_array.offset),
          bounds_checker, &f_array_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  if (object->header_.version < 7)
    return mojo::internal::ValidationError::NONE;
  {
    
  const mojo::Handle f_message_pipe_handle = object->f_message_pipe;
  if (!bounds_checker->ClaimHandle(f_message_pipe_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MultiVersionStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 9);
  mojo::internal::Encode(&this->f_rect, handles);
  mojo::internal::Encode(&this->f_string, handles);
  mojo::internal::Encode(&this->f_array, handles);
  mojo::internal::EncodeHandle(&this->f_message_pipe, handles);
}

void MultiVersionStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  if (header_.version < 1)
    return;
  mojo::internal::Decode(&this->f_rect, handles);
  if (header_.version < 3)
    return;
  mojo::internal::Decode(&this->f_string, handles);
  if (header_.version < 5)
    return;
  mojo::internal::Decode(&this->f_array, handles);
  if (header_.version < 7)
    return;
  mojo::internal::DecodeHandle(&this->f_message_pipe, handles);
}

MultiVersionStruct_Data::MultiVersionStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 9;
}


// static
MultiVersionStructV0_Data* MultiVersionStructV0_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MultiVersionStructV0_Data))) MultiVersionStructV0_Data();
}

// static
mojo::internal::ValidationError MultiVersionStructV0_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MultiVersionStructV0_Data* object = static_cast<const MultiVersionStructV0_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void MultiVersionStructV0_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void MultiVersionStructV0_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

MultiVersionStructV0_Data::MultiVersionStructV0_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
MultiVersionStructV1_Data* MultiVersionStructV1_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MultiVersionStructV1_Data))) MultiVersionStructV1_Data();
}

// static
mojo::internal::ValidationError MultiVersionStructV1_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MultiVersionStructV1_Data* object = static_cast<const MultiVersionStructV1_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }, { 1, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  if (object->header_.version < 1)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f_rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::test::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f_rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MultiVersionStructV1_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 1);
  mojo::internal::Encode(&this->f_rect, handles);
}

void MultiVersionStructV1_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  if (header_.version < 1)
    return;
  mojo::internal::Decode(&this->f_rect, handles);
}

MultiVersionStructV1_Data::MultiVersionStructV1_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 1;
}


// static
MultiVersionStructV3_Data* MultiVersionStructV3_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MultiVersionStructV3_Data))) MultiVersionStructV3_Data();
}

// static
mojo::internal::ValidationError MultiVersionStructV3_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MultiVersionStructV3_Data* object = static_cast<const MultiVersionStructV3_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }, { 1, 24 }, { 3, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  if (object->header_.version < 1)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f_rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::test::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f_rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  if (object->header_.version < 3)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f_string.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f_string_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f_string.offset),
          bounds_checker, &f_string_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MultiVersionStructV3_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 3);
  mojo::internal::Encode(&this->f_rect, handles);
  mojo::internal::Encode(&this->f_string, handles);
}

void MultiVersionStructV3_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  if (header_.version < 1)
    return;
  mojo::internal::Decode(&this->f_rect, handles);
  if (header_.version < 3)
    return;
  mojo::internal::Decode(&this->f_string, handles);
}

MultiVersionStructV3_Data::MultiVersionStructV3_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 3;
}


// static
MultiVersionStructV5_Data* MultiVersionStructV5_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MultiVersionStructV5_Data))) MultiVersionStructV5_Data();
}

// static
mojo::internal::ValidationError MultiVersionStructV5_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MultiVersionStructV5_Data* object = static_cast<const MultiVersionStructV5_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }, { 1, 24 }, { 3, 32 }, { 5, 40 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  if (object->header_.version < 1)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f_rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::test::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f_rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  if (object->header_.version < 3)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f_string.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f_string_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f_string.offset),
          bounds_checker, &f_string_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  if (object->header_.version < 5)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f_array.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f_array_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<int8_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f_array.offset),
          bounds_checker, &f_array_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MultiVersionStructV5_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 5);
  mojo::internal::Encode(&this->f_rect, handles);
  mojo::internal::Encode(&this->f_string, handles);
  mojo::internal::Encode(&this->f_array, handles);
}

void MultiVersionStructV5_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  if (header_.version < 1)
    return;
  mojo::internal::Decode(&this->f_rect, handles);
  if (header_.version < 3)
    return;
  mojo::internal::Decode(&this->f_string, handles);
  if (header_.version < 5)
    return;
  mojo::internal::Decode(&this->f_array, handles);
}

MultiVersionStructV5_Data::MultiVersionStructV5_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 5;
}


// static
MultiVersionStructV7_Data* MultiVersionStructV7_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MultiVersionStructV7_Data))) MultiVersionStructV7_Data();
}

// static
mojo::internal::ValidationError MultiVersionStructV7_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MultiVersionStructV7_Data* object = static_cast<const MultiVersionStructV7_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }, { 1, 24 }, { 3, 32 }, { 5, 40 }, { 7, 48 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  if (object->header_.version < 1)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f_rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::test::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f_rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  if (object->header_.version < 3)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f_string.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f_string_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f_string.offset),
          bounds_checker, &f_string_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  if (object->header_.version < 5)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->f_array.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams f_array_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<int8_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->f_array.offset),
          bounds_checker, &f_array_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  if (object->header_.version < 7)
    return mojo::internal::ValidationError::NONE;
  {
    
  const mojo::Handle f_message_pipe_handle = object->f_message_pipe;
  if (!bounds_checker->ClaimHandle(f_message_pipe_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MultiVersionStructV7_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 7);
  mojo::internal::Encode(&this->f_rect, handles);
  mojo::internal::Encode(&this->f_string, handles);
  mojo::internal::Encode(&this->f_array, handles);
  mojo::internal::EncodeHandle(&this->f_message_pipe, handles);
}

void MultiVersionStructV7_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  if (header_.version < 1)
    return;
  mojo::internal::Decode(&this->f_rect, handles);
  if (header_.version < 3)
    return;
  mojo::internal::Decode(&this->f_string, handles);
  if (header_.version < 5)
    return;
  mojo::internal::Decode(&this->f_array, handles);
  if (header_.version < 7)
    return;
  mojo::internal::DecodeHandle(&this->f_message_pipe, handles);
}

MultiVersionStructV7_Data::MultiVersionStructV7_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 7;
}


// static
ContainsInterface_Data* ContainsInterface_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ContainsInterface_Data))) ContainsInterface_Data();
}

// static
mojo::internal::ValidationError ContainsInterface_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ContainsInterface_Data* object = static_cast<const ContainsInterface_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle some_interface_handle = object->some_interface.handle;
  if (some_interface_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid some_interface field in ContainsInterface struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(some_interface_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ContainsInterface_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->some_interface, handles);
}

void ContainsInterface_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->some_interface, handles);
}

ContainsInterface_Data::ContainsInterface_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
ContainsOther_Data* ContainsOther_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ContainsOther_Data))) ContainsOther_Data();
}

// static
mojo::internal::ValidationError ContainsOther_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ContainsOther_Data* object = static_cast<const ContainsOther_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void ContainsOther_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void ContainsOther_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

ContainsOther_Data::ContainsOther_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
ContainsInterfaceRequest_Data* ContainsInterfaceRequest_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ContainsInterfaceRequest_Data))) ContainsInterfaceRequest_Data();
}

// static
mojo::internal::ValidationError ContainsInterfaceRequest_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ContainsInterfaceRequest_Data* object = static_cast<const ContainsInterfaceRequest_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle req_handle = object->req;
  if (req_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid req field in ContainsInterfaceRequest struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(req_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  const mojo::Handle nullable_req_handle = object->nullable_req;
  if (!bounds_checker->ClaimHandle(nullable_req_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ContainsInterfaceRequest_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->req, handles);
  mojo::internal::EncodeHandle(&this->nullable_req, handles);
}

void ContainsInterfaceRequest_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->req, handles);
  mojo::internal::DecodeHandle(&this->nullable_req, handles);
}

ContainsInterfaceRequest_Data::ContainsInterfaceRequest_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
DartKeywordStruct_Data* DartKeywordStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(DartKeywordStruct_Data))) DartKeywordStruct_Data();
}

// static
mojo::internal::ValidationError DartKeywordStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const DartKeywordStruct_Data* object = static_cast<const DartKeywordStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void DartKeywordStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void DartKeywordStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

DartKeywordStruct_Data::DartKeywordStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// --- Union definitions ---
// static
UnionOfStructs_Data* UnionOfStructs_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(UnionOfStructs_Data))) UnionOfStructs_Data();
}


// static
mojo::internal::ValidationError UnionOfStructs_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(UnionOfStructs_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const UnionOfStructs_Data* object = static_cast<const UnionOfStructs_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case UnionOfStructs_Tag::NR: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::NamedRegion_Data>*>(&object->data.f_nr))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'nr' in 'UnionOfStructs'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::NamedRegion_Data>*>(&object->data.f_nr))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionOfStructs_Tag::A_NR: {

        if (!(reinterpret_cast<const mojo::internal::ArrayPointer<internal::NamedRegion_Data*>*>(&object->data.f_a_nr))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'a_nr' in 'UnionOfStructs'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::ArrayPointer<internal::NamedRegion_Data*>*>(&object->data.f_a_nr))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }const mojo::internal::ArrayValidateParams a_nr_validate_params(
            0, false, nullptr);
        auto validate_retval = mojo::Array<NamedRegionPtr>::Data_::Validate(
                mojo::internal::DecodePointerRaw(&(reinterpret_cast<const mojo::internal::ArrayPointer<internal::NamedRegion_Data*>*>(&object->data.f_a_nr))->offset),
                bounds_checker, &a_nr_validate_params,
                err);
        if (validate_retval != mojo::internal::ValidationError::NONE) {
          return validate_retval;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionOfStructs_Tag::A_RP: {

        if (!(reinterpret_cast<const mojo::internal::ArrayPointer<internal::RectPair_Data*>*>(&object->data.f_a_rp))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'a_rp' in 'UnionOfStructs'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::ArrayPointer<internal::RectPair_Data*>*>(&object->data.f_a_rp))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }const mojo::internal::ArrayValidateParams a_rp_validate_params(
            0, false, nullptr);
        auto validate_retval = mojo::Array<RectPairPtr>::Data_::Validate(
                mojo::internal::DecodePointerRaw(&(reinterpret_cast<const mojo::internal::ArrayPointer<internal::RectPair_Data*>*>(&object->data.f_a_rp))->offset),
                bounds_checker, &a_rp_validate_params,
                err);
        if (validate_retval != mojo::internal::ValidationError::NONE) {
          return validate_retval;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionOfStructs_Tag::M_NDFV: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<mojo::internal::Map_Data<int64_t, internal::NoDefaultFieldValues_Data*>>*>(&object->data.f_m_ndfv))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'm_ndfv' in 'UnionOfStructs'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<mojo::internal::Map_Data<int64_t, internal::NoDefaultFieldValues_Data*>>*>(&object->data.f_m_ndfv))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionOfStructs_Tag::M_HS: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<mojo::internal::Map_Data<int64_t, internal::HandleStruct_Data*>>*>(&object->data.f_m_hs))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'm_hs' in 'UnionOfStructs'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<mojo::internal::Map_Data<int64_t, internal::HandleStruct_Data*>>*>(&object->data.f_m_hs))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void UnionOfStructs_Data::set_null() {
  size = 0U;
  tag = static_cast<UnionOfStructs_Tag>(0);
  data.unknown = 0U;
}

UnionOfStructs_Data::UnionOfStructs_Data() {
}

void UnionOfStructs_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case UnionOfStructs_Tag::NR: {
      mojo::internal::Encode(&data.f_nr, handles);
      return;
    }
    case UnionOfStructs_Tag::A_NR: {
      mojo::internal::Encode(&data.f_a_nr, handles);
      return;
    }
    case UnionOfStructs_Tag::A_RP: {
      mojo::internal::Encode(&data.f_a_rp, handles);
      return;
    }
    case UnionOfStructs_Tag::M_NDFV: {
      mojo::internal::Encode(&data.f_m_ndfv, handles);
      return;
    }
    case UnionOfStructs_Tag::M_HS: {
      mojo::internal::Encode(&data.f_m_hs, handles);
      return;
    }
    case UnionOfStructs_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void UnionOfStructs_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case UnionOfStructs_Tag::NR: {
      mojo::internal::Decode(&data.f_nr, handles);
      return;
    }
    case UnionOfStructs_Tag::A_NR: {
      mojo::internal::Decode(&data.f_a_nr, handles);
      return;
    }
    case UnionOfStructs_Tag::A_RP: {
      mojo::internal::Decode(&data.f_a_rp, handles);
      return;
    }
    case UnionOfStructs_Tag::M_NDFV: {
      mojo::internal::Decode(&data.f_m_ndfv, handles);
      return;
    }
    case UnionOfStructs_Tag::M_HS: {
      mojo::internal::Decode(&data.f_m_hs, handles);
      return;
    }
    default:
      return;
  }
}


// --- Definitions of the data structs for interface methods ---


// static
SomeInterface_SomeMethod_Params_Data* SomeInterface_SomeMethod_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(SomeInterface_SomeMethod_Params_Data))) SomeInterface_SomeMethod_Params_Data();
}

// static
mojo::internal::ValidationError SomeInterface_SomeMethod_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const SomeInterface_SomeMethod_Params_Data* object = static_cast<const SomeInterface_SomeMethod_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->pair.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null pair field in SomeInterface_SomeMethod_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->pair.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = RectPair::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->pair.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void SomeInterface_SomeMethod_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->pair, handles);
}

void SomeInterface_SomeMethod_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->pair, handles);
}

SomeInterface_SomeMethod_Params_Data::SomeInterface_SomeMethod_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
SomeInterface_SomeMethod_ResponseParams_Data* SomeInterface_SomeMethod_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(SomeInterface_SomeMethod_ResponseParams_Data))) SomeInterface_SomeMethod_ResponseParams_Data();
}

// static
mojo::internal::ValidationError SomeInterface_SomeMethod_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const SomeInterface_SomeMethod_ResponseParams_Data* object = static_cast<const SomeInterface_SomeMethod_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->other_pair.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null other_pair field in SomeInterface_SomeMethod_ResponseParams struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->other_pair.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = RectPair::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->other_pair.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void SomeInterface_SomeMethod_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->other_pair, handles);
}

void SomeInterface_SomeMethod_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->other_pair, handles);
}

SomeInterface_SomeMethod_ResponseParams_Data::SomeInterface_SomeMethod_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


}  // namespace internal

// --- Request and response validator definitions for interfaces ---
mojo::internal::ValidationError SomeInterfaceRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'SomeInterface', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::SomeInterface_Base::MessageOrdinals method_ordinal =
      static_cast<internal::SomeInterface_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::SomeInterface_Base::MessageOrdinals::SomeMethod: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'SomeInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::SomeInterface_SomeMethod_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'SomeInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'SomeInterface'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError SomeInterfaceResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'SomeInterface', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'SomeInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::SomeInterface_Base::MessageOrdinals method_ordinal =
      static_cast<internal::SomeInterface_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::SomeInterface_Base::MessageOrdinals::SomeMethod: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::SomeInterface_SomeMethod_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'SomeInterface',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'SomeInterface'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
} 

// --- Enums ---

// Base interface definitions (Name_, Version_, Constants, Enums)
const uint32_t internal::SomeInterface_Base::Version_;

// Constants

// Enums

// Struct Constants
const char* DefaultFieldValues::kFoo = "foo";
const int32_t ScopedConstants::TEN;
const int32_t ScopedConstants::ALSO_TEN;
const double FloatNumberValues::V0 = INFINITY;
const double FloatNumberValues::V1 = -INFINITY;
const double FloatNumberValues::V2 = NAN;
const float FloatNumberValues::V3 = INFINITY;
const float FloatNumberValues::V4 = -INFINITY;
const float FloatNumberValues::V5 = NAN;
const float FloatNumberValues::V6 = 0;
const double FloatNumberValues::V7 = 1234567890.123;
const double FloatNumberValues::V8 = 1.2e+20;
const double FloatNumberValues::V9 = -1.2e+20;
const int8_t IntegerNumberValues::V0;
const int8_t IntegerNumberValues::V1;
const int8_t IntegerNumberValues::V2;
const int8_t IntegerNumberValues::V3;
const int8_t IntegerNumberValues::V4;
const int16_t IntegerNumberValues::V5;
const int16_t IntegerNumberValues::V6;
const int16_t IntegerNumberValues::V7;
const int16_t IntegerNumberValues::V8;
const int16_t IntegerNumberValues::V9;
const int32_t IntegerNumberValues::V10;
const int32_t IntegerNumberValues::V11;
const int32_t IntegerNumberValues::V12;
const int32_t IntegerNumberValues::V13;
const int32_t IntegerNumberValues::V14;
const int64_t IntegerNumberValues::V15;
const int64_t IntegerNumberValues::V16;
const int64_t IntegerNumberValues::V17;
const int64_t IntegerNumberValues::V18;
const int64_t IntegerNumberValues::V19;
const uint8_t UnsignedNumberValues::V0;
const uint8_t UnsignedNumberValues::V1;
const uint8_t UnsignedNumberValues::V2;
const uint16_t UnsignedNumberValues::V3;
const uint16_t UnsignedNumberValues::V4;
const uint16_t UnsignedNumberValues::V5;
const uint32_t UnsignedNumberValues::V6;
const uint32_t UnsignedNumberValues::V7;
const uint32_t UnsignedNumberValues::V8;
const uint64_t UnsignedNumberValues::V9;
const uint64_t UnsignedNumberValues::V10;
const uint64_t UnsignedNumberValues::V11;

// --- Struct builder definitions ---

// static
StructOfStructsPtr StructOfStructs::New() {
  StructOfStructsPtr rv;
  mojo::internal::StructHelper<StructOfStructs>::Initialize(&rv);
  return rv;
}

StructOfStructs::StructOfStructs()
    : nr(),
      a_nr(),
      a_rp(),
      m_ndfv(),
      m_hs() {
}

StructOfStructs::~StructOfStructs() {
}



bool StructOfStructs::Equals(const StructOfStructs& other) const {
  if (!mojo::internal::ValueTraits<NamedRegionPtr>::Equals(this->nr, other.nr))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<NamedRegionPtr>>::Equals(this->a_nr, other.a_nr))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<RectPairPtr>>::Equals(this->a_rp, other.a_rp))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<int64_t, NoDefaultFieldValuesPtr>>::Equals(this->m_ndfv, other.m_ndfv))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<int64_t, HandleStructPtr>>::Equals(this->m_hs, other.m_hs))
    return false;
  return true;
}


// static
NamedRegionPtr NamedRegion::New() {
  NamedRegionPtr rv;
  mojo::internal::StructHelper<NamedRegion>::Initialize(&rv);
  return rv;
}

NamedRegion::NamedRegion()
    : name(),
      rects() {
}

NamedRegion::~NamedRegion() {
}


NamedRegionPtr NamedRegion::Clone() const {
  NamedRegionPtr rv(New());
  rv->name = name;
  rv->rects = rects.Clone();
  return rv;
}


bool NamedRegion::Equals(const NamedRegion& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->name, other.name))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::test::RectPtr>>::Equals(this->rects, other.rects))
    return false;
  return true;
}


// static
RectPairPtr RectPair::New() {
  RectPairPtr rv;
  mojo::internal::StructHelper<RectPair>::Initialize(&rv);
  return rv;
}

RectPair::RectPair()
    : first(),
      second() {
}

RectPair::~RectPair() {
}


RectPairPtr RectPair::Clone() const {
  RectPairPtr rv(New());
  rv->first = first.Clone();
  rv->second = second.Clone();
  return rv;
}


bool RectPair::Equals(const RectPair& other) const {
  if (!mojo::internal::ValueTraits<mojo::test::RectPtr>::Equals(this->first, other.first))
    return false;
  if (!mojo::internal::ValueTraits<mojo::test::RectPtr>::Equals(this->second, other.second))
    return false;
  return true;
}


// static
EmptyStructPtr EmptyStruct::New() {
  EmptyStructPtr rv;
  mojo::internal::StructHelper<EmptyStruct>::Initialize(&rv);
  return rv;
}

EmptyStruct::EmptyStruct() {
}

EmptyStruct::~EmptyStruct() {
}


EmptyStructPtr EmptyStruct::Clone() const {
  EmptyStructPtr rv(New());
  return rv;
}


bool EmptyStruct::Equals(const EmptyStruct& other) const {
  return true;
}


// static
HandleStructPtr HandleStruct::New() {
  HandleStructPtr rv;
  mojo::internal::StructHelper<HandleStruct>::Initialize(&rv);
  return rv;
}

HandleStruct::HandleStruct()
    : h(),
      array_h() {
}

HandleStruct::~HandleStruct() {
}



bool HandleStruct::Equals(const HandleStruct& other) const {
  if (!mojo::internal::ValueTraits<mojo::ScopedMessagePipeHandle>::Equals(this->h, other.h))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::ScopedMessagePipeHandle>>::Equals(this->array_h, other.array_h))
    return false;
  return true;
}


// static
NullableHandleStructPtr NullableHandleStruct::New() {
  NullableHandleStructPtr rv;
  mojo::internal::StructHelper<NullableHandleStruct>::Initialize(&rv);
  return rv;
}

NullableHandleStruct::NullableHandleStruct()
    : h(),
      data(1234) {
}

NullableHandleStruct::~NullableHandleStruct() {
}



bool NullableHandleStruct::Equals(const NullableHandleStruct& other) const {
  if (!mojo::internal::ValueTraits<mojo::ScopedMessagePipeHandle>::Equals(this->h, other.h))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->data, other.data))
    return false;
  return true;
}


// static
NoDefaultFieldValuesPtr NoDefaultFieldValues::New() {
  NoDefaultFieldValuesPtr rv;
  mojo::internal::StructHelper<NoDefaultFieldValues>::Initialize(&rv);
  return rv;
}

NoDefaultFieldValues::NoDefaultFieldValues()
    : f0(),
      f1(),
      f2(),
      f3(),
      f4(),
      f5(),
      f6(),
      f7(),
      f8(),
      f9(),
      f10(),
      f11(),
      f12(),
      f13(),
      f14(),
      f15(),
      f16(),
      f17(),
      f18(),
      f19(),
      f20(),
      f21(),
      f22(),
      f23(),
      f24(),
      f25(),
      f26(),
      f27(),
      f28() {
}

NoDefaultFieldValues::~NoDefaultFieldValues() {
}



bool NoDefaultFieldValues::Equals(const NoDefaultFieldValues& other) const {
  if (!mojo::internal::ValueTraits<bool>::Equals(this->f0, other.f0))
    return false;
  if (!mojo::internal::ValueTraits<int8_t>::Equals(this->f1, other.f1))
    return false;
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->f2, other.f2))
    return false;
  if (!mojo::internal::ValueTraits<int16_t>::Equals(this->f3, other.f3))
    return false;
  if (!mojo::internal::ValueTraits<uint16_t>::Equals(this->f4, other.f4))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f5, other.f5))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->f6, other.f6))
    return false;
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->f7, other.f7))
    return false;
  if (!mojo::internal::ValueTraits<uint64_t>::Equals(this->f8, other.f8))
    return false;
  if (!mojo::internal::ValueTraits<float>::Equals(this->f9, other.f9))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->f10, other.f10))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->f11, other.f11))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->f12, other.f12))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedMessagePipeHandle>::Equals(this->f13, other.f13))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedDataPipeConsumerHandle>::Equals(this->f14, other.f14))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedDataPipeProducerHandle>::Equals(this->f15, other.f15))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedMessagePipeHandle>::Equals(this->f16, other.f16))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedDataPipeConsumerHandle>::Equals(this->f17, other.f17))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedDataPipeProducerHandle>::Equals(this->f18, other.f18))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedHandle>::Equals(this->f19, other.f19))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedHandle>::Equals(this->f20, other.f20))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedSharedBufferHandle>::Equals(this->f21, other.f21))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedSharedBufferHandle>::Equals(this->f22, other.f22))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->f23, other.f23))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->f24, other.f24))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->f25, other.f25))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->f26, other.f26))
    return false;
  if (!mojo::internal::ValueTraits<EmptyStructPtr>::Equals(this->f27, other.f27))
    return false;
  if (!mojo::internal::ValueTraits<EmptyStructPtr>::Equals(this->f28, other.f28))
    return false;
  return true;
}


// static
DefaultFieldValuesPtr DefaultFieldValues::New() {
  DefaultFieldValuesPtr rv;
  mojo::internal::StructHelper<DefaultFieldValues>::Initialize(&rv);
  return rv;
}

DefaultFieldValues::DefaultFieldValues()
    : f0(true),
      f1(100),
      f2(100U),
      f3(100),
      f4(100U),
      f5(100),
      f6(100U),
      f7(100),
      f8(100ULL),
      f9(100),
      f10(100.0f),
      f11(100),
      f12(100.0),
      f13(DefaultFieldValues::kFoo),
      f14(DefaultFieldValues::kFoo),
      f15(mojo::test::Rect::New()),
      f16(mojo::test::Rect::New()) {
}

DefaultFieldValues::~DefaultFieldValues() {
}


DefaultFieldValuesPtr DefaultFieldValues::Clone() const {
  DefaultFieldValuesPtr rv(New());
  rv->f0 = f0;
  rv->f1 = f1;
  rv->f2 = f2;
  rv->f3 = f3;
  rv->f4 = f4;
  rv->f5 = f5;
  rv->f6 = f6;
  rv->f7 = f7;
  rv->f8 = f8;
  rv->f9 = f9;
  rv->f10 = f10;
  rv->f11 = f11;
  rv->f12 = f12;
  rv->f13 = f13;
  rv->f14 = f14;
  rv->f15 = f15.Clone();
  rv->f16 = f16.Clone();
  return rv;
}


bool DefaultFieldValues::Equals(const DefaultFieldValues& other) const {
  if (!mojo::internal::ValueTraits<bool>::Equals(this->f0, other.f0))
    return false;
  if (!mojo::internal::ValueTraits<int8_t>::Equals(this->f1, other.f1))
    return false;
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->f2, other.f2))
    return false;
  if (!mojo::internal::ValueTraits<int16_t>::Equals(this->f3, other.f3))
    return false;
  if (!mojo::internal::ValueTraits<uint16_t>::Equals(this->f4, other.f4))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f5, other.f5))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->f6, other.f6))
    return false;
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->f7, other.f7))
    return false;
  if (!mojo::internal::ValueTraits<uint64_t>::Equals(this->f8, other.f8))
    return false;
  if (!mojo::internal::ValueTraits<float>::Equals(this->f9, other.f9))
    return false;
  if (!mojo::internal::ValueTraits<float>::Equals(this->f10, other.f10))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->f11, other.f11))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->f12, other.f12))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->f13, other.f13))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->f14, other.f14))
    return false;
  if (!mojo::internal::ValueTraits<mojo::test::RectPtr>::Equals(this->f15, other.f15))
    return false;
  if (!mojo::internal::ValueTraits<mojo::test::RectPtr>::Equals(this->f16, other.f16))
    return false;
  return true;
}

// static
bool ScopedConstants::EType_IsValidValue(EType value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 10:
    case 11:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream,
                         const ScopedConstants::EType& val) {
  return (stream << static_cast<int32_t>(val));
}

// static
ScopedConstantsPtr ScopedConstants::New() {
  ScopedConstantsPtr rv;
  mojo::internal::StructHelper<ScopedConstants>::Initialize(&rv);
  return rv;
}

ScopedConstants::ScopedConstants()
    : f0(ScopedConstants::EType::E0),
      f1(ScopedConstants::EType::E1),
      f2(ScopedConstants::EType::E2),
      f3(ScopedConstants::EType::E3),
      f4(ScopedConstants::EType::E4),
      f5(ScopedConstants::TEN),
      f6(ScopedConstants::ALSO_TEN) {
}

ScopedConstants::~ScopedConstants() {
}


ScopedConstantsPtr ScopedConstants::Clone() const {
  ScopedConstantsPtr rv(New());
  rv->f0 = f0;
  rv->f1 = f1;
  rv->f2 = f2;
  rv->f3 = f3;
  rv->f4 = f4;
  rv->f5 = f5;
  rv->f6 = f6;
  return rv;
}


bool ScopedConstants::Equals(const ScopedConstants& other) const {
  if (!mojo::internal::ValueTraits<ScopedConstants::EType>::Equals(this->f0, other.f0))
    return false;
  if (!mojo::internal::ValueTraits<ScopedConstants::EType>::Equals(this->f1, other.f1))
    return false;
  if (!mojo::internal::ValueTraits<ScopedConstants::EType>::Equals(this->f2, other.f2))
    return false;
  if (!mojo::internal::ValueTraits<ScopedConstants::EType>::Equals(this->f3, other.f3))
    return false;
  if (!mojo::internal::ValueTraits<ScopedConstants::EType>::Equals(this->f4, other.f4))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f5, other.f5))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f6, other.f6))
    return false;
  return true;
}


// static
MapKeyTypesPtr MapKeyTypes::New() {
  MapKeyTypesPtr rv;
  mojo::internal::StructHelper<MapKeyTypes>::Initialize(&rv);
  return rv;
}

MapKeyTypes::MapKeyTypes()
    : f0(),
      f1(),
      f2(),
      f3(),
      f4(),
      f5(),
      f6(),
      f7(),
      f8(),
      f9(),
      f10(),
      f11() {
}

MapKeyTypes::~MapKeyTypes() {
}


MapKeyTypesPtr MapKeyTypes::Clone() const {
  MapKeyTypesPtr rv(New());
  rv->f0 = f0.Clone();
  rv->f1 = f1.Clone();
  rv->f2 = f2.Clone();
  rv->f3 = f3.Clone();
  rv->f4 = f4.Clone();
  rv->f5 = f5.Clone();
  rv->f6 = f6.Clone();
  rv->f7 = f7.Clone();
  rv->f8 = f8.Clone();
  rv->f9 = f9.Clone();
  rv->f10 = f10.Clone();
  rv->f11 = f11.Clone();
  return rv;
}


bool MapKeyTypes::Equals(const MapKeyTypes& other) const {
  if (!mojo::internal::ValueTraits<mojo::Map<bool, bool>>::Equals(this->f0, other.f0))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<int8_t, int8_t>>::Equals(this->f1, other.f1))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<uint8_t, uint8_t>>::Equals(this->f2, other.f2))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<int16_t, int16_t>>::Equals(this->f3, other.f3))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<uint16_t, uint16_t>>::Equals(this->f4, other.f4))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<int32_t, int32_t>>::Equals(this->f5, other.f5))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<uint32_t, uint32_t>>::Equals(this->f6, other.f6))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<int64_t, int64_t>>::Equals(this->f7, other.f7))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<uint64_t, uint64_t>>::Equals(this->f8, other.f8))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<float, float>>::Equals(this->f9, other.f9))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<double, double>>::Equals(this->f10, other.f10))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::String>>::Equals(this->f11, other.f11))
    return false;
  return true;
}


// static
MapValueTypesPtr MapValueTypes::New() {
  MapValueTypesPtr rv;
  mojo::internal::StructHelper<MapValueTypes>::Initialize(&rv);
  return rv;
}

MapValueTypes::MapValueTypes()
    : f0(),
      f1(),
      f2(),
      f3(),
      f4(),
      f5(),
      f6(),
      f7(),
      f8(),
      f9(),
      f10(),
      f11() {
}

MapValueTypes::~MapValueTypes() {
}



bool MapValueTypes::Equals(const MapValueTypes& other) const {
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::Array<mojo::String> >>::Equals(this->f0, other.f0))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::Array<mojo::String> >>::Equals(this->f1, other.f1))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::Array<mojo::String> >>::Equals(this->f2, other.f2))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::Array<mojo::String> >>::Equals(this->f3, other.f3))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::Array<mojo::Array<mojo::String> > >>::Equals(this->f4, other.f4))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::Array<mojo::Array<mojo::String> > >>::Equals(this->f5, other.f5))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::test::RectPtr>>::Equals(this->f6, other.f6))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::Map<mojo::String, mojo::String> >>::Equals(this->f7, other.f7))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::Array<mojo::Map<mojo::String, mojo::String> > >>::Equals(this->f8, other.f8))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::ScopedHandle>>::Equals(this->f9, other.f9))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::Array<mojo::ScopedHandle> >>::Equals(this->f10, other.f10))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::Map<mojo::String, mojo::ScopedHandle> >>::Equals(this->f11, other.f11))
    return false;
  return true;
}


// static
ArrayValueTypesPtr ArrayValueTypes::New() {
  ArrayValueTypesPtr rv;
  mojo::internal::StructHelper<ArrayValueTypes>::Initialize(&rv);
  return rv;
}

ArrayValueTypes::ArrayValueTypes()
    : f0(),
      f1(),
      f2(),
      f3(),
      f4(),
      f5() {
}

ArrayValueTypes::~ArrayValueTypes() {
}


ArrayValueTypesPtr ArrayValueTypes::Clone() const {
  ArrayValueTypesPtr rv(New());
  rv->f0 = f0.Clone();
  rv->f1 = f1.Clone();
  rv->f2 = f2.Clone();
  rv->f3 = f3.Clone();
  rv->f4 = f4.Clone();
  rv->f5 = f5.Clone();
  return rv;
}


bool ArrayValueTypes::Equals(const ArrayValueTypes& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<int8_t>>::Equals(this->f0, other.f0))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<int16_t>>::Equals(this->f1, other.f1))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<int32_t>>::Equals(this->f2, other.f2))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<int64_t>>::Equals(this->f3, other.f3))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<float>>::Equals(this->f4, other.f4))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<double>>::Equals(this->f5, other.f5))
    return false;
  return true;
}


// static
FloatNumberValuesPtr FloatNumberValues::New() {
  FloatNumberValuesPtr rv;
  mojo::internal::StructHelper<FloatNumberValues>::Initialize(&rv);
  return rv;
}

FloatNumberValues::FloatNumberValues()
    : f0(FloatNumberValues::V0),
      f1(FloatNumberValues::V1),
      f2(FloatNumberValues::V2),
      f3(FloatNumberValues::V3),
      f4(FloatNumberValues::V4),
      f5(FloatNumberValues::V5),
      f6(FloatNumberValues::V6),
      f7(FloatNumberValues::V7),
      f8(FloatNumberValues::V8),
      f9(FloatNumberValues::V9) {
}

FloatNumberValues::~FloatNumberValues() {
}


FloatNumberValuesPtr FloatNumberValues::Clone() const {
  FloatNumberValuesPtr rv(New());
  rv->f0 = f0;
  rv->f1 = f1;
  rv->f2 = f2;
  rv->f3 = f3;
  rv->f4 = f4;
  rv->f5 = f5;
  rv->f6 = f6;
  rv->f7 = f7;
  rv->f8 = f8;
  rv->f9 = f9;
  return rv;
}


bool FloatNumberValues::Equals(const FloatNumberValues& other) const {
  if (!mojo::internal::ValueTraits<double>::Equals(this->f0, other.f0))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->f1, other.f1))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->f2, other.f2))
    return false;
  if (!mojo::internal::ValueTraits<float>::Equals(this->f3, other.f3))
    return false;
  if (!mojo::internal::ValueTraits<float>::Equals(this->f4, other.f4))
    return false;
  if (!mojo::internal::ValueTraits<float>::Equals(this->f5, other.f5))
    return false;
  if (!mojo::internal::ValueTraits<float>::Equals(this->f6, other.f6))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->f7, other.f7))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->f8, other.f8))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->f9, other.f9))
    return false;
  return true;
}


// static
IntegerNumberValuesPtr IntegerNumberValues::New() {
  IntegerNumberValuesPtr rv;
  mojo::internal::StructHelper<IntegerNumberValues>::Initialize(&rv);
  return rv;
}

IntegerNumberValues::IntegerNumberValues()
    : f0(IntegerNumberValues::V0),
      f1(IntegerNumberValues::V1),
      f2(IntegerNumberValues::V2),
      f3(IntegerNumberValues::V3),
      f4(IntegerNumberValues::V4),
      f5(IntegerNumberValues::V5),
      f6(IntegerNumberValues::V6),
      f7(IntegerNumberValues::V7),
      f8(IntegerNumberValues::V8),
      f9(IntegerNumberValues::V9),
      f10(IntegerNumberValues::V10),
      f11(IntegerNumberValues::V11),
      f12(IntegerNumberValues::V12),
      f13(IntegerNumberValues::V13),
      f14(IntegerNumberValues::V14),
      f15(IntegerNumberValues::V15),
      f16(IntegerNumberValues::V16),
      f17(IntegerNumberValues::V17),
      f18(IntegerNumberValues::V18),
      f19(IntegerNumberValues::V19) {
}

IntegerNumberValues::~IntegerNumberValues() {
}


IntegerNumberValuesPtr IntegerNumberValues::Clone() const {
  IntegerNumberValuesPtr rv(New());
  rv->f0 = f0;
  rv->f1 = f1;
  rv->f2 = f2;
  rv->f3 = f3;
  rv->f4 = f4;
  rv->f5 = f5;
  rv->f6 = f6;
  rv->f7 = f7;
  rv->f8 = f8;
  rv->f9 = f9;
  rv->f10 = f10;
  rv->f11 = f11;
  rv->f12 = f12;
  rv->f13 = f13;
  rv->f14 = f14;
  rv->f15 = f15;
  rv->f16 = f16;
  rv->f17 = f17;
  rv->f18 = f18;
  rv->f19 = f19;
  return rv;
}


bool IntegerNumberValues::Equals(const IntegerNumberValues& other) const {
  if (!mojo::internal::ValueTraits<int8_t>::Equals(this->f0, other.f0))
    return false;
  if (!mojo::internal::ValueTraits<int8_t>::Equals(this->f1, other.f1))
    return false;
  if (!mojo::internal::ValueTraits<int8_t>::Equals(this->f2, other.f2))
    return false;
  if (!mojo::internal::ValueTraits<int8_t>::Equals(this->f3, other.f3))
    return false;
  if (!mojo::internal::ValueTraits<int8_t>::Equals(this->f4, other.f4))
    return false;
  if (!mojo::internal::ValueTraits<int16_t>::Equals(this->f5, other.f5))
    return false;
  if (!mojo::internal::ValueTraits<int16_t>::Equals(this->f6, other.f6))
    return false;
  if (!mojo::internal::ValueTraits<int16_t>::Equals(this->f7, other.f7))
    return false;
  if (!mojo::internal::ValueTraits<int16_t>::Equals(this->f8, other.f8))
    return false;
  if (!mojo::internal::ValueTraits<int16_t>::Equals(this->f9, other.f9))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f10, other.f10))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f11, other.f11))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f12, other.f12))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f13, other.f13))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f14, other.f14))
    return false;
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->f15, other.f15))
    return false;
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->f16, other.f16))
    return false;
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->f17, other.f17))
    return false;
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->f18, other.f18))
    return false;
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->f19, other.f19))
    return false;
  return true;
}


// static
UnsignedNumberValuesPtr UnsignedNumberValues::New() {
  UnsignedNumberValuesPtr rv;
  mojo::internal::StructHelper<UnsignedNumberValues>::Initialize(&rv);
  return rv;
}

UnsignedNumberValues::UnsignedNumberValues()
    : f0(UnsignedNumberValues::V0),
      f1(UnsignedNumberValues::V1),
      f2(UnsignedNumberValues::V2),
      f3(UnsignedNumberValues::V3),
      f4(UnsignedNumberValues::V4),
      f5(UnsignedNumberValues::V5),
      f6(UnsignedNumberValues::V6),
      f7(UnsignedNumberValues::V7),
      f8(UnsignedNumberValues::V8),
      f9(UnsignedNumberValues::V9),
      f10(UnsignedNumberValues::V10),
      f11(UnsignedNumberValues::V11) {
}

UnsignedNumberValues::~UnsignedNumberValues() {
}


UnsignedNumberValuesPtr UnsignedNumberValues::Clone() const {
  UnsignedNumberValuesPtr rv(New());
  rv->f0 = f0;
  rv->f1 = f1;
  rv->f2 = f2;
  rv->f3 = f3;
  rv->f4 = f4;
  rv->f5 = f5;
  rv->f6 = f6;
  rv->f7 = f7;
  rv->f8 = f8;
  rv->f9 = f9;
  rv->f10 = f10;
  rv->f11 = f11;
  return rv;
}


bool UnsignedNumberValues::Equals(const UnsignedNumberValues& other) const {
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->f0, other.f0))
    return false;
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->f1, other.f1))
    return false;
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->f2, other.f2))
    return false;
  if (!mojo::internal::ValueTraits<uint16_t>::Equals(this->f3, other.f3))
    return false;
  if (!mojo::internal::ValueTraits<uint16_t>::Equals(this->f4, other.f4))
    return false;
  if (!mojo::internal::ValueTraits<uint16_t>::Equals(this->f5, other.f5))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->f6, other.f6))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->f7, other.f7))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->f8, other.f8))
    return false;
  if (!mojo::internal::ValueTraits<uint64_t>::Equals(this->f9, other.f9))
    return false;
  if (!mojo::internal::ValueTraits<uint64_t>::Equals(this->f10, other.f10))
    return false;
  if (!mojo::internal::ValueTraits<uint64_t>::Equals(this->f11, other.f11))
    return false;
  return true;
}


// static
BitArrayValuesPtr BitArrayValues::New() {
  BitArrayValuesPtr rv;
  mojo::internal::StructHelper<BitArrayValues>::Initialize(&rv);
  return rv;
}

BitArrayValues::BitArrayValues()
    : f0(),
      f1(),
      f2(),
      f3(),
      f4(),
      f5(),
      f6() {
}

BitArrayValues::~BitArrayValues() {
}


BitArrayValuesPtr BitArrayValues::Clone() const {
  BitArrayValuesPtr rv(New());
  rv->f0 = f0.Clone();
  rv->f1 = f1.Clone();
  rv->f2 = f2.Clone();
  rv->f3 = f3.Clone();
  rv->f4 = f4.Clone();
  rv->f5 = f5.Clone();
  rv->f6 = f6.Clone();
  return rv;
}


bool BitArrayValues::Equals(const BitArrayValues& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<bool>>::Equals(this->f0, other.f0))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<bool>>::Equals(this->f1, other.f1))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<bool>>::Equals(this->f2, other.f2))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<bool>>::Equals(this->f3, other.f3))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::Array<bool> >>::Equals(this->f4, other.f4))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::Array<bool> >>::Equals(this->f5, other.f5))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::Array<bool> >>::Equals(this->f6, other.f6))
    return false;
  return true;
}


// static
MultiVersionStructPtr MultiVersionStruct::New() {
  MultiVersionStructPtr rv;
  mojo::internal::StructHelper<MultiVersionStruct>::Initialize(&rv);
  return rv;
}

MultiVersionStruct::MultiVersionStruct()
    : f_int32(),
      f_rect(),
      f_string(),
      f_array(),
      f_message_pipe(),
      f_bool(),
      f_int16() {
}

MultiVersionStruct::~MultiVersionStruct() {
}



bool MultiVersionStruct::Equals(const MultiVersionStruct& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f_int32, other.f_int32))
    return false;
  if (!mojo::internal::ValueTraits<mojo::test::RectPtr>::Equals(this->f_rect, other.f_rect))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->f_string, other.f_string))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<int8_t>>::Equals(this->f_array, other.f_array))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedMessagePipeHandle>::Equals(this->f_message_pipe, other.f_message_pipe))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->f_bool, other.f_bool))
    return false;
  if (!mojo::internal::ValueTraits<int16_t>::Equals(this->f_int16, other.f_int16))
    return false;
  return true;
}


// static
MultiVersionStructV0Ptr MultiVersionStructV0::New() {
  MultiVersionStructV0Ptr rv;
  mojo::internal::StructHelper<MultiVersionStructV0>::Initialize(&rv);
  return rv;
}

MultiVersionStructV0::MultiVersionStructV0()
    : f_int32() {
}

MultiVersionStructV0::~MultiVersionStructV0() {
}


MultiVersionStructV0Ptr MultiVersionStructV0::Clone() const {
  MultiVersionStructV0Ptr rv(New());
  rv->f_int32 = f_int32;
  return rv;
}


bool MultiVersionStructV0::Equals(const MultiVersionStructV0& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f_int32, other.f_int32))
    return false;
  return true;
}


// static
MultiVersionStructV1Ptr MultiVersionStructV1::New() {
  MultiVersionStructV1Ptr rv;
  mojo::internal::StructHelper<MultiVersionStructV1>::Initialize(&rv);
  return rv;
}

MultiVersionStructV1::MultiVersionStructV1()
    : f_int32(),
      f_rect() {
}

MultiVersionStructV1::~MultiVersionStructV1() {
}


MultiVersionStructV1Ptr MultiVersionStructV1::Clone() const {
  MultiVersionStructV1Ptr rv(New());
  rv->f_int32 = f_int32;
  rv->f_rect = f_rect.Clone();
  return rv;
}


bool MultiVersionStructV1::Equals(const MultiVersionStructV1& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f_int32, other.f_int32))
    return false;
  if (!mojo::internal::ValueTraits<mojo::test::RectPtr>::Equals(this->f_rect, other.f_rect))
    return false;
  return true;
}


// static
MultiVersionStructV3Ptr MultiVersionStructV3::New() {
  MultiVersionStructV3Ptr rv;
  mojo::internal::StructHelper<MultiVersionStructV3>::Initialize(&rv);
  return rv;
}

MultiVersionStructV3::MultiVersionStructV3()
    : f_int32(),
      f_rect(),
      f_string() {
}

MultiVersionStructV3::~MultiVersionStructV3() {
}


MultiVersionStructV3Ptr MultiVersionStructV3::Clone() const {
  MultiVersionStructV3Ptr rv(New());
  rv->f_int32 = f_int32;
  rv->f_rect = f_rect.Clone();
  rv->f_string = f_string;
  return rv;
}


bool MultiVersionStructV3::Equals(const MultiVersionStructV3& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f_int32, other.f_int32))
    return false;
  if (!mojo::internal::ValueTraits<mojo::test::RectPtr>::Equals(this->f_rect, other.f_rect))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->f_string, other.f_string))
    return false;
  return true;
}


// static
MultiVersionStructV5Ptr MultiVersionStructV5::New() {
  MultiVersionStructV5Ptr rv;
  mojo::internal::StructHelper<MultiVersionStructV5>::Initialize(&rv);
  return rv;
}

MultiVersionStructV5::MultiVersionStructV5()
    : f_int32(),
      f_rect(),
      f_string(),
      f_array() {
}

MultiVersionStructV5::~MultiVersionStructV5() {
}


MultiVersionStructV5Ptr MultiVersionStructV5::Clone() const {
  MultiVersionStructV5Ptr rv(New());
  rv->f_int32 = f_int32;
  rv->f_rect = f_rect.Clone();
  rv->f_string = f_string;
  rv->f_array = f_array.Clone();
  return rv;
}


bool MultiVersionStructV5::Equals(const MultiVersionStructV5& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f_int32, other.f_int32))
    return false;
  if (!mojo::internal::ValueTraits<mojo::test::RectPtr>::Equals(this->f_rect, other.f_rect))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->f_string, other.f_string))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<int8_t>>::Equals(this->f_array, other.f_array))
    return false;
  return true;
}


// static
MultiVersionStructV7Ptr MultiVersionStructV7::New() {
  MultiVersionStructV7Ptr rv;
  mojo::internal::StructHelper<MultiVersionStructV7>::Initialize(&rv);
  return rv;
}

MultiVersionStructV7::MultiVersionStructV7()
    : f_int32(),
      f_rect(),
      f_string(),
      f_array(),
      f_message_pipe(),
      f_bool() {
}

MultiVersionStructV7::~MultiVersionStructV7() {
}



bool MultiVersionStructV7::Equals(const MultiVersionStructV7& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->f_int32, other.f_int32))
    return false;
  if (!mojo::internal::ValueTraits<mojo::test::RectPtr>::Equals(this->f_rect, other.f_rect))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->f_string, other.f_string))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<int8_t>>::Equals(this->f_array, other.f_array))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedMessagePipeHandle>::Equals(this->f_message_pipe, other.f_message_pipe))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->f_bool, other.f_bool))
    return false;
  return true;
}


// static
ContainsInterfacePtr ContainsInterface::New() {
  ContainsInterfacePtr rv;
  mojo::internal::StructHelper<ContainsInterface>::Initialize(&rv);
  return rv;
}

ContainsInterface::ContainsInterface()
    : some_interface() {
}

ContainsInterface::~ContainsInterface() {
}



bool ContainsInterface::Equals(const ContainsInterface& other) const {
  if (!mojo::internal::ValueTraits<mojo::InterfaceHandle<SomeInterface>>::Equals(this->some_interface, other.some_interface))
    return false;
  return true;
}


// static
ContainsOtherPtr ContainsOther::New() {
  ContainsOtherPtr rv;
  mojo::internal::StructHelper<ContainsOther>::Initialize(&rv);
  return rv;
}

ContainsOther::ContainsOther()
    : other() {
}

ContainsOther::~ContainsOther() {
}


ContainsOtherPtr ContainsOther::Clone() const {
  ContainsOtherPtr rv(New());
  rv->other = other;
  return rv;
}


bool ContainsOther::Equals(const ContainsOther& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->other, other.other))
    return false;
  return true;
}


// static
ContainsInterfaceRequestPtr ContainsInterfaceRequest::New() {
  ContainsInterfaceRequestPtr rv;
  mojo::internal::StructHelper<ContainsInterfaceRequest>::Initialize(&rv);
  return rv;
}

ContainsInterfaceRequest::ContainsInterfaceRequest()
    : req(),
      nullable_req() {
}

ContainsInterfaceRequest::~ContainsInterfaceRequest() {
}



bool ContainsInterfaceRequest::Equals(const ContainsInterfaceRequest& other) const {
  if (!mojo::internal::ValueTraits<mojo::InterfaceRequest<SomeInterface>>::Equals(this->req, other.req))
    return false;
  if (!mojo::internal::ValueTraits<mojo::InterfaceRequest<SomeInterface>>::Equals(this->nullable_req, other.nullable_req))
    return false;
  return true;
}

// static
bool DartKeywordStruct::Keywords_IsValidValue(Keywords value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream,
                         const DartKeywordStruct::Keywords& val) {
  return (stream << static_cast<int32_t>(val));
}

// static
DartKeywordStructPtr DartKeywordStruct::New() {
  DartKeywordStructPtr rv;
  mojo::internal::StructHelper<DartKeywordStruct>::Initialize(&rv);
  return rv;
}

DartKeywordStruct::DartKeywordStruct()
    : await(),
      is(),
      rethrow() {
}

DartKeywordStruct::~DartKeywordStruct() {
}


DartKeywordStructPtr DartKeywordStruct::Clone() const {
  DartKeywordStructPtr rv(New());
  rv->await = await;
  rv->is = is;
  rv->rethrow = rethrow;
  return rv;
}


bool DartKeywordStruct::Equals(const DartKeywordStruct& other) const {
  if (!mojo::internal::ValueTraits<DartKeywordStruct::Keywords>::Equals(this->await, other.await))
    return false;
  if (!mojo::internal::ValueTraits<DartKeywordStruct::Keywords>::Equals(this->is, other.is))
    return false;
  if (!mojo::internal::ValueTraits<DartKeywordStruct::Keywords>::Equals(this->rethrow, other.rethrow))
    return false;
  return true;
}


// --- Union builder definitions ---// static
UnionOfStructsPtr UnionOfStructs::New() {
  UnionOfStructsPtr rv;
  mojo::internal::StructHelper<UnionOfStructs>::Initialize(&rv);
  return rv;
}

UnionOfStructs::UnionOfStructs() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

UnionOfStructs::~UnionOfStructs() {
  DestroyActive();
}



bool UnionOfStructs::Equals(const UnionOfStructs& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::NR:

      return mojo::internal::ValueTraits<NamedRegionPtr>::Equals(*(data_.nr), *(other.data_.nr));
    case Tag::A_NR:

      return mojo::internal::ValueTraits<mojo::Array<NamedRegionPtr>>::Equals(*(data_.a_nr), *(other.data_.a_nr));
    case Tag::A_RP:

      return mojo::internal::ValueTraits<mojo::Array<RectPairPtr>>::Equals(*(data_.a_rp), *(other.data_.a_rp));
    case Tag::M_NDFV:

      return mojo::internal::ValueTraits<mojo::Map<int64_t, NoDefaultFieldValuesPtr>>::Equals(*(data_.m_ndfv), *(other.data_.m_ndfv));
    case Tag::M_HS:

      return mojo::internal::ValueTraits<mojo::Map<int64_t, HandleStructPtr>>::Equals(*(data_.m_hs), *(other.data_.m_hs));
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool UnionOfStructs::is_nr() const {
  return tag_ == Tag::NR;
}

NamedRegionPtr& UnionOfStructs::get_nr() const {
  MOJO_DCHECK(tag_ == Tag::NR);

  return *(data_.nr);
}

void UnionOfStructs::set_nr(NamedRegionPtr nr) {
  SwitchActive(Tag::NR);

  *(data_.nr) = nr.Pass();

}
bool UnionOfStructs::is_a_nr() const {
  return tag_ == Tag::A_NR;
}

mojo::Array<NamedRegionPtr>& UnionOfStructs::get_a_nr() const {
  MOJO_DCHECK(tag_ == Tag::A_NR);

  return *(data_.a_nr);
}

void UnionOfStructs::set_a_nr(mojo::Array<NamedRegionPtr> a_nr) {
  SwitchActive(Tag::A_NR);

  *(data_.a_nr) = a_nr.Pass();

}
bool UnionOfStructs::is_a_rp() const {
  return tag_ == Tag::A_RP;
}

mojo::Array<RectPairPtr>& UnionOfStructs::get_a_rp() const {
  MOJO_DCHECK(tag_ == Tag::A_RP);

  return *(data_.a_rp);
}

void UnionOfStructs::set_a_rp(mojo::Array<RectPairPtr> a_rp) {
  SwitchActive(Tag::A_RP);

  *(data_.a_rp) = a_rp.Pass();

}
bool UnionOfStructs::is_m_ndfv() const {
  return tag_ == Tag::M_NDFV;
}

mojo::Map<int64_t, NoDefaultFieldValuesPtr>& UnionOfStructs::get_m_ndfv() const {
  MOJO_DCHECK(tag_ == Tag::M_NDFV);

  return *(data_.m_ndfv);
}

void UnionOfStructs::set_m_ndfv(mojo::Map<int64_t, NoDefaultFieldValuesPtr> m_ndfv) {
  SwitchActive(Tag::M_NDFV);

  *(data_.m_ndfv) = m_ndfv.Pass();

}
bool UnionOfStructs::is_m_hs() const {
  return tag_ == Tag::M_HS;
}

mojo::Map<int64_t, HandleStructPtr>& UnionOfStructs::get_m_hs() const {
  MOJO_DCHECK(tag_ == Tag::M_HS);

  return *(data_.m_hs);
}

void UnionOfStructs::set_m_hs(mojo::Map<int64_t, HandleStructPtr> m_hs) {
  SwitchActive(Tag::M_HS);

  *(data_.m_hs) = m_hs.Pass();

}

bool UnionOfStructs::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void UnionOfStructs::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void UnionOfStructs::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::NR:

      data_.nr = new NamedRegionPtr();
      break;
    case Tag::A_NR:

      data_.a_nr = new mojo::Array<NamedRegionPtr>();
      break;
    case Tag::A_RP:

      data_.a_rp = new mojo::Array<RectPairPtr>();
      break;
    case Tag::M_NDFV:

      data_.m_ndfv = new mojo::Map<int64_t, NoDefaultFieldValuesPtr>();
      break;
    case Tag::M_HS:

      data_.m_hs = new mojo::Map<int64_t, HandleStructPtr>();
      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void UnionOfStructs::DestroyActive() {
  switch (tag_) {

    case Tag::NR:

      delete data_.nr;
      break;
    case Tag::A_NR:

      delete data_.a_nr;
      break;
    case Tag::A_RP:

      delete data_.a_rp;
      break;
    case Tag::M_NDFV:

      delete data_.m_ndfv;
      break;
    case Tag::M_HS:

      delete data_.m_hs;
      break;
    default:
      break;
  }
}


// --- Struct Serialization Helpers ---

size_t StructOfStructs::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructOfStructs::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructOfStructs_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructOfStructs::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructOfStructs_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructOfStructs::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructOfStructs_Data* input =
      static_cast<internal::StructOfStructs_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructOfStructs& input) {
  size_t size = sizeof(internal::StructOfStructs_Data);
  size += input.nr.is_null()
              ? 0
              : GetSerializedSize_(*input.nr);
  size += GetSerializedSize_(input.a_nr);
  size += GetSerializedSize_(input.a_rp);
  size += GetSerializedSize_(input.m_ndfv);
  size += GetSerializedSize_(input.m_hs);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructOfStructs* input,
    mojo::internal::Buffer* buf,
    internal::StructOfStructs_Data** output) {
  if (input) {
    internal::StructOfStructs_Data* result =
        internal::StructOfStructs_Data::New(buf);
    {auto retval =Serialize_(input->nr.get(),
                 buf,
                 &result->nr.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->nr.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null nr in StructOfStructs struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams a_nr_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->a_nr, buf, &result->a_nr.ptr,
                            &a_nr_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->a_nr.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a_nr in StructOfStructs struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams a_rp_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->a_rp, buf, &result->a_rp.ptr,
                            &a_rp_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->a_rp.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a_rp in StructOfStructs struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams m_ndfv_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->m_ndfv, buf, &result->m_ndfv.ptr,
          &m_ndfv_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->m_ndfv.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null m_ndfv in StructOfStructs struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams m_hs_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->m_hs, buf, &result->m_hs.ptr,
          &m_hs_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->m_hs.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null m_hs in StructOfStructs struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructOfStructs_Data* input,
                  StructOfStructs* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->nr.ptr) {
        result->nr = NamedRegion::New();
        Deserialize_(input->nr.ptr, result->nr.get());
      }
      Deserialize_(input->a_nr.ptr, &result->a_nr);
      Deserialize_(input->a_rp.ptr, &result->a_rp);
      Deserialize_(input->m_ndfv.ptr, &result->m_ndfv);
      Deserialize_(input->m_hs.ptr, &result->m_hs);
    } while (false);
  }
}


size_t NamedRegion::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool NamedRegion::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::NamedRegion_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool NamedRegion::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::NamedRegion_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void NamedRegion::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::NamedRegion_Data* input =
      static_cast<internal::NamedRegion_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const NamedRegion& input) {
  size_t size = sizeof(internal::NamedRegion_Data);
  size += GetSerializedSize_(input.name);
  size += GetSerializedSize_(input.rects);
  return size;
}

mojo::internal::ValidationError Serialize_(
    NamedRegion* input,
    mojo::internal::Buffer* buf,
    internal::NamedRegion_Data** output) {
  if (input) {
    internal::NamedRegion_Data* result =
        internal::NamedRegion_Data::New(buf);
    SerializeString_(input->name, buf, &result->name.ptr);
    {
      const mojo::internal::ArrayValidateParams rects_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->rects, buf, &result->rects.ptr,
                            &rects_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::NamedRegion_Data* input,
                  NamedRegion* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->name.ptr, &result->name);
      Deserialize_(input->rects.ptr, &result->rects);
    } while (false);
  }
}


size_t RectPair::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool RectPair::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::RectPair_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool RectPair::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::RectPair_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void RectPair::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::RectPair_Data* input =
      static_cast<internal::RectPair_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const RectPair& input) {
  size_t size = sizeof(internal::RectPair_Data);
  size += input.first.is_null()
              ? 0
              : GetSerializedSize_(*input.first);
  size += input.second.is_null()
              ? 0
              : GetSerializedSize_(*input.second);
  return size;
}

mojo::internal::ValidationError Serialize_(
    RectPair* input,
    mojo::internal::Buffer* buf,
    internal::RectPair_Data** output) {
  if (input) {
    internal::RectPair_Data* result =
        internal::RectPair_Data::New(buf);
    {auto retval =Serialize_(input->first.get(),
                 buf,
                 &result->first.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->second.get(),
                 buf,
                 &result->second.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::RectPair_Data* input,
                  RectPair* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->first.ptr) {
        result->first = mojo::test::Rect::New();
        Deserialize_(input->first.ptr, result->first.get());
      }
      if (input->second.ptr) {
        result->second = mojo::test::Rect::New();
        Deserialize_(input->second.ptr, result->second.get());
      }
    } while (false);
  }
}


size_t EmptyStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool EmptyStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::EmptyStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool EmptyStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::EmptyStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void EmptyStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::EmptyStruct_Data* input =
      static_cast<internal::EmptyStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const EmptyStruct& input) {
  size_t size = sizeof(internal::EmptyStruct_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    EmptyStruct* input,
    mojo::internal::Buffer* buf,
    internal::EmptyStruct_Data** output) {
  if (input) {
    internal::EmptyStruct_Data* result =
        internal::EmptyStruct_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::EmptyStruct_Data* input,
                  EmptyStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


size_t HandleStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool HandleStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::HandleStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool HandleStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::HandleStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void HandleStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::HandleStruct_Data* input =
      static_cast<internal::HandleStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const HandleStruct& input) {
  size_t size = sizeof(internal::HandleStruct_Data);
  size += GetSerializedSize_(input.array_h);
  return size;
}

mojo::internal::ValidationError Serialize_(
    HandleStruct* input,
    mojo::internal::Buffer* buf,
    internal::HandleStruct_Data** output) {
  if (input) {
    internal::HandleStruct_Data* result =
        internal::HandleStruct_Data::New(buf);
    result->h = input->h.release();
    {
      const mojo::internal::ArrayValidateParams array_h_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->array_h, buf, &result->array_h.ptr,
                            &array_h_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->array_h.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null array_h in HandleStruct struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::HandleStruct_Data* input,
                  HandleStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->h.reset(mojo::internal::FetchAndReset(&input->h));
      Deserialize_(input->array_h.ptr, &result->array_h);
    } while (false);
  }
}


size_t NullableHandleStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool NullableHandleStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::NullableHandleStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool NullableHandleStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::NullableHandleStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void NullableHandleStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::NullableHandleStruct_Data* input =
      static_cast<internal::NullableHandleStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const NullableHandleStruct& input) {
  size_t size = sizeof(internal::NullableHandleStruct_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    NullableHandleStruct* input,
    mojo::internal::Buffer* buf,
    internal::NullableHandleStruct_Data** output) {
  if (input) {
    internal::NullableHandleStruct_Data* result =
        internal::NullableHandleStruct_Data::New(buf);
    result->h = input->h.release();
    result->data = input->data;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::NullableHandleStruct_Data* input,
                  NullableHandleStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->h.reset(mojo::internal::FetchAndReset(&input->h));
      result->data = input->data;
    } while (false);
  }
}


size_t NoDefaultFieldValues::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool NoDefaultFieldValues::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::NoDefaultFieldValues_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool NoDefaultFieldValues::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::NoDefaultFieldValues_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void NoDefaultFieldValues::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::NoDefaultFieldValues_Data* input =
      static_cast<internal::NoDefaultFieldValues_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const NoDefaultFieldValues& input) {
  size_t size = sizeof(internal::NoDefaultFieldValues_Data);
  size += GetSerializedSize_(input.f11);
  size += GetSerializedSize_(input.f12);
  size += GetSerializedSize_(input.f23);
  size += GetSerializedSize_(input.f24);
  size += GetSerializedSize_(input.f25);
  size += GetSerializedSize_(input.f26);
  size += input.f27.is_null()
              ? 0
              : GetSerializedSize_(*input.f27);
  size += input.f28.is_null()
              ? 0
              : GetSerializedSize_(*input.f28);
  return size;
}

mojo::internal::ValidationError Serialize_(
    NoDefaultFieldValues* input,
    mojo::internal::Buffer* buf,
    internal::NoDefaultFieldValues_Data** output) {
  if (input) {
    internal::NoDefaultFieldValues_Data* result =
        internal::NoDefaultFieldValues_Data::New(buf);
    result->f0 = input->f0;
    result->f1 = input->f1;
    result->f2 = input->f2;
    result->f3 = input->f3;
    result->f4 = input->f4;
    result->f5 = input->f5;
    result->f6 = input->f6;
    result->f7 = input->f7;
    result->f8 = input->f8;
    result->f9 = input->f9;
    result->f10 = input->f10;
    SerializeString_(input->f11, buf, &result->f11.ptr);
    if (!result->f11.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f11 in NoDefaultFieldValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    SerializeString_(input->f12, buf, &result->f12.ptr);
    result->f13 = input->f13.release();
    if (!result->f13.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid f13 in NoDefaultFieldValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    result->f14 = input->f14.release();
    if (!result->f14.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid f14 in NoDefaultFieldValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    result->f15 = input->f15.release();
    if (!result->f15.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid f15 in NoDefaultFieldValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    result->f16 = input->f16.release();
    result->f17 = input->f17.release();
    result->f18 = input->f18.release();
    result->f19 = input->f19.release();
    if (!result->f19.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid f19 in NoDefaultFieldValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    result->f20 = input->f20.release();
    result->f21 = input->f21.release();
    if (!result->f21.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid f21 in NoDefaultFieldValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    result->f22 = input->f22.release();
    {
      const mojo::internal::ArrayValidateParams f23_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->f23, buf, &result->f23.ptr,
                            &f23_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f23.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f23 in NoDefaultFieldValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f24_validate_params(
        0, true, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->f24, buf, &result->f24.ptr,
                            &f24_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f24.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f24 in NoDefaultFieldValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f25_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->f25, buf, &result->f25.ptr,
                            &f25_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams f26_validate_params(
        0, true, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->f26, buf, &result->f26.ptr,
                            &f26_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->f27.get(),
                 buf,
                 &result->f27.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f27.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f27 in NoDefaultFieldValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->f28.get(),
                 buf,
                 &result->f28.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::NoDefaultFieldValues_Data* input,
                  NoDefaultFieldValues* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->f0 = input->f0;
      result->f1 = input->f1;
      result->f2 = input->f2;
      result->f3 = input->f3;
      result->f4 = input->f4;
      result->f5 = input->f5;
      result->f6 = input->f6;
      result->f7 = input->f7;
      result->f8 = input->f8;
      result->f9 = input->f9;
      result->f10 = input->f10;
      Deserialize_(input->f11.ptr, &result->f11);
      Deserialize_(input->f12.ptr, &result->f12);
      result->f13.reset(mojo::internal::FetchAndReset(&input->f13));
      result->f14.reset(mojo::internal::FetchAndReset(&input->f14));
      result->f15.reset(mojo::internal::FetchAndReset(&input->f15));
      result->f16.reset(mojo::internal::FetchAndReset(&input->f16));
      result->f17.reset(mojo::internal::FetchAndReset(&input->f17));
      result->f18.reset(mojo::internal::FetchAndReset(&input->f18));
      result->f19.reset(mojo::internal::FetchAndReset(&input->f19));
      result->f20.reset(mojo::internal::FetchAndReset(&input->f20));
      result->f21.reset(mojo::internal::FetchAndReset(&input->f21));
      result->f22.reset(mojo::internal::FetchAndReset(&input->f22));
      Deserialize_(input->f23.ptr, &result->f23);
      Deserialize_(input->f24.ptr, &result->f24);
      Deserialize_(input->f25.ptr, &result->f25);
      Deserialize_(input->f26.ptr, &result->f26);
      if (input->f27.ptr) {
        result->f27 = EmptyStruct::New();
        Deserialize_(input->f27.ptr, result->f27.get());
      }
      if (input->f28.ptr) {
        result->f28 = EmptyStruct::New();
        Deserialize_(input->f28.ptr, result->f28.get());
      }
    } while (false);
  }
}


size_t DefaultFieldValues::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool DefaultFieldValues::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::DefaultFieldValues_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool DefaultFieldValues::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::DefaultFieldValues_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void DefaultFieldValues::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::DefaultFieldValues_Data* input =
      static_cast<internal::DefaultFieldValues_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const DefaultFieldValues& input) {
  size_t size = sizeof(internal::DefaultFieldValues_Data);
  size += GetSerializedSize_(input.f13);
  size += GetSerializedSize_(input.f14);
  size += input.f15.is_null()
              ? 0
              : GetSerializedSize_(*input.f15);
  size += input.f16.is_null()
              ? 0
              : GetSerializedSize_(*input.f16);
  return size;
}

mojo::internal::ValidationError Serialize_(
    DefaultFieldValues* input,
    mojo::internal::Buffer* buf,
    internal::DefaultFieldValues_Data** output) {
  if (input) {
    internal::DefaultFieldValues_Data* result =
        internal::DefaultFieldValues_Data::New(buf);
    result->f0 = input->f0;
    result->f1 = input->f1;
    result->f2 = input->f2;
    result->f3 = input->f3;
    result->f4 = input->f4;
    result->f5 = input->f5;
    result->f6 = input->f6;
    result->f7 = input->f7;
    result->f8 = input->f8;
    result->f9 = input->f9;
    result->f10 = input->f10;
    result->f11 = input->f11;
    result->f12 = input->f12;
    SerializeString_(input->f13, buf, &result->f13.ptr);
    if (!result->f13.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f13 in DefaultFieldValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    SerializeString_(input->f14, buf, &result->f14.ptr);
    {auto retval =Serialize_(input->f15.get(),
                 buf,
                 &result->f15.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f15.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f15 in DefaultFieldValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->f16.get(),
                 buf,
                 &result->f16.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::DefaultFieldValues_Data* input,
                  DefaultFieldValues* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->f0 = input->f0;
      result->f1 = input->f1;
      result->f2 = input->f2;
      result->f3 = input->f3;
      result->f4 = input->f4;
      result->f5 = input->f5;
      result->f6 = input->f6;
      result->f7 = input->f7;
      result->f8 = input->f8;
      result->f9 = input->f9;
      result->f10 = input->f10;
      result->f11 = input->f11;
      result->f12 = input->f12;
      Deserialize_(input->f13.ptr, &result->f13);
      Deserialize_(input->f14.ptr, &result->f14);
      if (input->f15.ptr) {
        result->f15 = mojo::test::Rect::New();
        Deserialize_(input->f15.ptr, result->f15.get());
      }
      if (input->f16.ptr) {
        result->f16 = mojo::test::Rect::New();
        Deserialize_(input->f16.ptr, result->f16.get());
      }
    } while (false);
  }
}


size_t ScopedConstants::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ScopedConstants::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ScopedConstants_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ScopedConstants::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ScopedConstants_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ScopedConstants::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ScopedConstants_Data* input =
      static_cast<internal::ScopedConstants_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ScopedConstants& input) {
  size_t size = sizeof(internal::ScopedConstants_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ScopedConstants* input,
    mojo::internal::Buffer* buf,
    internal::ScopedConstants_Data** output) {
  if (input) {
    internal::ScopedConstants_Data* result =
        internal::ScopedConstants_Data::New(buf);
    result->f0 =
      static_cast<int32_t>(input->f0);
    result->f1 =
      static_cast<int32_t>(input->f1);
    result->f2 =
      static_cast<int32_t>(input->f2);
    result->f3 =
      static_cast<int32_t>(input->f3);
    result->f4 =
      static_cast<int32_t>(input->f4);
    result->f5 = input->f5;
    result->f6 = input->f6;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ScopedConstants_Data* input,
                  ScopedConstants* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->f0 = static_cast<ScopedConstants::EType>(input->f0);
      result->f1 = static_cast<ScopedConstants::EType>(input->f1);
      result->f2 = static_cast<ScopedConstants::EType>(input->f2);
      result->f3 = static_cast<ScopedConstants::EType>(input->f3);
      result->f4 = static_cast<ScopedConstants::EType>(input->f4);
      result->f5 = input->f5;
      result->f6 = input->f6;
    } while (false);
  }
}


size_t MapKeyTypes::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MapKeyTypes::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MapKeyTypes_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MapKeyTypes::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MapKeyTypes_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MapKeyTypes::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MapKeyTypes_Data* input =
      static_cast<internal::MapKeyTypes_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MapKeyTypes& input) {
  size_t size = sizeof(internal::MapKeyTypes_Data);
  size += GetSerializedSize_(input.f0);
  size += GetSerializedSize_(input.f1);
  size += GetSerializedSize_(input.f2);
  size += GetSerializedSize_(input.f3);
  size += GetSerializedSize_(input.f4);
  size += GetSerializedSize_(input.f5);
  size += GetSerializedSize_(input.f6);
  size += GetSerializedSize_(input.f7);
  size += GetSerializedSize_(input.f8);
  size += GetSerializedSize_(input.f9);
  size += GetSerializedSize_(input.f10);
  size += GetSerializedSize_(input.f11);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MapKeyTypes* input,
    mojo::internal::Buffer* buf,
    internal::MapKeyTypes_Data** output) {
  if (input) {
    internal::MapKeyTypes_Data* result =
        internal::MapKeyTypes_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams f0_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->f0, buf, &result->f0.ptr,
          &f0_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f0 in MapKeyTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f1_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->f1, buf, &result->f1.ptr,
          &f1_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f1.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f1 in MapKeyTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f2_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->f2, buf, &result->f2.ptr,
          &f2_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f2.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f2 in MapKeyTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f3_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->f3, buf, &result->f3.ptr,
          &f3_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f3.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f3 in MapKeyTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f4_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->f4, buf, &result->f4.ptr,
          &f4_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f4.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f4 in MapKeyTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f5_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->f5, buf, &result->f5.ptr,
          &f5_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f5.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f5 in MapKeyTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f6_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->f6, buf, &result->f6.ptr,
          &f6_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f6.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f6 in MapKeyTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f7_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->f7, buf, &result->f7.ptr,
          &f7_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f7.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f7 in MapKeyTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f8_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->f8, buf, &result->f8.ptr,
          &f8_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f8.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f8 in MapKeyTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f9_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->f9, buf, &result->f9.ptr,
          &f9_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f9.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f9 in MapKeyTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f10_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->f10, buf, &result->f10.ptr,
          &f10_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f10.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f10 in MapKeyTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f11_validate_params(
          0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeMap_(
          &input->f11, buf, &result->f11.ptr,
          &f11_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f11.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f11 in MapKeyTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MapKeyTypes_Data* input,
                  MapKeyTypes* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->f0.ptr, &result->f0);
      Deserialize_(input->f1.ptr, &result->f1);
      Deserialize_(input->f2.ptr, &result->f2);
      Deserialize_(input->f3.ptr, &result->f3);
      Deserialize_(input->f4.ptr, &result->f4);
      Deserialize_(input->f5.ptr, &result->f5);
      Deserialize_(input->f6.ptr, &result->f6);
      Deserialize_(input->f7.ptr, &result->f7);
      Deserialize_(input->f8.ptr, &result->f8);
      Deserialize_(input->f9.ptr, &result->f9);
      Deserialize_(input->f10.ptr, &result->f10);
      Deserialize_(input->f11.ptr, &result->f11);
    } while (false);
  }
}


size_t MapValueTypes::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MapValueTypes::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MapValueTypes_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MapValueTypes::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MapValueTypes_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MapValueTypes::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MapValueTypes_Data* input =
      static_cast<internal::MapValueTypes_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MapValueTypes& input) {
  size_t size = sizeof(internal::MapValueTypes_Data);
  size += GetSerializedSize_(input.f0);
  size += GetSerializedSize_(input.f1);
  size += GetSerializedSize_(input.f2);
  size += GetSerializedSize_(input.f3);
  size += GetSerializedSize_(input.f4);
  size += GetSerializedSize_(input.f5);
  size += GetSerializedSize_(input.f6);
  size += GetSerializedSize_(input.f7);
  size += GetSerializedSize_(input.f8);
  size += GetSerializedSize_(input.f9);
  size += GetSerializedSize_(input.f10);
  size += GetSerializedSize_(input.f11);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MapValueTypes* input,
    mojo::internal::Buffer* buf,
    internal::MapValueTypes_Data** output) {
  if (input) {
    internal::MapValueTypes_Data* result =
        internal::MapValueTypes_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams f0_validate_params(
          0, false, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr)));auto retval =mojo::SerializeMap_(
          &input->f0, buf, &result->f0.ptr,
          &f0_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f0 in MapValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f1_validate_params(
          0, true, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr)));auto retval =mojo::SerializeMap_(
          &input->f1, buf, &result->f1.ptr,
          &f1_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f1.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f1 in MapValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f2_validate_params(
          0, false, new mojo::internal::ArrayValidateParams(0, true, new mojo::internal::ArrayValidateParams(0, false, nullptr)));auto retval =mojo::SerializeMap_(
          &input->f2, buf, &result->f2.ptr,
          &f2_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f2.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f2 in MapValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f3_validate_params(
          0, false, new mojo::internal::ArrayValidateParams(2, false, new mojo::internal::ArrayValidateParams(0, false, nullptr)));auto retval =mojo::SerializeMap_(
          &input->f3, buf, &result->f3.ptr,
          &f3_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f3.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f3 in MapValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f4_validate_params(
          0, false, new mojo::internal::ArrayValidateParams(0, true, new mojo::internal::ArrayValidateParams(2, false, new mojo::internal::ArrayValidateParams(0, false, nullptr))));auto retval =mojo::SerializeMap_(
          &input->f4, buf, &result->f4.ptr,
          &f4_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f4.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f4 in MapValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f5_validate_params(
          0, false, new mojo::internal::ArrayValidateParams(1, false, new mojo::internal::ArrayValidateParams(2, false, new mojo::internal::ArrayValidateParams(0, false, nullptr))));auto retval =mojo::SerializeMap_(
          &input->f5, buf, &result->f5.ptr,
          &f5_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f5.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f5 in MapValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f6_validate_params(
          0, true, nullptr);auto retval =mojo::SerializeMap_(
          &input->f6, buf, &result->f6.ptr,
          &f6_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f6.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f6 in MapValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f7_validate_params(
          0, false, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr)));auto retval =mojo::SerializeMap_(
          &input->f7, buf, &result->f7.ptr,
          &f7_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f7.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f7 in MapValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f8_validate_params(
          0, false, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr))));auto retval =mojo::SerializeMap_(
          &input->f8, buf, &result->f8.ptr,
          &f8_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f8.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f8 in MapValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f9_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->f9, buf, &result->f9.ptr,
          &f9_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f9.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f9 in MapValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f10_validate_params(
          0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeMap_(
          &input->f10, buf, &result->f10.ptr,
          &f10_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f10.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f10 in MapValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f11_validate_params(
          0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeMap_(
          &input->f11, buf, &result->f11.ptr,
          &f11_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f11.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f11 in MapValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MapValueTypes_Data* input,
                  MapValueTypes* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->f0.ptr, &result->f0);
      Deserialize_(input->f1.ptr, &result->f1);
      Deserialize_(input->f2.ptr, &result->f2);
      Deserialize_(input->f3.ptr, &result->f3);
      Deserialize_(input->f4.ptr, &result->f4);
      Deserialize_(input->f5.ptr, &result->f5);
      Deserialize_(input->f6.ptr, &result->f6);
      Deserialize_(input->f7.ptr, &result->f7);
      Deserialize_(input->f8.ptr, &result->f8);
      Deserialize_(input->f9.ptr, &result->f9);
      Deserialize_(input->f10.ptr, &result->f10);
      Deserialize_(input->f11.ptr, &result->f11);
    } while (false);
  }
}


size_t ArrayValueTypes::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ArrayValueTypes::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ArrayValueTypes_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ArrayValueTypes::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ArrayValueTypes_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ArrayValueTypes::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ArrayValueTypes_Data* input =
      static_cast<internal::ArrayValueTypes_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ArrayValueTypes& input) {
  size_t size = sizeof(internal::ArrayValueTypes_Data);
  size += GetSerializedSize_(input.f0);
  size += GetSerializedSize_(input.f1);
  size += GetSerializedSize_(input.f2);
  size += GetSerializedSize_(input.f3);
  size += GetSerializedSize_(input.f4);
  size += GetSerializedSize_(input.f5);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ArrayValueTypes* input,
    mojo::internal::Buffer* buf,
    internal::ArrayValueTypes_Data** output) {
  if (input) {
    internal::ArrayValueTypes_Data* result =
        internal::ArrayValueTypes_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams f0_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->f0, buf, &result->f0.ptr,
                            &f0_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f0 in ArrayValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f1_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->f1, buf, &result->f1.ptr,
                            &f1_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f1.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f1 in ArrayValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f2_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->f2, buf, &result->f2.ptr,
                            &f2_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f2.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f2 in ArrayValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f3_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->f3, buf, &result->f3.ptr,
                            &f3_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f3.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f3 in ArrayValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f4_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->f4, buf, &result->f4.ptr,
                            &f4_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f4.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f4 in ArrayValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f5_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->f5, buf, &result->f5.ptr,
                            &f5_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f5.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f5 in ArrayValueTypes struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ArrayValueTypes_Data* input,
                  ArrayValueTypes* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->f0.ptr, &result->f0);
      Deserialize_(input->f1.ptr, &result->f1);
      Deserialize_(input->f2.ptr, &result->f2);
      Deserialize_(input->f3.ptr, &result->f3);
      Deserialize_(input->f4.ptr, &result->f4);
      Deserialize_(input->f5.ptr, &result->f5);
    } while (false);
  }
}


size_t FloatNumberValues::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FloatNumberValues::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FloatNumberValues_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FloatNumberValues::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FloatNumberValues_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FloatNumberValues::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FloatNumberValues_Data* input =
      static_cast<internal::FloatNumberValues_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FloatNumberValues& input) {
  size_t size = sizeof(internal::FloatNumberValues_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FloatNumberValues* input,
    mojo::internal::Buffer* buf,
    internal::FloatNumberValues_Data** output) {
  if (input) {
    internal::FloatNumberValues_Data* result =
        internal::FloatNumberValues_Data::New(buf);
    result->f0 = input->f0;
    result->f1 = input->f1;
    result->f2 = input->f2;
    result->f3 = input->f3;
    result->f4 = input->f4;
    result->f5 = input->f5;
    result->f6 = input->f6;
    result->f7 = input->f7;
    result->f8 = input->f8;
    result->f9 = input->f9;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FloatNumberValues_Data* input,
                  FloatNumberValues* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->f0 = input->f0;
      result->f1 = input->f1;
      result->f2 = input->f2;
      result->f3 = input->f3;
      result->f4 = input->f4;
      result->f5 = input->f5;
      result->f6 = input->f6;
      result->f7 = input->f7;
      result->f8 = input->f8;
      result->f9 = input->f9;
    } while (false);
  }
}


size_t IntegerNumberValues::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool IntegerNumberValues::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::IntegerNumberValues_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool IntegerNumberValues::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::IntegerNumberValues_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void IntegerNumberValues::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::IntegerNumberValues_Data* input =
      static_cast<internal::IntegerNumberValues_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const IntegerNumberValues& input) {
  size_t size = sizeof(internal::IntegerNumberValues_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    IntegerNumberValues* input,
    mojo::internal::Buffer* buf,
    internal::IntegerNumberValues_Data** output) {
  if (input) {
    internal::IntegerNumberValues_Data* result =
        internal::IntegerNumberValues_Data::New(buf);
    result->f0 = input->f0;
    result->f1 = input->f1;
    result->f2 = input->f2;
    result->f3 = input->f3;
    result->f4 = input->f4;
    result->f5 = input->f5;
    result->f6 = input->f6;
    result->f7 = input->f7;
    result->f8 = input->f8;
    result->f9 = input->f9;
    result->f10 = input->f10;
    result->f11 = input->f11;
    result->f12 = input->f12;
    result->f13 = input->f13;
    result->f14 = input->f14;
    result->f15 = input->f15;
    result->f16 = input->f16;
    result->f17 = input->f17;
    result->f18 = input->f18;
    result->f19 = input->f19;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::IntegerNumberValues_Data* input,
                  IntegerNumberValues* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->f0 = input->f0;
      result->f1 = input->f1;
      result->f2 = input->f2;
      result->f3 = input->f3;
      result->f4 = input->f4;
      result->f5 = input->f5;
      result->f6 = input->f6;
      result->f7 = input->f7;
      result->f8 = input->f8;
      result->f9 = input->f9;
      result->f10 = input->f10;
      result->f11 = input->f11;
      result->f12 = input->f12;
      result->f13 = input->f13;
      result->f14 = input->f14;
      result->f15 = input->f15;
      result->f16 = input->f16;
      result->f17 = input->f17;
      result->f18 = input->f18;
      result->f19 = input->f19;
    } while (false);
  }
}


size_t UnsignedNumberValues::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool UnsignedNumberValues::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::UnsignedNumberValues_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool UnsignedNumberValues::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::UnsignedNumberValues_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void UnsignedNumberValues::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::UnsignedNumberValues_Data* input =
      static_cast<internal::UnsignedNumberValues_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const UnsignedNumberValues& input) {
  size_t size = sizeof(internal::UnsignedNumberValues_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    UnsignedNumberValues* input,
    mojo::internal::Buffer* buf,
    internal::UnsignedNumberValues_Data** output) {
  if (input) {
    internal::UnsignedNumberValues_Data* result =
        internal::UnsignedNumberValues_Data::New(buf);
    result->f0 = input->f0;
    result->f1 = input->f1;
    result->f2 = input->f2;
    result->f3 = input->f3;
    result->f4 = input->f4;
    result->f5 = input->f5;
    result->f6 = input->f6;
    result->f7 = input->f7;
    result->f8 = input->f8;
    result->f9 = input->f9;
    result->f10 = input->f10;
    result->f11 = input->f11;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::UnsignedNumberValues_Data* input,
                  UnsignedNumberValues* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->f0 = input->f0;
      result->f1 = input->f1;
      result->f2 = input->f2;
      result->f3 = input->f3;
      result->f4 = input->f4;
      result->f5 = input->f5;
      result->f6 = input->f6;
      result->f7 = input->f7;
      result->f8 = input->f8;
      result->f9 = input->f9;
      result->f10 = input->f10;
      result->f11 = input->f11;
    } while (false);
  }
}


size_t BitArrayValues::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool BitArrayValues::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::BitArrayValues_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool BitArrayValues::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::BitArrayValues_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void BitArrayValues::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::BitArrayValues_Data* input =
      static_cast<internal::BitArrayValues_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const BitArrayValues& input) {
  size_t size = sizeof(internal::BitArrayValues_Data);
  size += GetSerializedSize_(input.f0);
  size += GetSerializedSize_(input.f1);
  size += GetSerializedSize_(input.f2);
  size += GetSerializedSize_(input.f3);
  size += GetSerializedSize_(input.f4);
  size += GetSerializedSize_(input.f5);
  size += GetSerializedSize_(input.f6);
  return size;
}

mojo::internal::ValidationError Serialize_(
    BitArrayValues* input,
    mojo::internal::Buffer* buf,
    internal::BitArrayValues_Data** output) {
  if (input) {
    internal::BitArrayValues_Data* result =
        internal::BitArrayValues_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams f0_validate_params(
        1, false, nullptr);auto retval =mojo::SerializeArray_(&input->f0, buf, &result->f0.ptr,
                            &f0_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f0 in BitArrayValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f1_validate_params(
        7, false, nullptr);auto retval =mojo::SerializeArray_(&input->f1, buf, &result->f1.ptr,
                            &f1_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f1.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f1 in BitArrayValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f2_validate_params(
        9, false, nullptr);auto retval =mojo::SerializeArray_(&input->f2, buf, &result->f2.ptr,
                            &f2_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f2.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f2 in BitArrayValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f3_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->f3, buf, &result->f3.ptr,
                            &f3_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f3.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f3 in BitArrayValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f4_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->f4, buf, &result->f4.ptr,
                            &f4_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f4.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f4 in BitArrayValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f5_validate_params(
        0, true, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->f5, buf, &result->f5.ptr,
                            &f5_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f5.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f5 in BitArrayValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams f6_validate_params(
        0, true, new mojo::internal::ArrayValidateParams(2, false, nullptr));auto retval =mojo::SerializeArray_(&input->f6, buf, &result->f6.ptr,
                            &f6_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->f6.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null f6 in BitArrayValues struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::BitArrayValues_Data* input,
                  BitArrayValues* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->f0.ptr, &result->f0);
      Deserialize_(input->f1.ptr, &result->f1);
      Deserialize_(input->f2.ptr, &result->f2);
      Deserialize_(input->f3.ptr, &result->f3);
      Deserialize_(input->f4.ptr, &result->f4);
      Deserialize_(input->f5.ptr, &result->f5);
      Deserialize_(input->f6.ptr, &result->f6);
    } while (false);
  }
}


size_t MultiVersionStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MultiVersionStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MultiVersionStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MultiVersionStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MultiVersionStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MultiVersionStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MultiVersionStruct_Data* input =
      static_cast<internal::MultiVersionStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MultiVersionStruct& input) {
  size_t size = sizeof(internal::MultiVersionStruct_Data);
  size += input.f_rect.is_null()
              ? 0
              : GetSerializedSize_(*input.f_rect);
  size += GetSerializedSize_(input.f_string);
  size += GetSerializedSize_(input.f_array);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MultiVersionStruct* input,
    mojo::internal::Buffer* buf,
    internal::MultiVersionStruct_Data** output) {
  if (input) {
    internal::MultiVersionStruct_Data* result =
        internal::MultiVersionStruct_Data::New(buf);
    result->f_int32 = input->f_int32;
    {auto retval =Serialize_(input->f_rect.get(),
                 buf,
                 &result->f_rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    SerializeString_(input->f_string, buf, &result->f_string.ptr);
    {
      const mojo::internal::ArrayValidateParams f_array_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->f_array, buf, &result->f_array.ptr,
                            &f_array_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    result->f_message_pipe = input->f_message_pipe.release();
    result->f_bool = input->f_bool;
    result->f_int16 = input->f_int16;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MultiVersionStruct_Data* input,
                  MultiVersionStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->f_int32 = input->f_int32;
      if (input->header_.version < 1)
        break;
      if (input->f_rect.ptr) {
        result->f_rect = mojo::test::Rect::New();
        Deserialize_(input->f_rect.ptr, result->f_rect.get());
      }
      if (input->header_.version < 3)
        break;
      Deserialize_(input->f_string.ptr, &result->f_string);
      if (input->header_.version < 5)
        break;
      Deserialize_(input->f_array.ptr, &result->f_array);
      if (input->header_.version < 7)
        break;
      result->f_message_pipe.reset(mojo::internal::FetchAndReset(&input->f_message_pipe));
      result->f_bool = input->f_bool;
      if (input->header_.version < 9)
        break;
      result->f_int16 = input->f_int16;
    } while (false);
  }
}


size_t MultiVersionStructV0::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MultiVersionStructV0::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MultiVersionStructV0_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MultiVersionStructV0::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MultiVersionStructV0_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MultiVersionStructV0::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MultiVersionStructV0_Data* input =
      static_cast<internal::MultiVersionStructV0_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MultiVersionStructV0& input) {
  size_t size = sizeof(internal::MultiVersionStructV0_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MultiVersionStructV0* input,
    mojo::internal::Buffer* buf,
    internal::MultiVersionStructV0_Data** output) {
  if (input) {
    internal::MultiVersionStructV0_Data* result =
        internal::MultiVersionStructV0_Data::New(buf);
    result->f_int32 = input->f_int32;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MultiVersionStructV0_Data* input,
                  MultiVersionStructV0* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->f_int32 = input->f_int32;
    } while (false);
  }
}


size_t MultiVersionStructV1::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MultiVersionStructV1::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MultiVersionStructV1_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MultiVersionStructV1::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MultiVersionStructV1_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MultiVersionStructV1::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MultiVersionStructV1_Data* input =
      static_cast<internal::MultiVersionStructV1_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MultiVersionStructV1& input) {
  size_t size = sizeof(internal::MultiVersionStructV1_Data);
  size += input.f_rect.is_null()
              ? 0
              : GetSerializedSize_(*input.f_rect);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MultiVersionStructV1* input,
    mojo::internal::Buffer* buf,
    internal::MultiVersionStructV1_Data** output) {
  if (input) {
    internal::MultiVersionStructV1_Data* result =
        internal::MultiVersionStructV1_Data::New(buf);
    result->f_int32 = input->f_int32;
    {auto retval =Serialize_(input->f_rect.get(),
                 buf,
                 &result->f_rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MultiVersionStructV1_Data* input,
                  MultiVersionStructV1* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->f_int32 = input->f_int32;
      if (input->header_.version < 1)
        break;
      if (input->f_rect.ptr) {
        result->f_rect = mojo::test::Rect::New();
        Deserialize_(input->f_rect.ptr, result->f_rect.get());
      }
    } while (false);
  }
}


size_t MultiVersionStructV3::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MultiVersionStructV3::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MultiVersionStructV3_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MultiVersionStructV3::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MultiVersionStructV3_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MultiVersionStructV3::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MultiVersionStructV3_Data* input =
      static_cast<internal::MultiVersionStructV3_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MultiVersionStructV3& input) {
  size_t size = sizeof(internal::MultiVersionStructV3_Data);
  size += input.f_rect.is_null()
              ? 0
              : GetSerializedSize_(*input.f_rect);
  size += GetSerializedSize_(input.f_string);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MultiVersionStructV3* input,
    mojo::internal::Buffer* buf,
    internal::MultiVersionStructV3_Data** output) {
  if (input) {
    internal::MultiVersionStructV3_Data* result =
        internal::MultiVersionStructV3_Data::New(buf);
    result->f_int32 = input->f_int32;
    {auto retval =Serialize_(input->f_rect.get(),
                 buf,
                 &result->f_rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    SerializeString_(input->f_string, buf, &result->f_string.ptr);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MultiVersionStructV3_Data* input,
                  MultiVersionStructV3* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->f_int32 = input->f_int32;
      if (input->header_.version < 1)
        break;
      if (input->f_rect.ptr) {
        result->f_rect = mojo::test::Rect::New();
        Deserialize_(input->f_rect.ptr, result->f_rect.get());
      }
      if (input->header_.version < 3)
        break;
      Deserialize_(input->f_string.ptr, &result->f_string);
    } while (false);
  }
}


size_t MultiVersionStructV5::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MultiVersionStructV5::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MultiVersionStructV5_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MultiVersionStructV5::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MultiVersionStructV5_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MultiVersionStructV5::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MultiVersionStructV5_Data* input =
      static_cast<internal::MultiVersionStructV5_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MultiVersionStructV5& input) {
  size_t size = sizeof(internal::MultiVersionStructV5_Data);
  size += input.f_rect.is_null()
              ? 0
              : GetSerializedSize_(*input.f_rect);
  size += GetSerializedSize_(input.f_string);
  size += GetSerializedSize_(input.f_array);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MultiVersionStructV5* input,
    mojo::internal::Buffer* buf,
    internal::MultiVersionStructV5_Data** output) {
  if (input) {
    internal::MultiVersionStructV5_Data* result =
        internal::MultiVersionStructV5_Data::New(buf);
    result->f_int32 = input->f_int32;
    {auto retval =Serialize_(input->f_rect.get(),
                 buf,
                 &result->f_rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    SerializeString_(input->f_string, buf, &result->f_string.ptr);
    {
      const mojo::internal::ArrayValidateParams f_array_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->f_array, buf, &result->f_array.ptr,
                            &f_array_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MultiVersionStructV5_Data* input,
                  MultiVersionStructV5* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->f_int32 = input->f_int32;
      if (input->header_.version < 1)
        break;
      if (input->f_rect.ptr) {
        result->f_rect = mojo::test::Rect::New();
        Deserialize_(input->f_rect.ptr, result->f_rect.get());
      }
      if (input->header_.version < 3)
        break;
      Deserialize_(input->f_string.ptr, &result->f_string);
      if (input->header_.version < 5)
        break;
      Deserialize_(input->f_array.ptr, &result->f_array);
    } while (false);
  }
}


size_t MultiVersionStructV7::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MultiVersionStructV7::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MultiVersionStructV7_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MultiVersionStructV7::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MultiVersionStructV7_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MultiVersionStructV7::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MultiVersionStructV7_Data* input =
      static_cast<internal::MultiVersionStructV7_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MultiVersionStructV7& input) {
  size_t size = sizeof(internal::MultiVersionStructV7_Data);
  size += input.f_rect.is_null()
              ? 0
              : GetSerializedSize_(*input.f_rect);
  size += GetSerializedSize_(input.f_string);
  size += GetSerializedSize_(input.f_array);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MultiVersionStructV7* input,
    mojo::internal::Buffer* buf,
    internal::MultiVersionStructV7_Data** output) {
  if (input) {
    internal::MultiVersionStructV7_Data* result =
        internal::MultiVersionStructV7_Data::New(buf);
    result->f_int32 = input->f_int32;
    {auto retval =Serialize_(input->f_rect.get(),
                 buf,
                 &result->f_rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    SerializeString_(input->f_string, buf, &result->f_string.ptr);
    {
      const mojo::internal::ArrayValidateParams f_array_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->f_array, buf, &result->f_array.ptr,
                            &f_array_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    result->f_message_pipe = input->f_message_pipe.release();
    result->f_bool = input->f_bool;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MultiVersionStructV7_Data* input,
                  MultiVersionStructV7* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->f_int32 = input->f_int32;
      if (input->header_.version < 1)
        break;
      if (input->f_rect.ptr) {
        result->f_rect = mojo::test::Rect::New();
        Deserialize_(input->f_rect.ptr, result->f_rect.get());
      }
      if (input->header_.version < 3)
        break;
      Deserialize_(input->f_string.ptr, &result->f_string);
      if (input->header_.version < 5)
        break;
      Deserialize_(input->f_array.ptr, &result->f_array);
      if (input->header_.version < 7)
        break;
      result->f_message_pipe.reset(mojo::internal::FetchAndReset(&input->f_message_pipe));
      result->f_bool = input->f_bool;
    } while (false);
  }
}


size_t ContainsInterface::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ContainsInterface::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ContainsInterface_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ContainsInterface::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ContainsInterface_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ContainsInterface::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ContainsInterface_Data* input =
      static_cast<internal::ContainsInterface_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ContainsInterface& input) {
  size_t size = sizeof(internal::ContainsInterface_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ContainsInterface* input,
    mojo::internal::Buffer* buf,
    internal::ContainsInterface_Data** output) {
  if (input) {
    internal::ContainsInterface_Data* result =
        internal::ContainsInterface_Data::New(buf);
    mojo::internal::InterfaceHandleToData(input->some_interface.Pass(),
                                          &result->some_interface);
    if (!result->some_interface.handle.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid some_interface in ContainsInterface struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ContainsInterface_Data* input,
                  ContainsInterface* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      mojo::internal::InterfaceDataToHandle(&input->some_interface, &result->some_interface);
    } while (false);
  }
}


size_t ContainsOther::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ContainsOther::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ContainsOther_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ContainsOther::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ContainsOther_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ContainsOther::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ContainsOther_Data* input =
      static_cast<internal::ContainsOther_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ContainsOther& input) {
  size_t size = sizeof(internal::ContainsOther_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ContainsOther* input,
    mojo::internal::Buffer* buf,
    internal::ContainsOther_Data** output) {
  if (input) {
    internal::ContainsOther_Data* result =
        internal::ContainsOther_Data::New(buf);
    result->other = input->other;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ContainsOther_Data* input,
                  ContainsOther* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->other = input->other;
    } while (false);
  }
}


size_t ContainsInterfaceRequest::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ContainsInterfaceRequest::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ContainsInterfaceRequest_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ContainsInterfaceRequest::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ContainsInterfaceRequest_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ContainsInterfaceRequest::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ContainsInterfaceRequest_Data* input =
      static_cast<internal::ContainsInterfaceRequest_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ContainsInterfaceRequest& input) {
  size_t size = sizeof(internal::ContainsInterfaceRequest_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ContainsInterfaceRequest* input,
    mojo::internal::Buffer* buf,
    internal::ContainsInterfaceRequest_Data** output) {
  if (input) {
    internal::ContainsInterfaceRequest_Data* result =
        internal::ContainsInterfaceRequest_Data::New(buf);
    result->req = input->req.PassMessagePipe().release();
    if (!result->req.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid req in ContainsInterfaceRequest struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    result->nullable_req = input->nullable_req.PassMessagePipe().release();
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ContainsInterfaceRequest_Data* input,
                  ContainsInterfaceRequest* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->req.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&input->req)));
      result->nullable_req.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&input->nullable_req)));
    } while (false);
  }
}


size_t DartKeywordStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool DartKeywordStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::DartKeywordStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool DartKeywordStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::DartKeywordStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void DartKeywordStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::DartKeywordStruct_Data* input =
      static_cast<internal::DartKeywordStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const DartKeywordStruct& input) {
  size_t size = sizeof(internal::DartKeywordStruct_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    DartKeywordStruct* input,
    mojo::internal::Buffer* buf,
    internal::DartKeywordStruct_Data** output) {
  if (input) {
    internal::DartKeywordStruct_Data* result =
        internal::DartKeywordStruct_Data::New(buf);
    result->await =
      static_cast<int32_t>(input->await);
    result->is =
      static_cast<int32_t>(input->is);
    result->rethrow =
      static_cast<int32_t>(input->rethrow);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::DartKeywordStruct_Data* input,
                  DartKeywordStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->await = static_cast<DartKeywordStruct::Keywords>(input->await);
      result->is = static_cast<DartKeywordStruct::Keywords>(input->is);
      result->rethrow = static_cast<DartKeywordStruct::Keywords>(input->rethrow);
    } while (false);
  }
}


// --- Union Serialization Helpers ---

size_t GetSerializedSize_(const UnionOfStructsPtr& input) {
   size_t size = sizeof(internal::UnionOfStructs_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<UnionOfStructs> input_acc(input.get());
  switch (input->which()) {


    case UnionOfStructs::Tag::NR:

      size += GetSerializedSize_(*(input_acc.data()->nr->get()));

      break;

    case UnionOfStructs::Tag::A_NR:

      size += GetSerializedSize_(*(input_acc.data()->a_nr));

      break;

    case UnionOfStructs::Tag::A_RP:

      size += GetSerializedSize_(*(input_acc.data()->a_rp));

      break;

    case UnionOfStructs::Tag::M_NDFV:

      size += GetSerializedSize_(*(input_acc.data()->m_ndfv));

      break;

    case UnionOfStructs::Tag::M_HS:

      size += GetSerializedSize_(*(input_acc.data()->m_hs));

      break;
    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    UnionOfStructs* input,
    mojo::internal::Buffer* buf,
    internal::UnionOfStructs_Data** output) {
  internal::UnionOfStructs_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<UnionOfStructs> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case UnionOfStructs::Tag::NR: {


          {auto retval =Serialize_(input_acc.data()->nr->get(),
                     buf,
                     &result->data.f_nr.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case UnionOfStructs::Tag::A_NR: {


          {
          const mojo::internal::ArrayValidateParams a_nr_validate_params(
            0, false, nullptr);auto retval =mojo::SerializeArray_(input_acc.data()->a_nr, buf, &result->data.f_a_nr.ptr,
                                &a_nr_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case UnionOfStructs::Tag::A_RP: {


          {
          const mojo::internal::ArrayValidateParams a_rp_validate_params(
            0, false, nullptr);auto retval =mojo::SerializeArray_(input_acc.data()->a_rp, buf, &result->data.f_a_rp.ptr,
                                &a_rp_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case UnionOfStructs::Tag::M_NDFV: {


          {
          const mojo::internal::ArrayValidateParams m_ndfv_validate_params(
              0, false, nullptr);auto retval =mojo::SerializeMap_(
              input_acc.data()->m_ndfv, buf, &result->data.f_m_ndfv.ptr,
              &m_ndfv_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }

        break;
      }
      case UnionOfStructs::Tag::M_HS: {


          {
          const mojo::internal::ArrayValidateParams m_hs_validate_params(
              0, false, nullptr);auto retval =mojo::SerializeMap_(
              input_acc.data()->m_hs, buf, &result->data.f_m_hs.ptr,
              &m_hs_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }

        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::UnionOfStructs_Data* input,
                  UnionOfStructs* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<UnionOfStructs> result_acc(output);
    switch (input->tag) {

      case UnionOfStructs::Tag::NR: {

        result_acc.SwitchActive(UnionOfStructs::Tag::NR);

        *result_acc.data()->nr =
            NamedRegion::New();
        Deserialize_(input->data.f_nr.ptr,
            result_acc.data()->nr->get());


        break;
      }
      case UnionOfStructs::Tag::A_NR: {

        result_acc.SwitchActive(UnionOfStructs::Tag::A_NR);

        Deserialize_(input->data.f_a_nr.ptr, result_acc.data()->a_nr);


        break;
      }
      case UnionOfStructs::Tag::A_RP: {

        result_acc.SwitchActive(UnionOfStructs::Tag::A_RP);

        Deserialize_(input->data.f_a_rp.ptr, result_acc.data()->a_rp);


        break;
      }
      case UnionOfStructs::Tag::M_NDFV: {

        result_acc.SwitchActive(UnionOfStructs::Tag::M_NDFV);

        Deserialize_(input->data.f_m_ndfv.ptr, result_acc.data()->m_ndfv);


        break;
      }
      case UnionOfStructs::Tag::M_HS: {

        result_acc.SwitchActive(UnionOfStructs::Tag::M_HS);

        Deserialize_(input->data.f_m_hs.ptr, result_acc.data()->m_hs);


        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing UnionOfStructs with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


// --- Structs for interface method parameters ---


// static
SomeInterface_SomeMethod_ParamsPtr SomeInterface_SomeMethod_Params::New() {
  SomeInterface_SomeMethod_ParamsPtr rv;
  mojo::internal::StructHelper<SomeInterface_SomeMethod_Params>::Initialize(&rv);
  return rv;
}

SomeInterface_SomeMethod_Params::SomeInterface_SomeMethod_Params()
    : pair() {
}

SomeInterface_SomeMethod_Params::~SomeInterface_SomeMethod_Params() {
}


SomeInterface_SomeMethod_ParamsPtr SomeInterface_SomeMethod_Params::Clone() const {
  SomeInterface_SomeMethod_ParamsPtr rv(New());
  rv->pair = pair.Clone();
  return rv;
}


bool SomeInterface_SomeMethod_Params::Equals(const SomeInterface_SomeMethod_Params& other) const {
  if (!mojo::internal::ValueTraits<RectPairPtr>::Equals(this->pair, other.pair))
    return false;
  return true;
}


size_t SomeInterface_SomeMethod_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool SomeInterface_SomeMethod_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::SomeInterface_SomeMethod_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool SomeInterface_SomeMethod_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::SomeInterface_SomeMethod_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void SomeInterface_SomeMethod_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::SomeInterface_SomeMethod_Params_Data* input =
      static_cast<internal::SomeInterface_SomeMethod_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const SomeInterface_SomeMethod_Params& input) {
  size_t size = sizeof(internal::SomeInterface_SomeMethod_Params_Data);
  size += input.pair.is_null()
              ? 0
              : GetSerializedSize_(*input.pair);
  return size;
}

mojo::internal::ValidationError Serialize_(
    SomeInterface_SomeMethod_Params* input,
    mojo::internal::Buffer* buf,
    internal::SomeInterface_SomeMethod_Params_Data** output) {
  if (input) {
    internal::SomeInterface_SomeMethod_Params_Data* result =
        internal::SomeInterface_SomeMethod_Params_Data::New(buf);
    {auto retval =Serialize_(input->pair.get(),
                 buf,
                 &result->pair.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->pair.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null pair in SomeInterface_SomeMethod_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::SomeInterface_SomeMethod_Params_Data* input,
                  SomeInterface_SomeMethod_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->pair.ptr) {
        result->pair = RectPair::New();
        Deserialize_(input->pair.ptr, result->pair.get());
      }
    } while (false);
  }
}


// static
SomeInterface_SomeMethod_ResponseParamsPtr SomeInterface_SomeMethod_ResponseParams::New() {
  SomeInterface_SomeMethod_ResponseParamsPtr rv;
  mojo::internal::StructHelper<SomeInterface_SomeMethod_ResponseParams>::Initialize(&rv);
  return rv;
}

SomeInterface_SomeMethod_ResponseParams::SomeInterface_SomeMethod_ResponseParams()
    : other_pair() {
}

SomeInterface_SomeMethod_ResponseParams::~SomeInterface_SomeMethod_ResponseParams() {
}


SomeInterface_SomeMethod_ResponseParamsPtr SomeInterface_SomeMethod_ResponseParams::Clone() const {
  SomeInterface_SomeMethod_ResponseParamsPtr rv(New());
  rv->other_pair = other_pair.Clone();
  return rv;
}


bool SomeInterface_SomeMethod_ResponseParams::Equals(const SomeInterface_SomeMethod_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<RectPairPtr>::Equals(this->other_pair, other.other_pair))
    return false;
  return true;
}


size_t SomeInterface_SomeMethod_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool SomeInterface_SomeMethod_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::SomeInterface_SomeMethod_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool SomeInterface_SomeMethod_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::SomeInterface_SomeMethod_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void SomeInterface_SomeMethod_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::SomeInterface_SomeMethod_ResponseParams_Data* input =
      static_cast<internal::SomeInterface_SomeMethod_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const SomeInterface_SomeMethod_ResponseParams& input) {
  size_t size = sizeof(internal::SomeInterface_SomeMethod_ResponseParams_Data);
  size += input.other_pair.is_null()
              ? 0
              : GetSerializedSize_(*input.other_pair);
  return size;
}

mojo::internal::ValidationError Serialize_(
    SomeInterface_SomeMethod_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::SomeInterface_SomeMethod_ResponseParams_Data** output) {
  if (input) {
    internal::SomeInterface_SomeMethod_ResponseParams_Data* result =
        internal::SomeInterface_SomeMethod_ResponseParams_Data::New(buf);
    {auto retval =Serialize_(input->other_pair.get(),
                 buf,
                 &result->other_pair.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->other_pair.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null other_pair in SomeInterface_SomeMethod_ResponseParams struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::SomeInterface_SomeMethod_ResponseParams_Data* input,
                  SomeInterface_SomeMethod_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->other_pair.ptr) {
        result->other_pair = RectPair::New();
        Deserialize_(input->other_pair.ptr, result->other_pair.get());
      }
    } while (false);
  }
}

}  // namespace test
}  // namespace mojo
