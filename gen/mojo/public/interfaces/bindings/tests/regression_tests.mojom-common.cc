// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/public/interfaces/bindings/tests/regression_tests.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace regression_tests {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// static
Edge_Data* Edge_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Edge_Data))) Edge_Data();
}

// static
mojo::internal::ValidationError Edge_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Edge_Data* object = static_cast<const Edge_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->v.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = Vertex::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->v.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Edge_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->v, handles);
}

void Edge_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->v, handles);
}

Edge_Data::Edge_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
Vertex_Data* Vertex_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Vertex_Data))) Vertex_Data();
}

// static
mojo::internal::ValidationError Vertex_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Vertex_Data* object = static_cast<const Vertex_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->e.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = EmptyStruct::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->e.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Vertex_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->e, handles);
}

void Vertex_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->e, handles);
}

Vertex_Data::Vertex_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
EmptyStruct_Data* EmptyStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(EmptyStruct_Data))) EmptyStruct_Data();
}

// static
mojo::internal::ValidationError EmptyStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const EmptyStruct_Data* object = static_cast<const EmptyStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void EmptyStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void EmptyStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

EmptyStruct_Data::EmptyStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
A_Data* A_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(A_Data))) A_Data();
}

// static
mojo::internal::ValidationError A_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const A_Data* object = static_cast<const A_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->b.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = B::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->b.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void A_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->b, handles);
}

void A_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->b, handles);
}

A_Data::A_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
B_Data* B_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(B_Data))) B_Data();
}

// static
mojo::internal::ValidationError B_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const B_Data* object = static_cast<const B_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->a.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = A::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->a.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void B_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->a, handles);
}

void B_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->a, handles);
}

B_Data::B_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructWithHandleCalledHandles_Data* StructWithHandleCalledHandles_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructWithHandleCalledHandles_Data))) StructWithHandleCalledHandles_Data();
}

// static
mojo::internal::ValidationError StructWithHandleCalledHandles_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructWithHandleCalledHandles_Data* object = static_cast<const StructWithHandleCalledHandles_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle handles_handle = object->handles;
  if (handles_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid handles field in StructWithHandleCalledHandles struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(handles_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructWithHandleCalledHandles_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->handles, handles);
}

void StructWithHandleCalledHandles_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->handles, handles);
}

StructWithHandleCalledHandles_Data::StructWithHandleCalledHandles_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructWithArrayOfHandlesCalledHandles_Data* StructWithArrayOfHandlesCalledHandles_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructWithArrayOfHandlesCalledHandles_Data))) StructWithArrayOfHandlesCalledHandles_Data();
}

// static
mojo::internal::ValidationError StructWithArrayOfHandlesCalledHandles_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructWithArrayOfHandlesCalledHandles_Data* object = static_cast<const StructWithArrayOfHandlesCalledHandles_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->handles.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null handles field in StructWithArrayOfHandlesCalledHandles struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->handles.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams handles_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<mojo::ScopedHandle>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->handles.offset),
          bounds_checker, &handles_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructWithArrayOfHandlesCalledHandles_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->handles, handles);
}

void StructWithArrayOfHandlesCalledHandles_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->handles, handles);
}

StructWithArrayOfHandlesCalledHandles_Data::StructWithArrayOfHandlesCalledHandles_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructWithInterfaceCalledHandles_Data* StructWithInterfaceCalledHandles_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructWithInterfaceCalledHandles_Data))) StructWithInterfaceCalledHandles_Data();
}

// static
mojo::internal::ValidationError StructWithInterfaceCalledHandles_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructWithInterfaceCalledHandles_Data* object = static_cast<const StructWithInterfaceCalledHandles_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle handles_handle = object->handles.handle;
  if (handles_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid handles field in StructWithInterfaceCalledHandles struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(handles_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructWithInterfaceCalledHandles_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->handles, handles);
}

void StructWithInterfaceCalledHandles_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->handles, handles);
}

StructWithInterfaceCalledHandles_Data::StructWithInterfaceCalledHandles_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
ContainsArrayOfEnum_Data* ContainsArrayOfEnum_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ContainsArrayOfEnum_Data))) ContainsArrayOfEnum_Data();
}

// static
mojo::internal::ValidationError ContainsArrayOfEnum_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ContainsArrayOfEnum_Data* object = static_cast<const ContainsArrayOfEnum_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->array_of_enums.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null array_of_enums field in ContainsArrayOfEnum struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->array_of_enums.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams array_of_enums_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<NormalEnum>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->array_of_enums.offset),
          bounds_checker, &array_of_enums_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ContainsArrayOfEnum_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->array_of_enums, handles);
}

void ContainsArrayOfEnum_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->array_of_enums, handles);
}

ContainsArrayOfEnum_Data::ContainsArrayOfEnum_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// --- Union definitions ---


// --- Definitions of the data structs for interface methods ---


// static
CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data* CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data))) CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data();
}

// static
mojo::internal::ValidationError CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data* object = static_cast<const CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data* CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data))) CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data();
}

// static
mojo::internal::ValidationError CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data* object = static_cast<const CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data* CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data))) CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data();
}

// static
mojo::internal::ValidationError CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data* object = static_cast<const CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data* CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data))) CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data();
}

// static
mojo::internal::ValidationError CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data* object = static_cast<const CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
CheckNameCollision_WithNameCollision_Params_Data* CheckNameCollision_WithNameCollision_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(CheckNameCollision_WithNameCollision_Params_Data))) CheckNameCollision_WithNameCollision_Params_Data();
}

// static
mojo::internal::ValidationError CheckNameCollision_WithNameCollision_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const CheckNameCollision_WithNameCollision_Params_Data* object = static_cast<const CheckNameCollision_WithNameCollision_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void CheckNameCollision_WithNameCollision_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void CheckNameCollision_WithNameCollision_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

CheckNameCollision_WithNameCollision_Params_Data::CheckNameCollision_WithNameCollision_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
CheckNameCollision_WithNameCollision_ResponseParams_Data* CheckNameCollision_WithNameCollision_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(CheckNameCollision_WithNameCollision_ResponseParams_Data))) CheckNameCollision_WithNameCollision_ResponseParams_Data();
}

// static
mojo::internal::ValidationError CheckNameCollision_WithNameCollision_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const CheckNameCollision_WithNameCollision_ResponseParams_Data* object = static_cast<const CheckNameCollision_WithNameCollision_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void CheckNameCollision_WithNameCollision_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void CheckNameCollision_WithNameCollision_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

CheckNameCollision_WithNameCollision_ResponseParams_Data::CheckNameCollision_WithNameCollision_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data* CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data))) CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data();
}

// static
mojo::internal::ValidationError CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data* object = static_cast<const CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
TestInterface_SomeMessage_Params_Data* TestInterface_SomeMessage_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(TestInterface_SomeMessage_Params_Data))) TestInterface_SomeMessage_Params_Data();
}

// static
mojo::internal::ValidationError TestInterface_SomeMessage_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const TestInterface_SomeMessage_Params_Data* object = static_cast<const TestInterface_SomeMessage_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void TestInterface_SomeMessage_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void TestInterface_SomeMessage_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

TestInterface_SomeMessage_Params_Data::TestInterface_SomeMessage_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
Regression551_Get_Params_Data* Regression551_Get_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Regression551_Get_Params_Data))) Regression551_Get_Params_Data();
}

// static
mojo::internal::ValidationError Regression551_Get_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Regression551_Get_Params_Data* object = static_cast<const Regression551_Get_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->key_prefixes.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null key_prefixes field in Regression551_Get_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->key_prefixes.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams key_prefixes_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->key_prefixes.offset),
          bounds_checker, &key_prefixes_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Regression551_Get_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->key_prefixes, handles);
}

void Regression551_Get_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->key_prefixes, handles);
}

Regression551_Get_Params_Data::Regression551_Get_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
Regression551_Get_ResponseParams_Data* Regression551_Get_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Regression551_Get_ResponseParams_Data))) Regression551_Get_ResponseParams_Data();
}

// static
mojo::internal::ValidationError Regression551_Get_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Regression551_Get_ResponseParams_Data* object = static_cast<const Regression551_Get_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void Regression551_Get_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void Regression551_Get_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

Regression551_Get_ResponseParams_Data::Regression551_Get_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ServiceName_serviceName_Params_Data* ServiceName_serviceName_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ServiceName_serviceName_Params_Data))) ServiceName_serviceName_Params_Data();
}

// static
mojo::internal::ValidationError ServiceName_serviceName_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ServiceName_serviceName_Params_Data* object = static_cast<const ServiceName_serviceName_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void ServiceName_serviceName_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void ServiceName_serviceName_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

ServiceName_serviceName_Params_Data::ServiceName_serviceName_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
ServiceName_serviceName_ResponseParams_Data* ServiceName_serviceName_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ServiceName_serviceName_ResponseParams_Data))) ServiceName_serviceName_ResponseParams_Data();
}

// static
mojo::internal::ValidationError ServiceName_serviceName_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ServiceName_serviceName_ResponseParams_Data* object = static_cast<const ServiceName_serviceName_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->serviceName.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null serviceName field in ServiceName_serviceName_ResponseParams struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->serviceName.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams serviceName_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->serviceName.offset),
          bounds_checker, &serviceName_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ServiceName_serviceName_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->serviceName, handles);
}

void ServiceName_serviceName_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->serviceName, handles);
}

ServiceName_serviceName_ResponseParams_Data::ServiceName_serviceName_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


}  // namespace internal

// --- Request and response validator definitions for interfaces ---
mojo::internal::ValidationError CheckMethodWithEmptyResponseRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'CheckMethodWithEmptyResponse', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::CheckMethodWithEmptyResponse_Base::MessageOrdinals method_ordinal =
      static_cast<internal::CheckMethodWithEmptyResponse_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::CheckMethodWithEmptyResponse_Base::MessageOrdinals::WithoutParameterAndEmptyResponse: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'CheckMethodWithEmptyResponse', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'CheckMethodWithEmptyResponse', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::CheckMethodWithEmptyResponse_Base::MessageOrdinals::WithParameterAndEmptyResponse: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'CheckMethodWithEmptyResponse', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'CheckMethodWithEmptyResponse', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'CheckMethodWithEmptyResponse'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError CheckMethodWithEmptyResponseResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'CheckMethodWithEmptyResponse', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'CheckMethodWithEmptyResponse', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::CheckMethodWithEmptyResponse_Base::MessageOrdinals method_ordinal =
      static_cast<internal::CheckMethodWithEmptyResponse_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::CheckMethodWithEmptyResponse_Base::MessageOrdinals::WithoutParameterAndEmptyResponse: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'CheckMethodWithEmptyResponse',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::CheckMethodWithEmptyResponse_Base::MessageOrdinals::WithParameterAndEmptyResponse: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'CheckMethodWithEmptyResponse',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'CheckMethodWithEmptyResponse'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError CheckNameCollisionRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'CheckNameCollision', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::CheckNameCollision_Base::MessageOrdinals method_ordinal =
      static_cast<internal::CheckNameCollision_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::CheckNameCollision_Base::MessageOrdinals::WithNameCollision: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'CheckNameCollision', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::CheckNameCollision_WithNameCollision_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'CheckNameCollision', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'CheckNameCollision'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError CheckNameCollisionResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'CheckNameCollision', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'CheckNameCollision', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::CheckNameCollision_Base::MessageOrdinals method_ordinal =
      static_cast<internal::CheckNameCollision_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::CheckNameCollision_Base::MessageOrdinals::WithNameCollision: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::CheckNameCollision_WithNameCollision_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'CheckNameCollision',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'CheckNameCollision'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError CheckEnumCapsRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'CheckEnumCaps', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::CheckEnumCaps_Base::MessageOrdinals method_ordinal =
      static_cast<internal::CheckEnumCaps_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::CheckEnumCaps_Base::MessageOrdinals::SetEnumWithINTERNALAllCaps: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'CheckEnumCaps', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'CheckEnumCaps', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'CheckEnumCaps'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError TestInterfaceRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'TestInterface', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::TestInterface_Base::MessageOrdinals method_ordinal =
      static_cast<internal::TestInterface_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::TestInterface_Base::MessageOrdinals::SomeMessage: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'TestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::TestInterface_SomeMessage_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'TestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'TestInterface'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError Regression551RequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'Regression551', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::Regression551_Base::MessageOrdinals method_ordinal =
      static_cast<internal::Regression551_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::Regression551_Base::MessageOrdinals::Get: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'Regression551', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::Regression551_Get_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'Regression551', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'Regression551'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError Regression551ResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'Regression551', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'Regression551', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::Regression551_Base::MessageOrdinals method_ordinal =
      static_cast<internal::Regression551_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::Regression551_Base::MessageOrdinals::Get: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::Regression551_Get_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'Regression551',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'Regression551'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError ServiceNameRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'ServiceName', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::ServiceName_Base::MessageOrdinals method_ordinal =
      static_cast<internal::ServiceName_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::ServiceName_Base::MessageOrdinals::serviceName: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ServiceName', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ServiceName_serviceName_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ServiceName', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'ServiceName'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError ServiceNameResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'ServiceName', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'ServiceName', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::ServiceName_Base::MessageOrdinals method_ordinal =
      static_cast<internal::ServiceName_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::ServiceName_Base::MessageOrdinals::serviceName: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::ServiceName_serviceName_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'ServiceName',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'ServiceName'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
} 

// --- Enums ---
bool EnumWithReference_IsValidValue(EnumWithReference value) {
  switch (static_cast<int32_t>(value)) {
    case 30:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const EnumWithReference& val) {
  return (stream << static_cast<int32_t>(val));
}
bool EnumWithLowercase_IsValidValue(EnumWithLowercase value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const EnumWithLowercase& val) {
  return (stream << static_cast<int32_t>(val));
}
bool EnumWithNumbers_IsValidValue(EnumWithNumbers value) {
  switch (static_cast<int32_t>(value)) {
    case 4:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const EnumWithNumbers& val) {
  return (stream << static_cast<int32_t>(val));
}
bool EnumWithK_IsValidValue(EnumWithK value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const EnumWithK& val) {
  return (stream << static_cast<int32_t>(val));
}
bool EnumWithINTERNALAllCaps_IsValidValue(EnumWithINTERNALAllCaps value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const EnumWithINTERNALAllCaps& val) {
  return (stream << static_cast<int32_t>(val));
}
bool NormalEnum_IsValidValue(NormalEnum value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const NormalEnum& val) {
  return (stream << static_cast<int32_t>(val));
}
bool CamelCaseTestEnum_IsValidValue(CamelCaseTestEnum value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const CamelCaseTestEnum& val) {
  return (stream << static_cast<int32_t>(val));
}

// Base interface definitions (Name_, Version_, Constants, Enums)
const uint32_t internal::CheckMethodWithEmptyResponse_Base::Version_;

// Constants

// Enums
const uint32_t internal::CheckNameCollision_Base::Version_;

// Constants

// Enums
const uint32_t internal::CheckEnumCaps_Base::Version_;

// Constants

// Enums
const uint32_t internal::TestInterface_Base::Version_;

// Constants

// Enums
const uint32_t internal::Regression551_Base::Version_;

// Constants

// Enums
const uint32_t internal::ServiceName_Base::Version_;

// Constants

// Enums

// Struct Constants

// --- Struct builder definitions ---

// static
EdgePtr Edge::New() {
  EdgePtr rv;
  mojo::internal::StructHelper<Edge>::Initialize(&rv);
  return rv;
}

Edge::Edge()
    : v() {
}

Edge::~Edge() {
}


EdgePtr Edge::Clone() const {
  EdgePtr rv(New());
  rv->v = v.Clone();
  return rv;
}


bool Edge::Equals(const Edge& other) const {
  if (!mojo::internal::ValueTraits<VertexPtr>::Equals(this->v, other.v))
    return false;
  return true;
}


// static
VertexPtr Vertex::New() {
  VertexPtr rv;
  mojo::internal::StructHelper<Vertex>::Initialize(&rv);
  return rv;
}

Vertex::Vertex()
    : e() {
}

Vertex::~Vertex() {
}


VertexPtr Vertex::Clone() const {
  VertexPtr rv(New());
  rv->e = e.Clone();
  return rv;
}


bool Vertex::Equals(const Vertex& other) const {
  if (!mojo::internal::ValueTraits<EmptyStructPtr>::Equals(this->e, other.e))
    return false;
  return true;
}


// static
EmptyStructPtr EmptyStruct::New() {
  EmptyStructPtr rv;
  mojo::internal::StructHelper<EmptyStruct>::Initialize(&rv);
  return rv;
}

EmptyStruct::EmptyStruct() {
}

EmptyStruct::~EmptyStruct() {
}


EmptyStructPtr EmptyStruct::Clone() const {
  EmptyStructPtr rv(New());
  return rv;
}


bool EmptyStruct::Equals(const EmptyStruct& other) const {
  return true;
}


// static
APtr A::New() {
  APtr rv;
  mojo::internal::StructHelper<A>::Initialize(&rv);
  return rv;
}

A::A()
    : b() {
}

A::~A() {
}


APtr A::Clone() const {
  APtr rv(New());
  rv->b = b.Clone();
  return rv;
}


bool A::Equals(const A& other) const {
  if (!mojo::internal::ValueTraits<BPtr>::Equals(this->b, other.b))
    return false;
  return true;
}


// static
BPtr B::New() {
  BPtr rv;
  mojo::internal::StructHelper<B>::Initialize(&rv);
  return rv;
}

B::B()
    : a() {
}

B::~B() {
}


BPtr B::Clone() const {
  BPtr rv(New());
  rv->a = a.Clone();
  return rv;
}


bool B::Equals(const B& other) const {
  if (!mojo::internal::ValueTraits<APtr>::Equals(this->a, other.a))
    return false;
  return true;
}


// static
StructWithHandleCalledHandlesPtr StructWithHandleCalledHandles::New() {
  StructWithHandleCalledHandlesPtr rv;
  mojo::internal::StructHelper<StructWithHandleCalledHandles>::Initialize(&rv);
  return rv;
}

StructWithHandleCalledHandles::StructWithHandleCalledHandles()
    : handles() {
}

StructWithHandleCalledHandles::~StructWithHandleCalledHandles() {
}



bool StructWithHandleCalledHandles::Equals(const StructWithHandleCalledHandles& other) const {
  if (!mojo::internal::ValueTraits<mojo::ScopedHandle>::Equals(this->handles, other.handles))
    return false;
  return true;
}


// static
StructWithArrayOfHandlesCalledHandlesPtr StructWithArrayOfHandlesCalledHandles::New() {
  StructWithArrayOfHandlesCalledHandlesPtr rv;
  mojo::internal::StructHelper<StructWithArrayOfHandlesCalledHandles>::Initialize(&rv);
  return rv;
}

StructWithArrayOfHandlesCalledHandles::StructWithArrayOfHandlesCalledHandles()
    : handles() {
}

StructWithArrayOfHandlesCalledHandles::~StructWithArrayOfHandlesCalledHandles() {
}



bool StructWithArrayOfHandlesCalledHandles::Equals(const StructWithArrayOfHandlesCalledHandles& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::ScopedHandle>>::Equals(this->handles, other.handles))
    return false;
  return true;
}


// static
StructWithInterfaceCalledHandlesPtr StructWithInterfaceCalledHandles::New() {
  StructWithInterfaceCalledHandlesPtr rv;
  mojo::internal::StructHelper<StructWithInterfaceCalledHandles>::Initialize(&rv);
  return rv;
}

StructWithInterfaceCalledHandles::StructWithInterfaceCalledHandles()
    : handles() {
}

StructWithInterfaceCalledHandles::~StructWithInterfaceCalledHandles() {
}



bool StructWithInterfaceCalledHandles::Equals(const StructWithInterfaceCalledHandles& other) const {
  if (!mojo::internal::ValueTraits<mojo::InterfaceHandle<TestInterface>>::Equals(this->handles, other.handles))
    return false;
  return true;
}


// static
ContainsArrayOfEnumPtr ContainsArrayOfEnum::New() {
  ContainsArrayOfEnumPtr rv;
  mojo::internal::StructHelper<ContainsArrayOfEnum>::Initialize(&rv);
  return rv;
}

ContainsArrayOfEnum::ContainsArrayOfEnum()
    : array_of_enums() {
}

ContainsArrayOfEnum::~ContainsArrayOfEnum() {
}


ContainsArrayOfEnumPtr ContainsArrayOfEnum::Clone() const {
  ContainsArrayOfEnumPtr rv(New());
  rv->array_of_enums = array_of_enums.Clone();
  return rv;
}


bool ContainsArrayOfEnum::Equals(const ContainsArrayOfEnum& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<NormalEnum>>::Equals(this->array_of_enums, other.array_of_enums))
    return false;
  return true;
}


// --- Union builder definitions ---

// --- Struct Serialization Helpers ---

size_t Edge::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Edge::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Edge_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Edge::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Edge_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Edge::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Edge_Data* input =
      static_cast<internal::Edge_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Edge& input) {
  size_t size = sizeof(internal::Edge_Data);
  size += input.v.is_null()
              ? 0
              : GetSerializedSize_(*input.v);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Edge* input,
    mojo::internal::Buffer* buf,
    internal::Edge_Data** output) {
  if (input) {
    internal::Edge_Data* result =
        internal::Edge_Data::New(buf);
    {auto retval =Serialize_(input->v.get(),
                 buf,
                 &result->v.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Edge_Data* input,
                  Edge* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->v.ptr) {
        result->v = Vertex::New();
        Deserialize_(input->v.ptr, result->v.get());
      }
    } while (false);
  }
}


size_t Vertex::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Vertex::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Vertex_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Vertex::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Vertex_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Vertex::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Vertex_Data* input =
      static_cast<internal::Vertex_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Vertex& input) {
  size_t size = sizeof(internal::Vertex_Data);
  size += input.e.is_null()
              ? 0
              : GetSerializedSize_(*input.e);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Vertex* input,
    mojo::internal::Buffer* buf,
    internal::Vertex_Data** output) {
  if (input) {
    internal::Vertex_Data* result =
        internal::Vertex_Data::New(buf);
    {auto retval =Serialize_(input->e.get(),
                 buf,
                 &result->e.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Vertex_Data* input,
                  Vertex* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->e.ptr) {
        result->e = EmptyStruct::New();
        Deserialize_(input->e.ptr, result->e.get());
      }
    } while (false);
  }
}


size_t EmptyStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool EmptyStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::EmptyStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool EmptyStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::EmptyStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void EmptyStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::EmptyStruct_Data* input =
      static_cast<internal::EmptyStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const EmptyStruct& input) {
  size_t size = sizeof(internal::EmptyStruct_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    EmptyStruct* input,
    mojo::internal::Buffer* buf,
    internal::EmptyStruct_Data** output) {
  if (input) {
    internal::EmptyStruct_Data* result =
        internal::EmptyStruct_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::EmptyStruct_Data* input,
                  EmptyStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


size_t A::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool A::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::A_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool A::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::A_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void A::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::A_Data* input =
      static_cast<internal::A_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const A& input) {
  size_t size = sizeof(internal::A_Data);
  size += input.b.is_null()
              ? 0
              : GetSerializedSize_(*input.b);
  return size;
}

mojo::internal::ValidationError Serialize_(
    A* input,
    mojo::internal::Buffer* buf,
    internal::A_Data** output) {
  if (input) {
    internal::A_Data* result =
        internal::A_Data::New(buf);
    {auto retval =Serialize_(input->b.get(),
                 buf,
                 &result->b.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::A_Data* input,
                  A* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->b.ptr) {
        result->b = B::New();
        Deserialize_(input->b.ptr, result->b.get());
      }
    } while (false);
  }
}


size_t B::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool B::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::B_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool B::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::B_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void B::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::B_Data* input =
      static_cast<internal::B_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const B& input) {
  size_t size = sizeof(internal::B_Data);
  size += input.a.is_null()
              ? 0
              : GetSerializedSize_(*input.a);
  return size;
}

mojo::internal::ValidationError Serialize_(
    B* input,
    mojo::internal::Buffer* buf,
    internal::B_Data** output) {
  if (input) {
    internal::B_Data* result =
        internal::B_Data::New(buf);
    {auto retval =Serialize_(input->a.get(),
                 buf,
                 &result->a.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::B_Data* input,
                  B* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->a.ptr) {
        result->a = A::New();
        Deserialize_(input->a.ptr, result->a.get());
      }
    } while (false);
  }
}


size_t StructWithHandleCalledHandles::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructWithHandleCalledHandles::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructWithHandleCalledHandles_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructWithHandleCalledHandles::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructWithHandleCalledHandles_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructWithHandleCalledHandles::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructWithHandleCalledHandles_Data* input =
      static_cast<internal::StructWithHandleCalledHandles_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructWithHandleCalledHandles& input) {
  size_t size = sizeof(internal::StructWithHandleCalledHandles_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructWithHandleCalledHandles* input,
    mojo::internal::Buffer* buf,
    internal::StructWithHandleCalledHandles_Data** output) {
  if (input) {
    internal::StructWithHandleCalledHandles_Data* result =
        internal::StructWithHandleCalledHandles_Data::New(buf);
    result->handles = input->handles.release();
    if (!result->handles.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid handles in StructWithHandleCalledHandles struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructWithHandleCalledHandles_Data* input,
                  StructWithHandleCalledHandles* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->handles.reset(mojo::internal::FetchAndReset(&input->handles));
    } while (false);
  }
}


size_t StructWithArrayOfHandlesCalledHandles::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructWithArrayOfHandlesCalledHandles::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructWithArrayOfHandlesCalledHandles_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructWithArrayOfHandlesCalledHandles::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructWithArrayOfHandlesCalledHandles_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructWithArrayOfHandlesCalledHandles::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructWithArrayOfHandlesCalledHandles_Data* input =
      static_cast<internal::StructWithArrayOfHandlesCalledHandles_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructWithArrayOfHandlesCalledHandles& input) {
  size_t size = sizeof(internal::StructWithArrayOfHandlesCalledHandles_Data);
  size += GetSerializedSize_(input.handles);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructWithArrayOfHandlesCalledHandles* input,
    mojo::internal::Buffer* buf,
    internal::StructWithArrayOfHandlesCalledHandles_Data** output) {
  if (input) {
    internal::StructWithArrayOfHandlesCalledHandles_Data* result =
        internal::StructWithArrayOfHandlesCalledHandles_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams handles_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->handles, buf, &result->handles.ptr,
                            &handles_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->handles.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null handles in StructWithArrayOfHandlesCalledHandles struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructWithArrayOfHandlesCalledHandles_Data* input,
                  StructWithArrayOfHandlesCalledHandles* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->handles.ptr, &result->handles);
    } while (false);
  }
}


size_t StructWithInterfaceCalledHandles::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructWithInterfaceCalledHandles::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructWithInterfaceCalledHandles_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructWithInterfaceCalledHandles::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructWithInterfaceCalledHandles_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructWithInterfaceCalledHandles::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructWithInterfaceCalledHandles_Data* input =
      static_cast<internal::StructWithInterfaceCalledHandles_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructWithInterfaceCalledHandles& input) {
  size_t size = sizeof(internal::StructWithInterfaceCalledHandles_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructWithInterfaceCalledHandles* input,
    mojo::internal::Buffer* buf,
    internal::StructWithInterfaceCalledHandles_Data** output) {
  if (input) {
    internal::StructWithInterfaceCalledHandles_Data* result =
        internal::StructWithInterfaceCalledHandles_Data::New(buf);
    mojo::internal::InterfaceHandleToData(input->handles.Pass(),
                                          &result->handles);
    if (!result->handles.handle.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid handles in StructWithInterfaceCalledHandles struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructWithInterfaceCalledHandles_Data* input,
                  StructWithInterfaceCalledHandles* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      mojo::internal::InterfaceDataToHandle(&input->handles, &result->handles);
    } while (false);
  }
}


size_t ContainsArrayOfEnum::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ContainsArrayOfEnum::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ContainsArrayOfEnum_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ContainsArrayOfEnum::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ContainsArrayOfEnum_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ContainsArrayOfEnum::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ContainsArrayOfEnum_Data* input =
      static_cast<internal::ContainsArrayOfEnum_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ContainsArrayOfEnum& input) {
  size_t size = sizeof(internal::ContainsArrayOfEnum_Data);
  size += GetSerializedSize_(input.array_of_enums);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ContainsArrayOfEnum* input,
    mojo::internal::Buffer* buf,
    internal::ContainsArrayOfEnum_Data** output) {
  if (input) {
    internal::ContainsArrayOfEnum_Data* result =
        internal::ContainsArrayOfEnum_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams array_of_enums_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->array_of_enums, buf, &result->array_of_enums.ptr,
                            &array_of_enums_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->array_of_enums.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null array_of_enums in ContainsArrayOfEnum struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ContainsArrayOfEnum_Data* input,
                  ContainsArrayOfEnum* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->array_of_enums.ptr, &result->array_of_enums);
    } while (false);
  }
}


// --- Union Serialization Helpers ---

// --- Structs for interface method parameters ---


// static
CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ParamsPtr CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params::New() {
  CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ParamsPtr rv;
  mojo::internal::StructHelper<CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params>::Initialize(&rv);
  return rv;
}

CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params() {
}

CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params::~CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params() {
}


CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ParamsPtr CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params::Clone() const {
  CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ParamsPtr rv(New());
  return rv;
}


bool CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params::Equals(const CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params& other) const {
  return true;
}


size_t CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data* input =
      static_cast<internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params& input) {
  size_t size = sizeof(internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params* input,
    mojo::internal::Buffer* buf,
    internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data** output) {
  if (input) {
    internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data* result =
        internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data* input,
                  CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


// static
CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParamsPtr CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams::New() {
  CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParamsPtr rv;
  mojo::internal::StructHelper<CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams>::Initialize(&rv);
  return rv;
}

CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams() {
}

CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams::~CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams() {
}


CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParamsPtr CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams::Clone() const {
  CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParamsPtr rv(New());
  return rv;
}


bool CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams::Equals(const CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams& other) const {
  return true;
}


size_t CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data* input =
      static_cast<internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams& input) {
  size_t size = sizeof(internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data** output) {
  if (input) {
    internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data* result =
        internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data* input,
                  CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}



// static
CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ParamsPtr CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params::New() {
  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ParamsPtr rv;
  mojo::internal::StructHelper<CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params>::Initialize(&rv);
  return rv;
}

CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params()
    : b() {
}

CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params::~CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params() {
}


CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ParamsPtr CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params::Clone() const {
  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ParamsPtr rv(New());
  rv->b = b;
  return rv;
}


bool CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params::Equals(const CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params& other) const {
  if (!mojo::internal::ValueTraits<bool>::Equals(this->b, other.b))
    return false;
  return true;
}


size_t CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data* input =
      static_cast<internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params& input) {
  size_t size = sizeof(internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params* input,
    mojo::internal::Buffer* buf,
    internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data** output) {
  if (input) {
    internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data* result =
        internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data::New(buf);
    result->b = input->b;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data* input,
                  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->b = input->b;
    } while (false);
  }
}


// static
CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParamsPtr CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams::New() {
  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParamsPtr rv;
  mojo::internal::StructHelper<CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams>::Initialize(&rv);
  return rv;
}

CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams() {
}

CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams::~CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams() {
}


CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParamsPtr CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams::Clone() const {
  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParamsPtr rv(New());
  return rv;
}


bool CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams::Equals(const CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams& other) const {
  return true;
}


size_t CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data* input =
      static_cast<internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams& input) {
  size_t size = sizeof(internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data** output) {
  if (input) {
    internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data* result =
        internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data* input,
                  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}



// static
CheckNameCollision_WithNameCollision_ParamsPtr CheckNameCollision_WithNameCollision_Params::New() {
  CheckNameCollision_WithNameCollision_ParamsPtr rv;
  mojo::internal::StructHelper<CheckNameCollision_WithNameCollision_Params>::Initialize(&rv);
  return rv;
}

CheckNameCollision_WithNameCollision_Params::CheckNameCollision_WithNameCollision_Params()
    : message(),
      response() {
}

CheckNameCollision_WithNameCollision_Params::~CheckNameCollision_WithNameCollision_Params() {
}


CheckNameCollision_WithNameCollision_ParamsPtr CheckNameCollision_WithNameCollision_Params::Clone() const {
  CheckNameCollision_WithNameCollision_ParamsPtr rv(New());
  rv->message = message;
  rv->response = response;
  return rv;
}


bool CheckNameCollision_WithNameCollision_Params::Equals(const CheckNameCollision_WithNameCollision_Params& other) const {
  if (!mojo::internal::ValueTraits<bool>::Equals(this->message, other.message))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->response, other.response))
    return false;
  return true;
}


size_t CheckNameCollision_WithNameCollision_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool CheckNameCollision_WithNameCollision_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::CheckNameCollision_WithNameCollision_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool CheckNameCollision_WithNameCollision_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::CheckNameCollision_WithNameCollision_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void CheckNameCollision_WithNameCollision_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::CheckNameCollision_WithNameCollision_Params_Data* input =
      static_cast<internal::CheckNameCollision_WithNameCollision_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const CheckNameCollision_WithNameCollision_Params& input) {
  size_t size = sizeof(internal::CheckNameCollision_WithNameCollision_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    CheckNameCollision_WithNameCollision_Params* input,
    mojo::internal::Buffer* buf,
    internal::CheckNameCollision_WithNameCollision_Params_Data** output) {
  if (input) {
    internal::CheckNameCollision_WithNameCollision_Params_Data* result =
        internal::CheckNameCollision_WithNameCollision_Params_Data::New(buf);
    result->message = input->message;
    result->response = input->response;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::CheckNameCollision_WithNameCollision_Params_Data* input,
                  CheckNameCollision_WithNameCollision_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->message = input->message;
      result->response = input->response;
    } while (false);
  }
}


// static
CheckNameCollision_WithNameCollision_ResponseParamsPtr CheckNameCollision_WithNameCollision_ResponseParams::New() {
  CheckNameCollision_WithNameCollision_ResponseParamsPtr rv;
  mojo::internal::StructHelper<CheckNameCollision_WithNameCollision_ResponseParams>::Initialize(&rv);
  return rv;
}

CheckNameCollision_WithNameCollision_ResponseParams::CheckNameCollision_WithNameCollision_ResponseParams()
    : message(),
      response() {
}

CheckNameCollision_WithNameCollision_ResponseParams::~CheckNameCollision_WithNameCollision_ResponseParams() {
}


CheckNameCollision_WithNameCollision_ResponseParamsPtr CheckNameCollision_WithNameCollision_ResponseParams::Clone() const {
  CheckNameCollision_WithNameCollision_ResponseParamsPtr rv(New());
  rv->message = message;
  rv->response = response;
  return rv;
}


bool CheckNameCollision_WithNameCollision_ResponseParams::Equals(const CheckNameCollision_WithNameCollision_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<bool>::Equals(this->message, other.message))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->response, other.response))
    return false;
  return true;
}


size_t CheckNameCollision_WithNameCollision_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool CheckNameCollision_WithNameCollision_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::CheckNameCollision_WithNameCollision_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool CheckNameCollision_WithNameCollision_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::CheckNameCollision_WithNameCollision_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void CheckNameCollision_WithNameCollision_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::CheckNameCollision_WithNameCollision_ResponseParams_Data* input =
      static_cast<internal::CheckNameCollision_WithNameCollision_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const CheckNameCollision_WithNameCollision_ResponseParams& input) {
  size_t size = sizeof(internal::CheckNameCollision_WithNameCollision_ResponseParams_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    CheckNameCollision_WithNameCollision_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::CheckNameCollision_WithNameCollision_ResponseParams_Data** output) {
  if (input) {
    internal::CheckNameCollision_WithNameCollision_ResponseParams_Data* result =
        internal::CheckNameCollision_WithNameCollision_ResponseParams_Data::New(buf);
    result->message = input->message;
    result->response = input->response;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::CheckNameCollision_WithNameCollision_ResponseParams_Data* input,
                  CheckNameCollision_WithNameCollision_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->message = input->message;
      result->response = input->response;
    } while (false);
  }
}



// static
CheckEnumCaps_SetEnumWithINTERNALAllCaps_ParamsPtr CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params::New() {
  CheckEnumCaps_SetEnumWithINTERNALAllCaps_ParamsPtr rv;
  mojo::internal::StructHelper<CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params>::Initialize(&rv);
  return rv;
}

CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params()
    : e() {
}

CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params::~CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params() {
}


CheckEnumCaps_SetEnumWithINTERNALAllCaps_ParamsPtr CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params::Clone() const {
  CheckEnumCaps_SetEnumWithINTERNALAllCaps_ParamsPtr rv(New());
  rv->e = e;
  return rv;
}


bool CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params::Equals(const CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params& other) const {
  if (!mojo::internal::ValueTraits<EnumWithINTERNALAllCaps>::Equals(this->e, other.e))
    return false;
  return true;
}


size_t CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data* input =
      static_cast<internal::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params& input) {
  size_t size = sizeof(internal::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params* input,
    mojo::internal::Buffer* buf,
    internal::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data** output) {
  if (input) {
    internal::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data* result =
        internal::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data::New(buf);
    result->e =
      static_cast<int32_t>(input->e);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data* input,
                  CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->e = static_cast<EnumWithINTERNALAllCaps>(input->e);
    } while (false);
  }
}



// static
TestInterface_SomeMessage_ParamsPtr TestInterface_SomeMessage_Params::New() {
  TestInterface_SomeMessage_ParamsPtr rv;
  mojo::internal::StructHelper<TestInterface_SomeMessage_Params>::Initialize(&rv);
  return rv;
}

TestInterface_SomeMessage_Params::TestInterface_SomeMessage_Params() {
}

TestInterface_SomeMessage_Params::~TestInterface_SomeMessage_Params() {
}


TestInterface_SomeMessage_ParamsPtr TestInterface_SomeMessage_Params::Clone() const {
  TestInterface_SomeMessage_ParamsPtr rv(New());
  return rv;
}


bool TestInterface_SomeMessage_Params::Equals(const TestInterface_SomeMessage_Params& other) const {
  return true;
}


size_t TestInterface_SomeMessage_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool TestInterface_SomeMessage_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::TestInterface_SomeMessage_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool TestInterface_SomeMessage_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::TestInterface_SomeMessage_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void TestInterface_SomeMessage_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::TestInterface_SomeMessage_Params_Data* input =
      static_cast<internal::TestInterface_SomeMessage_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const TestInterface_SomeMessage_Params& input) {
  size_t size = sizeof(internal::TestInterface_SomeMessage_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    TestInterface_SomeMessage_Params* input,
    mojo::internal::Buffer* buf,
    internal::TestInterface_SomeMessage_Params_Data** output) {
  if (input) {
    internal::TestInterface_SomeMessage_Params_Data* result =
        internal::TestInterface_SomeMessage_Params_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::TestInterface_SomeMessage_Params_Data* input,
                  TestInterface_SomeMessage_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}



// static
Regression551_Get_ParamsPtr Regression551_Get_Params::New() {
  Regression551_Get_ParamsPtr rv;
  mojo::internal::StructHelper<Regression551_Get_Params>::Initialize(&rv);
  return rv;
}

Regression551_Get_Params::Regression551_Get_Params()
    : key_prefixes() {
}

Regression551_Get_Params::~Regression551_Get_Params() {
}


Regression551_Get_ParamsPtr Regression551_Get_Params::Clone() const {
  Regression551_Get_ParamsPtr rv(New());
  rv->key_prefixes = key_prefixes.Clone();
  return rv;
}


bool Regression551_Get_Params::Equals(const Regression551_Get_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->key_prefixes, other.key_prefixes))
    return false;
  return true;
}


size_t Regression551_Get_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Regression551_Get_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Regression551_Get_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Regression551_Get_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Regression551_Get_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Regression551_Get_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Regression551_Get_Params_Data* input =
      static_cast<internal::Regression551_Get_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Regression551_Get_Params& input) {
  size_t size = sizeof(internal::Regression551_Get_Params_Data);
  size += GetSerializedSize_(input.key_prefixes);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Regression551_Get_Params* input,
    mojo::internal::Buffer* buf,
    internal::Regression551_Get_Params_Data** output) {
  if (input) {
    internal::Regression551_Get_Params_Data* result =
        internal::Regression551_Get_Params_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams key_prefixes_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->key_prefixes, buf, &result->key_prefixes.ptr,
                            &key_prefixes_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->key_prefixes.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null key_prefixes in Regression551_Get_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Regression551_Get_Params_Data* input,
                  Regression551_Get_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->key_prefixes.ptr, &result->key_prefixes);
    } while (false);
  }
}


// static
Regression551_Get_ResponseParamsPtr Regression551_Get_ResponseParams::New() {
  Regression551_Get_ResponseParamsPtr rv;
  mojo::internal::StructHelper<Regression551_Get_ResponseParams>::Initialize(&rv);
  return rv;
}

Regression551_Get_ResponseParams::Regression551_Get_ResponseParams()
    : result() {
}

Regression551_Get_ResponseParams::~Regression551_Get_ResponseParams() {
}


Regression551_Get_ResponseParamsPtr Regression551_Get_ResponseParams::Clone() const {
  Regression551_Get_ResponseParamsPtr rv(New());
  rv->result = result;
  return rv;
}


bool Regression551_Get_ResponseParams::Equals(const Regression551_Get_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->result, other.result))
    return false;
  return true;
}


size_t Regression551_Get_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Regression551_Get_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Regression551_Get_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Regression551_Get_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Regression551_Get_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Regression551_Get_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Regression551_Get_ResponseParams_Data* input =
      static_cast<internal::Regression551_Get_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Regression551_Get_ResponseParams& input) {
  size_t size = sizeof(internal::Regression551_Get_ResponseParams_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Regression551_Get_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::Regression551_Get_ResponseParams_Data** output) {
  if (input) {
    internal::Regression551_Get_ResponseParams_Data* result =
        internal::Regression551_Get_ResponseParams_Data::New(buf);
    result->result = input->result;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Regression551_Get_ResponseParams_Data* input,
                  Regression551_Get_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->result = input->result;
    } while (false);
  }
}



// static
ServiceName_serviceName_ParamsPtr ServiceName_serviceName_Params::New() {
  ServiceName_serviceName_ParamsPtr rv;
  mojo::internal::StructHelper<ServiceName_serviceName_Params>::Initialize(&rv);
  return rv;
}

ServiceName_serviceName_Params::ServiceName_serviceName_Params() {
}

ServiceName_serviceName_Params::~ServiceName_serviceName_Params() {
}


ServiceName_serviceName_ParamsPtr ServiceName_serviceName_Params::Clone() const {
  ServiceName_serviceName_ParamsPtr rv(New());
  return rv;
}


bool ServiceName_serviceName_Params::Equals(const ServiceName_serviceName_Params& other) const {
  return true;
}


size_t ServiceName_serviceName_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ServiceName_serviceName_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ServiceName_serviceName_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ServiceName_serviceName_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ServiceName_serviceName_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ServiceName_serviceName_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ServiceName_serviceName_Params_Data* input =
      static_cast<internal::ServiceName_serviceName_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ServiceName_serviceName_Params& input) {
  size_t size = sizeof(internal::ServiceName_serviceName_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ServiceName_serviceName_Params* input,
    mojo::internal::Buffer* buf,
    internal::ServiceName_serviceName_Params_Data** output) {
  if (input) {
    internal::ServiceName_serviceName_Params_Data* result =
        internal::ServiceName_serviceName_Params_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ServiceName_serviceName_Params_Data* input,
                  ServiceName_serviceName_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


// static
ServiceName_serviceName_ResponseParamsPtr ServiceName_serviceName_ResponseParams::New() {
  ServiceName_serviceName_ResponseParamsPtr rv;
  mojo::internal::StructHelper<ServiceName_serviceName_ResponseParams>::Initialize(&rv);
  return rv;
}

ServiceName_serviceName_ResponseParams::ServiceName_serviceName_ResponseParams()
    : serviceName() {
}

ServiceName_serviceName_ResponseParams::~ServiceName_serviceName_ResponseParams() {
}


ServiceName_serviceName_ResponseParamsPtr ServiceName_serviceName_ResponseParams::Clone() const {
  ServiceName_serviceName_ResponseParamsPtr rv(New());
  rv->serviceName = serviceName;
  return rv;
}


bool ServiceName_serviceName_ResponseParams::Equals(const ServiceName_serviceName_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->serviceName, other.serviceName))
    return false;
  return true;
}


size_t ServiceName_serviceName_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ServiceName_serviceName_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ServiceName_serviceName_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ServiceName_serviceName_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ServiceName_serviceName_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ServiceName_serviceName_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ServiceName_serviceName_ResponseParams_Data* input =
      static_cast<internal::ServiceName_serviceName_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ServiceName_serviceName_ResponseParams& input) {
  size_t size = sizeof(internal::ServiceName_serviceName_ResponseParams_Data);
  size += GetSerializedSize_(input.serviceName);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ServiceName_serviceName_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::ServiceName_serviceName_ResponseParams_Data** output) {
  if (input) {
    internal::ServiceName_serviceName_ResponseParams_Data* result =
        internal::ServiceName_serviceName_ResponseParams_Data::New(buf);
    SerializeString_(input->serviceName, buf, &result->serviceName.ptr);
    if (!result->serviceName.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null serviceName in ServiceName_serviceName_ResponseParams struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ServiceName_serviceName_ResponseParams_Data* input,
                  ServiceName_serviceName_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->serviceName.ptr, &result->serviceName);
    } while (false);
  }
}

}  // namespace regression_tests
