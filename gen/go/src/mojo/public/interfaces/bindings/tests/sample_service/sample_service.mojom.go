// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/public/interfaces/bindings/tests/sample_service.mojom
//

package sample_service

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	ioutil "io/ioutil"
	base64 "encoding/base64"
	fmt "fmt"
	bytes "bytes"
	sample_import "mojo/public/interfaces/bindings/tests/sample_import"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
	gzip "compress/gzip"
	sample_import2 "mojo/public/interfaces/bindings/tests/sample_import2"
)

// This global variable contains a mojom_types.RuntimeTypeInfo struct
// describing the types defined in this file and all of its imports as
// well as the top-level interfaces defined in this file.
var runtimeTypeInfo__ = mojom_types.RuntimeTypeInfo{}

func getRuntimeTypeInfo() mojom_types.RuntimeTypeInfo {
  if runtimeTypeInfo__.TypeMap == nil {
    initRuntimeTypeInfo()
  }
  return runtimeTypeInfo__
}

func initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this file.
  // The string contains the base64 encoding of the gzip-compressed bytes.
  serializedRuntimeTypeInfo := "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"

  // Deserialize RuntimeTypeInfo
  compressedBytes, err := base64.StdEncoding.DecodeString(serializedRuntimeTypeInfo)
  if err != nil {
    panic(fmt.Sprintf("Error while base64Decoding runtimeTypeInfo: %s", err.Error()))
  }
  reader, err := gzip.NewReader(bytes.NewBuffer(compressedBytes))
  if err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  uncompressedBytes, err := ioutil.ReadAll(reader)
  if err != nil {
     panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  if err = reader.Close(); err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  decoder := bindings.NewDecoder(uncompressedBytes, nil)
  runtimeTypeInfo__.Decode(decoder)

  for s, udt := range sample_import2.GetAllMojomTypeDefinitions() {
    runtimeTypeInfo__.TypeMap[s] = udt
  }


  for s, udt := range sample_import.GetAllMojomTypeDefinitions() {
    runtimeTypeInfo__.TypeMap[s] = udt
  }


}
func GetAllMojomTypeDefinitions() map[string]mojom_types.UserDefinedType {
  return getRuntimeTypeInfo().TypeMap
}

type Bar_Type int32

const (
	Bar_Type_Vertical Bar_Type = 1
	Bar_Type_Horizontal = Bar_Type_Vertical + 1;
	Bar_Type_Both = Bar_Type_Horizontal + 1;
	Bar_Type_Invalid = Bar_Type_Both + 1;
)
// Bar_TypeMojomType returns the UserDefinedType that describes the Mojom
// type of Bar_Type. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func Bar_TypeMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.Bar.Type"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Bar_Type) MojomType() mojom_types.UserDefinedType {
	return Bar_TypeMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Bar_Type) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type Service_BazOptions int32

const (
	Service_BazOptions_Regular Service_BazOptions = 0
	Service_BazOptions_Extra = Service_BazOptions_Regular + 1;
)
// Service_BazOptionsMojomType returns the UserDefinedType that describes the Mojom
// type of Service_BazOptions. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func Service_BazOptionsMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.Service.BazOptions"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Service_BazOptions) MojomType() mojom_types.UserDefinedType {
	return Service_BazOptionsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Service_BazOptions) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type Service interface {
	Frobinate(inFoo *Foo, inBaz Service_BazOptions, inPort *Port_Pointer) (outResult int32, err error)
	GetPort(inPort Port_Request) (err error)
}


// ServiceMojomType returns the UserDefinedType that describes the Mojom
// type of Service. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func ServiceMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.Service"]
}




type Service_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Service_Request) MojomType() mojom_types.UserDefinedType {
	return ServiceMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Service_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type Service_Pointer bindings.InterfacePointer


type Service_ServiceFactory struct{
	Delegate Service_Factory
}

type Service_Factory interface {
	Create(request Service_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *Service_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &Service_ServiceDescription{}
}

func (f *Service_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := Service_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForService creates a message pipe for use with the
// Service interface with a Service_Request on one end and a Service_Pointer on the other.
func CreateMessagePipeForService() (Service_Request, Service_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return Service_Request(r), Service_Pointer(p)
}

const service_Frobinate_Name uint32 = 0
const service_GetPort_Name uint32 = 1

type Service_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewServiceProxy(p Service_Pointer, waiter bindings.AsyncWaiter) *Service_Proxy {
	return &Service_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *Service_Proxy) Close_Proxy() {
	p.router.Close()
}

type service_Frobinate_Params struct {
	inFoo *Foo
	inBaz Service_BazOptions
	inPort *Port_Pointer
}


func (s *service_Frobinate_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if s.inFoo == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.inFoo).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.WriteInt32(int32(s.inBaz)); err != nil {
		return err
	}
	if s.inPort == nil {
		encoder.WriteInvalidInterface()
	} else {
		if err := encoder.WriteInterface((*s.inPort).PassMessagePipe()); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var service_Frobinate_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *service_Frobinate_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(service_Frobinate_Params_Versions), func(i int) bool {
		return service_Frobinate_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(service_Frobinate_Params_Versions) {
		if service_Frobinate_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := service_Frobinate_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.inFoo = nil
		} else {
			s.inFoo = new(Foo)
			if err := (*s.inFoo).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inBaz = Service_BazOptions(value0)
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadInterface()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inPort = &Port_Pointer{handleOwner}
		} else {
			s.inPort = nil
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type service_Frobinate_ResponseParams struct {
	outResult int32
}


func (s *service_Frobinate_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.outResult); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var service_Frobinate_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *service_Frobinate_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(service_Frobinate_ResponseParams_Versions), func(i int) bool {
		return service_Frobinate_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(service_Frobinate_ResponseParams_Versions) {
		if service_Frobinate_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := service_Frobinate_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outResult = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Service_Proxy) Frobinate(inFoo *Foo, inBaz Service_BazOptions, inPort *Port_Pointer) (outResult int32, err error) {
	payload := &service_Frobinate_Params{
		inFoo,
		inBaz,
		inPort,
	}
	header := bindings.MessageHeader{
		Type: service_Frobinate_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, service_Frobinate_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response service_Frobinate_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outResult = response.outResult
	return
}

type service_GetPort_Params struct {
	inPort Port_Request
}


func (s *service_GetPort_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteHandle(s.inPort.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var service_GetPort_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *service_GetPort_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(service_GetPort_Params_Versions), func(i int) bool {
		return service_GetPort_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(service_GetPort_Params_Versions) {
		if service_GetPort_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := service_GetPort_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inPort = Port_Request{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Service_Proxy) GetPort(inPort Port_Request) (err error) {
	payload := &service_GetPort_Params{
		inPort,
	}
	header := bindings.MessageHeader{
		Type: service_GetPort_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type service_Stub struct {
	connector *bindings.Connector
	impl Service
}

func NewServiceStub(r Service_Request, impl Service, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &service_Stub{connector, impl})
}


func (f *Service_Request) ServiceDescription() service_describer.ServiceDescription {
	return &Service_ServiceDescription{}
}


type Service_ServiceDescription struct{}

func (sd *Service_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *Service_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *Service_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*Service_ServiceDescription)(nil)


func (s *service_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case service_Frobinate_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request service_Frobinate_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response service_Frobinate_ResponseParams
		response.outResult, err = s.impl.Frobinate(request.inFoo, request.inBaz, request.inPort)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: service_Frobinate_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case service_GetPort_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request service_GetPort_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.GetPort(request.inPort)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type Port interface {
	PostMessage(inMessageText string, inPort Port_Pointer) (err error)
}


// PortMojomType returns the UserDefinedType that describes the Mojom
// type of Port. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func PortMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.Port"]
}




type Port_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Port_Request) MojomType() mojom_types.UserDefinedType {
	return PortMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Port_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type Port_Pointer bindings.InterfacePointer


type Port_ServiceFactory struct{
	Delegate Port_Factory
}

type Port_Factory interface {
	Create(request Port_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *Port_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &Port_ServiceDescription{}
}

func (f *Port_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := Port_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForPort creates a message pipe for use with the
// Port interface with a Port_Request on one end and a Port_Pointer on the other.
func CreateMessagePipeForPort() (Port_Request, Port_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return Port_Request(r), Port_Pointer(p)
}

const port_PostMessage_Name uint32 = 0

type Port_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewPortProxy(p Port_Pointer, waiter bindings.AsyncWaiter) *Port_Proxy {
	return &Port_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *Port_Proxy) Close_Proxy() {
	p.router.Close()
}

type port_PostMessage_Params struct {
	inMessageText string
	inPort Port_Pointer
}


func (s *port_PostMessage_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inMessageText); err != nil {
		return err
	}
	if err := encoder.WriteInterface(s.inPort.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var port_PostMessage_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *port_PostMessage_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(port_PostMessage_Params_Versions), func(i int) bool {
		return port_PostMessage_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(port_PostMessage_Params_Versions) {
		if port_PostMessage_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := port_PostMessage_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inMessageText = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadInterface()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inPort = Port_Pointer{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Port_Proxy) PostMessage(inMessageText string, inPort Port_Pointer) (err error) {
	payload := &port_PostMessage_Params{
		inMessageText,
		inPort,
	}
	header := bindings.MessageHeader{
		Type: port_PostMessage_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type port_Stub struct {
	connector *bindings.Connector
	impl Port
}

func NewPortStub(r Port_Request, impl Port, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &port_Stub{connector, impl})
}


func (f *Port_Request) ServiceDescription() service_describer.ServiceDescription {
	return &Port_ServiceDescription{}
}


type Port_ServiceDescription struct{}

func (sd *Port_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *Port_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *Port_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*Port_ServiceDescription)(nil)


func (s *port_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case port_PostMessage_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request port_PostMessage_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.PostMessage(request.inMessageText, request.inPort)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type Bar struct {
	Alpha uint8
	Beta uint8
	Gamma uint8
	Type Bar_Type
}
// BarMojomType returns the UserDefinedType that describes the Mojom
// type of Bar. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func BarMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.Bar"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Bar) MojomType() mojom_types.UserDefinedType {
	return BarMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Bar) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *Bar) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteUint8(s.Alpha); err != nil {
		return err
	}
	if err := encoder.WriteUint8(s.Beta); err != nil {
		return err
	}
	if err := encoder.WriteUint8(s.Gamma); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.Type)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var bar_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *Bar) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(bar_Versions), func(i int) bool {
		return bar_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(bar_Versions) {
		if bar_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := bar_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.Alpha = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.Beta = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.Gamma = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Type = Bar_Type(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type Foo struct {
	Name string
	X int32
	Y int32
	A bool
	B bool
	C bool
	Bar *Bar
	ExtraBars *[]Bar
	Data *[]uint8
	Source *system.MessagePipeHandle
	InputStreams *[]system.ConsumerHandle
	OutputStreams *[]system.ProducerHandle
	ArrayOfArrayOfBools *[][]bool
	MultiArrayOfStrings *[][][]string
	ArrayOfBools *[]bool
}
// FooMojomType returns the UserDefinedType that describes the Mojom
// type of Foo. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func FooMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.Foo"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Foo) MojomType() mojom_types.UserDefinedType {
	return FooMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Foo) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *Foo) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(88, 0)
	if err := encoder.WriteInt32(s.X); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.Y); err != nil {
		return err
	}
	if err := encoder.WriteBool(s.A); err != nil {
		return err
	}
	if err := encoder.WriteBool(s.B); err != nil {
		return err
	}
	if err := encoder.WriteBool(s.C); err != nil {
		return err
	}
	if s.Source == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.Source)); err != nil {
			return err
		}
	}
	if s.Bar == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.Bar).Encode(encoder); err != nil {
			return err
		}
	}
	if s.Data == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.Data))), 8)
		for _, elem0 := range (*s.Data) {
			if err := encoder.WriteUint8(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if s.ExtraBars == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.ExtraBars))), 64)
		for _, elem0 := range (*s.ExtraBars) {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem0.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.Name); err != nil {
		return err
	}
	if s.InputStreams == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.InputStreams))), 32)
		for _, elem0 := range (*s.InputStreams) {
			if err := encoder.WriteHandle(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if s.OutputStreams == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.OutputStreams))), 32)
		for _, elem0 := range (*s.OutputStreams) {
			if err := encoder.WriteHandle(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if s.ArrayOfArrayOfBools == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.ArrayOfArrayOfBools))), 64)
		for _, elem0 := range (*s.ArrayOfArrayOfBools) {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(elem0)), 1)
			for _, elem1 := range elem0 {
				if err := encoder.WriteBool(elem1); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if s.MultiArrayOfStrings == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.MultiArrayOfStrings))), 64)
		for _, elem0 := range (*s.MultiArrayOfStrings) {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(elem0)), 64)
			for _, elem1 := range elem0 {
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				encoder.StartArray(uint32(len(elem1)), 64)
				for _, elem2 := range elem1 {
					if err := encoder.WritePointer(); err != nil {
						return err
					}
					if err := encoder.WriteString(elem2); err != nil {
						return err
					}
				}
				if err := encoder.Finish(); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if s.ArrayOfBools == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.ArrayOfBools))), 1)
		for _, elem0 := range (*s.ArrayOfBools) {
			if err := encoder.WriteBool(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var foo_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{96, 0},
}

func (s *Foo) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(foo_Versions), func(i int) bool {
		return foo_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(foo_Versions) {
		if foo_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := foo_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.X = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Y = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.A = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.B = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.C = value0
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.Source = &handle0
		} else {
			s.Source = nil
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Bar = nil
		} else {
			s.Bar = new(Bar)
			if err := (*s.Bar).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Data = nil
		} else {
			s.Data = new([]uint8)
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			(*s.Data) = make([]uint8, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadUint8()
				if err != nil {
					return err
				}
				(*s.Data)[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.ExtraBars = nil
		} else {
			s.ExtraBars = new([]Bar)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.ExtraBars) = make([]Bar, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := (*s.ExtraBars)[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.Name = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.InputStreams = nil
		} else {
			s.InputStreams = new([]system.ConsumerHandle)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.InputStreams) = make([]system.ConsumerHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadConsumerHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					(*s.InputStreams)[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.OutputStreams = nil
		} else {
			s.OutputStreams = new([]system.ProducerHandle)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.OutputStreams) = make([]system.ProducerHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadProducerHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					(*s.OutputStreams)[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.ArrayOfArrayOfBools = nil
		} else {
			s.ArrayOfArrayOfBools = new([][]bool)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.ArrayOfArrayOfBools) = make([][]bool, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(1)
					if err != nil {
						return err
					}
					(*s.ArrayOfArrayOfBools)[i0] = make([]bool, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadBool()
						if err != nil {
							return err
						}
						(*s.ArrayOfArrayOfBools)[i0][i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.MultiArrayOfStrings = nil
		} else {
			s.MultiArrayOfStrings = new([][][]string)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.MultiArrayOfStrings) = make([][][]string, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					(*s.MultiArrayOfStrings)[i0] = make([][]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							len2, err := decoder.StartArray(64)
							if err != nil {
								return err
							}
							(*s.MultiArrayOfStrings)[i0][i1] = make([]string, len2)
							for i2 := uint32(0); i2 < len2; i2++ {
								pointer3, err := decoder.ReadPointer()
								if err != nil {
									return err
								}
								if pointer3 == 0 {
									return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
								} else {
									value3, err := decoder.ReadString()
									if err != nil {
										return err
									}
									(*s.MultiArrayOfStrings)[i0][i1][i2] = value3
								}
							}
							if err := decoder.Finish(); err != nil {
								return err
							}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.ArrayOfBools = nil
		} else {
			s.ArrayOfBools = new([]bool)
			len0, err := decoder.StartArray(1)
			if err != nil {
				return err
			}
			(*s.ArrayOfBools) = make([]bool, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadBool()
				if err != nil {
					return err
				}
				(*s.ArrayOfBools)[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type DefaultsTest struct {
	A0 int8
	A1 uint8
	A2 int16
	A3 uint16
	A4 int32
	A5 uint32
	A6 int64
	A7 uint64
	A8 int32
	A9 int32
	A10 int32
	A11 bool
	A12 bool
	A13 float32
	A14 float64
	A15 float64
	A16 float64
	A17 float64
	A18 []uint8
	A19 string
	A20 Bar_Type
	A21 sample_import.Point
	A22 sample_import2.Thing
	A23 uint64
	A24 int64
	A25 int64
	A26 float64
	A27 float64
	A28 float64
	A29 float32
	A30 float32
	A31 float32
}
// DefaultsTestMojomType returns the UserDefinedType that describes the Mojom
// type of DefaultsTest. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func DefaultsTestMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.DefaultsTest"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*DefaultsTest) MojomType() mojom_types.UserDefinedType {
	return DefaultsTestMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*DefaultsTest) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *DefaultsTest) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(176, 0)
	if err := encoder.WriteInt8(s.A0); err != nil {
		return err
	}
	if err := encoder.WriteUint8(s.A1); err != nil {
		return err
	}
	if err := encoder.WriteInt16(s.A2); err != nil {
		return err
	}
	if err := encoder.WriteUint16(s.A3); err != nil {
		return err
	}
	if err := encoder.WriteBool(s.A11); err != nil {
		return err
	}
	if err := encoder.WriteBool(s.A12); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.A4); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.A5); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.A6); err != nil {
		return err
	}
	if err := encoder.WriteUint64(s.A7); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.A8); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.A9); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.A10); err != nil {
		return err
	}
	if err := encoder.WriteFloat32(s.A13); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.A14); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.A15); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.A16); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.A17); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.A18)), 8)
	for _, elem0 := range s.A18 {
		if err := encoder.WriteUint8(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.A19); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.A20)); err != nil {
		return err
	}
	if err := encoder.WriteFloat32(s.A29); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.A21.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.A22.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WriteUint64(s.A23); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.A24); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.A25); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.A26); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.A27); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.A28); err != nil {
		return err
	}
	if err := encoder.WriteFloat32(s.A30); err != nil {
		return err
	}
	if err := encoder.WriteFloat32(s.A31); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var defaultsTest_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{184, 0},
}

func (s *DefaultsTest) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(defaultsTest_Versions), func(i int) bool {
		return defaultsTest_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(defaultsTest_Versions) {
		if defaultsTest_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := defaultsTest_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt8()
		if err != nil {
			return err
		}
		s.A0 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.A1 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt16()
		if err != nil {
			return err
		}
		s.A2 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint16()
		if err != nil {
			return err
		}
		s.A3 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.A11 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.A12 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.A4 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.A5 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.A6 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint64()
		if err != nil {
			return err
		}
		s.A7 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.A8 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.A9 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.A10 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.A13 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.A14 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.A15 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.A16 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.A17 = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			s.A18 = make([]uint8, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadUint8()
				if err != nil {
					return err
				}
				s.A18[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.A19 = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.A20 = Bar_Type(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.A29 = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.A21.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.A22.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint64()
		if err != nil {
			return err
		}
		s.A23 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.A24 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.A25 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.A26 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.A27 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.A28 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.A30 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.A31 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructWithHoleV1 struct {
	V1 int32
	V2 int64
}
// StructWithHoleV1MojomType returns the UserDefinedType that describes the Mojom
// type of StructWithHoleV1. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithHoleV1MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.StructWithHoleV1"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithHoleV1) MojomType() mojom_types.UserDefinedType {
	return StructWithHoleV1MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithHoleV1) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithHoleV1) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInt32(s.V1); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.V2); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithHoleV1_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *StructWithHoleV1) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithHoleV1_Versions), func(i int) bool {
		return structWithHoleV1_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithHoleV1_Versions) {
		if structWithHoleV1_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithHoleV1_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.V1 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.V2 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructWithHoleV2 struct {
	V1 int32
	V2 int64
	V3 int32
}
// StructWithHoleV2MojomType returns the UserDefinedType that describes the Mojom
// type of StructWithHoleV2. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithHoleV2MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.StructWithHoleV2"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithHoleV2) MojomType() mojom_types.UserDefinedType {
	return StructWithHoleV2MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithHoleV2) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithHoleV2) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInt32(s.V1); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.V3); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.V2); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithHoleV2_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *StructWithHoleV2) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithHoleV2_Versions), func(i int) bool {
		return structWithHoleV2_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithHoleV2_Versions) {
		if structWithHoleV2_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithHoleV2_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.V1 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.V3 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.V2 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type NonNullableMapStruct struct {
	MapField map[string]string
}
// NonNullableMapStructMojomType returns the UserDefinedType that describes the Mojom
// type of NonNullableMapStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func NonNullableMapStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.NonNullableMapStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*NonNullableMapStruct) MojomType() mojom_types.UserDefinedType {
	return NonNullableMapStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*NonNullableMapStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *NonNullableMapStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 []string
		if encoder.Deterministic() {
		  for key0, _ := range s.MapField {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]string, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.MapField[key]
		  }
		} else {
		  for key0, value0 := range s.MapField {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var nonNullableMapStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *NonNullableMapStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(nonNullableMapStruct_Versions), func(i int) bool {
		return nonNullableMapStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(nonNullableMapStruct_Versions) {
		if nonNullableMapStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := nonNullableMapStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							values0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string]string)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.MapField = map0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

