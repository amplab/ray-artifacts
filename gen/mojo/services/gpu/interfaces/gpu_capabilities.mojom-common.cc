// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/services/gpu/interfaces/gpu_capabilities.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace mojo {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// static
GpuShaderPrecision_Data* GpuShaderPrecision_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(GpuShaderPrecision_Data))) GpuShaderPrecision_Data();
}

// static
mojo::internal::ValidationError GpuShaderPrecision_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const GpuShaderPrecision_Data* object = static_cast<const GpuShaderPrecision_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void GpuShaderPrecision_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void GpuShaderPrecision_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

GpuShaderPrecision_Data::GpuShaderPrecision_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
GpuPerStagePrecisions_Data* GpuPerStagePrecisions_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(GpuPerStagePrecisions_Data))) GpuPerStagePrecisions_Data();
}

// static
mojo::internal::ValidationError GpuPerStagePrecisions_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const GpuPerStagePrecisions_Data* object = static_cast<const GpuPerStagePrecisions_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 56 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->low_int.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null low_int field in GpuPerStagePrecisions struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->low_int.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = GpuShaderPrecision::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->low_int.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->medium_int.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null medium_int field in GpuPerStagePrecisions struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->medium_int.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = GpuShaderPrecision::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->medium_int.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->high_int.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null high_int field in GpuPerStagePrecisions struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->high_int.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = GpuShaderPrecision::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->high_int.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->low_float.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null low_float field in GpuPerStagePrecisions struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->low_float.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = GpuShaderPrecision::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->low_float.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->medium_float.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null medium_float field in GpuPerStagePrecisions struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->medium_float.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = GpuShaderPrecision::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->medium_float.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->high_float.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null high_float field in GpuPerStagePrecisions struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->high_float.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = GpuShaderPrecision::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->high_float.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void GpuPerStagePrecisions_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->low_int, handles);
  mojo::internal::Encode(&this->medium_int, handles);
  mojo::internal::Encode(&this->high_int, handles);
  mojo::internal::Encode(&this->low_float, handles);
  mojo::internal::Encode(&this->medium_float, handles);
  mojo::internal::Encode(&this->high_float, handles);
}

void GpuPerStagePrecisions_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->low_int, handles);
  mojo::internal::Decode(&this->medium_int, handles);
  mojo::internal::Decode(&this->high_int, handles);
  mojo::internal::Decode(&this->low_float, handles);
  mojo::internal::Decode(&this->medium_float, handles);
  mojo::internal::Decode(&this->high_float, handles);
}

GpuPerStagePrecisions_Data::GpuPerStagePrecisions_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
GpuCapabilities_Data* GpuCapabilities_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(GpuCapabilities_Data))) GpuCapabilities_Data();
}

// static
mojo::internal::ValidationError GpuCapabilities_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const GpuCapabilities_Data* object = static_cast<const GpuCapabilities_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 80 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->vertex_shader_precisions.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null vertex_shader_precisions field in GpuCapabilities struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->vertex_shader_precisions.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = GpuPerStagePrecisions::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->vertex_shader_precisions.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->fragment_shader_precisions.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null fragment_shader_precisions field in GpuCapabilities struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->fragment_shader_precisions.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = GpuPerStagePrecisions::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->fragment_shader_precisions.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void GpuCapabilities_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->vertex_shader_precisions, handles);
  mojo::internal::Encode(&this->fragment_shader_precisions, handles);
}

void GpuCapabilities_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->vertex_shader_precisions, handles);
  mojo::internal::Decode(&this->fragment_shader_precisions, handles);
}

GpuCapabilities_Data::GpuCapabilities_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// --- Union definitions ---


// --- Definitions of the data structs for interface methods ---

}  // namespace internal

// --- Request and response validator definitions for interfaces --- 

// --- Enums ---

// Base interface definitions (Name_, Version_, Constants, Enums)

// Struct Constants

// --- Struct builder definitions ---

// static
GpuShaderPrecisionPtr GpuShaderPrecision::New() {
  GpuShaderPrecisionPtr rv;
  mojo::internal::StructHelper<GpuShaderPrecision>::Initialize(&rv);
  return rv;
}

GpuShaderPrecision::GpuShaderPrecision()
    : min_range(),
      max_range(),
      precision() {
}

GpuShaderPrecision::~GpuShaderPrecision() {
}


GpuShaderPrecisionPtr GpuShaderPrecision::Clone() const {
  GpuShaderPrecisionPtr rv(New());
  rv->min_range = min_range;
  rv->max_range = max_range;
  rv->precision = precision;
  return rv;
}


bool GpuShaderPrecision::Equals(const GpuShaderPrecision& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->min_range, other.min_range))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->max_range, other.max_range))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->precision, other.precision))
    return false;
  return true;
}


// static
GpuPerStagePrecisionsPtr GpuPerStagePrecisions::New() {
  GpuPerStagePrecisionsPtr rv;
  mojo::internal::StructHelper<GpuPerStagePrecisions>::Initialize(&rv);
  return rv;
}

GpuPerStagePrecisions::GpuPerStagePrecisions()
    : low_int(),
      medium_int(),
      high_int(),
      low_float(),
      medium_float(),
      high_float() {
}

GpuPerStagePrecisions::~GpuPerStagePrecisions() {
}


GpuPerStagePrecisionsPtr GpuPerStagePrecisions::Clone() const {
  GpuPerStagePrecisionsPtr rv(New());
  rv->low_int = low_int.Clone();
  rv->medium_int = medium_int.Clone();
  rv->high_int = high_int.Clone();
  rv->low_float = low_float.Clone();
  rv->medium_float = medium_float.Clone();
  rv->high_float = high_float.Clone();
  return rv;
}


bool GpuPerStagePrecisions::Equals(const GpuPerStagePrecisions& other) const {
  if (!mojo::internal::ValueTraits<GpuShaderPrecisionPtr>::Equals(this->low_int, other.low_int))
    return false;
  if (!mojo::internal::ValueTraits<GpuShaderPrecisionPtr>::Equals(this->medium_int, other.medium_int))
    return false;
  if (!mojo::internal::ValueTraits<GpuShaderPrecisionPtr>::Equals(this->high_int, other.high_int))
    return false;
  if (!mojo::internal::ValueTraits<GpuShaderPrecisionPtr>::Equals(this->low_float, other.low_float))
    return false;
  if (!mojo::internal::ValueTraits<GpuShaderPrecisionPtr>::Equals(this->medium_float, other.medium_float))
    return false;
  if (!mojo::internal::ValueTraits<GpuShaderPrecisionPtr>::Equals(this->high_float, other.high_float))
    return false;
  return true;
}


// static
GpuCapabilitiesPtr GpuCapabilities::New() {
  GpuCapabilitiesPtr rv;
  mojo::internal::StructHelper<GpuCapabilities>::Initialize(&rv);
  return rv;
}

GpuCapabilities::GpuCapabilities()
    : vertex_shader_precisions(),
      fragment_shader_precisions(),
      max_combined_texture_image_units(),
      max_cube_map_texture_size(),
      max_fragment_uniform_vectors(),
      max_renderbuffer_size(),
      max_texture_image_units(),
      max_texture_size(),
      max_varying_vectors(),
      max_vertex_attribs(),
      max_vertex_texture_image_units(),
      max_vertex_uniform_vectors(),
      num_compressed_texture_formats(),
      num_shader_binary_formats(),
      bind_generates_resource_chromium(),
      post_sub_buffer(),
      egl_image_external(),
      texture_format_bgra8888(),
      texture_format_etc1(),
      texture_format_etc1_npot(),
      texture_rectangle(),
      iosurface(),
      texture_usage(),
      texture_storage(),
      discard_framebuffer(),
      sync_query(),
      image(),
      future_sync_points(),
      blend_equation_advanced(),
      blend_equation_advanced_coherent() {
}

GpuCapabilities::~GpuCapabilities() {
}


GpuCapabilitiesPtr GpuCapabilities::Clone() const {
  GpuCapabilitiesPtr rv(New());
  rv->vertex_shader_precisions = vertex_shader_precisions.Clone();
  rv->fragment_shader_precisions = fragment_shader_precisions.Clone();
  rv->max_combined_texture_image_units = max_combined_texture_image_units;
  rv->max_cube_map_texture_size = max_cube_map_texture_size;
  rv->max_fragment_uniform_vectors = max_fragment_uniform_vectors;
  rv->max_renderbuffer_size = max_renderbuffer_size;
  rv->max_texture_image_units = max_texture_image_units;
  rv->max_texture_size = max_texture_size;
  rv->max_varying_vectors = max_varying_vectors;
  rv->max_vertex_attribs = max_vertex_attribs;
  rv->max_vertex_texture_image_units = max_vertex_texture_image_units;
  rv->max_vertex_uniform_vectors = max_vertex_uniform_vectors;
  rv->num_compressed_texture_formats = num_compressed_texture_formats;
  rv->num_shader_binary_formats = num_shader_binary_formats;
  rv->bind_generates_resource_chromium = bind_generates_resource_chromium;
  rv->post_sub_buffer = post_sub_buffer;
  rv->egl_image_external = egl_image_external;
  rv->texture_format_bgra8888 = texture_format_bgra8888;
  rv->texture_format_etc1 = texture_format_etc1;
  rv->texture_format_etc1_npot = texture_format_etc1_npot;
  rv->texture_rectangle = texture_rectangle;
  rv->iosurface = iosurface;
  rv->texture_usage = texture_usage;
  rv->texture_storage = texture_storage;
  rv->discard_framebuffer = discard_framebuffer;
  rv->sync_query = sync_query;
  rv->image = image;
  rv->future_sync_points = future_sync_points;
  rv->blend_equation_advanced = blend_equation_advanced;
  rv->blend_equation_advanced_coherent = blend_equation_advanced_coherent;
  return rv;
}


bool GpuCapabilities::Equals(const GpuCapabilities& other) const {
  if (!mojo::internal::ValueTraits<GpuPerStagePrecisionsPtr>::Equals(this->vertex_shader_precisions, other.vertex_shader_precisions))
    return false;
  if (!mojo::internal::ValueTraits<GpuPerStagePrecisionsPtr>::Equals(this->fragment_shader_precisions, other.fragment_shader_precisions))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->max_combined_texture_image_units, other.max_combined_texture_image_units))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->max_cube_map_texture_size, other.max_cube_map_texture_size))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->max_fragment_uniform_vectors, other.max_fragment_uniform_vectors))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->max_renderbuffer_size, other.max_renderbuffer_size))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->max_texture_image_units, other.max_texture_image_units))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->max_texture_size, other.max_texture_size))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->max_varying_vectors, other.max_varying_vectors))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->max_vertex_attribs, other.max_vertex_attribs))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->max_vertex_texture_image_units, other.max_vertex_texture_image_units))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->max_vertex_uniform_vectors, other.max_vertex_uniform_vectors))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->num_compressed_texture_formats, other.num_compressed_texture_formats))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->num_shader_binary_formats, other.num_shader_binary_formats))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->bind_generates_resource_chromium, other.bind_generates_resource_chromium))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->post_sub_buffer, other.post_sub_buffer))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->egl_image_external, other.egl_image_external))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->texture_format_bgra8888, other.texture_format_bgra8888))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->texture_format_etc1, other.texture_format_etc1))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->texture_format_etc1_npot, other.texture_format_etc1_npot))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->texture_rectangle, other.texture_rectangle))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->iosurface, other.iosurface))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->texture_usage, other.texture_usage))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->texture_storage, other.texture_storage))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->discard_framebuffer, other.discard_framebuffer))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->sync_query, other.sync_query))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->image, other.image))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->future_sync_points, other.future_sync_points))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->blend_equation_advanced, other.blend_equation_advanced))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->blend_equation_advanced_coherent, other.blend_equation_advanced_coherent))
    return false;
  return true;
}


// --- Union builder definitions ---

// --- Struct Serialization Helpers ---

size_t GpuShaderPrecision::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool GpuShaderPrecision::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::GpuShaderPrecision_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool GpuShaderPrecision::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::GpuShaderPrecision_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void GpuShaderPrecision::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::GpuShaderPrecision_Data* input =
      static_cast<internal::GpuShaderPrecision_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const GpuShaderPrecision& input) {
  size_t size = sizeof(internal::GpuShaderPrecision_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    GpuShaderPrecision* input,
    mojo::internal::Buffer* buf,
    internal::GpuShaderPrecision_Data** output) {
  if (input) {
    internal::GpuShaderPrecision_Data* result =
        internal::GpuShaderPrecision_Data::New(buf);
    result->min_range = input->min_range;
    result->max_range = input->max_range;
    result->precision = input->precision;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::GpuShaderPrecision_Data* input,
                  GpuShaderPrecision* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->min_range = input->min_range;
      result->max_range = input->max_range;
      result->precision = input->precision;
    } while (false);
  }
}


size_t GpuPerStagePrecisions::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool GpuPerStagePrecisions::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::GpuPerStagePrecisions_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool GpuPerStagePrecisions::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::GpuPerStagePrecisions_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void GpuPerStagePrecisions::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::GpuPerStagePrecisions_Data* input =
      static_cast<internal::GpuPerStagePrecisions_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const GpuPerStagePrecisions& input) {
  size_t size = sizeof(internal::GpuPerStagePrecisions_Data);
  size += input.low_int.is_null()
              ? 0
              : GetSerializedSize_(*input.low_int);
  size += input.medium_int.is_null()
              ? 0
              : GetSerializedSize_(*input.medium_int);
  size += input.high_int.is_null()
              ? 0
              : GetSerializedSize_(*input.high_int);
  size += input.low_float.is_null()
              ? 0
              : GetSerializedSize_(*input.low_float);
  size += input.medium_float.is_null()
              ? 0
              : GetSerializedSize_(*input.medium_float);
  size += input.high_float.is_null()
              ? 0
              : GetSerializedSize_(*input.high_float);
  return size;
}

mojo::internal::ValidationError Serialize_(
    GpuPerStagePrecisions* input,
    mojo::internal::Buffer* buf,
    internal::GpuPerStagePrecisions_Data** output) {
  if (input) {
    internal::GpuPerStagePrecisions_Data* result =
        internal::GpuPerStagePrecisions_Data::New(buf);
    {auto retval =Serialize_(input->low_int.get(),
                 buf,
                 &result->low_int.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->low_int.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null low_int in GpuPerStagePrecisions struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->medium_int.get(),
                 buf,
                 &result->medium_int.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->medium_int.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null medium_int in GpuPerStagePrecisions struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->high_int.get(),
                 buf,
                 &result->high_int.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->high_int.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null high_int in GpuPerStagePrecisions struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->low_float.get(),
                 buf,
                 &result->low_float.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->low_float.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null low_float in GpuPerStagePrecisions struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->medium_float.get(),
                 buf,
                 &result->medium_float.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->medium_float.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null medium_float in GpuPerStagePrecisions struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->high_float.get(),
                 buf,
                 &result->high_float.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->high_float.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null high_float in GpuPerStagePrecisions struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::GpuPerStagePrecisions_Data* input,
                  GpuPerStagePrecisions* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->low_int.ptr) {
        result->low_int = GpuShaderPrecision::New();
        Deserialize_(input->low_int.ptr, result->low_int.get());
      }
      if (input->medium_int.ptr) {
        result->medium_int = GpuShaderPrecision::New();
        Deserialize_(input->medium_int.ptr, result->medium_int.get());
      }
      if (input->high_int.ptr) {
        result->high_int = GpuShaderPrecision::New();
        Deserialize_(input->high_int.ptr, result->high_int.get());
      }
      if (input->low_float.ptr) {
        result->low_float = GpuShaderPrecision::New();
        Deserialize_(input->low_float.ptr, result->low_float.get());
      }
      if (input->medium_float.ptr) {
        result->medium_float = GpuShaderPrecision::New();
        Deserialize_(input->medium_float.ptr, result->medium_float.get());
      }
      if (input->high_float.ptr) {
        result->high_float = GpuShaderPrecision::New();
        Deserialize_(input->high_float.ptr, result->high_float.get());
      }
    } while (false);
  }
}


size_t GpuCapabilities::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool GpuCapabilities::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::GpuCapabilities_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool GpuCapabilities::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::GpuCapabilities_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void GpuCapabilities::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::GpuCapabilities_Data* input =
      static_cast<internal::GpuCapabilities_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const GpuCapabilities& input) {
  size_t size = sizeof(internal::GpuCapabilities_Data);
  size += input.vertex_shader_precisions.is_null()
              ? 0
              : GetSerializedSize_(*input.vertex_shader_precisions);
  size += input.fragment_shader_precisions.is_null()
              ? 0
              : GetSerializedSize_(*input.fragment_shader_precisions);
  return size;
}

mojo::internal::ValidationError Serialize_(
    GpuCapabilities* input,
    mojo::internal::Buffer* buf,
    internal::GpuCapabilities_Data** output) {
  if (input) {
    internal::GpuCapabilities_Data* result =
        internal::GpuCapabilities_Data::New(buf);
    {auto retval =Serialize_(input->vertex_shader_precisions.get(),
                 buf,
                 &result->vertex_shader_precisions.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->vertex_shader_precisions.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null vertex_shader_precisions in GpuCapabilities struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->fragment_shader_precisions.get(),
                 buf,
                 &result->fragment_shader_precisions.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->fragment_shader_precisions.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null fragment_shader_precisions in GpuCapabilities struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->max_combined_texture_image_units = input->max_combined_texture_image_units;
    result->max_cube_map_texture_size = input->max_cube_map_texture_size;
    result->max_fragment_uniform_vectors = input->max_fragment_uniform_vectors;
    result->max_renderbuffer_size = input->max_renderbuffer_size;
    result->max_texture_image_units = input->max_texture_image_units;
    result->max_texture_size = input->max_texture_size;
    result->max_varying_vectors = input->max_varying_vectors;
    result->max_vertex_attribs = input->max_vertex_attribs;
    result->max_vertex_texture_image_units = input->max_vertex_texture_image_units;
    result->max_vertex_uniform_vectors = input->max_vertex_uniform_vectors;
    result->num_compressed_texture_formats = input->num_compressed_texture_formats;
    result->num_shader_binary_formats = input->num_shader_binary_formats;
    result->bind_generates_resource_chromium = input->bind_generates_resource_chromium;
    result->post_sub_buffer = input->post_sub_buffer;
    result->egl_image_external = input->egl_image_external;
    result->texture_format_bgra8888 = input->texture_format_bgra8888;
    result->texture_format_etc1 = input->texture_format_etc1;
    result->texture_format_etc1_npot = input->texture_format_etc1_npot;
    result->texture_rectangle = input->texture_rectangle;
    result->iosurface = input->iosurface;
    result->texture_usage = input->texture_usage;
    result->texture_storage = input->texture_storage;
    result->discard_framebuffer = input->discard_framebuffer;
    result->sync_query = input->sync_query;
    result->image = input->image;
    result->future_sync_points = input->future_sync_points;
    result->blend_equation_advanced = input->blend_equation_advanced;
    result->blend_equation_advanced_coherent = input->blend_equation_advanced_coherent;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::GpuCapabilities_Data* input,
                  GpuCapabilities* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->vertex_shader_precisions.ptr) {
        result->vertex_shader_precisions = GpuPerStagePrecisions::New();
        Deserialize_(input->vertex_shader_precisions.ptr, result->vertex_shader_precisions.get());
      }
      if (input->fragment_shader_precisions.ptr) {
        result->fragment_shader_precisions = GpuPerStagePrecisions::New();
        Deserialize_(input->fragment_shader_precisions.ptr, result->fragment_shader_precisions.get());
      }
      result->max_combined_texture_image_units = input->max_combined_texture_image_units;
      result->max_cube_map_texture_size = input->max_cube_map_texture_size;
      result->max_fragment_uniform_vectors = input->max_fragment_uniform_vectors;
      result->max_renderbuffer_size = input->max_renderbuffer_size;
      result->max_texture_image_units = input->max_texture_image_units;
      result->max_texture_size = input->max_texture_size;
      result->max_varying_vectors = input->max_varying_vectors;
      result->max_vertex_attribs = input->max_vertex_attribs;
      result->max_vertex_texture_image_units = input->max_vertex_texture_image_units;
      result->max_vertex_uniform_vectors = input->max_vertex_uniform_vectors;
      result->num_compressed_texture_formats = input->num_compressed_texture_formats;
      result->num_shader_binary_formats = input->num_shader_binary_formats;
      result->bind_generates_resource_chromium = input->bind_generates_resource_chromium;
      result->post_sub_buffer = input->post_sub_buffer;
      result->egl_image_external = input->egl_image_external;
      result->texture_format_bgra8888 = input->texture_format_bgra8888;
      result->texture_format_etc1 = input->texture_format_etc1;
      result->texture_format_etc1_npot = input->texture_format_etc1_npot;
      result->texture_rectangle = input->texture_rectangle;
      result->iosurface = input->iosurface;
      result->texture_usage = input->texture_usage;
      result->texture_storage = input->texture_storage;
      result->discard_framebuffer = input->discard_framebuffer;
      result->sync_query = input->sync_query;
      result->image = input->image;
      result->future_sync_points = input->future_sync_points;
      result->blend_equation_advanced = input->blend_equation_advanced;
      result->blend_equation_advanced_coherent = input->blend_equation_advanced_coherent;
    } while (false);
  }
}


// --- Union Serialization Helpers ---

// --- Structs for interface method parameters ---
}  // namespace mojo
