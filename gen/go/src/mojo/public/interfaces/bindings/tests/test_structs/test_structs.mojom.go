// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/public/interfaces/bindings/tests/test_structs.mojom
//

package test_structs

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	ioutil "io/ioutil"
	rect "mojo/public/interfaces/bindings/tests/rect"
	fmt "fmt"
	bytes "bytes"
	base64 "encoding/base64"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
	gzip "compress/gzip"
)

// This global variable contains a mojom_types.RuntimeTypeInfo struct
// describing the types defined in this file and all of its imports as
// well as the top-level interfaces defined in this file.
var runtimeTypeInfo__ = mojom_types.RuntimeTypeInfo{}

func getRuntimeTypeInfo() mojom_types.RuntimeTypeInfo {
  if runtimeTypeInfo__.TypeMap == nil {
    initRuntimeTypeInfo()
  }
  return runtimeTypeInfo__
}

func initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this file.
  // The string contains the base64 encoding of the gzip-compressed bytes.
  serializedRuntimeTypeInfo := "H4sIAAAJbogC/+yda3Abx33A7/AgQYqSIFmiqMhyEFmRaTsm8eADTNuYskWVqi2JkWSZbtKQIHEUYJMADIA15TYN0yQzmj7Vt780Zd9qZzpl+phqpjMdfavSNi2nHzr8yI/8VjbtpGynbXpH/Je8W+ze3e4d9pYmMQOtDtwF7n77+u///9//9iiNVxzSJKT45yiNYSmer9LWSLf193P6ewvlUxvpKKQFSD+C9DGkG5DGQ400C+kkpMuQrkD6FNJNSGNheA5IJyFdhvQRpGuQbkPaE4H7g7QA6QNIVyFdh3Qb0kS0kY5D+pL+vqC/77wzMTb1xtg7n10ov1vuq2u1et/lajV3/25uflG7c7+i1Rr5X9TfnyLnf61Y3ysC2ZXP6O+L5Pyvl0v1XLFUu1aqa9W53Kxm5M/o75dd5r+lva//UH3nd3qNZ7Mvd7Ne0Ko293MlV62/od3/oFzN365XF2d3vnhQf7/iMn8fXNWgzKcp5bS53OJ8/WpRm8/vsroE7Y+Qf2yhUr+P7sjm/q/Ol3P1G4sLM1p1rwpe0N+fJOcfz5Xy8xp8cR/cAyGfwfueVrV+s839Xs9VdBDQZmzqRc+317pseF3XYRXvatVasVzarZh+eDZX+e8mGfOnGPNnGPMPMuYftuN9I7eg5W9p9/TstlxulAktzy7/4vx8bmZes7ST5/W858j5b2mz9Ylcseo0rtyeLVe0vN4ra/VcqV7bG8d7XeXvGzMajE27ul1e0HbHCLv72Hmim3ON1Hl8e6ukE8ay2/F7q1Qr3itpeUvH2VQb9WjMP8bUsa7uzUfGf5Od1uv4Kev1027r9fYnrNfZ89b5bfR56993IJuvX8V+f9R6XbmF5b9rvZ7+0Hq9+jPW65VvWq+X/9h63fMn1uulb2Hf/1fW642/sV6Pfxv7vu9Yrwv/ivH6LvZ937PyGo+qu9fGVLvapWL1sXdtTOGJ89a/L3+6cZ3A5I0Y1HMvCCKAefeF5Bj0+ffhNamQX2f093H9jU/SRts9q78dpvEmOehP9Xe7/v6i0ZaNdl3Qe1F/ZXahXC3WP+zXv+KV2XJV669VZ/uN7+6vLM7MF2f7i6ij1fpniqV8sXSv1m/8bOPfqVqjs/QZRRZ25CP93WZ63gngUgF56GHYKr+sRa1csqb7DpnkNacXjbdi4m3qHk2vTvi9uSSZ36r+PiaAXwK7Z/T7YYWPU4yDk+qGU4rM6VvQboPiFOHkFOfgFHLDKU3m9GcBc4pycurh4BR2wylD5vTnAXNq4+SU4OAUccNpgMzpLwLmFOLk1MvBKeqG0yCZ01/C/4PipCpW+SRG6FdtJn64nIG+YLWDTc6YoPDqhnkNX9wn4Ddpy3+ca1oVI1+MghyD+EwCjyVogB/BRPkY6UVgoMu27w85I6M/zwnB7VO1mf9klTMGAuDU7gMn0XLGYACcOnzgJFrOGFKDle+VfSJnDOucTgfEKWQaZ/zmKFoOyaqNuVcWjqpPHJMcHNvccBwicxxRG/oQmTiGCOOfnbzXbuKEy3txkG8ehOx5jmPy3jSFp8HKmA+Ixhn9hfS/DmacpnooCZL/cI6k9hkFe5+f8lzSQX6u6Y87VdxDhPMpq+LXHebfR58bY/dR/W1Rotvb1yxZ7dqxSvi9HszeihQ0bttxwWbe6yG1YzAaIruAS/NiU30tCWrPPdh4UVHt27WodcoR0DlWtfeJfO4LlitDLWrPrONHhHOdQxs/DPNPlzF+gjFuCoDjvD/Uv+SkQN7hAMaPkM34oWB+GF71Hug5LM4DYEs/Qxw3GjnweqlLNO+Z9bqtHh+Owm+VgRvOZVFt3KtoLm7nIzTOrkf55Ko1ilxFdDIhylXknDjHLwuchxQXciuvv0wCxhT0O8uq1U8q6PkOtefcB7lincDja2pjTgxKfjPfj1EXCC1vfbDyjrRIv1eskeWvrx9w3jGf9YTHYZ1Z1eqFavmDJt7f+JjxtpsXzONQk7+pas876+C/8YTyHMivz+XtN93XTwmaB1j9J/FxPQv8JkJWvVqCc/zOutRroPH78tuXrxl80uCj5oZ3HypE4P4VtTH2tZq7EydV8dYu8XH32u3GNfJvc8VJL4TzWZaET8indoTGyVtjd8Zv3XxbGYA+4YoPKkRoR18VxIkm5651+yPnGu6IxjqU6OQMY8ezVl7EnDifLyhi5Vx8nsXnCzR+uPLv7nvvarkM/m2wDngA3/MI+O/uC4CFdQzWHb3gYDIO9ukC3MADsO8/An/Rp0egfBeUPwblj0M+ANl7EvrlM/brRHz+3QjI3v1jirj1M17fpHEV5xSmcFIF27u/FCAng0HegVM7hVNIsL17ShGnd+DhFKFwigi2d09LzilG4dQm2N6dA38GWTlFKZxigu3ZM5K3pw4Kpy7B9upZydtTG4UTj99SuxtOw2ROecnbUyeFE4/fUswNpyyZkyZ5ewpROPH4LXW44TRC5jQneXuicbrIwanThV13LpUkcroXIKc9mfqdURonlcKJx3/riCtOKSKnguT9jsaJxz+ryxWnNJFTMUBOTu1JNenfUfktLB8Lp6OuOGWInN4VzMnJLw3Xy3fBGgVpOnj1I6z1MMpRD8dc1cMA8Xnfg7lEVD2oEtVDFKsH1WQPGeeoh+Ou6mGQ+LzzgvQdTvYoxNvY/K6Y/EMo++Md/RJpfCc4+MZd8R0i8l0QNM8nKPORV7529r0ToN+w8yNSVH/8iJ4B1pYgHvrrPPgYUcJ8NNXHJUHt3Q0/cz6c3zQoROMn/fWbIQY3IfrNkHPiPP86YHvCJMwjqN0sQboC6VNsnqPFI3qIxSOyiUfRBKbPPi4KIX+KMX+aMX+GMf8AY/5BxvxDjPmHGfNnGfOPNLUbVO8J6Hco/tMWKP4mQfH+BBpeLygmHoK9aLuLb50g2g70twLlXzdyFrrfu0m+fsfKW/T+yaey8k7x8E4x8xa9D/PbsvJO8/BOM+uxRO/n/DslWP9jKu8MD+8MM+9nBdvJ/l5W3gM8vAeE6LO92Nv+QVbegzy8B4Xoxb3Y7b4jK+8hHt5Digj9uhf73z/KOl8O8/AeFqKn92JH/CdZeWd5eGeZeWcF2yPXZOU9wsN7xFaf1GnSB9H0cUiv5FUfh/ZTWoKaKo2YnN0WPZI1B86lVwlm/2/CZv9vRBG3H6oDqqZAaTcvwmci7SSqEnxcIuQfnjNCYU0Vmri8BG0tiHgUEYLfHGLntO+2h9I/k+AQlLzoj773HOjMiUGnlUaM6POWfkrOiXP/l4D1vY9g7FnBnxv6M7LzTGN63SeQbiE9Hwi8E1h8+VVINyCNo/ES0gqkK1g8eeRYmoQ0BX3XXRzwPqT+Yi6X4iyX5iyX4Sw3wFlukLPcEGe5Yc5yWc5yIAbY2ZfJ9Z7kLJfiLJfmLJfhLDfAWW6Qs9wQZ7lhznJZznIj5HEQxWtA511swTg0DfPKGorLCA66q2C/SIDd4uFR08RrjHMw4G+cgHES9rk8gTjqSdjntHIGfv8s/D7EUd86Z28PCUtiD9lSgokr4dYewjuPsHIXvc/m32TlnvI2D7NyF71v57uyck97k2NYuYcF20n+XVbuGW9yICv3iGB7yX/Iyn3AmxxN407b99Ym2G7yPcntJrzrEFbuMcH2k/+U3H7Cu45j5d4p2I6yLSv3YW/rYFbuXYLtKf8lK/esNz0CK/djgu0q/y0r9xFvehga96iP/k1e9o39j2Tc0f0ihRSvHouV+ykO7l72of2vtNxTnvSArNx5/Mu87Gv7P2m5pz3pUVm58/iZedkn931puWc86aFZufP4m3nZF6eosnIf8KTHp3Fv89EPyss+uJC03Ac92UFYufP4Q3nZHxeWlvuQJzsSK3cev6gTrrgPE583Ii33YU92OFbuoxzcT7riniU+b1Ra7llPdkxW7jz7nJ9xxX2E+Lxt0nIf8WQHtvM3MtZIkw7+gIm4P/6AaH+u5dB6hbQ/15oD5/OzgvT1BdBVIf+pXT8hMMhtgQEjAYLhBDTkZbCjrwLwDbCnx2Ef4CgowCpH6f0irMhzDuLPKWLOu8DvO+5wzcpN9L6+nw+YW5hyzcpN9P68X4BxKShu7ZRrVm6i99n9YsDcIpRrVm4JwfZfI05wd4DcYpRrVm6iz038pYDbW5RyzcpN9DmJvxxwe+ugXLNyywq2n/5KwO2tjXLNym1UsP3zVwNub52Ua1Zu44Ltl78WcHsLUa5ZuU0Itj/+esDtTaVcs3KbFGw//I0AuanY/aiK/TlkpPIk/UKXsrdvjaZfePKMP/oFdI7g9VxlRwWC9AfN5whac+DP+ZsB6RfW0H5DWKitggCdgIlmFfPPX4OBdBr0CXFw8JgG//y1+P7QL3wTdEAytPuQTbtPEGwaqkLe57cf9BO/pYjZH+kXd7VF3EXrN1b2GXen9q7uE/3Ib8Mz7SfuIcL86rW9i9av/A6U3Y/tPaQ0x99UW1QvovU3vwv2pP1UL6opf0xQfxGtH/o9kGVlqJeoy3mZZL9kjScsu/7p95VGDFwZ6iVsUy9+r+9k12/9wT4cx9D8EjaNU0HXm2j92h9KpO+ItJCraP3bo328no74OG+L1t/90cdofogI0P/FQXDY9Yuh3CctnhH+QufhXl+crxfvatVasVwyHQNAOA+XnBN/7s8JOu97FPSOqH0vA58eFFcI9IHrYOjMgj5wOUbvH2a7qFs9Hyq/RNHzVWz0KKpCP68AtUv0OglzxPViCeqg8TmK6zU3pRPMpJvq41W1IUeKqA+cp8Eyq9rr71QGnqoPPFUHnsfAVjk3VdVI8fVGBfEUsV5QberHyQ9qiaLn81o/YYf6icN3zBnIdIp4/VxWG2dziD4HicQ3ZMO3x8EPY4miz/PKN+p6PNmJFNjU/l9TxcYJNOux7dojmodHKbyRf1U7A+8I4XNW3u0OvLthzJmbWtBqtdw9bapSrGjN487raiOuqQxxK+1eCQ7OUR/adbvrcX2mXJ5v5ntFFbO+ovGMUJ7/AqQdDDzbfODZwSJ3pIaaeI4JmiezUK+4/RutI5H8i3gsE+RulTC/qth6rMc0/oQJ3KJQh73Y5+3Y/fWY6rPd9DlN3i+E/JH3DVn+FFHeb4Q4uwR2Njt538iJ1/O4Gkw8oIMiv18T1I/s1qXm/kFdl0Za3k5TrttpqrmdvqkGExd7Uj1Y7fX64XrT1/XmjX263myKD88579LGm6Voy8ebjOvxJtNcb59XxZ0Da9Zfojjd26GDNe7cOhx3fB13bh/quaTWc90JSM+Fjze9GC+/1lW0cX+rreXj/qDrcX+wud+8LWjc74V+gTihc3dRw5qMHKzxf/Jw/Pd1/H/ncPyXevz/0UM7R0vtHF+QxM6Bj/M0PWer9Zm0+fhxR8vn42HX8/Fw8zj2JUHzMa6HXkJ6MajIAszHa9Awk+0Ha36eOpyffZ2fpw/nZ6nn59zh/NzS+Xnm0A8hED+E2UM/hJb6IeRVcX7eUYL+BslryB+4ELC9vMluAP1qxadzd1GcvRu5BS1/S7uHKqo5zp41B15vzyrynbtr/EnUvnUkB5R0SgqBz3noD7LMh6L2lR+Ftm5IcaT4jM/BXBfEPBZVyPsC/ZDzeM/tRevKxAV/15U3yle0uZy+ZLxa1Obzewf3Nq8ryTnxehsW1N+3oO9swu9uAp9NsO9twji4CYLFJghWm6An34QJaRMqYhPW65sQD2MT9hNsQ1yMGMTF6IG4GL3wwFk4t3L8JMwPEIekAAdHLJ1upA/gHMuP4BzLRwBuHc6zjME5llkIwF8430ifPme/HlYEjWNO8Teyirj9DSQOYcp9iz5vciRgDu2U+xZ9/uNnFTFxkGkcaH6jPOcCeokX8QMBc4hR7pvnnD4v8Rt+UGn4dgbFIeqjXOMlXsIPBdweOmzkVFYOXuITfC7g9tCm2OvVWDh4iQfwasDtoVOx13+xcPCy/3404PYQctCXsHDwsp/9csDtgaKe44or42X/+WsBtgc7/QBPHBcv+8FfF8TBzT55Oy48cVS8nNd2RSK9ScSGy0UOLl7OUxtTxO2LMK+xWLmMcnDxct7ZVUVMPIs4tuZi5XKFg4uX88h+OAAuYQ4uPHFlvJwXNg6fyWDPsePyJgcXL+d5XVPE2BfjmP2ElQtPvBwv5239SABcePrRHQ4uXs7DekMi+cWOC0+cn1NuuKTJ8u2b+0R++SIHl9OuuJDl3euCx12kE2TlMs3BpdsVF7K8e0MR7zcT4bATFji4nHHFhSzv3oT/i7ITmmUL1vigdtwqHNx6XHEjy8PG/HhCIm68duklDm5nXXEjy8ufF8xNbVF7W+bg9glX3Mjy9C1FzDl2brnZtbeoDbcHHNzOueJGlrdvKw3fKJH91Pz76HPkDzS2UKnfNwXEQ34CBH8HS1ZWzg85OD/rijNZfr8TgL9JKzjb+ZcY6/wVB/+S6bDP/iWL8/O5mXltPFfKz2t7D0TwLyHmxOvpFUU+fzI7OdFvP4wOqF/c/xDdZ59Eeguz3RU/lznis18G8sPK5+o5Epd+Rdy5zAo23xj39c8Rqx6d5v9FiwuxDeljh/6ZxfrnuI2d07gHwyltIlesorinVnc14y/kdvapgPrhtMo3b/vdD5H/4lyxWqsT+FwQ1N5o84mf+1DsuPrtF4r8wGvabLmUb+b6/D7lyuv3uQE3kD1mz3cU6/dIn/UUy38G5Jzbs+WKln+9XKrVc6V6bac/n7X0fzwHeRxYFDgO4Pp50niahLZFqAfsgfrGjJPb8PEla5pHL7n7njtjNxTF0E687C7/5Tdv35zaKaQ0x2uOgSPCOozzj2ACXQLHvnFw4FntdDcOmuPztmIcdPIL/Yrg/qpQ+isar3cqnaOd0M6L6aH4iSAuY0m+dslar37LU05+rssHrF5VvF5TYuqVZ3714rf71QNWryG8XtNi6pXH39KLH/JPH7B6DeP1mhFTrzz+o178qr92wOo1gtfrgH/1aqevOMVRr178xL8uUF9BWpfg9Yv0p0huZZWPWXnz+B978Uf/hmS8kX4GLRZ41xd2606z3zp+H70qm54J97d5TBkXXoC1skP3bLqfJUHrzJdAd+PMeY+HuZ+jeWASBItlmIi2YeDqpawX3K7LspR1vuKw/kDP5cC9b4yyjrsPY6+I+H12fFS/+aQY+VDWQx8GxGdX36zuPZevfNKMfCjrip8QxAfFm0AcSLxCreSVYeRFkdd/UhCvVq+LnPrzEb/5DzDyp8jVXw56vFPdzQejDvMwep2Gufi2/hjX0D2a9NYmTpYcOJd3VTF+iz02encVW4eY5RucJ4oPUAnz6T2TFJ4ojo1B67pWL5Tz5Hb0ntpol6L7MXruiZD75zVeWcrzIvvg3vO+UtXeX9RqdfJzo5cM55+ItAsiu1AFLKek9tAtwXodt/8adrVzdPvVriGY9zwU1B4nfWqP58BXxtIeaxV9dNf2RXvc9rk9Oo1T5XpBq05VqPZ8o12+eADbJZIDN2J89lWFZl/defCbc42UaF/FcpDr5ZSgdS++jn2A7A8wby7D+jXRJsc4i+S9EqU9n5bMbxKPo2bjz2fJSuIsMk4Xms9yUyXifNYNrIPwI3cTpyuoeoj7bLfbq4dqhVQPZxSx/tWs9eB1fCfxtzu3vcdn+xryS1qYKuXnfpy8Pgnq3HZF2Ytn4rY+0HM6xYHrB50tqX+QirDWU8JnexnqJwtThRqpn5yF9rZf6ilhkgOMZ8P9qJE+nVA/lqx28lFUaT6HE/3+tk/6BxRH962SPpyahJ4E/ObebVtz4PdzBBiKlocqIA+tw/olC/LQkyhdz2j8aV2w3NP1MZF7aHrbdZd2AL/km6MHRL5x4h0SJMcc+5jLMSTOYRPnsCB55fihvLJTxKk+IoLkkvgBlUtwfUwSgCe77bnT9qGtYflRe3mrVCveK2n5G4sLM1rVLs4xOWfTPKuK9XvH1/cF4I6eG+2XfAIpkrfRvrUJSJchXUV6L+S3hvSykFYgTYMtjVCPJFB9d5Oc5VKc5dKc5TKc5QY4yw1ylhviLDfMWS7LWQ7iGdr4KVHqPclZLkXsB2vIbwkm0lVMb/kQBUiGfRQVcADYAEP0xFHoR7DfJhmn6zuRDxXJf61V+k7aPovnVLn819D9co8HST7uouN9f1JW7ilv4zArd9HxxROyck97m8do3GMU7qLjmV9QxcXzYuKe8SYHsHIXHT/9eVm5D3iTo1i5i47XflFW7oPe5FAa9w4Kd9Hx4S/Jyn3ImxzPyl10PPoXZOU+7G0dxMqdZ7+Pl/j3vbJyz3pbR9K4d1K489htvcTbf0lW7iPe1uGs3HnssF7i+78sGXd0v/z6iCQXd55zFbycJ/AZabmnPOmB7OzbXab6+P8AAAD//85rgqGQRAEA"

  // Deserialize RuntimeTypeInfo
  compressedBytes, err := base64.StdEncoding.DecodeString(serializedRuntimeTypeInfo)
  if err != nil {
    panic(fmt.Sprintf("Error while base64Decoding runtimeTypeInfo: %s", err.Error()))
  }
  reader, err := gzip.NewReader(bytes.NewBuffer(compressedBytes))
  if err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  uncompressedBytes, err := ioutil.ReadAll(reader)
  if err != nil {
     panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  if err = reader.Close(); err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  decoder := bindings.NewDecoder(uncompressedBytes, nil)
  runtimeTypeInfo__.Decode(decoder)

  for s, udt := range rect.GetAllMojomTypeDefinitions() {
    runtimeTypeInfo__.TypeMap[s] = udt
  }


}
func GetAllMojomTypeDefinitions() map[string]mojom_types.UserDefinedType {
  return getRuntimeTypeInfo().TypeMap
}

type ScopedConstants_EType int32

const (
	ScopedConstants_EType_E0 ScopedConstants_EType = 0
	ScopedConstants_EType_E1 = ScopedConstants_EType_E0 + 1;
	ScopedConstants_EType_E2 = 10
	ScopedConstants_EType_E3 = ScopedConstants_EType_E2
	ScopedConstants_EType_E4 = ScopedConstants_EType_E3 + 1;
)
// ScopedConstants_ETypeMojomType returns the UserDefinedType that describes the Mojom
// type of ScopedConstants_EType. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func ScopedConstants_ETypeMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.ScopedConstants.EType"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ScopedConstants_EType) MojomType() mojom_types.UserDefinedType {
	return ScopedConstants_ETypeMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ScopedConstants_EType) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type DartKeywordStruct_Keywords int32

const (
	DartKeywordStruct_Keywords_Await DartKeywordStruct_Keywords = 0
	DartKeywordStruct_Keywords_Is = DartKeywordStruct_Keywords_Await + 1;
	DartKeywordStruct_Keywords_Rethrow = DartKeywordStruct_Keywords_Is + 1;
)
// DartKeywordStruct_KeywordsMojomType returns the UserDefinedType that describes the Mojom
// type of DartKeywordStruct_Keywords. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func DartKeywordStruct_KeywordsMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.DartKeywordStruct.Keywords"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*DartKeywordStruct_Keywords) MojomType() mojom_types.UserDefinedType {
	return DartKeywordStruct_KeywordsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*DartKeywordStruct_Keywords) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type SomeInterface interface {
	SomeMethod(inPair RectPair) (outOtherPair RectPair, err error)
}


// SomeInterfaceMojomType returns the UserDefinedType that describes the Mojom
// type of SomeInterface. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func SomeInterfaceMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.SomeInterface"]
}




type SomeInterface_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*SomeInterface_Request) MojomType() mojom_types.UserDefinedType {
	return SomeInterfaceMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*SomeInterface_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type SomeInterface_Pointer bindings.InterfacePointer


type SomeInterface_ServiceFactory struct{
	Delegate SomeInterface_Factory
}

type SomeInterface_Factory interface {
	Create(request SomeInterface_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *SomeInterface_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &SomeInterface_ServiceDescription{}
}

func (f *SomeInterface_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := SomeInterface_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForSomeInterface creates a message pipe for use with the
// SomeInterface interface with a SomeInterface_Request on one end and a SomeInterface_Pointer on the other.
func CreateMessagePipeForSomeInterface() (SomeInterface_Request, SomeInterface_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return SomeInterface_Request(r), SomeInterface_Pointer(p)
}

const someInterface_SomeMethod_Name uint32 = 0

type SomeInterface_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewSomeInterfaceProxy(p SomeInterface_Pointer, waiter bindings.AsyncWaiter) *SomeInterface_Proxy {
	return &SomeInterface_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *SomeInterface_Proxy) Close_Proxy() {
	p.router.Close()
}

type someInterface_SomeMethod_Params struct {
	inPair RectPair
}


func (s *someInterface_SomeMethod_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inPair.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var someInterface_SomeMethod_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *someInterface_SomeMethod_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(someInterface_SomeMethod_Params_Versions), func(i int) bool {
		return someInterface_SomeMethod_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(someInterface_SomeMethod_Params_Versions) {
		if someInterface_SomeMethod_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := someInterface_SomeMethod_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inPair.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type someInterface_SomeMethod_ResponseParams struct {
	outOtherPair RectPair
}


func (s *someInterface_SomeMethod_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.outOtherPair.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var someInterface_SomeMethod_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *someInterface_SomeMethod_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(someInterface_SomeMethod_ResponseParams_Versions), func(i int) bool {
		return someInterface_SomeMethod_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(someInterface_SomeMethod_ResponseParams_Versions) {
		if someInterface_SomeMethod_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := someInterface_SomeMethod_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.outOtherPair.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *SomeInterface_Proxy) SomeMethod(inPair RectPair) (outOtherPair RectPair, err error) {
	payload := &someInterface_SomeMethod_Params{
		inPair,
	}
	header := bindings.MessageHeader{
		Type: someInterface_SomeMethod_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, someInterface_SomeMethod_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response someInterface_SomeMethod_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outOtherPair = response.outOtherPair
	return
}

type someInterface_Stub struct {
	connector *bindings.Connector
	impl SomeInterface
}

func NewSomeInterfaceStub(r SomeInterface_Request, impl SomeInterface, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &someInterface_Stub{connector, impl})
}


func (f *SomeInterface_Request) ServiceDescription() service_describer.ServiceDescription {
	return &SomeInterface_ServiceDescription{}
}


type SomeInterface_ServiceDescription struct{}

func (sd *SomeInterface_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *SomeInterface_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *SomeInterface_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*SomeInterface_ServiceDescription)(nil)


func (s *someInterface_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case someInterface_SomeMethod_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request someInterface_SomeMethod_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response someInterface_SomeMethod_ResponseParams
		response.outOtherPair, err = s.impl.SomeMethod(request.inPair)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: someInterface_SomeMethod_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type StructOfStructs struct {
	Nr NamedRegion
	ANr []NamedRegion
	ARp []RectPair
	MNdfv map[int64]NoDefaultFieldValues
	MHs map[int64]HandleStruct
}
// StructOfStructsMojomType returns the UserDefinedType that describes the Mojom
// type of StructOfStructs. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructOfStructsMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructOfStructs"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructOfStructs) MojomType() mojom_types.UserDefinedType {
	return StructOfStructsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructOfStructs) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructOfStructs) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(40, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.Nr.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.ANr)), 64)
	for _, elem0 := range s.ANr {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.ARp)), 64)
	for _, elem0 := range s.ARp {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []int64
		var values0 []NoDefaultFieldValues
		if encoder.Deterministic() {
		  for key0, _ := range s.MNdfv {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]NoDefaultFieldValues, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.MNdfv[key]
		  }
		} else {
		  for key0, value0 := range s.MNdfv {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WriteInt64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem1.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []int64
		var values0 []HandleStruct
		if encoder.Deterministic() {
		  for key0, _ := range s.MHs {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]HandleStruct, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.MHs[key]
		  }
		} else {
		  for key0, value0 := range s.MHs {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WriteInt64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem1.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structOfStructs_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{48, 0},
}

func (s *StructOfStructs) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structOfStructs_Versions), func(i int) bool {
		return structOfStructs_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structOfStructs_Versions) {
		if structOfStructs_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structOfStructs_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.Nr.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.ANr = make([]NamedRegion, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := s.ANr[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.ARp = make([]RectPair, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := s.ARp[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []int64
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]int64, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadInt64()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []NoDefaultFieldValues
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([]NoDefaultFieldValues, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							if err := values0[i1].Decode(decoder); err != nil {
								return err
							}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[int64]NoDefaultFieldValues)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.MNdfv = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []int64
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]int64, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadInt64()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []HandleStruct
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([]HandleStruct, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							if err := values0[i1].Decode(decoder); err != nil {
								return err
							}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[int64]HandleStruct)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.MHs = map0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type NamedRegion struct {
	Name *string
	Rects *[]rect.Rect
}
// NamedRegionMojomType returns the UserDefinedType that describes the Mojom
// type of NamedRegion. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func NamedRegionMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.NamedRegion"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*NamedRegion) MojomType() mojom_types.UserDefinedType {
	return NamedRegionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*NamedRegion) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *NamedRegion) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.Name == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.Name)); err != nil {
			return err
		}
	}
	if s.Rects == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.Rects))), 64)
		for _, elem0 := range (*s.Rects) {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem0.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var namedRegion_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *NamedRegion) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(namedRegion_Versions), func(i int) bool {
		return namedRegion_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(namedRegion_Versions) {
		if namedRegion_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := namedRegion_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Name = nil
		} else {
			s.Name = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.Name) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Rects = nil
		} else {
			s.Rects = new([]rect.Rect)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.Rects) = make([]rect.Rect, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := (*s.Rects)[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type RectPair struct {
	First *rect.Rect
	Second *rect.Rect
}
// RectPairMojomType returns the UserDefinedType that describes the Mojom
// type of RectPair. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func RectPairMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.RectPair"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*RectPair) MojomType() mojom_types.UserDefinedType {
	return RectPairMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*RectPair) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *RectPair) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.First == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.First).Encode(encoder); err != nil {
			return err
		}
	}
	if s.Second == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.Second).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var rectPair_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *RectPair) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(rectPair_Versions), func(i int) bool {
		return rectPair_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(rectPair_Versions) {
		if rectPair_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := rectPair_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.First = nil
		} else {
			s.First = new(rect.Rect)
			if err := (*s.First).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Second = nil
		} else {
			s.Second = new(rect.Rect)
			if err := (*s.Second).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type EmptyStruct struct {
}
// EmptyStructMojomType returns the UserDefinedType that describes the Mojom
// type of EmptyStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func EmptyStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.EmptyStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*EmptyStruct) MojomType() mojom_types.UserDefinedType {
	return EmptyStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*EmptyStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *EmptyStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var emptyStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *EmptyStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(emptyStruct_Versions), func(i int) bool {
		return emptyStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(emptyStruct_Versions) {
		if emptyStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := emptyStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type HandleStruct struct {
	H *system.MessagePipeHandle
	ArrayH []system.MessagePipeHandle
}
// HandleStructMojomType returns the UserDefinedType that describes the Mojom
// type of HandleStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func HandleStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.HandleStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*HandleStruct) MojomType() mojom_types.UserDefinedType {
	return HandleStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*HandleStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *HandleStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.H == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.H)); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.ArrayH)), 32)
	for _, elem0 := range s.ArrayH {
		if err := encoder.WriteHandle(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var handleStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *HandleStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(handleStruct_Versions), func(i int) bool {
		return handleStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(handleStruct_Versions) {
		if handleStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := handleStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.H = &handle0
		} else {
			s.H = nil
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.ArrayH = make([]system.MessagePipeHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadMessagePipeHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					s.ArrayH[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type NullableHandleStruct struct {
	H *system.MessagePipeHandle
	Data int32
}
// NullableHandleStructMojomType returns the UserDefinedType that describes the Mojom
// type of NullableHandleStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func NullableHandleStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.NullableHandleStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*NullableHandleStruct) MojomType() mojom_types.UserDefinedType {
	return NullableHandleStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*NullableHandleStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *NullableHandleStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if s.H == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.H)); err != nil {
			return err
		}
	}
	if err := encoder.WriteInt32(s.Data); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var nullableHandleStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *NullableHandleStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(nullableHandleStruct_Versions), func(i int) bool {
		return nullableHandleStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(nullableHandleStruct_Versions) {
		if nullableHandleStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := nullableHandleStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.H = &handle0
		} else {
			s.H = nil
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Data = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type NoDefaultFieldValues struct {
	F0 bool
	F1 int8
	F2 uint8
	F3 int16
	F4 uint16
	F5 int32
	F6 uint32
	F7 int64
	F8 uint64
	F9 float32
	F10 float64
	F11 string
	F12 *string
	F13 system.MessagePipeHandle
	F14 system.ConsumerHandle
	F15 system.ProducerHandle
	F16 *system.MessagePipeHandle
	F17 *system.ConsumerHandle
	F18 *system.ProducerHandle
	F19 system.Handle
	F20 *system.Handle
	F21 system.SharedBufferHandle
	F22 *system.SharedBufferHandle
	F23 []string
	F24 []*string
	F25 *[]string
	F26 *[]*string
	F27 EmptyStruct
	F28 *EmptyStruct
}
// NoDefaultFieldValuesMojomType returns the UserDefinedType that describes the Mojom
// type of NoDefaultFieldValues. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func NoDefaultFieldValuesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.NoDefaultFieldValues"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*NoDefaultFieldValues) MojomType() mojom_types.UserDefinedType {
	return NoDefaultFieldValuesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*NoDefaultFieldValues) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *NoDefaultFieldValues) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(152, 0)
	if err := encoder.WriteBool(s.F0); err != nil {
		return err
	}
	if err := encoder.WriteInt8(s.F1); err != nil {
		return err
	}
	if err := encoder.WriteUint8(s.F2); err != nil {
		return err
	}
	if err := encoder.WriteInt16(s.F3); err != nil {
		return err
	}
	if err := encoder.WriteUint16(s.F4); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.F5); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.F6); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.F7); err != nil {
		return err
	}
	if err := encoder.WriteUint64(s.F8); err != nil {
		return err
	}
	if err := encoder.WriteFloat32(s.F9); err != nil {
		return err
	}
	if err := encoder.WriteHandle(s.F13); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.F10); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.F11); err != nil {
		return err
	}
	if s.F12 == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.F12)); err != nil {
			return err
		}
	}
	if err := encoder.WriteHandle(s.F14); err != nil {
		return err
	}
	if err := encoder.WriteHandle(s.F15); err != nil {
		return err
	}
	if s.F16 == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.F16)); err != nil {
			return err
		}
	}
	if s.F17 == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.F17)); err != nil {
			return err
		}
	}
	if s.F18 == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.F18)); err != nil {
			return err
		}
	}
	if err := encoder.WriteHandle(s.F19); err != nil {
		return err
	}
	if s.F20 == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.F20)); err != nil {
			return err
		}
	}
	if err := encoder.WriteHandle(s.F21); err != nil {
		return err
	}
	if s.F22 == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.F22)); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F23)), 64)
	for _, elem0 := range s.F23 {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F24)), 64)
	for _, elem0 := range s.F24 {
		if elem0 == nil {
			encoder.WriteNullPointer()
		} else {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString((*elem0)); err != nil {
				return err
			}
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.F25 == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.F25))), 64)
		for _, elem0 := range (*s.F25) {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if s.F26 == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.F26))), 64)
		for _, elem0 := range (*s.F26) {
			if elem0 == nil {
				encoder.WriteNullPointer()
			} else {
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				if err := encoder.WriteString((*elem0)); err != nil {
					return err
				}
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.F27.Encode(encoder); err != nil {
		return err
	}
	if s.F28 == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.F28).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var noDefaultFieldValues_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{160, 0},
}

func (s *NoDefaultFieldValues) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(noDefaultFieldValues_Versions), func(i int) bool {
		return noDefaultFieldValues_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(noDefaultFieldValues_Versions) {
		if noDefaultFieldValues_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := noDefaultFieldValues_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.F0 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt8()
		if err != nil {
			return err
		}
		s.F1 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.F2 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt16()
		if err != nil {
			return err
		}
		s.F3 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint16()
		if err != nil {
			return err
		}
		s.F4 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F5 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.F6 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.F7 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint64()
		if err != nil {
			return err
		}
		s.F8 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.F9 = value0
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.F13 = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.F10 = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.F11 = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.F12 = nil
		} else {
			s.F12 = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.F12) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadConsumerHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.F14 = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadProducerHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.F15 = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.F16 = &handle0
		} else {
			s.F16 = nil
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadConsumerHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.F17 = &handle0
		} else {
			s.F17 = nil
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadProducerHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.F18 = &handle0
		} else {
			s.F18 = nil
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.F19 = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.F20 = &handle0
		} else {
			s.F20 = nil
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadSharedBufferHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.F21 = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadSharedBufferHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.F22 = &handle0
		} else {
			s.F22 = nil
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.F23 = make([]string, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					value1, err := decoder.ReadString()
					if err != nil {
						return err
					}
					s.F23[i0] = value1
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.F24 = make([]*string, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					s.F24[i0] = nil
				} else {
					s.F24[i0] = new(string)
					value1, err := decoder.ReadString()
					if err != nil {
						return err
					}
					(*s.F24[i0]) = value1
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.F25 = nil
		} else {
			s.F25 = new([]string)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.F25) = make([]string, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					value1, err := decoder.ReadString()
					if err != nil {
						return err
					}
					(*s.F25)[i0] = value1
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.F26 = nil
		} else {
			s.F26 = new([]*string)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.F26) = make([]*string, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					(*s.F26)[i0] = nil
				} else {
					(*s.F26)[i0] = new(string)
					value1, err := decoder.ReadString()
					if err != nil {
						return err
					}
					(*(*s.F26)[i0]) = value1
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.F27.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.F28 = nil
		} else {
			s.F28 = new(EmptyStruct)
			if err := (*s.F28).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type DefaultFieldValues struct {
	F0 bool
	F1 int8
	F2 uint8
	F3 int16
	F4 uint16
	F5 int32
	F6 uint32
	F7 int64
	F8 uint64
	F9 float32
	F10 float32
	F11 float64
	F12 float64
	F13 string
	F14 *string
	F15 rect.Rect
	F16 *rect.Rect
}
// DefaultFieldValuesMojomType returns the UserDefinedType that describes the Mojom
// type of DefaultFieldValues. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func DefaultFieldValuesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.DefaultFieldValues"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*DefaultFieldValues) MojomType() mojom_types.UserDefinedType {
	return DefaultFieldValuesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*DefaultFieldValues) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *DefaultFieldValues) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(88, 0)
	if err := encoder.WriteBool(s.F0); err != nil {
		return err
	}
	if err := encoder.WriteInt8(s.F1); err != nil {
		return err
	}
	if err := encoder.WriteUint8(s.F2); err != nil {
		return err
	}
	if err := encoder.WriteInt16(s.F3); err != nil {
		return err
	}
	if err := encoder.WriteUint16(s.F4); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.F5); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.F6); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.F7); err != nil {
		return err
	}
	if err := encoder.WriteUint64(s.F8); err != nil {
		return err
	}
	if err := encoder.WriteFloat32(s.F9); err != nil {
		return err
	}
	if err := encoder.WriteFloat32(s.F10); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.F11); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.F12); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.F13); err != nil {
		return err
	}
	if s.F14 == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.F14)); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.F15.Encode(encoder); err != nil {
		return err
	}
	if s.F16 == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.F16).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var defaultFieldValues_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{96, 0},
}

func (s *DefaultFieldValues) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(defaultFieldValues_Versions), func(i int) bool {
		return defaultFieldValues_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(defaultFieldValues_Versions) {
		if defaultFieldValues_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := defaultFieldValues_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.F0 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt8()
		if err != nil {
			return err
		}
		s.F1 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.F2 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt16()
		if err != nil {
			return err
		}
		s.F3 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint16()
		if err != nil {
			return err
		}
		s.F4 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F5 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.F6 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.F7 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint64()
		if err != nil {
			return err
		}
		s.F8 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.F9 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.F10 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.F11 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.F12 = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.F13 = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.F14 = nil
		} else {
			s.F14 = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.F14) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.F15.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.F16 = nil
		} else {
			s.F16 = new(rect.Rect)
			if err := (*s.F16).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type ScopedConstants struct {
	F0 ScopedConstants_EType
	F1 ScopedConstants_EType
	F2 ScopedConstants_EType
	F3 ScopedConstants_EType
	F4 ScopedConstants_EType
	F5 int32
	F6 int32
}
// ScopedConstantsMojomType returns the UserDefinedType that describes the Mojom
// type of ScopedConstants. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func ScopedConstantsMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.ScopedConstants"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ScopedConstants) MojomType() mojom_types.UserDefinedType {
	return ScopedConstantsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ScopedConstants) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *ScopedConstants) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WriteInt32(int32(s.F0)); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.F1)); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.F2)); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.F3)); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.F4)); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.F5); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.F6); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var scopedConstants_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *ScopedConstants) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(scopedConstants_Versions), func(i int) bool {
		return scopedConstants_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(scopedConstants_Versions) {
		if scopedConstants_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := scopedConstants_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F0 = ScopedConstants_EType(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F1 = ScopedConstants_EType(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F2 = ScopedConstants_EType(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F3 = ScopedConstants_EType(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F4 = ScopedConstants_EType(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F5 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F6 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type MapKeyTypes struct {
	F0 map[bool]bool
	F1 map[int8]int8
	F2 map[uint8]uint8
	F3 map[int16]int16
	F4 map[uint16]uint16
	F5 map[int32]int32
	F6 map[uint32]uint32
	F7 map[int64]int64
	F8 map[uint64]uint64
	F9 map[float32]float32
	F10 map[float64]float64
	F11 map[string]string
}
// MapKeyTypesMojomType returns the UserDefinedType that describes the Mojom
// type of MapKeyTypes. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func MapKeyTypesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.MapKeyTypes"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*MapKeyTypes) MojomType() mojom_types.UserDefinedType {
	return MapKeyTypesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*MapKeyTypes) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *MapKeyTypes) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(96, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []bool
		var values0 []bool
		if encoder.Deterministic() {
		  for key0, _ := range s.F0 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]bool, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F0[key]
		  }
		} else {
		  for key0, value0 := range s.F0 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 1)
		for _, elem1 := range keys0 {
			if err := encoder.WriteBool(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 1)
		for _, elem1 := range values0 {
			if err := encoder.WriteBool(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []int8
		var values0 []int8
		if encoder.Deterministic() {
		  for key0, _ := range s.F1 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]int8, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F1[key]
		  }
		} else {
		  for key0, value0 := range s.F1 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 8)
		for _, elem1 := range keys0 {
			if err := encoder.WriteInt8(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 8)
		for _, elem1 := range values0 {
			if err := encoder.WriteInt8(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []uint8
		var values0 []uint8
		if encoder.Deterministic() {
		  for key0, _ := range s.F2 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]uint8, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F2[key]
		  }
		} else {
		  for key0, value0 := range s.F2 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 8)
		for _, elem1 := range keys0 {
			if err := encoder.WriteUint8(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 8)
		for _, elem1 := range values0 {
			if err := encoder.WriteUint8(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []int16
		var values0 []int16
		if encoder.Deterministic() {
		  for key0, _ := range s.F3 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]int16, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F3[key]
		  }
		} else {
		  for key0, value0 := range s.F3 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 16)
		for _, elem1 := range keys0 {
			if err := encoder.WriteInt16(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 16)
		for _, elem1 := range values0 {
			if err := encoder.WriteInt16(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []uint16
		var values0 []uint16
		if encoder.Deterministic() {
		  for key0, _ := range s.F4 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]uint16, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F4[key]
		  }
		} else {
		  for key0, value0 := range s.F4 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 16)
		for _, elem1 := range keys0 {
			if err := encoder.WriteUint16(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 16)
		for _, elem1 := range values0 {
			if err := encoder.WriteUint16(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []int32
		var values0 []int32
		if encoder.Deterministic() {
		  for key0, _ := range s.F5 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]int32, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F5[key]
		  }
		} else {
		  for key0, value0 := range s.F5 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 32)
		for _, elem1 := range keys0 {
			if err := encoder.WriteInt32(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 32)
		for _, elem1 := range values0 {
			if err := encoder.WriteInt32(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []uint32
		var values0 []uint32
		if encoder.Deterministic() {
		  for key0, _ := range s.F6 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]uint32, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F6[key]
		  }
		} else {
		  for key0, value0 := range s.F6 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 32)
		for _, elem1 := range keys0 {
			if err := encoder.WriteUint32(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 32)
		for _, elem1 := range values0 {
			if err := encoder.WriteUint32(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []int64
		var values0 []int64
		if encoder.Deterministic() {
		  for key0, _ := range s.F7 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]int64, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F7[key]
		  }
		} else {
		  for key0, value0 := range s.F7 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WriteInt64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WriteInt64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []uint64
		var values0 []uint64
		if encoder.Deterministic() {
		  for key0, _ := range s.F8 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]uint64, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F8[key]
		  }
		} else {
		  for key0, value0 := range s.F8 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WriteUint64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WriteUint64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []float32
		var values0 []float32
		if encoder.Deterministic() {
		  for key0, _ := range s.F9 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]float32, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F9[key]
		  }
		} else {
		  for key0, value0 := range s.F9 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 32)
		for _, elem1 := range keys0 {
			if err := encoder.WriteFloat32(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 32)
		for _, elem1 := range values0 {
			if err := encoder.WriteFloat32(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []float64
		var values0 []float64
		if encoder.Deterministic() {
		  for key0, _ := range s.F10 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]float64, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F10[key]
		  }
		} else {
		  for key0, value0 := range s.F10 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WriteFloat64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WriteFloat64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 []string
		if encoder.Deterministic() {
		  for key0, _ := range s.F11 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]string, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F11[key]
		  }
		} else {
		  for key0, value0 := range s.F11 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var mapKeyTypes_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{104, 0},
}

func (s *MapKeyTypes) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(mapKeyTypes_Versions), func(i int) bool {
		return mapKeyTypes_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(mapKeyTypes_Versions) {
		if mapKeyTypes_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := mapKeyTypes_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []bool
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(1)
					if err != nil {
						return err
					}
					keys0 = make([]bool, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadBool()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []bool
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(1)
					if err != nil {
						return err
					}
					values0 = make([]bool, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadBool()
						if err != nil {
							return err
						}
						values0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[bool]bool)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F0 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []int8
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(8)
					if err != nil {
						return err
					}
					keys0 = make([]int8, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadInt8()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []int8
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(8)
					if err != nil {
						return err
					}
					values0 = make([]int8, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadInt8()
						if err != nil {
							return err
						}
						values0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[int8]int8)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F1 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []uint8
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(8)
					if err != nil {
						return err
					}
					keys0 = make([]uint8, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadUint8()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []uint8
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(8)
					if err != nil {
						return err
					}
					values0 = make([]uint8, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadUint8()
						if err != nil {
							return err
						}
						values0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[uint8]uint8)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F2 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []int16
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(16)
					if err != nil {
						return err
					}
					keys0 = make([]int16, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadInt16()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []int16
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(16)
					if err != nil {
						return err
					}
					values0 = make([]int16, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadInt16()
						if err != nil {
							return err
						}
						values0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[int16]int16)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F3 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []uint16
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(16)
					if err != nil {
						return err
					}
					keys0 = make([]uint16, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadUint16()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []uint16
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(16)
					if err != nil {
						return err
					}
					values0 = make([]uint16, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadUint16()
						if err != nil {
							return err
						}
						values0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[uint16]uint16)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F4 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []int32
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(32)
					if err != nil {
						return err
					}
					keys0 = make([]int32, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadInt32()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []int32
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(32)
					if err != nil {
						return err
					}
					values0 = make([]int32, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadInt32()
						if err != nil {
							return err
						}
						values0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[int32]int32)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F5 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []uint32
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(32)
					if err != nil {
						return err
					}
					keys0 = make([]uint32, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadUint32()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []uint32
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(32)
					if err != nil {
						return err
					}
					values0 = make([]uint32, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadUint32()
						if err != nil {
							return err
						}
						values0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[uint32]uint32)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F6 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []int64
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]int64, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadInt64()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []int64
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([]int64, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadInt64()
						if err != nil {
							return err
						}
						values0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[int64]int64)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F7 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []uint64
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]uint64, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadUint64()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []uint64
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([]uint64, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadUint64()
						if err != nil {
							return err
						}
						values0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[uint64]uint64)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F8 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []float32
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(32)
					if err != nil {
						return err
					}
					keys0 = make([]float32, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadFloat32()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []float32
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(32)
					if err != nil {
						return err
					}
					values0 = make([]float32, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadFloat32()
						if err != nil {
							return err
						}
						values0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[float32]float32)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F9 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []float64
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]float64, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadFloat64()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []float64
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([]float64, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadFloat64()
						if err != nil {
							return err
						}
						values0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[float64]float64)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F10 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							values0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string]string)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F11 = map0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type MapValueTypes struct {
	F0 map[string][]string
	F1 map[string]*[]string
	F2 map[string][]*string
	F3 map[string][2]string
	F4 map[string][]*[2]string
	F5 map[string][1][2]string
	F6 map[string]*rect.Rect
	F7 map[string]map[string]string
	F8 map[string][]map[string]string
	F9 map[string]system.Handle
	F10 map[string][]system.Handle
	F11 map[string]map[string]system.Handle
}
// MapValueTypesMojomType returns the UserDefinedType that describes the Mojom
// type of MapValueTypes. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func MapValueTypesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.MapValueTypes"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*MapValueTypes) MojomType() mojom_types.UserDefinedType {
	return MapValueTypesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*MapValueTypes) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *MapValueTypes) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(96, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 [][]string
		if encoder.Deterministic() {
		  for key0, _ := range s.F0 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([][]string, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F0[key]
		  }
		} else {
		  for key0, value0 := range s.F0 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(elem1)), 64)
			for _, elem2 := range elem1 {
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				if err := encoder.WriteString(elem2); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 []*[]string
		if encoder.Deterministic() {
		  for key0, _ := range s.F1 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]*[]string, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F1[key]
		  }
		} else {
		  for key0, value0 := range s.F1 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if elem1 == nil {
				encoder.WriteNullPointer()
			} else {
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				encoder.StartArray(uint32(len((*elem1))), 64)
				for _, elem2 := range (*elem1) {
					if err := encoder.WritePointer(); err != nil {
						return err
					}
					if err := encoder.WriteString(elem2); err != nil {
						return err
					}
				}
				if err := encoder.Finish(); err != nil {
					return err
				}
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 [][]*string
		if encoder.Deterministic() {
		  for key0, _ := range s.F2 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([][]*string, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F2[key]
		  }
		} else {
		  for key0, value0 := range s.F2 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(elem1)), 64)
			for _, elem2 := range elem1 {
				if elem2 == nil {
					encoder.WriteNullPointer()
				} else {
					if err := encoder.WritePointer(); err != nil {
						return err
					}
					if err := encoder.WriteString((*elem2)); err != nil {
						return err
					}
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 [][2]string
		if encoder.Deterministic() {
		  for key0, _ := range s.F3 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([][2]string, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F3[key]
		  }
		} else {
		  for key0, value0 := range s.F3 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(elem1)), 64)
			for _, elem2 := range elem1 {
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				if err := encoder.WriteString(elem2); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 [][]*[2]string
		if encoder.Deterministic() {
		  for key0, _ := range s.F4 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([][]*[2]string, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F4[key]
		  }
		} else {
		  for key0, value0 := range s.F4 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(elem1)), 64)
			for _, elem2 := range elem1 {
				if elem2 == nil {
					encoder.WriteNullPointer()
				} else {
					if err := encoder.WritePointer(); err != nil {
						return err
					}
					encoder.StartArray(uint32(len((*elem2))), 64)
					for _, elem3 := range (*elem2) {
						if err := encoder.WritePointer(); err != nil {
							return err
						}
						if err := encoder.WriteString(elem3); err != nil {
							return err
						}
					}
					if err := encoder.Finish(); err != nil {
						return err
					}
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 [][1][2]string
		if encoder.Deterministic() {
		  for key0, _ := range s.F5 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([][1][2]string, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F5[key]
		  }
		} else {
		  for key0, value0 := range s.F5 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(elem1)), 64)
			for _, elem2 := range elem1 {
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				encoder.StartArray(uint32(len(elem2)), 64)
				for _, elem3 := range elem2 {
					if err := encoder.WritePointer(); err != nil {
						return err
					}
					if err := encoder.WriteString(elem3); err != nil {
						return err
					}
				}
				if err := encoder.Finish(); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 []*rect.Rect
		if encoder.Deterministic() {
		  for key0, _ := range s.F6 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]*rect.Rect, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F6[key]
		  }
		} else {
		  for key0, value0 := range s.F6 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if elem1 == nil {
				encoder.WriteNullPointer()
			} else {
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				if err := (*elem1).Encode(encoder); err != nil {
					return err
				}
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 []map[string]string
		if encoder.Deterministic() {
		  for key0, _ := range s.F7 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]map[string]string, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F7[key]
		  }
		} else {
		  for key0, value0 := range s.F7 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartMap()
			{
				var keys2 []string
				var values2 []string
				if encoder.Deterministic() {
				  for key2, _ := range elem1 {
					keys2 = append(keys2, key2)
				  }
				  bindings.SortMapKeys(&keys2)
				  values2 = make([]string, len(keys2))
				  for i, key := range keys2 {
				    values2[i] = elem1[key]
				  }
				} else {
				  for key2, value2 := range elem1 {
					keys2 = append(keys2, key2)
					values2 = append(values2, value2)
				  }
				}
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				encoder.StartArray(uint32(len(keys2)), 64)
				for _, elem3 := range keys2 {
					if err := encoder.WritePointer(); err != nil {
						return err
					}
					if err := encoder.WriteString(elem3); err != nil {
						return err
					}
				}
				if err := encoder.Finish(); err != nil {
					return err
				}
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				encoder.StartArray(uint32(len(values2)), 64)
				for _, elem3 := range values2 {
					if err := encoder.WritePointer(); err != nil {
						return err
					}
					if err := encoder.WriteString(elem3); err != nil {
						return err
					}
				}
				if err := encoder.Finish(); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 [][]map[string]string
		if encoder.Deterministic() {
		  for key0, _ := range s.F8 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([][]map[string]string, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F8[key]
		  }
		} else {
		  for key0, value0 := range s.F8 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(elem1)), 64)
			for _, elem2 := range elem1 {
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				encoder.StartMap()
				{
					var keys3 []string
					var values3 []string
					if encoder.Deterministic() {
					  for key3, _ := range elem2 {
						keys3 = append(keys3, key3)
					  }
					  bindings.SortMapKeys(&keys3)
					  values3 = make([]string, len(keys3))
					  for i, key := range keys3 {
					    values3[i] = elem2[key]
					  }
					} else {
					  for key3, value3 := range elem2 {
						keys3 = append(keys3, key3)
						values3 = append(values3, value3)
					  }
					}
					if err := encoder.WritePointer(); err != nil {
						return err
					}
					encoder.StartArray(uint32(len(keys3)), 64)
					for _, elem4 := range keys3 {
						if err := encoder.WritePointer(); err != nil {
							return err
						}
						if err := encoder.WriteString(elem4); err != nil {
							return err
						}
					}
					if err := encoder.Finish(); err != nil {
						return err
					}
					if err := encoder.WritePointer(); err != nil {
						return err
					}
					encoder.StartArray(uint32(len(values3)), 64)
					for _, elem4 := range values3 {
						if err := encoder.WritePointer(); err != nil {
							return err
						}
						if err := encoder.WriteString(elem4); err != nil {
							return err
						}
					}
					if err := encoder.Finish(); err != nil {
						return err
					}
				}
				if err := encoder.Finish(); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 []system.Handle
		if encoder.Deterministic() {
		  for key0, _ := range s.F9 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]system.Handle, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F9[key]
		  }
		} else {
		  for key0, value0 := range s.F9 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 32)
		for _, elem1 := range values0 {
			if err := encoder.WriteHandle(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 [][]system.Handle
		if encoder.Deterministic() {
		  for key0, _ := range s.F10 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([][]system.Handle, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F10[key]
		  }
		} else {
		  for key0, value0 := range s.F10 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(elem1)), 32)
			for _, elem2 := range elem1 {
				if err := encoder.WriteHandle(elem2); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 []map[string]system.Handle
		if encoder.Deterministic() {
		  for key0, _ := range s.F11 {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]map[string]system.Handle, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.F11[key]
		  }
		} else {
		  for key0, value0 := range s.F11 {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartMap()
			{
				var keys2 []string
				var values2 []system.Handle
				if encoder.Deterministic() {
				  for key2, _ := range elem1 {
					keys2 = append(keys2, key2)
				  }
				  bindings.SortMapKeys(&keys2)
				  values2 = make([]system.Handle, len(keys2))
				  for i, key := range keys2 {
				    values2[i] = elem1[key]
				  }
				} else {
				  for key2, value2 := range elem1 {
					keys2 = append(keys2, key2)
					values2 = append(values2, value2)
				  }
				}
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				encoder.StartArray(uint32(len(keys2)), 64)
				for _, elem3 := range keys2 {
					if err := encoder.WritePointer(); err != nil {
						return err
					}
					if err := encoder.WriteString(elem3); err != nil {
						return err
					}
				}
				if err := encoder.Finish(); err != nil {
					return err
				}
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				encoder.StartArray(uint32(len(values2)), 32)
				for _, elem3 := range values2 {
					if err := encoder.WriteHandle(elem3); err != nil {
						return err
					}
				}
				if err := encoder.Finish(); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var mapValueTypes_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{104, 0},
}

func (s *MapValueTypes) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(mapValueTypes_Versions), func(i int) bool {
		return mapValueTypes_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(mapValueTypes_Versions) {
		if mapValueTypes_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := mapValueTypes_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 [][]string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([][]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							len2, err := decoder.StartArray(64)
							if err != nil {
								return err
							}
							values0[i1] = make([]string, len2)
							for i2 := uint32(0); i2 < len2; i2++ {
								pointer3, err := decoder.ReadPointer()
								if err != nil {
									return err
								}
								if pointer3 == 0 {
									return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
								} else {
									value3, err := decoder.ReadString()
									if err != nil {
										return err
									}
									values0[i1][i2] = value3
								}
							}
							if err := decoder.Finish(); err != nil {
								return err
							}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string][]string)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F0 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []*[]string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([]*[]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							values0[i1] = nil
						} else {
							values0[i1] = new([]string)
							len2, err := decoder.StartArray(64)
							if err != nil {
								return err
							}
							(*values0[i1]) = make([]string, len2)
							for i2 := uint32(0); i2 < len2; i2++ {
								pointer3, err := decoder.ReadPointer()
								if err != nil {
									return err
								}
								if pointer3 == 0 {
									return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
								} else {
									value3, err := decoder.ReadString()
									if err != nil {
										return err
									}
									(*values0[i1])[i2] = value3
								}
							}
							if err := decoder.Finish(); err != nil {
								return err
							}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string]*[]string)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F1 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 [][]*string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([][]*string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							len2, err := decoder.StartArray(64)
							if err != nil {
								return err
							}
							values0[i1] = make([]*string, len2)
							for i2 := uint32(0); i2 < len2; i2++ {
								pointer3, err := decoder.ReadPointer()
								if err != nil {
									return err
								}
								if pointer3 == 0 {
									values0[i1][i2] = nil
								} else {
									values0[i1][i2] = new(string)
									value3, err := decoder.ReadString()
									if err != nil {
										return err
									}
									(*values0[i1][i2]) = value3
								}
							}
							if err := decoder.Finish(); err != nil {
								return err
							}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string][]*string)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F2 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 [][2]string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([][2]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							len2, err := decoder.StartArray(64)
							if err != nil {
								return err
							}
							if len2 != 2 {
								return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
									fmt.Sprintf("invalid array length: expected %d, got %d", 2, len2),
								}
							}
							for i2 := uint32(0); i2 < len2; i2++ {
								pointer3, err := decoder.ReadPointer()
								if err != nil {
									return err
								}
								if pointer3 == 0 {
									return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
								} else {
									value3, err := decoder.ReadString()
									if err != nil {
										return err
									}
									values0[i1][i2] = value3
								}
							}
							if err := decoder.Finish(); err != nil {
								return err
							}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string][2]string)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F3 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 [][]*[2]string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([][]*[2]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							len2, err := decoder.StartArray(64)
							if err != nil {
								return err
							}
							values0[i1] = make([]*[2]string, len2)
							for i2 := uint32(0); i2 < len2; i2++ {
								pointer3, err := decoder.ReadPointer()
								if err != nil {
									return err
								}
								if pointer3 == 0 {
									values0[i1][i2] = nil
								} else {
									values0[i1][i2] = new([2]string)
									len3, err := decoder.StartArray(64)
									if err != nil {
										return err
									}
									if len3 != 2 {
										return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
											fmt.Sprintf("invalid array length: expected %d, got %d", 2, len3),
										}
									}
									for i3 := uint32(0); i3 < len3; i3++ {
										pointer4, err := decoder.ReadPointer()
										if err != nil {
											return err
										}
										if pointer4 == 0 {
											return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
										} else {
											value4, err := decoder.ReadString()
											if err != nil {
												return err
											}
											(*values0[i1][i2])[i3] = value4
										}
									}
									if err := decoder.Finish(); err != nil {
										return err
									}
								}
							}
							if err := decoder.Finish(); err != nil {
								return err
							}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string][]*[2]string)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F4 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 [][1][2]string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([][1][2]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							len2, err := decoder.StartArray(64)
							if err != nil {
								return err
							}
							if len2 != 1 {
								return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
									fmt.Sprintf("invalid array length: expected %d, got %d", 1, len2),
								}
							}
							for i2 := uint32(0); i2 < len2; i2++ {
								pointer3, err := decoder.ReadPointer()
								if err != nil {
									return err
								}
								if pointer3 == 0 {
									return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
								} else {
									len3, err := decoder.StartArray(64)
									if err != nil {
										return err
									}
									if len3 != 2 {
										return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
											fmt.Sprintf("invalid array length: expected %d, got %d", 2, len3),
										}
									}
									for i3 := uint32(0); i3 < len3; i3++ {
										pointer4, err := decoder.ReadPointer()
										if err != nil {
											return err
										}
										if pointer4 == 0 {
											return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
										} else {
											value4, err := decoder.ReadString()
											if err != nil {
												return err
											}
											values0[i1][i2][i3] = value4
										}
									}
									if err := decoder.Finish(); err != nil {
										return err
									}
								}
							}
							if err := decoder.Finish(); err != nil {
								return err
							}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string][1][2]string)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F5 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []*rect.Rect
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([]*rect.Rect, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							values0[i1] = nil
						} else {
							values0[i1] = new(rect.Rect)
							if err := (*values0[i1]).Decode(decoder); err != nil {
								return err
							}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string]*rect.Rect)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F6 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []map[string]string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([]map[string]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							if err := decoder.StartMap(); err != nil {
								return err
							}
							var keys2 []string
							{
								pointer3, err := decoder.ReadPointer()
								if err != nil {
									return err
								}
								if pointer3 == 0 {
									return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
								} else {
									len3, err := decoder.StartArray(64)
									if err != nil {
										return err
									}
									keys2 = make([]string, len3)
									for i3 := uint32(0); i3 < len3; i3++ {
										pointer4, err := decoder.ReadPointer()
										if err != nil {
											return err
										}
										if pointer4 == 0 {
											return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
										} else {
											value4, err := decoder.ReadString()
											if err != nil {
												return err
											}
											keys2[i3] = value4
										}
									}
									if err := decoder.Finish(); err != nil {
										return err
									}
								}
							}
							var values2 []string
							{
								pointer3, err := decoder.ReadPointer()
								if err != nil {
									return err
								}
								if pointer3 == 0 {
									return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
								} else {
									len3, err := decoder.StartArray(64)
									if err != nil {
										return err
									}
									values2 = make([]string, len3)
									for i3 := uint32(0); i3 < len3; i3++ {
										pointer4, err := decoder.ReadPointer()
										if err != nil {
											return err
										}
										if pointer4 == 0 {
											return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
										} else {
											value4, err := decoder.ReadString()
											if err != nil {
												return err
											}
											values2[i3] = value4
										}
									}
									if err := decoder.Finish(); err != nil {
										return err
									}
								}
							}
							if len(keys2) != len(values2) {
								return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
									fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys2), len(values2)),
								}
							}
							if err := decoder.Finish(); err != nil {
								return err
							}
							len2 := len(keys2)
							map2 := make(map[string]string)
							for i2 := 0; i2 < len2; i2++ {
								map2[keys2[i2]] = values2[i2]
							}
							values0[i1] = map2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string]map[string]string)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F7 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 [][]map[string]string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([][]map[string]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							len2, err := decoder.StartArray(64)
							if err != nil {
								return err
							}
							values0[i1] = make([]map[string]string, len2)
							for i2 := uint32(0); i2 < len2; i2++ {
								pointer3, err := decoder.ReadPointer()
								if err != nil {
									return err
								}
								if pointer3 == 0 {
									return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
								} else {
									if err := decoder.StartMap(); err != nil {
										return err
									}
									var keys3 []string
									{
										pointer4, err := decoder.ReadPointer()
										if err != nil {
											return err
										}
										if pointer4 == 0 {
											return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
										} else {
											len4, err := decoder.StartArray(64)
											if err != nil {
												return err
											}
											keys3 = make([]string, len4)
											for i4 := uint32(0); i4 < len4; i4++ {
												pointer5, err := decoder.ReadPointer()
												if err != nil {
													return err
												}
												if pointer5 == 0 {
													return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
												} else {
													value5, err := decoder.ReadString()
													if err != nil {
														return err
													}
													keys3[i4] = value5
												}
											}
											if err := decoder.Finish(); err != nil {
												return err
											}
										}
									}
									var values3 []string
									{
										pointer4, err := decoder.ReadPointer()
										if err != nil {
											return err
										}
										if pointer4 == 0 {
											return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
										} else {
											len4, err := decoder.StartArray(64)
											if err != nil {
												return err
											}
											values3 = make([]string, len4)
											for i4 := uint32(0); i4 < len4; i4++ {
												pointer5, err := decoder.ReadPointer()
												if err != nil {
													return err
												}
												if pointer5 == 0 {
													return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
												} else {
													value5, err := decoder.ReadString()
													if err != nil {
														return err
													}
													values3[i4] = value5
												}
											}
											if err := decoder.Finish(); err != nil {
												return err
											}
										}
									}
									if len(keys3) != len(values3) {
										return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
											fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys3), len(values3)),
										}
									}
									if err := decoder.Finish(); err != nil {
										return err
									}
									len3 := len(keys3)
									map3 := make(map[string]string)
									for i3 := 0; i3 < len3; i3++ {
										map3[keys3[i3]] = values3[i3]
									}
									values0[i1][i2] = map3
								}
							}
							if err := decoder.Finish(); err != nil {
								return err
							}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string][]map[string]string)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F8 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []system.Handle
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(32)
					if err != nil {
						return err
					}
					values0 = make([]system.Handle, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						handle2, err := decoder.ReadHandle()
						if err != nil {
							return err
						}
						if handle2.IsValid() {
							values0[i1] = handle2
						} else {
							return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string]system.Handle)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F9 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 [][]system.Handle
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([][]system.Handle, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							len2, err := decoder.StartArray(32)
							if err != nil {
								return err
							}
							values0[i1] = make([]system.Handle, len2)
							for i2 := uint32(0); i2 < len2; i2++ {
								handle3, err := decoder.ReadHandle()
								if err != nil {
									return err
								}
								if handle3.IsValid() {
									values0[i1][i2] = handle3
								} else {
									return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
								}
							}
							if err := decoder.Finish(); err != nil {
								return err
							}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string][]system.Handle)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F10 = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []map[string]system.Handle
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					values0 = make([]map[string]system.Handle, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							if err := decoder.StartMap(); err != nil {
								return err
							}
							var keys2 []string
							{
								pointer3, err := decoder.ReadPointer()
								if err != nil {
									return err
								}
								if pointer3 == 0 {
									return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
								} else {
									len3, err := decoder.StartArray(64)
									if err != nil {
										return err
									}
									keys2 = make([]string, len3)
									for i3 := uint32(0); i3 < len3; i3++ {
										pointer4, err := decoder.ReadPointer()
										if err != nil {
											return err
										}
										if pointer4 == 0 {
											return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
										} else {
											value4, err := decoder.ReadString()
											if err != nil {
												return err
											}
											keys2[i3] = value4
										}
									}
									if err := decoder.Finish(); err != nil {
										return err
									}
								}
							}
							var values2 []system.Handle
							{
								pointer3, err := decoder.ReadPointer()
								if err != nil {
									return err
								}
								if pointer3 == 0 {
									return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
								} else {
									len3, err := decoder.StartArray(32)
									if err != nil {
										return err
									}
									values2 = make([]system.Handle, len3)
									for i3 := uint32(0); i3 < len3; i3++ {
										handle4, err := decoder.ReadHandle()
										if err != nil {
											return err
										}
										if handle4.IsValid() {
											values2[i3] = handle4
										} else {
											return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
										}
									}
									if err := decoder.Finish(); err != nil {
										return err
									}
								}
							}
							if len(keys2) != len(values2) {
								return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
									fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys2), len(values2)),
								}
							}
							if err := decoder.Finish(); err != nil {
								return err
							}
							len2 := len(keys2)
							map2 := make(map[string]system.Handle)
							for i2 := 0; i2 < len2; i2++ {
								map2[keys2[i2]] = values2[i2]
							}
							values0[i1] = map2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string]map[string]system.Handle)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.F11 = map0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type ArrayValueTypes struct {
	F0 []int8
	F1 []int16
	F2 []int32
	F3 []int64
	F4 []float32
	F5 []float64
}
// ArrayValueTypesMojomType returns the UserDefinedType that describes the Mojom
// type of ArrayValueTypes. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func ArrayValueTypesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.ArrayValueTypes"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ArrayValueTypes) MojomType() mojom_types.UserDefinedType {
	return ArrayValueTypesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ArrayValueTypes) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *ArrayValueTypes) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(48, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F0)), 8)
	for _, elem0 := range s.F0 {
		if err := encoder.WriteInt8(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F1)), 16)
	for _, elem0 := range s.F1 {
		if err := encoder.WriteInt16(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F2)), 32)
	for _, elem0 := range s.F2 {
		if err := encoder.WriteInt32(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F3)), 64)
	for _, elem0 := range s.F3 {
		if err := encoder.WriteInt64(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F4)), 32)
	for _, elem0 := range s.F4 {
		if err := encoder.WriteFloat32(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F5)), 64)
	for _, elem0 := range s.F5 {
		if err := encoder.WriteFloat64(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var arrayValueTypes_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{56, 0},
}

func (s *ArrayValueTypes) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(arrayValueTypes_Versions), func(i int) bool {
		return arrayValueTypes_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(arrayValueTypes_Versions) {
		if arrayValueTypes_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := arrayValueTypes_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			s.F0 = make([]int8, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadInt8()
				if err != nil {
					return err
				}
				s.F0[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(16)
			if err != nil {
				return err
			}
			s.F1 = make([]int16, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadInt16()
				if err != nil {
					return err
				}
				s.F1[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.F2 = make([]int32, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadInt32()
				if err != nil {
					return err
				}
				s.F2[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.F3 = make([]int64, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadInt64()
				if err != nil {
					return err
				}
				s.F3[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.F4 = make([]float32, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadFloat32()
				if err != nil {
					return err
				}
				s.F4[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.F5 = make([]float64, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadFloat64()
				if err != nil {
					return err
				}
				s.F5[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type FloatNumberValues struct {
	F0 float64
	F1 float64
	F2 float64
	F3 float32
	F4 float32
	F5 float32
	F6 float32
	F7 float64
	F8 float64
	F9 float64
}
// FloatNumberValuesMojomType returns the UserDefinedType that describes the Mojom
// type of FloatNumberValues. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func FloatNumberValuesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.FloatNumberValues"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*FloatNumberValues) MojomType() mojom_types.UserDefinedType {
	return FloatNumberValuesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*FloatNumberValues) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *FloatNumberValues) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(64, 0)
	if err := encoder.WriteFloat64(s.F0); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.F1); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.F2); err != nil {
		return err
	}
	if err := encoder.WriteFloat32(s.F3); err != nil {
		return err
	}
	if err := encoder.WriteFloat32(s.F4); err != nil {
		return err
	}
	if err := encoder.WriteFloat32(s.F5); err != nil {
		return err
	}
	if err := encoder.WriteFloat32(s.F6); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.F7); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.F8); err != nil {
		return err
	}
	if err := encoder.WriteFloat64(s.F9); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var floatNumberValues_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{72, 0},
}

func (s *FloatNumberValues) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(floatNumberValues_Versions), func(i int) bool {
		return floatNumberValues_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(floatNumberValues_Versions) {
		if floatNumberValues_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := floatNumberValues_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.F0 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.F1 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.F2 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.F3 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.F4 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.F5 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat32()
		if err != nil {
			return err
		}
		s.F6 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.F7 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.F8 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadFloat64()
		if err != nil {
			return err
		}
		s.F9 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type IntegerNumberValues struct {
	F0 int8
	F1 int8
	F2 int8
	F3 int8
	F4 int8
	F5 int16
	F6 int16
	F7 int16
	F8 int16
	F9 int16
	F10 int32
	F11 int32
	F12 int32
	F13 int32
	F14 int32
	F15 int64
	F16 int64
	F17 int64
	F18 int64
	F19 int64
}
// IntegerNumberValuesMojomType returns the UserDefinedType that describes the Mojom
// type of IntegerNumberValues. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func IntegerNumberValuesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.IntegerNumberValues"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*IntegerNumberValues) MojomType() mojom_types.UserDefinedType {
	return IntegerNumberValuesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*IntegerNumberValues) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *IntegerNumberValues) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(80, 0)
	if err := encoder.WriteInt8(s.F0); err != nil {
		return err
	}
	if err := encoder.WriteInt8(s.F1); err != nil {
		return err
	}
	if err := encoder.WriteInt8(s.F2); err != nil {
		return err
	}
	if err := encoder.WriteInt8(s.F3); err != nil {
		return err
	}
	if err := encoder.WriteInt8(s.F4); err != nil {
		return err
	}
	if err := encoder.WriteInt16(s.F5); err != nil {
		return err
	}
	if err := encoder.WriteInt16(s.F6); err != nil {
		return err
	}
	if err := encoder.WriteInt16(s.F7); err != nil {
		return err
	}
	if err := encoder.WriteInt16(s.F8); err != nil {
		return err
	}
	if err := encoder.WriteInt16(s.F9); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.F10); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.F11); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.F12); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.F13); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.F14); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.F15); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.F16); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.F17); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.F18); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.F19); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var integerNumberValues_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{88, 0},
}

func (s *IntegerNumberValues) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(integerNumberValues_Versions), func(i int) bool {
		return integerNumberValues_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(integerNumberValues_Versions) {
		if integerNumberValues_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := integerNumberValues_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt8()
		if err != nil {
			return err
		}
		s.F0 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt8()
		if err != nil {
			return err
		}
		s.F1 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt8()
		if err != nil {
			return err
		}
		s.F2 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt8()
		if err != nil {
			return err
		}
		s.F3 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt8()
		if err != nil {
			return err
		}
		s.F4 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt16()
		if err != nil {
			return err
		}
		s.F5 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt16()
		if err != nil {
			return err
		}
		s.F6 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt16()
		if err != nil {
			return err
		}
		s.F7 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt16()
		if err != nil {
			return err
		}
		s.F8 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt16()
		if err != nil {
			return err
		}
		s.F9 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F10 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F11 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F12 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F13 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.F14 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.F15 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.F16 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.F17 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.F18 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.F19 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type UnsignedNumberValues struct {
	F0 uint8
	F1 uint8
	F2 uint8
	F3 uint16
	F4 uint16
	F5 uint16
	F6 uint32
	F7 uint32
	F8 uint32
	F9 uint64
	F10 uint64
	F11 uint64
}
// UnsignedNumberValuesMojomType returns the UserDefinedType that describes the Mojom
// type of UnsignedNumberValues. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func UnsignedNumberValuesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.UnsignedNumberValues"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnsignedNumberValues) MojomType() mojom_types.UserDefinedType {
	return UnsignedNumberValuesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnsignedNumberValues) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *UnsignedNumberValues) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(48, 0)
	if err := encoder.WriteUint8(s.F0); err != nil {
		return err
	}
	if err := encoder.WriteUint8(s.F1); err != nil {
		return err
	}
	if err := encoder.WriteUint8(s.F2); err != nil {
		return err
	}
	if err := encoder.WriteUint16(s.F3); err != nil {
		return err
	}
	if err := encoder.WriteUint16(s.F4); err != nil {
		return err
	}
	if err := encoder.WriteUint16(s.F5); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.F6); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.F7); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.F8); err != nil {
		return err
	}
	if err := encoder.WriteUint64(s.F9); err != nil {
		return err
	}
	if err := encoder.WriteUint64(s.F10); err != nil {
		return err
	}
	if err := encoder.WriteUint64(s.F11); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var unsignedNumberValues_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{56, 0},
}

func (s *UnsignedNumberValues) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(unsignedNumberValues_Versions), func(i int) bool {
		return unsignedNumberValues_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(unsignedNumberValues_Versions) {
		if unsignedNumberValues_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := unsignedNumberValues_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.F0 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.F1 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.F2 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint16()
		if err != nil {
			return err
		}
		s.F3 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint16()
		if err != nil {
			return err
		}
		s.F4 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint16()
		if err != nil {
			return err
		}
		s.F5 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.F6 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.F7 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.F8 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint64()
		if err != nil {
			return err
		}
		s.F9 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint64()
		if err != nil {
			return err
		}
		s.F10 = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint64()
		if err != nil {
			return err
		}
		s.F11 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type BitArrayValues struct {
	F0 [1]bool
	F1 [7]bool
	F2 [9]bool
	F3 []bool
	F4 [][]bool
	F5 []*[]bool
	F6 []*[2]bool
}
// BitArrayValuesMojomType returns the UserDefinedType that describes the Mojom
// type of BitArrayValues. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func BitArrayValuesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.BitArrayValues"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*BitArrayValues) MojomType() mojom_types.UserDefinedType {
	return BitArrayValuesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*BitArrayValues) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *BitArrayValues) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(56, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F0)), 1)
	for _, elem0 := range s.F0 {
		if err := encoder.WriteBool(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F1)), 1)
	for _, elem0 := range s.F1 {
		if err := encoder.WriteBool(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F2)), 1)
	for _, elem0 := range s.F2 {
		if err := encoder.WriteBool(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F3)), 1)
	for _, elem0 := range s.F3 {
		if err := encoder.WriteBool(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F4)), 64)
	for _, elem0 := range s.F4 {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(elem0)), 1)
		for _, elem1 := range elem0 {
			if err := encoder.WriteBool(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F5)), 64)
	for _, elem0 := range s.F5 {
		if elem0 == nil {
			encoder.WriteNullPointer()
		} else {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len((*elem0))), 1)
			for _, elem1 := range (*elem0) {
				if err := encoder.WriteBool(elem1); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.F6)), 64)
	for _, elem0 := range s.F6 {
		if elem0 == nil {
			encoder.WriteNullPointer()
		} else {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len((*elem0))), 1)
			for _, elem1 := range (*elem0) {
				if err := encoder.WriteBool(elem1); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var bitArrayValues_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{64, 0},
}

func (s *BitArrayValues) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(bitArrayValues_Versions), func(i int) bool {
		return bitArrayValues_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(bitArrayValues_Versions) {
		if bitArrayValues_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := bitArrayValues_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(1)
			if err != nil {
				return err
			}
			if len0 != 1 {
				return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
					fmt.Sprintf("invalid array length: expected %d, got %d", 1, len0),
				}
			}
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadBool()
				if err != nil {
					return err
				}
				s.F0[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(1)
			if err != nil {
				return err
			}
			if len0 != 7 {
				return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
					fmt.Sprintf("invalid array length: expected %d, got %d", 7, len0),
				}
			}
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadBool()
				if err != nil {
					return err
				}
				s.F1[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(1)
			if err != nil {
				return err
			}
			if len0 != 9 {
				return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
					fmt.Sprintf("invalid array length: expected %d, got %d", 9, len0),
				}
			}
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadBool()
				if err != nil {
					return err
				}
				s.F2[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(1)
			if err != nil {
				return err
			}
			s.F3 = make([]bool, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadBool()
				if err != nil {
					return err
				}
				s.F3[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.F4 = make([][]bool, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(1)
					if err != nil {
						return err
					}
					s.F4[i0] = make([]bool, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadBool()
						if err != nil {
							return err
						}
						s.F4[i0][i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.F5 = make([]*[]bool, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					s.F5[i0] = nil
				} else {
					s.F5[i0] = new([]bool)
					len1, err := decoder.StartArray(1)
					if err != nil {
						return err
					}
					(*s.F5[i0]) = make([]bool, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadBool()
						if err != nil {
							return err
						}
						(*s.F5[i0])[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.F6 = make([]*[2]bool, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					s.F6[i0] = nil
				} else {
					s.F6[i0] = new([2]bool)
					len1, err := decoder.StartArray(1)
					if err != nil {
						return err
					}
					if len1 != 2 {
						return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
							fmt.Sprintf("invalid array length: expected %d, got %d", 2, len1),
						}
					}
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadBool()
						if err != nil {
							return err
						}
						(*s.F6[i0])[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type MultiVersionStruct struct {
	FInt32 int32
	FRect *rect.Rect
	FString *string
	FArray *[]int8
	FMessagePipe *system.MessagePipeHandle
	FBool bool
	FInt16 int16
}
// MultiVersionStructMojomType returns the UserDefinedType that describes the Mojom
// type of MultiVersionStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func MultiVersionStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.MultiVersionStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*MultiVersionStruct) MojomType() mojom_types.UserDefinedType {
	return MultiVersionStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*MultiVersionStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *MultiVersionStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(40, 9)
	if err := encoder.WriteInt32(s.FInt32); err != nil {
		return err
	}
	if s.FMessagePipe == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.FMessagePipe)); err != nil {
			return err
		}
	}
	if s.FRect == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.FRect).Encode(encoder); err != nil {
			return err
		}
	}
	if s.FString == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.FString)); err != nil {
			return err
		}
	}
	if s.FArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.FArray))), 8)
		for _, elem0 := range (*s.FArray) {
			if err := encoder.WriteInt8(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.WriteBool(s.FBool); err != nil {
		return err
	}
	if err := encoder.WriteInt16(s.FInt16); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var multiVersionStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
	bindings.DataHeader{24, 1},
	bindings.DataHeader{32, 3},
	bindings.DataHeader{40, 5},
	bindings.DataHeader{48, 7},
	bindings.DataHeader{48, 9},
}

func (s *MultiVersionStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(multiVersionStruct_Versions), func(i int) bool {
		return multiVersionStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(multiVersionStruct_Versions) {
		if multiVersionStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := multiVersionStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.FInt32 = value0
	}
	if header.ElementsOrVersion >= 7 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.FMessagePipe = &handle0
		} else {
			s.FMessagePipe = nil
		}
	}
	if header.ElementsOrVersion >= 1 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.FRect = nil
		} else {
			s.FRect = new(rect.Rect)
			if err := (*s.FRect).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 3 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.FString = nil
		} else {
			s.FString = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.FString) = value0
		}
	}
	if header.ElementsOrVersion >= 5 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.FArray = nil
		} else {
			s.FArray = new([]int8)
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			(*s.FArray) = make([]int8, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadInt8()
				if err != nil {
					return err
				}
				(*s.FArray)[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 7 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.FBool = value0
	}
	if header.ElementsOrVersion >= 9 {
		value0, err := decoder.ReadInt16()
		if err != nil {
			return err
		}
		s.FInt16 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type MultiVersionStructV0 struct {
	FInt32 int32
}
// MultiVersionStructV0MojomType returns the UserDefinedType that describes the Mojom
// type of MultiVersionStructV0. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func MultiVersionStructV0MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.MultiVersionStructV0"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*MultiVersionStructV0) MojomType() mojom_types.UserDefinedType {
	return MultiVersionStructV0MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*MultiVersionStructV0) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *MultiVersionStructV0) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.FInt32); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var multiVersionStructV0_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *MultiVersionStructV0) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(multiVersionStructV0_Versions), func(i int) bool {
		return multiVersionStructV0_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(multiVersionStructV0_Versions) {
		if multiVersionStructV0_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := multiVersionStructV0_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.FInt32 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type MultiVersionStructV1 struct {
	FInt32 int32
	FRect *rect.Rect
}
// MultiVersionStructV1MojomType returns the UserDefinedType that describes the Mojom
// type of MultiVersionStructV1. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func MultiVersionStructV1MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.MultiVersionStructV1"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*MultiVersionStructV1) MojomType() mojom_types.UserDefinedType {
	return MultiVersionStructV1MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*MultiVersionStructV1) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *MultiVersionStructV1) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 1)
	if err := encoder.WriteInt32(s.FInt32); err != nil {
		return err
	}
	if s.FRect == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.FRect).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var multiVersionStructV1_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
	bindings.DataHeader{24, 1},
}

func (s *MultiVersionStructV1) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(multiVersionStructV1_Versions), func(i int) bool {
		return multiVersionStructV1_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(multiVersionStructV1_Versions) {
		if multiVersionStructV1_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := multiVersionStructV1_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.FInt32 = value0
	}
	if header.ElementsOrVersion >= 1 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.FRect = nil
		} else {
			s.FRect = new(rect.Rect)
			if err := (*s.FRect).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type MultiVersionStructV3 struct {
	FInt32 int32
	FRect *rect.Rect
	FString *string
}
// MultiVersionStructV3MojomType returns the UserDefinedType that describes the Mojom
// type of MultiVersionStructV3. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func MultiVersionStructV3MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.MultiVersionStructV3"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*MultiVersionStructV3) MojomType() mojom_types.UserDefinedType {
	return MultiVersionStructV3MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*MultiVersionStructV3) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *MultiVersionStructV3) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 3)
	if err := encoder.WriteInt32(s.FInt32); err != nil {
		return err
	}
	if s.FRect == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.FRect).Encode(encoder); err != nil {
			return err
		}
	}
	if s.FString == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.FString)); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var multiVersionStructV3_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
	bindings.DataHeader{24, 1},
	bindings.DataHeader{32, 3},
}

func (s *MultiVersionStructV3) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(multiVersionStructV3_Versions), func(i int) bool {
		return multiVersionStructV3_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(multiVersionStructV3_Versions) {
		if multiVersionStructV3_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := multiVersionStructV3_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.FInt32 = value0
	}
	if header.ElementsOrVersion >= 1 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.FRect = nil
		} else {
			s.FRect = new(rect.Rect)
			if err := (*s.FRect).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 3 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.FString = nil
		} else {
			s.FString = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.FString) = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type MultiVersionStructV5 struct {
	FInt32 int32
	FRect *rect.Rect
	FString *string
	FArray *[]int8
}
// MultiVersionStructV5MojomType returns the UserDefinedType that describes the Mojom
// type of MultiVersionStructV5. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func MultiVersionStructV5MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.MultiVersionStructV5"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*MultiVersionStructV5) MojomType() mojom_types.UserDefinedType {
	return MultiVersionStructV5MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*MultiVersionStructV5) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *MultiVersionStructV5) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 5)
	if err := encoder.WriteInt32(s.FInt32); err != nil {
		return err
	}
	if s.FRect == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.FRect).Encode(encoder); err != nil {
			return err
		}
	}
	if s.FString == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.FString)); err != nil {
			return err
		}
	}
	if s.FArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.FArray))), 8)
		for _, elem0 := range (*s.FArray) {
			if err := encoder.WriteInt8(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var multiVersionStructV5_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
	bindings.DataHeader{24, 1},
	bindings.DataHeader{32, 3},
	bindings.DataHeader{40, 5},
}

func (s *MultiVersionStructV5) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(multiVersionStructV5_Versions), func(i int) bool {
		return multiVersionStructV5_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(multiVersionStructV5_Versions) {
		if multiVersionStructV5_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := multiVersionStructV5_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.FInt32 = value0
	}
	if header.ElementsOrVersion >= 1 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.FRect = nil
		} else {
			s.FRect = new(rect.Rect)
			if err := (*s.FRect).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 3 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.FString = nil
		} else {
			s.FString = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.FString) = value0
		}
	}
	if header.ElementsOrVersion >= 5 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.FArray = nil
		} else {
			s.FArray = new([]int8)
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			(*s.FArray) = make([]int8, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadInt8()
				if err != nil {
					return err
				}
				(*s.FArray)[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type MultiVersionStructV7 struct {
	FInt32 int32
	FRect *rect.Rect
	FString *string
	FArray *[]int8
	FMessagePipe *system.MessagePipeHandle
	FBool bool
}
// MultiVersionStructV7MojomType returns the UserDefinedType that describes the Mojom
// type of MultiVersionStructV7. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func MultiVersionStructV7MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.MultiVersionStructV7"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*MultiVersionStructV7) MojomType() mojom_types.UserDefinedType {
	return MultiVersionStructV7MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*MultiVersionStructV7) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *MultiVersionStructV7) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(40, 7)
	if err := encoder.WriteInt32(s.FInt32); err != nil {
		return err
	}
	if s.FMessagePipe == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.FMessagePipe)); err != nil {
			return err
		}
	}
	if s.FRect == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.FRect).Encode(encoder); err != nil {
			return err
		}
	}
	if s.FString == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.FString)); err != nil {
			return err
		}
	}
	if s.FArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.FArray))), 8)
		for _, elem0 := range (*s.FArray) {
			if err := encoder.WriteInt8(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.WriteBool(s.FBool); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var multiVersionStructV7_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
	bindings.DataHeader{24, 1},
	bindings.DataHeader{32, 3},
	bindings.DataHeader{40, 5},
	bindings.DataHeader{48, 7},
}

func (s *MultiVersionStructV7) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(multiVersionStructV7_Versions), func(i int) bool {
		return multiVersionStructV7_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(multiVersionStructV7_Versions) {
		if multiVersionStructV7_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := multiVersionStructV7_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.FInt32 = value0
	}
	if header.ElementsOrVersion >= 7 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.FMessagePipe = &handle0
		} else {
			s.FMessagePipe = nil
		}
	}
	if header.ElementsOrVersion >= 1 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.FRect = nil
		} else {
			s.FRect = new(rect.Rect)
			if err := (*s.FRect).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 3 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.FString = nil
		} else {
			s.FString = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.FString) = value0
		}
	}
	if header.ElementsOrVersion >= 5 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.FArray = nil
		} else {
			s.FArray = new([]int8)
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			(*s.FArray) = make([]int8, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadInt8()
				if err != nil {
					return err
				}
				(*s.FArray)[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 7 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.FBool = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type ContainsInterface struct {
	SomeInterface SomeInterface_Pointer
}
// ContainsInterfaceMojomType returns the UserDefinedType that describes the Mojom
// type of ContainsInterface. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func ContainsInterfaceMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.ContainsInterface"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ContainsInterface) MojomType() mojom_types.UserDefinedType {
	return ContainsInterfaceMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ContainsInterface) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *ContainsInterface) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInterface(s.SomeInterface.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var containsInterface_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *ContainsInterface) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(containsInterface_Versions), func(i int) bool {
		return containsInterface_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(containsInterface_Versions) {
		if containsInterface_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := containsInterface_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadInterface()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.SomeInterface = SomeInterface_Pointer{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type ContainsOther struct {
	Other int32
}
// ContainsOtherMojomType returns the UserDefinedType that describes the Mojom
// type of ContainsOther. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func ContainsOtherMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.ContainsOther"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ContainsOther) MojomType() mojom_types.UserDefinedType {
	return ContainsOtherMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ContainsOther) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *ContainsOther) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.Other); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var containsOther_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *ContainsOther) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(containsOther_Versions), func(i int) bool {
		return containsOther_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(containsOther_Versions) {
		if containsOther_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := containsOther_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Other = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type ContainsInterfaceRequest struct {
	Req SomeInterface_Request
	NullableReq *SomeInterface_Request
}
// ContainsInterfaceRequestMojomType returns the UserDefinedType that describes the Mojom
// type of ContainsInterfaceRequest. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func ContainsInterfaceRequestMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.ContainsInterfaceRequest"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ContainsInterfaceRequest) MojomType() mojom_types.UserDefinedType {
	return ContainsInterfaceRequestMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ContainsInterfaceRequest) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *ContainsInterfaceRequest) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteHandle(s.Req.PassMessagePipe()); err != nil {
		return err
	}
	if s.NullableReq == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.NullableReq).PassMessagePipe()); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var containsInterfaceRequest_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *ContainsInterfaceRequest) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(containsInterfaceRequest_Versions), func(i int) bool {
		return containsInterfaceRequest_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(containsInterfaceRequest_Versions) {
		if containsInterfaceRequest_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := containsInterfaceRequest_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.Req = SomeInterface_Request{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.NullableReq = &SomeInterface_Request{handleOwner}
		} else {
			s.NullableReq = nil
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type DartKeywordStruct struct {
	Await DartKeywordStruct_Keywords
	Is DartKeywordStruct_Keywords
	Rethrow DartKeywordStruct_Keywords
}
// DartKeywordStructMojomType returns the UserDefinedType that describes the Mojom
// type of DartKeywordStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func DartKeywordStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.DartKeywordStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*DartKeywordStruct) MojomType() mojom_types.UserDefinedType {
	return DartKeywordStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*DartKeywordStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *DartKeywordStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInt32(int32(s.Await)); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.Is)); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.Rethrow)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var dartKeywordStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *DartKeywordStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(dartKeywordStruct_Versions), func(i int) bool {
		return dartKeywordStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(dartKeywordStruct_Versions) {
		if dartKeywordStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := dartKeywordStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Await = DartKeywordStruct_Keywords(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Is = DartKeywordStruct_Keywords(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Rethrow = DartKeywordStruct_Keywords(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type UnionOfStructs interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__UnionOfStructsReflect)
	Encode(encoder *bindings.Encoder) error
}


// UnionOfStructsMojomType returns the UserDefinedType that describes the Mojom
// type of UnionOfStructs. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func UnionOfStructsMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.UnionOfStructs"]
}



type __UnionOfStructsReflect struct {
	Nr NamedRegion
	ANr []NamedRegion
	ARp []RectPair
	MNdfv map[int64]NoDefaultFieldValues
	MHs map[int64]HandleStruct
}

func DecodeUnionOfStructs(decoder *bindings.Decoder) (UnionOfStructs, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value UnionOfStructsNr
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value UnionOfStructsANr
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 2:
		var value UnionOfStructsARp
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 3:
		var value UnionOfStructsMNdfv
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 4:
		var value UnionOfStructsMHs
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &UnionOfStructsUnknown{tag: tag}, nil
}

type UnionOfStructsUnknown struct { tag uint32 }
func (u *UnionOfStructsUnknown) Tag() uint32 { return u.tag }
func (u *UnionOfStructsUnknown) Interface() interface{} { return nil }
func (u *UnionOfStructsUnknown) __Reflect(__UnionOfStructsReflect) {}

func (u *UnionOfStructsUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown UnionOfStructs. There is no sane way to do that!");
}

type UnionOfStructsNr struct { Value NamedRegion }
func (u *UnionOfStructsNr) Tag() uint32 { return 0 }
func (u *UnionOfStructsNr) Interface() interface{} { return u.Value }
func (u *UnionOfStructsNr) __Reflect(__UnionOfStructsReflect) {}

func (u *UnionOfStructsNr) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionOfStructsNr) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionOfStructsNr) MojomType() mojom_types.UserDefinedType {
	return UnionOfStructsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionOfStructsNr) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionOfStructsANr struct { Value []NamedRegion }
func (u *UnionOfStructsANr) Tag() uint32 { return 1 }
func (u *UnionOfStructsANr) Interface() interface{} { return u.Value }
func (u *UnionOfStructsANr) __Reflect(__UnionOfStructsReflect) {}

func (u *UnionOfStructsANr) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(u.Value)), 64)
	for _, elem0 := range u.Value {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionOfStructsANr) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		len0, err := decoder.StartArray(64)
		if err != nil {
			return err
		}
		u.Value = make([]NamedRegion, len0)
		for i0 := uint32(0); i0 < len0; i0++ {
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				if err := u.Value[i0].Decode(decoder); err != nil {
					return err
				}
			}
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionOfStructsANr) MojomType() mojom_types.UserDefinedType {
	return UnionOfStructsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionOfStructsANr) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionOfStructsARp struct { Value []RectPair }
func (u *UnionOfStructsARp) Tag() uint32 { return 2 }
func (u *UnionOfStructsARp) Interface() interface{} { return u.Value }
func (u *UnionOfStructsARp) __Reflect(__UnionOfStructsReflect) {}

func (u *UnionOfStructsARp) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(u.Value)), 64)
	for _, elem0 := range u.Value {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionOfStructsARp) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		len0, err := decoder.StartArray(64)
		if err != nil {
			return err
		}
		u.Value = make([]RectPair, len0)
		for i0 := uint32(0); i0 < len0; i0++ {
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				if err := u.Value[i0].Decode(decoder); err != nil {
					return err
				}
			}
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionOfStructsARp) MojomType() mojom_types.UserDefinedType {
	return UnionOfStructsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionOfStructsARp) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionOfStructsMNdfv struct { Value map[int64]NoDefaultFieldValues }
func (u *UnionOfStructsMNdfv) Tag() uint32 { return 3 }
func (u *UnionOfStructsMNdfv) Interface() interface{} { return u.Value }
func (u *UnionOfStructsMNdfv) __Reflect(__UnionOfStructsReflect) {}

func (u *UnionOfStructsMNdfv) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []int64
		var values0 []NoDefaultFieldValues
		if encoder.Deterministic() {
		  for key0, _ := range u.Value {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]NoDefaultFieldValues, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = u.Value[key]
		  }
		} else {
		  for key0, value0 := range u.Value {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WriteInt64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem1.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionOfStructsMNdfv) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := decoder.StartMap(); err != nil {
			return err
		}
		var keys0 []int64
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(64)
				if err != nil {
					return err
				}
				keys0 = make([]int64, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					value2, err := decoder.ReadInt64()
					if err != nil {
						return err
					}
					keys0[i1] = value2
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		var values0 []NoDefaultFieldValues
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(64)
				if err != nil {
					return err
				}
				values0 = make([]NoDefaultFieldValues, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					pointer2, err := decoder.ReadPointer()
					if err != nil {
						return err
					}
					if pointer2 == 0 {
						return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
					} else {
						if err := values0[i1].Decode(decoder); err != nil {
							return err
						}
					}
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		if len(keys0) != len(values0) {
			return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
				fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
			}
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
		len0 := len(keys0)
		map0 := make(map[int64]NoDefaultFieldValues)
		for i0 := 0; i0 < len0; i0++ {
			map0[keys0[i0]] = values0[i0]
		}
		u.Value = map0
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionOfStructsMNdfv) MojomType() mojom_types.UserDefinedType {
	return UnionOfStructsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionOfStructsMNdfv) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionOfStructsMHs struct { Value map[int64]HandleStruct }
func (u *UnionOfStructsMHs) Tag() uint32 { return 4 }
func (u *UnionOfStructsMHs) Interface() interface{} { return u.Value }
func (u *UnionOfStructsMHs) __Reflect(__UnionOfStructsReflect) {}

func (u *UnionOfStructsMHs) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []int64
		var values0 []HandleStruct
		if encoder.Deterministic() {
		  for key0, _ := range u.Value {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]HandleStruct, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = u.Value[key]
		  }
		} else {
		  for key0, value0 := range u.Value {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WriteInt64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 64)
		for _, elem1 := range values0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem1.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionOfStructsMHs) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := decoder.StartMap(); err != nil {
			return err
		}
		var keys0 []int64
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(64)
				if err != nil {
					return err
				}
				keys0 = make([]int64, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					value2, err := decoder.ReadInt64()
					if err != nil {
						return err
					}
					keys0[i1] = value2
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		var values0 []HandleStruct
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(64)
				if err != nil {
					return err
				}
				values0 = make([]HandleStruct, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					pointer2, err := decoder.ReadPointer()
					if err != nil {
						return err
					}
					if pointer2 == 0 {
						return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
					} else {
						if err := values0[i1].Decode(decoder); err != nil {
							return err
						}
					}
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		if len(keys0) != len(values0) {
			return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
				fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
			}
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
		len0 := len(keys0)
		map0 := make(map[int64]HandleStruct)
		for i0 := 0; i0 < len0; i0++ {
			map0[keys0[i0]] = values0[i0]
		}
		u.Value = map0
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionOfStructsMHs) MojomType() mojom_types.UserDefinedType {
	return UnionOfStructsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionOfStructsMHs) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}



