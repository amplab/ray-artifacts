// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/services/location/interfaces/geocoder.mojom
//

package geocoder

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	fmt "fmt"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
	location "mojo/services/location/interfaces/location"
)


type Geocoder interface {
	AddressToLocation(inAddress string, inOptions *Options) (outStatus string, outResults *[]Result, err error)
	LocationToAddress(inLocation location.Location, inOptions *Options) (outStatus string, outResults *[]Result, err error)
}




type Geocoder_Request bindings.InterfaceRequest



type Geocoder_Pointer bindings.InterfacePointer


type Geocoder_ServiceFactory struct{
	Delegate Geocoder_Factory
}

type Geocoder_Factory interface {
	Create(request Geocoder_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *Geocoder_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &Geocoder_ServiceDescription{}
}

func (f *Geocoder_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := Geocoder_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForGeocoder creates a message pipe for use with the
// Geocoder interface with a Geocoder_Request on one end and a Geocoder_Pointer on the other.
func CreateMessagePipeForGeocoder() (Geocoder_Request, Geocoder_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return Geocoder_Request(r), Geocoder_Pointer(p)
}

const geocoder_AddressToLocation_Name uint32 = 0
const geocoder_LocationToAddress_Name uint32 = 1

type Geocoder_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewGeocoderProxy(p Geocoder_Pointer, waiter bindings.AsyncWaiter) *Geocoder_Proxy {
	return &Geocoder_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *Geocoder_Proxy) Close_Proxy() {
	p.router.Close()
}

type geocoder_AddressToLocation_Params struct {
	inAddress string
	inOptions *Options
}


func (s *geocoder_AddressToLocation_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inAddress); err != nil {
		return err
	}
	if s.inOptions == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.inOptions).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var geocoder_AddressToLocation_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *geocoder_AddressToLocation_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(geocoder_AddressToLocation_Params_Versions), func(i int) bool {
		return geocoder_AddressToLocation_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(geocoder_AddressToLocation_Params_Versions) {
		if geocoder_AddressToLocation_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := geocoder_AddressToLocation_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inAddress = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.inOptions = nil
		} else {
			s.inOptions = new(Options)
			if err := (*s.inOptions).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type geocoder_AddressToLocation_ResponseParams struct {
	outStatus string
	outResults *[]Result
}


func (s *geocoder_AddressToLocation_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.outStatus); err != nil {
		return err
	}
	if s.outResults == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.outResults))), 64)
		for _, elem0 := range (*s.outResults) {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem0.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var geocoder_AddressToLocation_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *geocoder_AddressToLocation_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(geocoder_AddressToLocation_ResponseParams_Versions), func(i int) bool {
		return geocoder_AddressToLocation_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(geocoder_AddressToLocation_ResponseParams_Versions) {
		if geocoder_AddressToLocation_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := geocoder_AddressToLocation_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.outStatus = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.outResults = nil
		} else {
			s.outResults = new([]Result)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.outResults) = make([]Result, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := (*s.outResults)[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Geocoder_Proxy) AddressToLocation(inAddress string, inOptions *Options) (outStatus string, outResults *[]Result, err error) {
	payload := &geocoder_AddressToLocation_Params{
		inAddress,
		inOptions,
	}
	header := bindings.MessageHeader{
		Type: geocoder_AddressToLocation_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, geocoder_AddressToLocation_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response geocoder_AddressToLocation_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outStatus = response.outStatus
	outResults = response.outResults
	return
}

type geocoder_LocationToAddress_Params struct {
	inLocation location.Location
	inOptions *Options
}


func (s *geocoder_LocationToAddress_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inLocation.Encode(encoder); err != nil {
		return err
	}
	if s.inOptions == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.inOptions).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var geocoder_LocationToAddress_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *geocoder_LocationToAddress_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(geocoder_LocationToAddress_Params_Versions), func(i int) bool {
		return geocoder_LocationToAddress_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(geocoder_LocationToAddress_Params_Versions) {
		if geocoder_LocationToAddress_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := geocoder_LocationToAddress_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inLocation.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.inOptions = nil
		} else {
			s.inOptions = new(Options)
			if err := (*s.inOptions).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type geocoder_LocationToAddress_ResponseParams struct {
	outStatus string
	outResults *[]Result
}


func (s *geocoder_LocationToAddress_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.outStatus); err != nil {
		return err
	}
	if s.outResults == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.outResults))), 64)
		for _, elem0 := range (*s.outResults) {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem0.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var geocoder_LocationToAddress_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *geocoder_LocationToAddress_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(geocoder_LocationToAddress_ResponseParams_Versions), func(i int) bool {
		return geocoder_LocationToAddress_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(geocoder_LocationToAddress_ResponseParams_Versions) {
		if geocoder_LocationToAddress_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := geocoder_LocationToAddress_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.outStatus = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.outResults = nil
		} else {
			s.outResults = new([]Result)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.outResults) = make([]Result, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := (*s.outResults)[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Geocoder_Proxy) LocationToAddress(inLocation location.Location, inOptions *Options) (outStatus string, outResults *[]Result, err error) {
	payload := &geocoder_LocationToAddress_Params{
		inLocation,
		inOptions,
	}
	header := bindings.MessageHeader{
		Type: geocoder_LocationToAddress_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, geocoder_LocationToAddress_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response geocoder_LocationToAddress_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outStatus = response.outStatus
	outResults = response.outResults
	return
}

type geocoder_Stub struct {
	connector *bindings.Connector
	impl Geocoder
}

func NewGeocoderStub(r Geocoder_Request, impl Geocoder, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &geocoder_Stub{connector, impl})
}


func (f *Geocoder_Request) ServiceDescription() service_describer.ServiceDescription {
	return &Geocoder_ServiceDescription{}
}


type Geocoder_ServiceDescription struct{}

func (sd *Geocoder_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *Geocoder_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *Geocoder_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*Geocoder_ServiceDescription)(nil)


func (s *geocoder_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case geocoder_AddressToLocation_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request geocoder_AddressToLocation_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response geocoder_AddressToLocation_ResponseParams
		response.outStatus, 		response.outResults, err = s.impl.AddressToLocation(request.inAddress, request.inOptions)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: geocoder_AddressToLocation_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case geocoder_LocationToAddress_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request geocoder_LocationToAddress_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response geocoder_LocationToAddress_ResponseParams
		response.outStatus, 		response.outResults, err = s.impl.LocationToAddress(request.inLocation, request.inOptions)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: geocoder_LocationToAddress_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type LocationType struct {
}


func (s *LocationType) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var locationType_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *LocationType) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(locationType_Versions), func(i int) bool {
		return locationType_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(locationType_Versions) {
		if locationType_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := locationType_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type Bounds struct {
	Northeast location.Location
	Southwest location.Location
}


func (s *Bounds) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.Northeast.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.Southwest.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var bounds_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *Bounds) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(bounds_Versions), func(i int) bool {
		return bounds_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(bounds_Versions) {
		if bounds_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := bounds_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.Northeast.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.Southwest.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type ComponentRestrictions struct {
	AdministrativeArea *string
	Country *string
	Locality *string
	PostalCode *string
	Route *string
}


func (s *ComponentRestrictions) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(40, 0)
	if s.AdministrativeArea == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.AdministrativeArea)); err != nil {
			return err
		}
	}
	if s.Country == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.Country)); err != nil {
			return err
		}
	}
	if s.Locality == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.Locality)); err != nil {
			return err
		}
	}
	if s.PostalCode == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.PostalCode)); err != nil {
			return err
		}
	}
	if s.Route == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.Route)); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var componentRestrictions_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{48, 0},
}

func (s *ComponentRestrictions) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(componentRestrictions_Versions), func(i int) bool {
		return componentRestrictions_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(componentRestrictions_Versions) {
		if componentRestrictions_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := componentRestrictions_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.AdministrativeArea = nil
		} else {
			s.AdministrativeArea = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.AdministrativeArea) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Country = nil
		} else {
			s.Country = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.Country) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Locality = nil
		} else {
			s.Locality = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.Locality) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.PostalCode = nil
		} else {
			s.PostalCode = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.PostalCode) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Route = nil
		} else {
			s.Route = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.Route) = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type Options struct {
	Restrictions *ComponentRestrictions
	Location *location.Location
	Region *string
}


func (s *Options) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if s.Restrictions == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.Restrictions).Encode(encoder); err != nil {
			return err
		}
	}
	if s.Location == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.Location).Encode(encoder); err != nil {
			return err
		}
	}
	if s.Region == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.Region)); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var options_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *Options) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(options_Versions), func(i int) bool {
		return options_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(options_Versions) {
		if options_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := options_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Restrictions = nil
		} else {
			s.Restrictions = new(ComponentRestrictions)
			if err := (*s.Restrictions).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Location = nil
		} else {
			s.Location = new(location.Location)
			if err := (*s.Location).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Region = nil
		} else {
			s.Region = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.Region) = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type Geometry struct {
	Location location.Location
	LocationType LocationType
	Viewport Bounds
	Bounds *Bounds
}


func (s *Geometry) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.Location.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.LocationType.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.Viewport.Encode(encoder); err != nil {
		return err
	}
	if s.Bounds == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.Bounds).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var geometry_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *Geometry) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(geometry_Versions), func(i int) bool {
		return geometry_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(geometry_Versions) {
		if geometry_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := geometry_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.Location.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.LocationType.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.Viewport.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Bounds = nil
		} else {
			s.Bounds = new(Bounds)
			if err := (*s.Bounds).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type Result struct {
	PartialMatch bool
	Geometry Geometry
	FormattedAddress string
	Types []string
}


func (s *Result) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WriteBool(s.PartialMatch); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.Geometry.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.FormattedAddress); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.Types)), 64)
	for _, elem0 := range s.Types {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var result_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *Result) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(result_Versions), func(i int) bool {
		return result_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(result_Versions) {
		if result_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := result_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.PartialMatch = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.Geometry.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.FormattedAddress = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.Types = make([]string, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					value1, err := decoder.ReadString()
					if err != nil {
						return err
					}
					s.Types[i0] = value1
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type Status struct {
}


func (s *Status) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var status_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *Status) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(status_Versions), func(i int) bool {
		return status_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(status_Versions) {
		if status_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := status_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

