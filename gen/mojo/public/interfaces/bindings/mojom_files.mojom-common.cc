// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/public/interfaces/bindings/mojom_files.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace mojo {
namespace bindings {
namespace types {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// static
MojomFile_Data* MojomFile_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MojomFile_Data))) MojomFile_Data();
}

// static
mojo::internal::ValidationError MojomFile_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MojomFile_Data* object = static_cast<const MojomFile_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 64 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->file_name.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null file_name field in MojomFile struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->file_name.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams file_name_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->file_name.offset),
          bounds_checker, &file_name_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->specified_file_name.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams specified_file_name_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->specified_file_name.offset),
          bounds_checker, &specified_file_name_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->module_namespace.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams module_namespace_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->module_namespace.offset),
          bounds_checker, &module_namespace_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->attributes.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams attributes_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<mojo::bindings::types::AttributePtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->attributes.offset),
          bounds_checker, &attributes_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->imports.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams imports_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->imports.offset),
          bounds_checker, &imports_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->declared_mojom_objects.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null declared_mojom_objects field in MojomFile struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->declared_mojom_objects.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = KeysByType::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->declared_mojom_objects.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->serialized_runtime_type_info.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams serialized_runtime_type_info_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->serialized_runtime_type_info.offset),
          bounds_checker, &serialized_runtime_type_info_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MojomFile_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->file_name, handles);
  mojo::internal::Encode(&this->specified_file_name, handles);
  mojo::internal::Encode(&this->module_namespace, handles);
  mojo::internal::Encode(&this->attributes, handles);
  mojo::internal::Encode(&this->imports, handles);
  mojo::internal::Encode(&this->declared_mojom_objects, handles);
  mojo::internal::Encode(&this->serialized_runtime_type_info, handles);
}

void MojomFile_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->file_name, handles);
  mojo::internal::Decode(&this->specified_file_name, handles);
  mojo::internal::Decode(&this->module_namespace, handles);
  mojo::internal::Decode(&this->attributes, handles);
  mojo::internal::Decode(&this->imports, handles);
  mojo::internal::Decode(&this->declared_mojom_objects, handles);
  mojo::internal::Decode(&this->serialized_runtime_type_info, handles);
}

MojomFile_Data::MojomFile_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
MojomFileGraph_Data* MojomFileGraph_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MojomFileGraph_Data))) MojomFileGraph_Data();
}

// static
mojo::internal::ValidationError MojomFileGraph_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MojomFileGraph_Data* object = static_cast<const MojomFileGraph_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->files.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null files field in MojomFileGraph struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->files.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams files_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<mojo::String, MojomFilePtr>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->files.offset),
              bounds_checker, &files_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->resolved_types.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null resolved_types field in MojomFileGraph struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->resolved_types.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams resolved_types_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<mojo::String, mojo::bindings::types::UserDefinedTypePtr>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->resolved_types.offset),
              bounds_checker, &resolved_types_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->resolved_constants.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null resolved_constants field in MojomFileGraph struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->resolved_constants.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams resolved_constants_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<mojo::String, mojo::bindings::types::DeclaredConstantPtr>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->resolved_constants.offset),
              bounds_checker, &resolved_constants_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MojomFileGraph_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->files, handles);
  mojo::internal::Encode(&this->resolved_types, handles);
  mojo::internal::Encode(&this->resolved_constants, handles);
}

void MojomFileGraph_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->files, handles);
  mojo::internal::Decode(&this->resolved_types, handles);
  mojo::internal::Decode(&this->resolved_constants, handles);
}

MojomFileGraph_Data::MojomFileGraph_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
KeysByType_Data* KeysByType_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeysByType_Data))) KeysByType_Data();
}

// static
mojo::internal::ValidationError KeysByType_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeysByType_Data* object = static_cast<const KeysByType_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 64 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->interfaces.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams interfaces_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->interfaces.offset),
          bounds_checker, &interfaces_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->structs.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams structs_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->structs.offset),
          bounds_checker, &structs_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->unions.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams unions_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->unions.offset),
          bounds_checker, &unions_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->top_level_enums.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams top_level_enums_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->top_level_enums.offset),
          bounds_checker, &top_level_enums_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->embedded_enums.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams embedded_enums_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->embedded_enums.offset),
          bounds_checker, &embedded_enums_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->top_level_constants.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams top_level_constants_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->top_level_constants.offset),
          bounds_checker, &top_level_constants_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->embedded_constants.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams embedded_constants_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->embedded_constants.offset),
          bounds_checker, &embedded_constants_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void KeysByType_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->interfaces, handles);
  mojo::internal::Encode(&this->structs, handles);
  mojo::internal::Encode(&this->unions, handles);
  mojo::internal::Encode(&this->top_level_enums, handles);
  mojo::internal::Encode(&this->embedded_enums, handles);
  mojo::internal::Encode(&this->top_level_constants, handles);
  mojo::internal::Encode(&this->embedded_constants, handles);
}

void KeysByType_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->interfaces, handles);
  mojo::internal::Decode(&this->structs, handles);
  mojo::internal::Decode(&this->unions, handles);
  mojo::internal::Decode(&this->top_level_enums, handles);
  mojo::internal::Decode(&this->embedded_enums, handles);
  mojo::internal::Decode(&this->top_level_constants, handles);
  mojo::internal::Decode(&this->embedded_constants, handles);
}

KeysByType_Data::KeysByType_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// --- Union definitions ---


// --- Definitions of the data structs for interface methods ---

}  // namespace internal

// --- Request and response validator definitions for interfaces --- 

// --- Enums ---

// Base interface definitions (Name_, Version_, Constants, Enums)

// Struct Constants

// --- Struct builder definitions ---

// static
MojomFilePtr MojomFile::New() {
  MojomFilePtr rv;
  mojo::internal::StructHelper<MojomFile>::Initialize(&rv);
  return rv;
}

MojomFile::MojomFile()
    : file_name(),
      specified_file_name(),
      module_namespace(),
      attributes(),
      imports(),
      declared_mojom_objects(),
      serialized_runtime_type_info() {
}

MojomFile::~MojomFile() {
}


MojomFilePtr MojomFile::Clone() const {
  MojomFilePtr rv(New());
  rv->file_name = file_name;
  rv->specified_file_name = specified_file_name;
  rv->module_namespace = module_namespace;
  rv->attributes = attributes.Clone();
  rv->imports = imports.Clone();
  rv->declared_mojom_objects = declared_mojom_objects.Clone();
  rv->serialized_runtime_type_info = serialized_runtime_type_info;
  return rv;
}


bool MojomFile::Equals(const MojomFile& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->file_name, other.file_name))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->specified_file_name, other.specified_file_name))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->module_namespace, other.module_namespace))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::bindings::types::AttributePtr>>::Equals(this->attributes, other.attributes))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->imports, other.imports))
    return false;
  if (!mojo::internal::ValueTraits<KeysByTypePtr>::Equals(this->declared_mojom_objects, other.declared_mojom_objects))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->serialized_runtime_type_info, other.serialized_runtime_type_info))
    return false;
  return true;
}


// static
MojomFileGraphPtr MojomFileGraph::New() {
  MojomFileGraphPtr rv;
  mojo::internal::StructHelper<MojomFileGraph>::Initialize(&rv);
  return rv;
}

MojomFileGraph::MojomFileGraph()
    : files(),
      resolved_types(),
      resolved_constants() {
}

MojomFileGraph::~MojomFileGraph() {
}


MojomFileGraphPtr MojomFileGraph::Clone() const {
  MojomFileGraphPtr rv(New());
  rv->files = files.Clone();
  rv->resolved_types = resolved_types.Clone();
  rv->resolved_constants = resolved_constants.Clone();
  return rv;
}


bool MojomFileGraph::Equals(const MojomFileGraph& other) const {
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, MojomFilePtr>>::Equals(this->files, other.files))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::bindings::types::UserDefinedTypePtr>>::Equals(this->resolved_types, other.resolved_types))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::bindings::types::DeclaredConstantPtr>>::Equals(this->resolved_constants, other.resolved_constants))
    return false;
  return true;
}


// static
KeysByTypePtr KeysByType::New() {
  KeysByTypePtr rv;
  mojo::internal::StructHelper<KeysByType>::Initialize(&rv);
  return rv;
}

KeysByType::KeysByType()
    : interfaces(),
      structs(),
      unions(),
      top_level_enums(),
      embedded_enums(),
      top_level_constants(),
      embedded_constants() {
}

KeysByType::~KeysByType() {
}


KeysByTypePtr KeysByType::Clone() const {
  KeysByTypePtr rv(New());
  rv->interfaces = interfaces.Clone();
  rv->structs = structs.Clone();
  rv->unions = unions.Clone();
  rv->top_level_enums = top_level_enums.Clone();
  rv->embedded_enums = embedded_enums.Clone();
  rv->top_level_constants = top_level_constants.Clone();
  rv->embedded_constants = embedded_constants.Clone();
  return rv;
}


bool KeysByType::Equals(const KeysByType& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->interfaces, other.interfaces))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->structs, other.structs))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->unions, other.unions))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->top_level_enums, other.top_level_enums))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->embedded_enums, other.embedded_enums))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->top_level_constants, other.top_level_constants))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->embedded_constants, other.embedded_constants))
    return false;
  return true;
}


// --- Union builder definitions ---

// --- Struct Serialization Helpers ---

size_t MojomFile::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MojomFile::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MojomFile_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MojomFile::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MojomFile_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MojomFile::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MojomFile_Data* input =
      static_cast<internal::MojomFile_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MojomFile& input) {
  size_t size = sizeof(internal::MojomFile_Data);
  size += GetSerializedSize_(input.file_name);
  size += GetSerializedSize_(input.specified_file_name);
  size += GetSerializedSize_(input.module_namespace);
  size += GetSerializedSize_(input.attributes);
  size += GetSerializedSize_(input.imports);
  size += input.declared_mojom_objects.is_null()
              ? 0
              : GetSerializedSize_(*input.declared_mojom_objects);
  size += GetSerializedSize_(input.serialized_runtime_type_info);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MojomFile* input,
    mojo::internal::Buffer* buf,
    internal::MojomFile_Data** output) {
  if (input) {
    internal::MojomFile_Data* result =
        internal::MojomFile_Data::New(buf);
    SerializeString_(input->file_name, buf, &result->file_name.ptr);
    if (!result->file_name.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null file_name in MojomFile struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    SerializeString_(input->specified_file_name, buf, &result->specified_file_name.ptr);
    SerializeString_(input->module_namespace, buf, &result->module_namespace.ptr);
    {
      const mojo::internal::ArrayValidateParams attributes_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->attributes, buf, &result->attributes.ptr,
                            &attributes_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams imports_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->imports, buf, &result->imports.ptr,
                            &imports_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->declared_mojom_objects.get(),
                 buf,
                 &result->declared_mojom_objects.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->declared_mojom_objects.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null declared_mojom_objects in MojomFile struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    SerializeString_(input->serialized_runtime_type_info, buf, &result->serialized_runtime_type_info.ptr);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MojomFile_Data* input,
                  MojomFile* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->file_name.ptr, &result->file_name);
      Deserialize_(input->specified_file_name.ptr, &result->specified_file_name);
      Deserialize_(input->module_namespace.ptr, &result->module_namespace);
      Deserialize_(input->attributes.ptr, &result->attributes);
      Deserialize_(input->imports.ptr, &result->imports);
      if (input->declared_mojom_objects.ptr) {
        result->declared_mojom_objects = KeysByType::New();
        Deserialize_(input->declared_mojom_objects.ptr, result->declared_mojom_objects.get());
      }
      Deserialize_(input->serialized_runtime_type_info.ptr, &result->serialized_runtime_type_info);
    } while (false);
  }
}


size_t MojomFileGraph::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MojomFileGraph::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MojomFileGraph_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MojomFileGraph::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MojomFileGraph_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MojomFileGraph::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MojomFileGraph_Data* input =
      static_cast<internal::MojomFileGraph_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MojomFileGraph& input) {
  size_t size = sizeof(internal::MojomFileGraph_Data);
  size += GetSerializedSize_(input.files);
  size += GetSerializedSize_(input.resolved_types);
  size += GetSerializedSize_(input.resolved_constants);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MojomFileGraph* input,
    mojo::internal::Buffer* buf,
    internal::MojomFileGraph_Data** output) {
  if (input) {
    internal::MojomFileGraph_Data* result =
        internal::MojomFileGraph_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams files_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->files, buf, &result->files.ptr,
          &files_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->files.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null files in MojomFileGraph struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams resolved_types_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->resolved_types, buf, &result->resolved_types.ptr,
          &resolved_types_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->resolved_types.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null resolved_types in MojomFileGraph struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams resolved_constants_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->resolved_constants, buf, &result->resolved_constants.ptr,
          &resolved_constants_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->resolved_constants.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null resolved_constants in MojomFileGraph struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MojomFileGraph_Data* input,
                  MojomFileGraph* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->files.ptr, &result->files);
      Deserialize_(input->resolved_types.ptr, &result->resolved_types);
      Deserialize_(input->resolved_constants.ptr, &result->resolved_constants);
    } while (false);
  }
}


size_t KeysByType::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeysByType::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeysByType_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeysByType::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeysByType_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeysByType::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeysByType_Data* input =
      static_cast<internal::KeysByType_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeysByType& input) {
  size_t size = sizeof(internal::KeysByType_Data);
  size += GetSerializedSize_(input.interfaces);
  size += GetSerializedSize_(input.structs);
  size += GetSerializedSize_(input.unions);
  size += GetSerializedSize_(input.top_level_enums);
  size += GetSerializedSize_(input.embedded_enums);
  size += GetSerializedSize_(input.top_level_constants);
  size += GetSerializedSize_(input.embedded_constants);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeysByType* input,
    mojo::internal::Buffer* buf,
    internal::KeysByType_Data** output) {
  if (input) {
    internal::KeysByType_Data* result =
        internal::KeysByType_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams interfaces_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->interfaces, buf, &result->interfaces.ptr,
                            &interfaces_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams structs_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->structs, buf, &result->structs.ptr,
                            &structs_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams unions_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->unions, buf, &result->unions.ptr,
                            &unions_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams top_level_enums_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->top_level_enums, buf, &result->top_level_enums.ptr,
                            &top_level_enums_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams embedded_enums_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->embedded_enums, buf, &result->embedded_enums.ptr,
                            &embedded_enums_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams top_level_constants_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->top_level_constants, buf, &result->top_level_constants.ptr,
                            &top_level_constants_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams embedded_constants_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->embedded_constants, buf, &result->embedded_constants.ptr,
                            &embedded_constants_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeysByType_Data* input,
                  KeysByType* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->interfaces.ptr, &result->interfaces);
      Deserialize_(input->structs.ptr, &result->structs);
      Deserialize_(input->unions.ptr, &result->unions);
      Deserialize_(input->top_level_enums.ptr, &result->top_level_enums);
      Deserialize_(input->embedded_enums.ptr, &result->embedded_enums);
      Deserialize_(input->top_level_constants.ptr, &result->top_level_constants);
      Deserialize_(input->embedded_constants.ptr, &result->embedded_constants);
    } while (false);
  }
}


// --- Union Serialization Helpers ---

// --- Structs for interface method parameters ---
}  // namespace types
}  // namespace bindings
}  // namespace mojo
