// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/public/interfaces/bindings/tests/test_included_unions.mojom
//

package test_included_unions

import (
	ioutil "io/ioutil"
	bytes "bytes"
	fmt "fmt"
	base64 "encoding/base64"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	gzip "compress/gzip"
)

// This global variable contains a mojom_types.RuntimeTypeInfo struct
// describing the types defined in this file and all of its imports as
// well as the top-level interfaces defined in this file.
var runtimeTypeInfo__ = mojom_types.RuntimeTypeInfo{}

func getRuntimeTypeInfo() mojom_types.RuntimeTypeInfo {
  if runtimeTypeInfo__.TypeMap == nil {
    initRuntimeTypeInfo()
  }
  return runtimeTypeInfo__
}

func initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this file.
  // The string contains the base64 encoding of the gzip-compressed bytes.
  serializedRuntimeTypeInfo := "H4sIAAAJbogC/5JggAABKG0ApdHFYTQHGo2uzgGJz4ikTgOIFYA4JDLANd7bNdIqNz8rX68ktbhEzzMvOac0JTUlNC8zP08Cqg+knwmPPWBFSPYxoLkfJv4fCgIYsANRIOYFYhRHAPnyQCwOxDicieEediBmA+IUII4BYv2M/NxU/YLk3PyizJIq/aLESt3k/KJU/eKiZH2QmfoFpUk5mcn6mXklqUVpicmpxfpJmXkpmXnpxfog6yBkfCbU0vhSkK3FeiCtubjClwEaxsjuYkbzL67wYkAKL2Tz0AEn1N5EHPHCAQ0LeoUDIAAA//+GvNbjwAIAAA=="

  // Deserialize RuntimeTypeInfo
  compressedBytes, err := base64.StdEncoding.DecodeString(serializedRuntimeTypeInfo)
  if err != nil {
    panic(fmt.Sprintf("Error while base64Decoding runtimeTypeInfo: %s", err.Error()))
  }
  reader, err := gzip.NewReader(bytes.NewBuffer(compressedBytes))
  if err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  uncompressedBytes, err := ioutil.ReadAll(reader)
  if err != nil {
     panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  if err = reader.Close(); err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  decoder := bindings.NewDecoder(uncompressedBytes, nil)
  runtimeTypeInfo__.Decode(decoder)

}
func GetAllMojomTypeDefinitions() map[string]mojom_types.UserDefinedType {
  return getRuntimeTypeInfo().TypeMap
}

type IncludedUnion interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__IncludedUnionReflect)
	Encode(encoder *bindings.Encoder) error
}


// IncludedUnionMojomType returns the UserDefinedType that describes the Mojom
// type of IncludedUnion. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func IncludedUnionMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.IncludedUnion"]
}



type __IncludedUnionReflect struct {
	A int8
}

func DecodeIncludedUnion(decoder *bindings.Decoder) (IncludedUnion, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value IncludedUnionA
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &IncludedUnionUnknown{tag: tag}, nil
}

type IncludedUnionUnknown struct { tag uint32 }
func (u *IncludedUnionUnknown) Tag() uint32 { return u.tag }
func (u *IncludedUnionUnknown) Interface() interface{} { return nil }
func (u *IncludedUnionUnknown) __Reflect(__IncludedUnionReflect) {}

func (u *IncludedUnionUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown IncludedUnion. There is no sane way to do that!");
}

type IncludedUnionA struct { Value int8 }
func (u *IncludedUnionA) Tag() uint32 { return 0 }
func (u *IncludedUnionA) Interface() interface{} { return u.Value }
func (u *IncludedUnionA) __Reflect(__IncludedUnionReflect) {}

func (u *IncludedUnionA) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt8(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *IncludedUnionA) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt8()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*IncludedUnionA) MojomType() mojom_types.UserDefinedType {
	return IncludedUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*IncludedUnionA) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}



