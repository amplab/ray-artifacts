// NOTE: This file was generated by the Mojo bindings generator.
#ifndef MOJO_SERVICES_GPU_INTERFACES_COMMAND_BUFFER_MOJOM_COMMON_H_
#define MOJO_SERVICES_GPU_INTERFACES_COMMAND_BUFFER_MOJOM_COMMON_H_

#include <stdint.h>
#include <iosfwd>

#include "mojo/public/cpp/bindings/array.h"
#include "mojo/public/cpp/bindings/callback.h"
#include "mojo/public/cpp/bindings/interface_handle.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/map.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/bindings/string.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/system/buffer.h"
#include "mojo/public/cpp/system/data_pipe.h"
#include "mojo/public/cpp/system/handle.h"
#include "mojo/public/cpp/system/message_pipe.h"
#include "mojo/services/gpu/interfaces/command_buffer.mojom-internal.h"
#include "mojo/services/gpu/interfaces/gpu_capabilities.mojom-common.h"
namespace mojo {

// --- Interface Forward Declarations ---
class CommandBufferSyncClient;
class CommandBufferSyncClientRequestValidator;
class CommandBufferSyncClient_Synchronous;
class CommandBufferSyncPointClient;
class CommandBufferSyncPointClientRequestValidator;
class CommandBufferSyncPointClient_Synchronous;
class CommandBufferLostContextObserver;
class CommandBufferLostContextObserverRequestValidator;
class CommandBufferLostContextObserver_Synchronous;
class CommandBuffer;
class CommandBufferRequestValidator;
class CommandBufferResponseValidator;
class CommandBuffer_Synchronous;

// --- Struct Forward Declarations ---
class CommandBufferState;

using CommandBufferStatePtr = mojo::StructPtr<CommandBufferState>;



// --- Union Forward Declarations ---

// --- Enums Declarations ---

// --- Constants ---

// --- Interface declarations ---
namespace internal {
class CommandBufferSyncClient_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = CommandBufferSyncClientRequestValidator;
  using ResponseValidator_ = mojo::internal::PassThroughValidator;
  using Synchronous_ = CommandBufferSyncClient_Synchronous;
  enum class MessageOrdinals : uint32_t {
    DidInitialize = 0,
    DidMakeProgress = 1,
  };


  virtual ~CommandBufferSyncClient_Base() {}
};

}  // namespace internal

// Async interface declaration

class CommandBufferSyncClientProxy;
class CommandBufferSyncClientStub;
class CommandBufferSyncClient_Synchronous;

class CommandBufferSyncClientRequestValidator;

class CommandBufferSyncClient : public internal::CommandBufferSyncClient_Base {
 public:
  virtual ~CommandBufferSyncClient() override {}

  using Proxy_ = CommandBufferSyncClientProxy;
  using Stub_ = CommandBufferSyncClientStub;
  virtual void DidInitialize(bool success, mojo::GpuCapabilitiesPtr capabilities) = 0;
  virtual void DidMakeProgress(CommandBufferStatePtr state) = 0;
};

namespace internal {
class CommandBufferSyncPointClient_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = CommandBufferSyncPointClientRequestValidator;
  using ResponseValidator_ = mojo::internal::PassThroughValidator;
  using Synchronous_ = CommandBufferSyncPointClient_Synchronous;
  enum class MessageOrdinals : uint32_t {
    DidInsertSyncPoint = 0,
  };


  virtual ~CommandBufferSyncPointClient_Base() {}
};

}  // namespace internal

// Async interface declaration

class CommandBufferSyncPointClientProxy;
class CommandBufferSyncPointClientStub;
class CommandBufferSyncPointClient_Synchronous;

class CommandBufferSyncPointClientRequestValidator;

class CommandBufferSyncPointClient : public internal::CommandBufferSyncPointClient_Base {
 public:
  virtual ~CommandBufferSyncPointClient() override {}

  using Proxy_ = CommandBufferSyncPointClientProxy;
  using Stub_ = CommandBufferSyncPointClientStub;
  virtual void DidInsertSyncPoint(uint32_t sync_point) = 0;
};

namespace internal {
class CommandBufferLostContextObserver_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = CommandBufferLostContextObserverRequestValidator;
  using ResponseValidator_ = mojo::internal::PassThroughValidator;
  using Synchronous_ = CommandBufferLostContextObserver_Synchronous;
  enum class MessageOrdinals : uint32_t {
    DidLoseContext = 0,
  };


  virtual ~CommandBufferLostContextObserver_Base() {}
};

}  // namespace internal

// Async interface declaration

class CommandBufferLostContextObserverProxy;
class CommandBufferLostContextObserverStub;
class CommandBufferLostContextObserver_Synchronous;

class CommandBufferLostContextObserverRequestValidator;

class CommandBufferLostContextObserver : public internal::CommandBufferLostContextObserver_Base {
 public:
  virtual ~CommandBufferLostContextObserver() override {}

  using Proxy_ = CommandBufferLostContextObserverProxy;
  using Stub_ = CommandBufferLostContextObserverStub;
  virtual void DidLoseContext(int32_t context_lost_reason) = 0;
};

namespace internal {
class CommandBuffer_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = CommandBufferRequestValidator;
  using ResponseValidator_ = CommandBufferResponseValidator;
  using Synchronous_ = CommandBuffer_Synchronous;
  enum class MessageOrdinals : uint32_t {
    Initialize = 0,
    SetGetBuffer = 1,
    Flush = 2,
    MakeProgress = 3,
    RegisterTransferBuffer = 4,
    DestroyTransferBuffer = 5,
    InsertSyncPoint = 6,
    RetireSyncPoint = 7,
    Echo = 8,
  };


  virtual ~CommandBuffer_Base() {}
};

}  // namespace internal

// Async interface declaration

class CommandBufferProxy;
class CommandBufferStub;
class CommandBuffer_Synchronous;

class CommandBufferRequestValidator;
class CommandBufferResponseValidator;

class CommandBuffer : public internal::CommandBuffer_Base {
 public:
  virtual ~CommandBuffer() override {}

  using Proxy_ = CommandBufferProxy;
  using Stub_ = CommandBufferStub;
  virtual void Initialize(mojo::InterfaceHandle<CommandBufferSyncClient> sync_client, mojo::InterfaceHandle<CommandBufferSyncPointClient> sync_point_client, mojo::InterfaceHandle<CommandBufferLostContextObserver> lost_observer, mojo::ScopedSharedBufferHandle shared_state) = 0;
  virtual void SetGetBuffer(int32_t buffer) = 0;
  virtual void Flush(int32_t put_offset) = 0;
  virtual void MakeProgress(int32_t last_get_offset) = 0;
  virtual void RegisterTransferBuffer(int32_t id, mojo::ScopedSharedBufferHandle transfer_buffer, uint32_t size) = 0;
  virtual void DestroyTransferBuffer(int32_t id) = 0;
  virtual void InsertSyncPoint(bool retire) = 0;
  virtual void RetireSyncPoint(uint32_t sync_point) = 0;
  using EchoCallback = mojo::Callback<void()>;
  virtual void Echo(const EchoCallback& callback) = 0;
};

}  // namespace mojo

// --- Internal Template Specializations ---

namespace mojo {
namespace internal {
template <>
struct WrapperTraits<mojo::CommandBufferStatePtr, true, false> {
  using DataType = mojo::internal::CommandBufferState_Data*;
};

}  // internal
}  // mojo
namespace mojo {

// --- Interface Request Validators ---
class CommandBufferSyncClientRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class CommandBufferSyncPointClientRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class CommandBufferLostContextObserverRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class CommandBufferRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface Response Validators ---
class CommandBufferResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface enum operators ---

// --- Unions ---
// Unions must be declared first because they can be members of structs.

// --- Inlined structs ---

// --- Non-inlined structs ---
class CommandBufferState {
 public:
  using Data_ = internal::CommandBufferState_Data;

  static CommandBufferStatePtr New();

  template <typename U>
  static CommandBufferStatePtr From(const U& u) {
    return mojo::TypeConverter<CommandBufferStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBufferState>::Convert(*this);
  }

  CommandBufferState();
  ~CommandBufferState();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CommandBufferStatePtr Clone() const;
  bool Equals(const CommandBufferState& other) const;

  int32_t num_entries;
  int32_t get_offset;
  int32_t put_offset;
  int32_t token;
  int32_t error;
  int32_t context_lost_reason;
  uint32_t generation;
};



// --- Struct serialization helpers ---
size_t GetSerializedSize_(const CommandBufferState& input);
mojo::internal::ValidationError Serialize_(
    CommandBufferState* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBufferState_Data** output);
void Deserialize_(internal::CommandBufferState_Data* input,
                  CommandBufferState* output);


// --- Union serialization helpers ---

// --- Request and response parameter structs for Interface methods ---
      

class CommandBufferSyncClient_DidInitialize_Params;

using CommandBufferSyncClient_DidInitialize_ParamsPtr = mojo::StructPtr<CommandBufferSyncClient_DidInitialize_Params>;


size_t GetSerializedSize_(const CommandBufferSyncClient_DidInitialize_Params& input);
mojo::internal::ValidationError Serialize_(
    CommandBufferSyncClient_DidInitialize_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBufferSyncClient_DidInitialize_Params_Data** output);
void Deserialize_(internal::CommandBufferSyncClient_DidInitialize_Params_Data* input,
                  CommandBufferSyncClient_DidInitialize_Params* output);

class CommandBufferSyncClient_DidInitialize_Params {
 public:
  using Data_ = internal::CommandBufferSyncClient_DidInitialize_Params_Data;

  static CommandBufferSyncClient_DidInitialize_ParamsPtr New();

  template <typename U>
  static CommandBufferSyncClient_DidInitialize_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBufferSyncClient_DidInitialize_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBufferSyncClient_DidInitialize_Params>::Convert(*this);
  }

  CommandBufferSyncClient_DidInitialize_Params();
  ~CommandBufferSyncClient_DidInitialize_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CommandBufferSyncClient_DidInitialize_ParamsPtr Clone() const;
  bool Equals(const CommandBufferSyncClient_DidInitialize_Params& other) const;

  bool success;
  mojo::GpuCapabilitiesPtr capabilities;
};




class CommandBufferSyncClient_DidMakeProgress_Params;

using CommandBufferSyncClient_DidMakeProgress_ParamsPtr = mojo::StructPtr<CommandBufferSyncClient_DidMakeProgress_Params>;


size_t GetSerializedSize_(const CommandBufferSyncClient_DidMakeProgress_Params& input);
mojo::internal::ValidationError Serialize_(
    CommandBufferSyncClient_DidMakeProgress_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBufferSyncClient_DidMakeProgress_Params_Data** output);
void Deserialize_(internal::CommandBufferSyncClient_DidMakeProgress_Params_Data* input,
                  CommandBufferSyncClient_DidMakeProgress_Params* output);

class CommandBufferSyncClient_DidMakeProgress_Params {
 public:
  using Data_ = internal::CommandBufferSyncClient_DidMakeProgress_Params_Data;

  static CommandBufferSyncClient_DidMakeProgress_ParamsPtr New();

  template <typename U>
  static CommandBufferSyncClient_DidMakeProgress_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBufferSyncClient_DidMakeProgress_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBufferSyncClient_DidMakeProgress_Params>::Convert(*this);
  }

  CommandBufferSyncClient_DidMakeProgress_Params();
  ~CommandBufferSyncClient_DidMakeProgress_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CommandBufferSyncClient_DidMakeProgress_ParamsPtr Clone() const;
  bool Equals(const CommandBufferSyncClient_DidMakeProgress_Params& other) const;

  CommandBufferStatePtr state;
};



      

class CommandBufferSyncPointClient_DidInsertSyncPoint_Params;

using CommandBufferSyncPointClient_DidInsertSyncPoint_ParamsPtr = mojo::InlinedStructPtr<CommandBufferSyncPointClient_DidInsertSyncPoint_Params>;


size_t GetSerializedSize_(const CommandBufferSyncPointClient_DidInsertSyncPoint_Params& input);
mojo::internal::ValidationError Serialize_(
    CommandBufferSyncPointClient_DidInsertSyncPoint_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBufferSyncPointClient_DidInsertSyncPoint_Params_Data** output);
void Deserialize_(internal::CommandBufferSyncPointClient_DidInsertSyncPoint_Params_Data* input,
                  CommandBufferSyncPointClient_DidInsertSyncPoint_Params* output);

class CommandBufferSyncPointClient_DidInsertSyncPoint_Params {
 public:
  using Data_ = internal::CommandBufferSyncPointClient_DidInsertSyncPoint_Params_Data;

  static CommandBufferSyncPointClient_DidInsertSyncPoint_ParamsPtr New();

  template <typename U>
  static CommandBufferSyncPointClient_DidInsertSyncPoint_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBufferSyncPointClient_DidInsertSyncPoint_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBufferSyncPointClient_DidInsertSyncPoint_Params>::Convert(*this);
  }

  CommandBufferSyncPointClient_DidInsertSyncPoint_Params();
  ~CommandBufferSyncPointClient_DidInsertSyncPoint_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CommandBufferSyncPointClient_DidInsertSyncPoint_ParamsPtr Clone() const;
  bool Equals(const CommandBufferSyncPointClient_DidInsertSyncPoint_Params& other) const;

  uint32_t sync_point;
};



      

class CommandBufferLostContextObserver_DidLoseContext_Params;

using CommandBufferLostContextObserver_DidLoseContext_ParamsPtr = mojo::InlinedStructPtr<CommandBufferLostContextObserver_DidLoseContext_Params>;


size_t GetSerializedSize_(const CommandBufferLostContextObserver_DidLoseContext_Params& input);
mojo::internal::ValidationError Serialize_(
    CommandBufferLostContextObserver_DidLoseContext_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBufferLostContextObserver_DidLoseContext_Params_Data** output);
void Deserialize_(internal::CommandBufferLostContextObserver_DidLoseContext_Params_Data* input,
                  CommandBufferLostContextObserver_DidLoseContext_Params* output);

class CommandBufferLostContextObserver_DidLoseContext_Params {
 public:
  using Data_ = internal::CommandBufferLostContextObserver_DidLoseContext_Params_Data;

  static CommandBufferLostContextObserver_DidLoseContext_ParamsPtr New();

  template <typename U>
  static CommandBufferLostContextObserver_DidLoseContext_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBufferLostContextObserver_DidLoseContext_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBufferLostContextObserver_DidLoseContext_Params>::Convert(*this);
  }

  CommandBufferLostContextObserver_DidLoseContext_Params();
  ~CommandBufferLostContextObserver_DidLoseContext_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CommandBufferLostContextObserver_DidLoseContext_ParamsPtr Clone() const;
  bool Equals(const CommandBufferLostContextObserver_DidLoseContext_Params& other) const;

  int32_t context_lost_reason;
};



      

class CommandBuffer_Initialize_Params;

using CommandBuffer_Initialize_ParamsPtr = mojo::StructPtr<CommandBuffer_Initialize_Params>;


size_t GetSerializedSize_(const CommandBuffer_Initialize_Params& input);
mojo::internal::ValidationError Serialize_(
    CommandBuffer_Initialize_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBuffer_Initialize_Params_Data** output);
void Deserialize_(internal::CommandBuffer_Initialize_Params_Data* input,
                  CommandBuffer_Initialize_Params* output);

class CommandBuffer_Initialize_Params {
 public:
  using Data_ = internal::CommandBuffer_Initialize_Params_Data;

  static CommandBuffer_Initialize_ParamsPtr New();

  template <typename U>
  static CommandBuffer_Initialize_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBuffer_Initialize_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBuffer_Initialize_Params>::Convert(*this);
  }

  CommandBuffer_Initialize_Params();
  ~CommandBuffer_Initialize_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const CommandBuffer_Initialize_Params& other) const;

  mojo::InterfaceHandle<CommandBufferSyncClient> sync_client;
  mojo::InterfaceHandle<CommandBufferSyncPointClient> sync_point_client;
  mojo::InterfaceHandle<CommandBufferLostContextObserver> lost_observer;
  mojo::ScopedSharedBufferHandle shared_state;
};




class CommandBuffer_SetGetBuffer_Params;

using CommandBuffer_SetGetBuffer_ParamsPtr = mojo::InlinedStructPtr<CommandBuffer_SetGetBuffer_Params>;


size_t GetSerializedSize_(const CommandBuffer_SetGetBuffer_Params& input);
mojo::internal::ValidationError Serialize_(
    CommandBuffer_SetGetBuffer_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBuffer_SetGetBuffer_Params_Data** output);
void Deserialize_(internal::CommandBuffer_SetGetBuffer_Params_Data* input,
                  CommandBuffer_SetGetBuffer_Params* output);

class CommandBuffer_SetGetBuffer_Params {
 public:
  using Data_ = internal::CommandBuffer_SetGetBuffer_Params_Data;

  static CommandBuffer_SetGetBuffer_ParamsPtr New();

  template <typename U>
  static CommandBuffer_SetGetBuffer_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBuffer_SetGetBuffer_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBuffer_SetGetBuffer_Params>::Convert(*this);
  }

  CommandBuffer_SetGetBuffer_Params();
  ~CommandBuffer_SetGetBuffer_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CommandBuffer_SetGetBuffer_ParamsPtr Clone() const;
  bool Equals(const CommandBuffer_SetGetBuffer_Params& other) const;

  int32_t buffer;
};




class CommandBuffer_Flush_Params;

using CommandBuffer_Flush_ParamsPtr = mojo::InlinedStructPtr<CommandBuffer_Flush_Params>;


size_t GetSerializedSize_(const CommandBuffer_Flush_Params& input);
mojo::internal::ValidationError Serialize_(
    CommandBuffer_Flush_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBuffer_Flush_Params_Data** output);
void Deserialize_(internal::CommandBuffer_Flush_Params_Data* input,
                  CommandBuffer_Flush_Params* output);

class CommandBuffer_Flush_Params {
 public:
  using Data_ = internal::CommandBuffer_Flush_Params_Data;

  static CommandBuffer_Flush_ParamsPtr New();

  template <typename U>
  static CommandBuffer_Flush_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBuffer_Flush_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBuffer_Flush_Params>::Convert(*this);
  }

  CommandBuffer_Flush_Params();
  ~CommandBuffer_Flush_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CommandBuffer_Flush_ParamsPtr Clone() const;
  bool Equals(const CommandBuffer_Flush_Params& other) const;

  int32_t put_offset;
};




class CommandBuffer_MakeProgress_Params;

using CommandBuffer_MakeProgress_ParamsPtr = mojo::InlinedStructPtr<CommandBuffer_MakeProgress_Params>;


size_t GetSerializedSize_(const CommandBuffer_MakeProgress_Params& input);
mojo::internal::ValidationError Serialize_(
    CommandBuffer_MakeProgress_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBuffer_MakeProgress_Params_Data** output);
void Deserialize_(internal::CommandBuffer_MakeProgress_Params_Data* input,
                  CommandBuffer_MakeProgress_Params* output);

class CommandBuffer_MakeProgress_Params {
 public:
  using Data_ = internal::CommandBuffer_MakeProgress_Params_Data;

  static CommandBuffer_MakeProgress_ParamsPtr New();

  template <typename U>
  static CommandBuffer_MakeProgress_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBuffer_MakeProgress_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBuffer_MakeProgress_Params>::Convert(*this);
  }

  CommandBuffer_MakeProgress_Params();
  ~CommandBuffer_MakeProgress_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CommandBuffer_MakeProgress_ParamsPtr Clone() const;
  bool Equals(const CommandBuffer_MakeProgress_Params& other) const;

  int32_t last_get_offset;
};




class CommandBuffer_RegisterTransferBuffer_Params;

using CommandBuffer_RegisterTransferBuffer_ParamsPtr = mojo::StructPtr<CommandBuffer_RegisterTransferBuffer_Params>;


size_t GetSerializedSize_(const CommandBuffer_RegisterTransferBuffer_Params& input);
mojo::internal::ValidationError Serialize_(
    CommandBuffer_RegisterTransferBuffer_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBuffer_RegisterTransferBuffer_Params_Data** output);
void Deserialize_(internal::CommandBuffer_RegisterTransferBuffer_Params_Data* input,
                  CommandBuffer_RegisterTransferBuffer_Params* output);

class CommandBuffer_RegisterTransferBuffer_Params {
 public:
  using Data_ = internal::CommandBuffer_RegisterTransferBuffer_Params_Data;

  static CommandBuffer_RegisterTransferBuffer_ParamsPtr New();

  template <typename U>
  static CommandBuffer_RegisterTransferBuffer_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBuffer_RegisterTransferBuffer_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBuffer_RegisterTransferBuffer_Params>::Convert(*this);
  }

  CommandBuffer_RegisterTransferBuffer_Params();
  ~CommandBuffer_RegisterTransferBuffer_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const CommandBuffer_RegisterTransferBuffer_Params& other) const;

  int32_t id;
  mojo::ScopedSharedBufferHandle transfer_buffer;
  uint32_t size;
};




class CommandBuffer_DestroyTransferBuffer_Params;

using CommandBuffer_DestroyTransferBuffer_ParamsPtr = mojo::InlinedStructPtr<CommandBuffer_DestroyTransferBuffer_Params>;


size_t GetSerializedSize_(const CommandBuffer_DestroyTransferBuffer_Params& input);
mojo::internal::ValidationError Serialize_(
    CommandBuffer_DestroyTransferBuffer_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBuffer_DestroyTransferBuffer_Params_Data** output);
void Deserialize_(internal::CommandBuffer_DestroyTransferBuffer_Params_Data* input,
                  CommandBuffer_DestroyTransferBuffer_Params* output);

class CommandBuffer_DestroyTransferBuffer_Params {
 public:
  using Data_ = internal::CommandBuffer_DestroyTransferBuffer_Params_Data;

  static CommandBuffer_DestroyTransferBuffer_ParamsPtr New();

  template <typename U>
  static CommandBuffer_DestroyTransferBuffer_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBuffer_DestroyTransferBuffer_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBuffer_DestroyTransferBuffer_Params>::Convert(*this);
  }

  CommandBuffer_DestroyTransferBuffer_Params();
  ~CommandBuffer_DestroyTransferBuffer_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CommandBuffer_DestroyTransferBuffer_ParamsPtr Clone() const;
  bool Equals(const CommandBuffer_DestroyTransferBuffer_Params& other) const;

  int32_t id;
};




class CommandBuffer_InsertSyncPoint_Params;

using CommandBuffer_InsertSyncPoint_ParamsPtr = mojo::InlinedStructPtr<CommandBuffer_InsertSyncPoint_Params>;


size_t GetSerializedSize_(const CommandBuffer_InsertSyncPoint_Params& input);
mojo::internal::ValidationError Serialize_(
    CommandBuffer_InsertSyncPoint_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBuffer_InsertSyncPoint_Params_Data** output);
void Deserialize_(internal::CommandBuffer_InsertSyncPoint_Params_Data* input,
                  CommandBuffer_InsertSyncPoint_Params* output);

class CommandBuffer_InsertSyncPoint_Params {
 public:
  using Data_ = internal::CommandBuffer_InsertSyncPoint_Params_Data;

  static CommandBuffer_InsertSyncPoint_ParamsPtr New();

  template <typename U>
  static CommandBuffer_InsertSyncPoint_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBuffer_InsertSyncPoint_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBuffer_InsertSyncPoint_Params>::Convert(*this);
  }

  CommandBuffer_InsertSyncPoint_Params();
  ~CommandBuffer_InsertSyncPoint_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CommandBuffer_InsertSyncPoint_ParamsPtr Clone() const;
  bool Equals(const CommandBuffer_InsertSyncPoint_Params& other) const;

  bool retire;
};




class CommandBuffer_RetireSyncPoint_Params;

using CommandBuffer_RetireSyncPoint_ParamsPtr = mojo::InlinedStructPtr<CommandBuffer_RetireSyncPoint_Params>;


size_t GetSerializedSize_(const CommandBuffer_RetireSyncPoint_Params& input);
mojo::internal::ValidationError Serialize_(
    CommandBuffer_RetireSyncPoint_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBuffer_RetireSyncPoint_Params_Data** output);
void Deserialize_(internal::CommandBuffer_RetireSyncPoint_Params_Data* input,
                  CommandBuffer_RetireSyncPoint_Params* output);

class CommandBuffer_RetireSyncPoint_Params {
 public:
  using Data_ = internal::CommandBuffer_RetireSyncPoint_Params_Data;

  static CommandBuffer_RetireSyncPoint_ParamsPtr New();

  template <typename U>
  static CommandBuffer_RetireSyncPoint_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBuffer_RetireSyncPoint_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBuffer_RetireSyncPoint_Params>::Convert(*this);
  }

  CommandBuffer_RetireSyncPoint_Params();
  ~CommandBuffer_RetireSyncPoint_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CommandBuffer_RetireSyncPoint_ParamsPtr Clone() const;
  bool Equals(const CommandBuffer_RetireSyncPoint_Params& other) const;

  uint32_t sync_point;
};




class CommandBuffer_Echo_Params;

using CommandBuffer_Echo_ParamsPtr = mojo::InlinedStructPtr<CommandBuffer_Echo_Params>;


size_t GetSerializedSize_(const CommandBuffer_Echo_Params& input);
mojo::internal::ValidationError Serialize_(
    CommandBuffer_Echo_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBuffer_Echo_Params_Data** output);
void Deserialize_(internal::CommandBuffer_Echo_Params_Data* input,
                  CommandBuffer_Echo_Params* output);

class CommandBuffer_Echo_Params {
 public:
  using Data_ = internal::CommandBuffer_Echo_Params_Data;

  static CommandBuffer_Echo_ParamsPtr New();

  template <typename U>
  static CommandBuffer_Echo_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBuffer_Echo_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBuffer_Echo_Params>::Convert(*this);
  }

  CommandBuffer_Echo_Params();
  ~CommandBuffer_Echo_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CommandBuffer_Echo_ParamsPtr Clone() const;
  bool Equals(const CommandBuffer_Echo_Params& other) const;

};



class CommandBuffer_Echo_ResponseParams;

using CommandBuffer_Echo_ResponseParamsPtr = mojo::InlinedStructPtr<CommandBuffer_Echo_ResponseParams>;


size_t GetSerializedSize_(const CommandBuffer_Echo_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    CommandBuffer_Echo_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::CommandBuffer_Echo_ResponseParams_Data** output);
void Deserialize_(internal::CommandBuffer_Echo_ResponseParams_Data* input,
                  CommandBuffer_Echo_ResponseParams* output);

class CommandBuffer_Echo_ResponseParams {
 public:
  using Data_ = internal::CommandBuffer_Echo_ResponseParams_Data;

  static CommandBuffer_Echo_ResponseParamsPtr New();

  template <typename U>
  static CommandBuffer_Echo_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<CommandBuffer_Echo_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommandBuffer_Echo_ResponseParams>::Convert(*this);
  }

  CommandBuffer_Echo_ResponseParams();
  ~CommandBuffer_Echo_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CommandBuffer_Echo_ResponseParamsPtr Clone() const;
  bool Equals(const CommandBuffer_Echo_ResponseParams& other) const;

};


}  // namespace mojo

#endif  // MOJO_SERVICES_GPU_INTERFACES_COMMAND_BUFFER_MOJOM_COMMON_H_
