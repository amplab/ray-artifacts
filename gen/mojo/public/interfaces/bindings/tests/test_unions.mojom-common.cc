// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/public/interfaces/bindings/tests/test_unions.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace mojo {
namespace test {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// static
StructOfUnions_Data* StructOfUnions_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructOfUnions_Data))) StructOfUnions_Data();
}

// static
mojo::internal::ValidationError StructOfUnions_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructOfUnions_Data* object = static_cast<const StructOfUnions_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 56 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (object->u.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null u field in StructOfUnions struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = ObjectUnion::Data_::Validate(
          &object->u, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->a_ou.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null a_ou field in StructOfUnions struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->a_ou.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams a_ou_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<ObjectUnionPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->a_ou.offset),
          bounds_checker, &a_ou_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->a_hu.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null a_hu field in StructOfUnions struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->a_hu.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams a_hu_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<HandleUnionPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->a_hu.offset),
          bounds_checker, &a_hu_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->m_ou.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null m_ou field in StructOfUnions struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->m_ou.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams m_ou_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<int64_t, ObjectUnionPtr>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->m_ou.offset),
              bounds_checker, &m_ou_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->m_hu.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null m_hu field in StructOfUnions struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->m_hu.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams m_hu_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<int64_t, HandleUnionPtr>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->m_hu.offset),
              bounds_checker, &m_hu_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructOfUnions_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  u.EncodePointersAndHandles(handles);
  mojo::internal::Encode(&this->a_ou, handles);
  mojo::internal::Encode(&this->a_hu, handles);
  mojo::internal::Encode(&this->m_ou, handles);
  mojo::internal::Encode(&this->m_hu, handles);
}

void StructOfUnions_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  u.DecodePointersAndHandles(handles);
  mojo::internal::Decode(&this->a_ou, handles);
  mojo::internal::Decode(&this->a_hu, handles);
  mojo::internal::Decode(&this->m_ou, handles);
  mojo::internal::Decode(&this->m_hu, handles);
}

StructOfUnions_Data::StructOfUnions_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
WrapperStruct_Data* WrapperStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(WrapperStruct_Data))) WrapperStruct_Data();
}

// static
mojo::internal::ValidationError WrapperStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const WrapperStruct_Data* object = static_cast<const WrapperStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 56 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  auto validate_retval = ObjectUnion::Data_::Validate(
          &object->object_union, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  auto validate_retval = PodUnion::Data_::Validate(
          &object->pod_union, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  auto validate_retval = HandleUnion::Data_::Validate(
          &object->handle_union, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void WrapperStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  object_union.EncodePointersAndHandles(handles);
  pod_union.EncodePointersAndHandles(handles);
  handle_union.EncodePointersAndHandles(handles);
}

void WrapperStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  object_union.DecodePointersAndHandles(handles);
  pod_union.DecodePointersAndHandles(handles);
  handle_union.DecodePointersAndHandles(handles);
}

WrapperStruct_Data::WrapperStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
DummyStruct_Data* DummyStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(DummyStruct_Data))) DummyStruct_Data();
}

// static
mojo::internal::ValidationError DummyStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const DummyStruct_Data* object = static_cast<const DummyStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void DummyStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void DummyStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

DummyStruct_Data::DummyStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
SmallStruct_Data* SmallStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(SmallStruct_Data))) SmallStruct_Data();
}

// static
mojo::internal::ValidationError SmallStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const SmallStruct_Data* object = static_cast<const SmallStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 72 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->dummy_struct.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = DummyStruct::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->dummy_struct.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  auto validate_retval = PodUnion::Data_::Validate(
          &object->pod_union, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->pod_union_array.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams pod_union_array_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<PodUnionPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->pod_union_array.offset),
          bounds_checker, &pod_union_array_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->nullable_pod_union_array.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams nullable_pod_union_array_validate_params(
      0, true, nullptr);
  auto validate_retval =
      mojo::Array<PodUnionPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->nullable_pod_union_array.offset),
          bounds_checker, &nullable_pod_union_array_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->s_array.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams s_array_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<DummyStructPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->s_array.offset),
          bounds_checker, &s_array_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->pod_union_map.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams pod_union_map_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<mojo::String, PodUnionPtr>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->pod_union_map.offset),
              bounds_checker, &pod_union_map_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->nullable_pod_union_map.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams nullable_pod_union_map_validate_params(
      0, true, nullptr);
  auto validate_retval = mojo::Map<mojo::String, PodUnionPtr>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->nullable_pod_union_map.offset),
              bounds_checker, &nullable_pod_union_map_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void SmallStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->dummy_struct, handles);
  pod_union.EncodePointersAndHandles(handles);
  mojo::internal::Encode(&this->pod_union_array, handles);
  mojo::internal::Encode(&this->nullable_pod_union_array, handles);
  mojo::internal::Encode(&this->s_array, handles);
  mojo::internal::Encode(&this->pod_union_map, handles);
  mojo::internal::Encode(&this->nullable_pod_union_map, handles);
}

void SmallStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->dummy_struct, handles);
  pod_union.DecodePointersAndHandles(handles);
  mojo::internal::Decode(&this->pod_union_array, handles);
  mojo::internal::Decode(&this->nullable_pod_union_array, handles);
  mojo::internal::Decode(&this->s_array, handles);
  mojo::internal::Decode(&this->pod_union_map, handles);
  mojo::internal::Decode(&this->nullable_pod_union_map, handles);
}

SmallStruct_Data::SmallStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
SmallStructNonNullableUnion_Data* SmallStructNonNullableUnion_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(SmallStructNonNullableUnion_Data))) SmallStructNonNullableUnion_Data();
}

// static
mojo::internal::ValidationError SmallStructNonNullableUnion_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const SmallStructNonNullableUnion_Data* object = static_cast<const SmallStructNonNullableUnion_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (object->pod_union.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null pod_union field in SmallStructNonNullableUnion struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = PodUnion::Data_::Validate(
          &object->pod_union, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void SmallStructNonNullableUnion_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  pod_union.EncodePointersAndHandles(handles);
}

void SmallStructNonNullableUnion_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  pod_union.DecodePointersAndHandles(handles);
}

SmallStructNonNullableUnion_Data::SmallStructNonNullableUnion_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructNullObjectUnion_Data* StructNullObjectUnion_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructNullObjectUnion_Data))) StructNullObjectUnion_Data();
}

// static
mojo::internal::ValidationError StructNullObjectUnion_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructNullObjectUnion_Data* object = static_cast<const StructNullObjectUnion_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  auto validate_retval = ObjectOnlyUnion::Data_::Validate(
          &object->obj_union, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructNullObjectUnion_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  obj_union.EncodePointersAndHandles(handles);
}

void StructNullObjectUnion_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  obj_union.DecodePointersAndHandles(handles);
}

StructNullObjectUnion_Data::StructNullObjectUnion_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
SmallObjStruct_Data* SmallObjStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(SmallObjStruct_Data))) SmallObjStruct_Data();
}

// static
mojo::internal::ValidationError SmallObjStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const SmallObjStruct_Data* object = static_cast<const SmallObjStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (object->obj_union.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null obj_union field in SmallObjStruct struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = ObjectUnion::Data_::Validate(
          &object->obj_union, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void SmallObjStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  obj_union.EncodePointersAndHandles(handles);
}

void SmallObjStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  obj_union.DecodePointersAndHandles(handles);
}

SmallObjStruct_Data::SmallObjStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
TryNonNullStruct_Data* TryNonNullStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(TryNonNullStruct_Data))) TryNonNullStruct_Data();
}

// static
mojo::internal::ValidationError TryNonNullStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const TryNonNullStruct_Data* object = static_cast<const TryNonNullStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->nullable.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = DummyStruct::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->nullable.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->non_nullable.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null non_nullable field in TryNonNullStruct struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->non_nullable.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = DummyStruct::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->non_nullable.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void TryNonNullStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->nullable, handles);
  mojo::internal::Encode(&this->non_nullable, handles);
}

void TryNonNullStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->nullable, handles);
  mojo::internal::Decode(&this->non_nullable, handles);
}

TryNonNullStruct_Data::TryNonNullStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
IncludingStruct_Data* IncludingStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(IncludingStruct_Data))) IncludingStruct_Data();
}

// static
mojo::internal::ValidationError IncludingStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const IncludingStruct_Data* object = static_cast<const IncludingStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (object->a.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null a field in IncludingStruct struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = mojo::test::IncludedUnion::Data_::Validate(
          &object->a, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void IncludingStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  a.EncodePointersAndHandles(handles);
}

void IncludingStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  a.DecodePointersAndHandles(handles);
}

IncludingStruct_Data::IncludingStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// --- Union definitions ---
// static
PodUnion_Data* PodUnion_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(PodUnion_Data))) PodUnion_Data();
}


// static
mojo::internal::ValidationError PodUnion_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(PodUnion_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const PodUnion_Data* object = static_cast<const PodUnion_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case PodUnion_Tag::F_INT8: {

        return mojo::internal::ValidationError::NONE;
    }
    case PodUnion_Tag::F_INT8_OTHER: {

        return mojo::internal::ValidationError::NONE;
    }
    case PodUnion_Tag::F_UINT8: {

        return mojo::internal::ValidationError::NONE;
    }
    case PodUnion_Tag::F_INT16: {

        return mojo::internal::ValidationError::NONE;
    }
    case PodUnion_Tag::F_UINT16: {

        return mojo::internal::ValidationError::NONE;
    }
    case PodUnion_Tag::F_INT32: {

        return mojo::internal::ValidationError::NONE;
    }
    case PodUnion_Tag::F_UINT32: {

        return mojo::internal::ValidationError::NONE;
    }
    case PodUnion_Tag::F_INT64: {

        return mojo::internal::ValidationError::NONE;
    }
    case PodUnion_Tag::F_UINT64: {

        return mojo::internal::ValidationError::NONE;
    }
    case PodUnion_Tag::F_FLOAT: {

        return mojo::internal::ValidationError::NONE;
    }
    case PodUnion_Tag::F_DOUBLE: {

        return mojo::internal::ValidationError::NONE;
    }
    case PodUnion_Tag::F_BOOL: {

        return mojo::internal::ValidationError::NONE;
    }
    case PodUnion_Tag::F_ENUM: {

        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void PodUnion_Data::set_null() {
  size = 0U;
  tag = static_cast<PodUnion_Tag>(0);
  data.unknown = 0U;
}

PodUnion_Data::PodUnion_Data() {
}

void PodUnion_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case PodUnion_Tag::F_INT8: {
      return;
    }
    case PodUnion_Tag::F_INT8_OTHER: {
      return;
    }
    case PodUnion_Tag::F_UINT8: {
      return;
    }
    case PodUnion_Tag::F_INT16: {
      return;
    }
    case PodUnion_Tag::F_UINT16: {
      return;
    }
    case PodUnion_Tag::F_INT32: {
      return;
    }
    case PodUnion_Tag::F_UINT32: {
      return;
    }
    case PodUnion_Tag::F_INT64: {
      return;
    }
    case PodUnion_Tag::F_UINT64: {
      return;
    }
    case PodUnion_Tag::F_FLOAT: {
      return;
    }
    case PodUnion_Tag::F_DOUBLE: {
      return;
    }
    case PodUnion_Tag::F_BOOL: {
      return;
    }
    case PodUnion_Tag::F_ENUM: {
      return;
    }
    case PodUnion_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void PodUnion_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case PodUnion_Tag::F_INT8: {
      return;
    }
    case PodUnion_Tag::F_INT8_OTHER: {
      return;
    }
    case PodUnion_Tag::F_UINT8: {
      return;
    }
    case PodUnion_Tag::F_INT16: {
      return;
    }
    case PodUnion_Tag::F_UINT16: {
      return;
    }
    case PodUnion_Tag::F_INT32: {
      return;
    }
    case PodUnion_Tag::F_UINT32: {
      return;
    }
    case PodUnion_Tag::F_INT64: {
      return;
    }
    case PodUnion_Tag::F_UINT64: {
      return;
    }
    case PodUnion_Tag::F_FLOAT: {
      return;
    }
    case PodUnion_Tag::F_DOUBLE: {
      return;
    }
    case PodUnion_Tag::F_BOOL: {
      return;
    }
    case PodUnion_Tag::F_ENUM: {
      return;
    }
    default:
      return;
  }
}
// static
UnionOfUnions_Data* UnionOfUnions_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(UnionOfUnions_Data))) UnionOfUnions_Data();
}


// static
mojo::internal::ValidationError UnionOfUnions_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(UnionOfUnions_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const UnionOfUnions_Data* object = static_cast<const UnionOfUnions_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case UnionOfUnions_Tag::U: {

        if (!(reinterpret_cast<const mojo::internal::UnionPointer<internal::ObjectUnion_Data>*>(&object->data.f_u))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'u' in 'UnionOfUnions'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::UnionPointer<internal::ObjectUnion_Data>*>(&object->data.f_u))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionOfUnions_Tag::A_OU: {

        if (!(reinterpret_cast<const mojo::internal::ArrayPointer<internal::ObjectUnion_Data>*>(&object->data.f_a_ou))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'a_ou' in 'UnionOfUnions'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::ArrayPointer<internal::ObjectUnion_Data>*>(&object->data.f_a_ou))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }const mojo::internal::ArrayValidateParams a_ou_validate_params(
            0, false, nullptr);
        auto validate_retval = mojo::Array<ObjectUnionPtr>::Data_::Validate(
                mojo::internal::DecodePointerRaw(&(reinterpret_cast<const mojo::internal::ArrayPointer<internal::ObjectUnion_Data>*>(&object->data.f_a_ou))->offset),
                bounds_checker, &a_ou_validate_params,
                err);
        if (validate_retval != mojo::internal::ValidationError::NONE) {
          return validate_retval;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionOfUnions_Tag::A_HU: {

        if (!(reinterpret_cast<const mojo::internal::ArrayPointer<internal::HandleUnion_Data>*>(&object->data.f_a_hu))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'a_hu' in 'UnionOfUnions'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::ArrayPointer<internal::HandleUnion_Data>*>(&object->data.f_a_hu))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }const mojo::internal::ArrayValidateParams a_hu_validate_params(
            0, false, nullptr);
        auto validate_retval = mojo::Array<HandleUnionPtr>::Data_::Validate(
                mojo::internal::DecodePointerRaw(&(reinterpret_cast<const mojo::internal::ArrayPointer<internal::HandleUnion_Data>*>(&object->data.f_a_hu))->offset),
                bounds_checker, &a_hu_validate_params,
                err);
        if (validate_retval != mojo::internal::ValidationError::NONE) {
          return validate_retval;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionOfUnions_Tag::M_OU: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<mojo::internal::Map_Data<int64_t, internal::ObjectUnion_Data>>*>(&object->data.f_m_ou))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'm_ou' in 'UnionOfUnions'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<mojo::internal::Map_Data<int64_t, internal::ObjectUnion_Data>>*>(&object->data.f_m_ou))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionOfUnions_Tag::M_HU: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<mojo::internal::Map_Data<int64_t, internal::HandleUnion_Data>>*>(&object->data.f_m_hu))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'm_hu' in 'UnionOfUnions'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<mojo::internal::Map_Data<int64_t, internal::HandleUnion_Data>>*>(&object->data.f_m_hu))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void UnionOfUnions_Data::set_null() {
  size = 0U;
  tag = static_cast<UnionOfUnions_Tag>(0);
  data.unknown = 0U;
}

UnionOfUnions_Data::UnionOfUnions_Data() {
}

void UnionOfUnions_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case UnionOfUnions_Tag::U: {
      mojo::internal::Encode(&data.f_u, handles);
      return;
    }
    case UnionOfUnions_Tag::A_OU: {
      mojo::internal::Encode(&data.f_a_ou, handles);
      return;
    }
    case UnionOfUnions_Tag::A_HU: {
      mojo::internal::Encode(&data.f_a_hu, handles);
      return;
    }
    case UnionOfUnions_Tag::M_OU: {
      mojo::internal::Encode(&data.f_m_ou, handles);
      return;
    }
    case UnionOfUnions_Tag::M_HU: {
      mojo::internal::Encode(&data.f_m_hu, handles);
      return;
    }
    case UnionOfUnions_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void UnionOfUnions_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case UnionOfUnions_Tag::U: {
      mojo::internal::Decode(&data.f_u, handles);
      return;
    }
    case UnionOfUnions_Tag::A_OU: {
      mojo::internal::Decode(&data.f_a_ou, handles);
      return;
    }
    case UnionOfUnions_Tag::A_HU: {
      mojo::internal::Decode(&data.f_a_hu, handles);
      return;
    }
    case UnionOfUnions_Tag::M_OU: {
      mojo::internal::Decode(&data.f_m_ou, handles);
      return;
    }
    case UnionOfUnions_Tag::M_HU: {
      mojo::internal::Decode(&data.f_m_hu, handles);
      return;
    }
    default:
      return;
  }
}
// static
ObjectUnion_Data* ObjectUnion_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ObjectUnion_Data))) ObjectUnion_Data();
}


// static
mojo::internal::ValidationError ObjectUnion_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(ObjectUnion_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const ObjectUnion_Data* object = static_cast<const ObjectUnion_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case ObjectUnion_Tag::F_INT8: {

        return mojo::internal::ValidationError::NONE;
    }
    case ObjectUnion_Tag::F_STRING: {

        if (!(reinterpret_cast<const mojo::internal::StringPointer*>(&object->data.f_f_string))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'f_string' in 'ObjectUnion'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StringPointer*>(&object->data.f_f_string))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }const mojo::internal::ArrayValidateParams f_string_validate_params(
            0, false, nullptr);
        auto validate_retval = mojo::String::Data_::Validate(
                mojo::internal::DecodePointerRaw(&(reinterpret_cast<const mojo::internal::StringPointer*>(&object->data.f_f_string))->offset),
                bounds_checker, &f_string_validate_params,
                err);
        if (validate_retval != mojo::internal::ValidationError::NONE) {
          return validate_retval;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case ObjectUnion_Tag::F_DUMMY: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::DummyStruct_Data>*>(&object->data.f_f_dummy))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'f_dummy' in 'ObjectUnion'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::DummyStruct_Data>*>(&object->data.f_f_dummy))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case ObjectUnion_Tag::F_NULLABLE: {

        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::DummyStruct_Data>*>(&object->data.f_f_nullable))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case ObjectUnion_Tag::F_ARRAY_INT8: {

        if (!(reinterpret_cast<const mojo::internal::ArrayPointer<int8_t>*>(&object->data.f_f_array_int8))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'f_array_int8' in 'ObjectUnion'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::ArrayPointer<int8_t>*>(&object->data.f_f_array_int8))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }const mojo::internal::ArrayValidateParams f_array_int8_validate_params(
            0, false, nullptr);
        auto validate_retval = mojo::Array<int8_t>::Data_::Validate(
                mojo::internal::DecodePointerRaw(&(reinterpret_cast<const mojo::internal::ArrayPointer<int8_t>*>(&object->data.f_f_array_int8))->offset),
                bounds_checker, &f_array_int8_validate_params,
                err);
        if (validate_retval != mojo::internal::ValidationError::NONE) {
          return validate_retval;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case ObjectUnion_Tag::F_MAP_INT8: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<mojo::internal::Map_Data<mojo::internal::String_Data*, int8_t>>*>(&object->data.f_f_map_int8))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'f_map_int8' in 'ObjectUnion'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<mojo::internal::Map_Data<mojo::internal::String_Data*, int8_t>>*>(&object->data.f_f_map_int8))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case ObjectUnion_Tag::F_POD_UNION: {

        if (!(reinterpret_cast<const mojo::internal::UnionPointer<internal::PodUnion_Data>*>(&object->data.f_f_pod_union))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'f_pod_union' in 'ObjectUnion'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::UnionPointer<internal::PodUnion_Data>*>(&object->data.f_f_pod_union))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void ObjectUnion_Data::set_null() {
  size = 0U;
  tag = static_cast<ObjectUnion_Tag>(0);
  data.unknown = 0U;
}

ObjectUnion_Data::ObjectUnion_Data() {
}

void ObjectUnion_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case ObjectUnion_Tag::F_INT8: {
      return;
    }
    case ObjectUnion_Tag::F_STRING: {
      mojo::internal::Encode(&data.f_f_string, handles);
      return;
    }
    case ObjectUnion_Tag::F_DUMMY: {
      mojo::internal::Encode(&data.f_f_dummy, handles);
      return;
    }
    case ObjectUnion_Tag::F_NULLABLE: {
      mojo::internal::Encode(&data.f_f_nullable, handles);
      return;
    }
    case ObjectUnion_Tag::F_ARRAY_INT8: {
      mojo::internal::Encode(&data.f_f_array_int8, handles);
      return;
    }
    case ObjectUnion_Tag::F_MAP_INT8: {
      mojo::internal::Encode(&data.f_f_map_int8, handles);
      return;
    }
    case ObjectUnion_Tag::F_POD_UNION: {
      mojo::internal::Encode(&data.f_f_pod_union, handles);
      return;
    }
    case ObjectUnion_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void ObjectUnion_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case ObjectUnion_Tag::F_INT8: {
      return;
    }
    case ObjectUnion_Tag::F_STRING: {
      mojo::internal::Decode(&data.f_f_string, handles);
      return;
    }
    case ObjectUnion_Tag::F_DUMMY: {
      mojo::internal::Decode(&data.f_f_dummy, handles);
      return;
    }
    case ObjectUnion_Tag::F_NULLABLE: {
      mojo::internal::Decode(&data.f_f_nullable, handles);
      return;
    }
    case ObjectUnion_Tag::F_ARRAY_INT8: {
      mojo::internal::Decode(&data.f_f_array_int8, handles);
      return;
    }
    case ObjectUnion_Tag::F_MAP_INT8: {
      mojo::internal::Decode(&data.f_f_map_int8, handles);
      return;
    }
    case ObjectUnion_Tag::F_POD_UNION: {
      mojo::internal::Decode(&data.f_f_pod_union, handles);
      return;
    }
    default:
      return;
  }
}
// static
HandleUnion_Data* HandleUnion_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(HandleUnion_Data))) HandleUnion_Data();
}


// static
mojo::internal::ValidationError HandleUnion_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(HandleUnion_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const HandleUnion_Data* object = static_cast<const HandleUnion_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case HandleUnion_Tag::F_HANDLE: {
const mojo::Handle f_handle_handle(object->data.f_f_handle);
          if (f_handle_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
            MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
               << "invalid f_handle field in HandleUnion";
            return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
          }
          if (!bounds_checker->ClaimHandle(f_handle_handle)) {
            MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
            return mojo::internal::ValidationError::ILLEGAL_HANDLE;
          }
        return mojo::internal::ValidationError::NONE;
    }
    case HandleUnion_Tag::F_MESSAGE_PIPE: {
const mojo::Handle f_message_pipe_handle(object->data.f_f_message_pipe);
          if (f_message_pipe_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
            MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
               << "invalid f_message_pipe field in HandleUnion";
            return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
          }
          if (!bounds_checker->ClaimHandle(f_message_pipe_handle)) {
            MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
            return mojo::internal::ValidationError::ILLEGAL_HANDLE;
          }
        return mojo::internal::ValidationError::NONE;
    }
    case HandleUnion_Tag::F_DATA_PIPE_CONSUMER: {
const mojo::Handle f_data_pipe_consumer_handle(object->data.f_f_data_pipe_consumer);
          if (f_data_pipe_consumer_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
            MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
               << "invalid f_data_pipe_consumer field in HandleUnion";
            return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
          }
          if (!bounds_checker->ClaimHandle(f_data_pipe_consumer_handle)) {
            MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
            return mojo::internal::ValidationError::ILLEGAL_HANDLE;
          }
        return mojo::internal::ValidationError::NONE;
    }
    case HandleUnion_Tag::F_DATA_PIPE_PRODUCER: {
const mojo::Handle f_data_pipe_producer_handle(object->data.f_f_data_pipe_producer);
          if (f_data_pipe_producer_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
            MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
               << "invalid f_data_pipe_producer field in HandleUnion";
            return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
          }
          if (!bounds_checker->ClaimHandle(f_data_pipe_producer_handle)) {
            MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
            return mojo::internal::ValidationError::ILLEGAL_HANDLE;
          }
        return mojo::internal::ValidationError::NONE;
    }
    case HandleUnion_Tag::F_SHARED_BUFFER: {
const mojo::Handle f_shared_buffer_handle(object->data.f_f_shared_buffer);
          if (f_shared_buffer_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
            MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
               << "invalid f_shared_buffer field in HandleUnion";
            return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
          }
          if (!bounds_checker->ClaimHandle(f_shared_buffer_handle)) {
            MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
            return mojo::internal::ValidationError::ILLEGAL_HANDLE;
          }
        return mojo::internal::ValidationError::NONE;
    }
    case HandleUnion_Tag::F_SMALL_CACHE: {

        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void HandleUnion_Data::set_null() {
  size = 0U;
  tag = static_cast<HandleUnion_Tag>(0);
  data.unknown = 0U;
}

HandleUnion_Data::HandleUnion_Data() {
}

void HandleUnion_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case HandleUnion_Tag::F_HANDLE: {
      mojo::internal::EncodeHandle(&data.f_f_handle, handles);
      return;
    }
    case HandleUnion_Tag::F_MESSAGE_PIPE: {
      mojo::internal::EncodeHandle(&data.f_f_message_pipe, handles);
      return;
    }
    case HandleUnion_Tag::F_DATA_PIPE_CONSUMER: {
      mojo::internal::EncodeHandle(&data.f_f_data_pipe_consumer, handles);
      return;
    }
    case HandleUnion_Tag::F_DATA_PIPE_PRODUCER: {
      mojo::internal::EncodeHandle(&data.f_f_data_pipe_producer, handles);
      return;
    }
    case HandleUnion_Tag::F_SHARED_BUFFER: {
      mojo::internal::EncodeHandle(&data.f_f_shared_buffer, handles);
      return;
    }
    case HandleUnion_Tag::F_SMALL_CACHE: {
      mojo::internal::EncodeHandle(
          reinterpret_cast<mojo::internal::Interface_Data*>(
              &data.f_f_small_cache), handles);
      return;
    }
    case HandleUnion_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void HandleUnion_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case HandleUnion_Tag::F_HANDLE: {
      mojo::internal::DecodeHandle(&data.f_f_handle, handles);
      return;
    }
    case HandleUnion_Tag::F_MESSAGE_PIPE: {
      mojo::internal::DecodeHandle(&data.f_f_message_pipe, handles);
      return;
    }
    case HandleUnion_Tag::F_DATA_PIPE_CONSUMER: {
      mojo::internal::DecodeHandle(&data.f_f_data_pipe_consumer, handles);
      return;
    }
    case HandleUnion_Tag::F_DATA_PIPE_PRODUCER: {
      mojo::internal::DecodeHandle(&data.f_f_data_pipe_producer, handles);
      return;
    }
    case HandleUnion_Tag::F_SHARED_BUFFER: {
      mojo::internal::DecodeHandle(&data.f_f_shared_buffer, handles);
      return;
    }
    case HandleUnion_Tag::F_SMALL_CACHE: {
      mojo::internal::DecodeHandle(
          reinterpret_cast<mojo::internal::Interface_Data*>(
              &data.f_f_small_cache), handles);
      return;
    }
    default:
      return;
  }
}
// static
ObjectOnlyUnion_Data* ObjectOnlyUnion_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ObjectOnlyUnion_Data))) ObjectOnlyUnion_Data();
}


// static
mojo::internal::ValidationError ObjectOnlyUnion_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(ObjectOnlyUnion_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const ObjectOnlyUnion_Data* object = static_cast<const ObjectOnlyUnion_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case ObjectOnlyUnion_Tag::DUMMY1: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::DummyStruct_Data>*>(&object->data.f_dummy1))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'dummy1' in 'ObjectOnlyUnion'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::DummyStruct_Data>*>(&object->data.f_dummy1))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void ObjectOnlyUnion_Data::set_null() {
  size = 0U;
  tag = static_cast<ObjectOnlyUnion_Tag>(0);
  data.unknown = 0U;
}

ObjectOnlyUnion_Data::ObjectOnlyUnion_Data() {
}

void ObjectOnlyUnion_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case ObjectOnlyUnion_Tag::DUMMY1: {
      mojo::internal::Encode(&data.f_dummy1, handles);
      return;
    }
    case ObjectOnlyUnion_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void ObjectOnlyUnion_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case ObjectOnlyUnion_Tag::DUMMY1: {
      mojo::internal::Decode(&data.f_dummy1, handles);
      return;
    }
    default:
      return;
  }
}
// static
OldUnion_Data* OldUnion_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(OldUnion_Data))) OldUnion_Data();
}


// static
mojo::internal::ValidationError OldUnion_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(OldUnion_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const OldUnion_Data* object = static_cast<const OldUnion_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case OldUnion_Tag::F_INT8: {

        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void OldUnion_Data::set_null() {
  size = 0U;
  tag = static_cast<OldUnion_Tag>(0);
  data.unknown = 0U;
}

OldUnion_Data::OldUnion_Data() {
}

void OldUnion_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case OldUnion_Tag::F_INT8: {
      return;
    }
    case OldUnion_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void OldUnion_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case OldUnion_Tag::F_INT8: {
      return;
    }
    default:
      return;
  }
}
// static
NewUnion_Data* NewUnion_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(NewUnion_Data))) NewUnion_Data();
}


// static
mojo::internal::ValidationError NewUnion_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(NewUnion_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const NewUnion_Data* object = static_cast<const NewUnion_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case NewUnion_Tag::F_INT8: {

        return mojo::internal::ValidationError::NONE;
    }
    case NewUnion_Tag::F_INT16: {

        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void NewUnion_Data::set_null() {
  size = 0U;
  tag = static_cast<NewUnion_Tag>(0);
  data.unknown = 0U;
}

NewUnion_Data::NewUnion_Data() {
}

void NewUnion_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case NewUnion_Tag::F_INT8: {
      return;
    }
    case NewUnion_Tag::F_INT16: {
      return;
    }
    case NewUnion_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void NewUnion_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case NewUnion_Tag::F_INT8: {
      return;
    }
    case NewUnion_Tag::F_INT16: {
      return;
    }
    default:
      return;
  }
}


// --- Definitions of the data structs for interface methods ---


// static
SmallCache_SetIntValue_Params_Data* SmallCache_SetIntValue_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(SmallCache_SetIntValue_Params_Data))) SmallCache_SetIntValue_Params_Data();
}

// static
mojo::internal::ValidationError SmallCache_SetIntValue_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const SmallCache_SetIntValue_Params_Data* object = static_cast<const SmallCache_SetIntValue_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void SmallCache_SetIntValue_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void SmallCache_SetIntValue_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

SmallCache_SetIntValue_Params_Data::SmallCache_SetIntValue_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
SmallCache_GetIntValue_Params_Data* SmallCache_GetIntValue_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(SmallCache_GetIntValue_Params_Data))) SmallCache_GetIntValue_Params_Data();
}

// static
mojo::internal::ValidationError SmallCache_GetIntValue_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const SmallCache_GetIntValue_Params_Data* object = static_cast<const SmallCache_GetIntValue_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void SmallCache_GetIntValue_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void SmallCache_GetIntValue_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

SmallCache_GetIntValue_Params_Data::SmallCache_GetIntValue_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
SmallCache_GetIntValue_ResponseParams_Data* SmallCache_GetIntValue_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(SmallCache_GetIntValue_ResponseParams_Data))) SmallCache_GetIntValue_ResponseParams_Data();
}

// static
mojo::internal::ValidationError SmallCache_GetIntValue_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const SmallCache_GetIntValue_ResponseParams_Data* object = static_cast<const SmallCache_GetIntValue_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void SmallCache_GetIntValue_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void SmallCache_GetIntValue_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

SmallCache_GetIntValue_ResponseParams_Data::SmallCache_GetIntValue_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
UnionInterface_Echo_Params_Data* UnionInterface_Echo_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(UnionInterface_Echo_Params_Data))) UnionInterface_Echo_Params_Data();
}

// static
mojo::internal::ValidationError UnionInterface_Echo_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const UnionInterface_Echo_Params_Data* object = static_cast<const UnionInterface_Echo_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (object->in_val.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null in_val field in UnionInterface_Echo_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = PodUnion::Data_::Validate(
          &object->in_val, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void UnionInterface_Echo_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  in_val.EncodePointersAndHandles(handles);
}

void UnionInterface_Echo_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  in_val.DecodePointersAndHandles(handles);
}

UnionInterface_Echo_Params_Data::UnionInterface_Echo_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
UnionInterface_Echo_ResponseParams_Data* UnionInterface_Echo_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(UnionInterface_Echo_ResponseParams_Data))) UnionInterface_Echo_ResponseParams_Data();
}

// static
mojo::internal::ValidationError UnionInterface_Echo_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const UnionInterface_Echo_ResponseParams_Data* object = static_cast<const UnionInterface_Echo_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (object->out_val.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null out_val field in UnionInterface_Echo_ResponseParams struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = PodUnion::Data_::Validate(
          &object->out_val, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void UnionInterface_Echo_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  out_val.EncodePointersAndHandles(handles);
}

void UnionInterface_Echo_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  out_val.DecodePointersAndHandles(handles);
}

UnionInterface_Echo_ResponseParams_Data::UnionInterface_Echo_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


}  // namespace internal

// --- Request and response validator definitions for interfaces ---
mojo::internal::ValidationError SmallCacheRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'SmallCache', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::SmallCache_Base::MessageOrdinals method_ordinal =
      static_cast<internal::SmallCache_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::SmallCache_Base::MessageOrdinals::SetIntValue: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'SmallCache', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::SmallCache_SetIntValue_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'SmallCache', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::SmallCache_Base::MessageOrdinals::GetIntValue: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'SmallCache', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::SmallCache_GetIntValue_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'SmallCache', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'SmallCache'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError SmallCacheResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'SmallCache', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'SmallCache', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::SmallCache_Base::MessageOrdinals method_ordinal =
      static_cast<internal::SmallCache_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::SmallCache_Base::MessageOrdinals::GetIntValue: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::SmallCache_GetIntValue_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'SmallCache',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'SmallCache'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError UnionInterfaceRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'UnionInterface', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::UnionInterface_Base::MessageOrdinals method_ordinal =
      static_cast<internal::UnionInterface_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::UnionInterface_Base::MessageOrdinals::Echo: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'UnionInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::UnionInterface_Echo_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'UnionInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'UnionInterface'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError UnionInterfaceResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'UnionInterface', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'UnionInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::UnionInterface_Base::MessageOrdinals method_ordinal =
      static_cast<internal::UnionInterface_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::UnionInterface_Base::MessageOrdinals::Echo: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::UnionInterface_Echo_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'UnionInterface',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'UnionInterface'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
} 

// --- Enums ---
bool AnEnum_IsValidValue(AnEnum value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const AnEnum& val) {
  return (stream << static_cast<int32_t>(val));
}

// Base interface definitions (Name_, Version_, Constants, Enums)
const uint32_t internal::SmallCache_Base::Version_;

// Constants

// Enums
const uint32_t internal::UnionInterface_Base::Version_;

// Constants

// Enums

// Struct Constants

// --- Struct builder definitions ---

// static
StructOfUnionsPtr StructOfUnions::New() {
  StructOfUnionsPtr rv;
  mojo::internal::StructHelper<StructOfUnions>::Initialize(&rv);
  return rv;
}

StructOfUnions::StructOfUnions()
    : u(),
      a_ou(),
      a_hu(),
      m_ou(),
      m_hu() {
}

StructOfUnions::~StructOfUnions() {
}



bool StructOfUnions::Equals(const StructOfUnions& other) const {
  if (!mojo::internal::ValueTraits<ObjectUnionPtr>::Equals(this->u, other.u))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<ObjectUnionPtr>>::Equals(this->a_ou, other.a_ou))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<HandleUnionPtr>>::Equals(this->a_hu, other.a_hu))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<int64_t, ObjectUnionPtr>>::Equals(this->m_ou, other.m_ou))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<int64_t, HandleUnionPtr>>::Equals(this->m_hu, other.m_hu))
    return false;
  return true;
}


// static
WrapperStructPtr WrapperStruct::New() {
  WrapperStructPtr rv;
  mojo::internal::StructHelper<WrapperStruct>::Initialize(&rv);
  return rv;
}

WrapperStruct::WrapperStruct()
    : object_union(),
      pod_union(),
      handle_union() {
}

WrapperStruct::~WrapperStruct() {
}



bool WrapperStruct::Equals(const WrapperStruct& other) const {
  if (!mojo::internal::ValueTraits<ObjectUnionPtr>::Equals(this->object_union, other.object_union))
    return false;
  if (!mojo::internal::ValueTraits<PodUnionPtr>::Equals(this->pod_union, other.pod_union))
    return false;
  if (!mojo::internal::ValueTraits<HandleUnionPtr>::Equals(this->handle_union, other.handle_union))
    return false;
  return true;
}


// static
DummyStructPtr DummyStruct::New() {
  DummyStructPtr rv;
  mojo::internal::StructHelper<DummyStruct>::Initialize(&rv);
  return rv;
}

DummyStruct::DummyStruct()
    : f_int8() {
}

DummyStruct::~DummyStruct() {
}


DummyStructPtr DummyStruct::Clone() const {
  DummyStructPtr rv(New());
  rv->f_int8 = f_int8;
  return rv;
}


bool DummyStruct::Equals(const DummyStruct& other) const {
  if (!mojo::internal::ValueTraits<int8_t>::Equals(this->f_int8, other.f_int8))
    return false;
  return true;
}


// static
SmallStructPtr SmallStruct::New() {
  SmallStructPtr rv;
  mojo::internal::StructHelper<SmallStruct>::Initialize(&rv);
  return rv;
}

SmallStruct::SmallStruct()
    : dummy_struct(),
      pod_union(),
      pod_union_array(),
      nullable_pod_union_array(),
      s_array(),
      pod_union_map(),
      nullable_pod_union_map() {
}

SmallStruct::~SmallStruct() {
}


SmallStructPtr SmallStruct::Clone() const {
  SmallStructPtr rv(New());
  rv->dummy_struct = dummy_struct.Clone();
  rv->pod_union = pod_union.Clone();
  rv->pod_union_array = pod_union_array.Clone();
  rv->nullable_pod_union_array = nullable_pod_union_array.Clone();
  rv->s_array = s_array.Clone();
  rv->pod_union_map = pod_union_map.Clone();
  rv->nullable_pod_union_map = nullable_pod_union_map.Clone();
  return rv;
}


bool SmallStruct::Equals(const SmallStruct& other) const {
  if (!mojo::internal::ValueTraits<DummyStructPtr>::Equals(this->dummy_struct, other.dummy_struct))
    return false;
  if (!mojo::internal::ValueTraits<PodUnionPtr>::Equals(this->pod_union, other.pod_union))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<PodUnionPtr>>::Equals(this->pod_union_array, other.pod_union_array))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<PodUnionPtr>>::Equals(this->nullable_pod_union_array, other.nullable_pod_union_array))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<DummyStructPtr>>::Equals(this->s_array, other.s_array))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, PodUnionPtr>>::Equals(this->pod_union_map, other.pod_union_map))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, PodUnionPtr>>::Equals(this->nullable_pod_union_map, other.nullable_pod_union_map))
    return false;
  return true;
}


// static
SmallStructNonNullableUnionPtr SmallStructNonNullableUnion::New() {
  SmallStructNonNullableUnionPtr rv;
  mojo::internal::StructHelper<SmallStructNonNullableUnion>::Initialize(&rv);
  return rv;
}

SmallStructNonNullableUnion::SmallStructNonNullableUnion()
    : pod_union() {
}

SmallStructNonNullableUnion::~SmallStructNonNullableUnion() {
}


SmallStructNonNullableUnionPtr SmallStructNonNullableUnion::Clone() const {
  SmallStructNonNullableUnionPtr rv(New());
  rv->pod_union = pod_union.Clone();
  return rv;
}


bool SmallStructNonNullableUnion::Equals(const SmallStructNonNullableUnion& other) const {
  if (!mojo::internal::ValueTraits<PodUnionPtr>::Equals(this->pod_union, other.pod_union))
    return false;
  return true;
}


// static
StructNullObjectUnionPtr StructNullObjectUnion::New() {
  StructNullObjectUnionPtr rv;
  mojo::internal::StructHelper<StructNullObjectUnion>::Initialize(&rv);
  return rv;
}

StructNullObjectUnion::StructNullObjectUnion()
    : obj_union() {
}

StructNullObjectUnion::~StructNullObjectUnion() {
}


StructNullObjectUnionPtr StructNullObjectUnion::Clone() const {
  StructNullObjectUnionPtr rv(New());
  rv->obj_union = obj_union.Clone();
  return rv;
}


bool StructNullObjectUnion::Equals(const StructNullObjectUnion& other) const {
  if (!mojo::internal::ValueTraits<ObjectOnlyUnionPtr>::Equals(this->obj_union, other.obj_union))
    return false;
  return true;
}


// static
SmallObjStructPtr SmallObjStruct::New() {
  SmallObjStructPtr rv;
  mojo::internal::StructHelper<SmallObjStruct>::Initialize(&rv);
  return rv;
}

SmallObjStruct::SmallObjStruct()
    : obj_union(),
      f_int8() {
}

SmallObjStruct::~SmallObjStruct() {
}


SmallObjStructPtr SmallObjStruct::Clone() const {
  SmallObjStructPtr rv(New());
  rv->obj_union = obj_union.Clone();
  rv->f_int8 = f_int8;
  return rv;
}


bool SmallObjStruct::Equals(const SmallObjStruct& other) const {
  if (!mojo::internal::ValueTraits<ObjectUnionPtr>::Equals(this->obj_union, other.obj_union))
    return false;
  if (!mojo::internal::ValueTraits<int8_t>::Equals(this->f_int8, other.f_int8))
    return false;
  return true;
}


// static
TryNonNullStructPtr TryNonNullStruct::New() {
  TryNonNullStructPtr rv;
  mojo::internal::StructHelper<TryNonNullStruct>::Initialize(&rv);
  return rv;
}

TryNonNullStruct::TryNonNullStruct()
    : nullable(),
      non_nullable() {
}

TryNonNullStruct::~TryNonNullStruct() {
}


TryNonNullStructPtr TryNonNullStruct::Clone() const {
  TryNonNullStructPtr rv(New());
  rv->nullable = nullable.Clone();
  rv->non_nullable = non_nullable.Clone();
  return rv;
}


bool TryNonNullStruct::Equals(const TryNonNullStruct& other) const {
  if (!mojo::internal::ValueTraits<DummyStructPtr>::Equals(this->nullable, other.nullable))
    return false;
  if (!mojo::internal::ValueTraits<DummyStructPtr>::Equals(this->non_nullable, other.non_nullable))
    return false;
  return true;
}


// static
IncludingStructPtr IncludingStruct::New() {
  IncludingStructPtr rv;
  mojo::internal::StructHelper<IncludingStruct>::Initialize(&rv);
  return rv;
}

IncludingStruct::IncludingStruct()
    : a() {
}

IncludingStruct::~IncludingStruct() {
}


IncludingStructPtr IncludingStruct::Clone() const {
  IncludingStructPtr rv(New());
  rv->a = a.Clone();
  return rv;
}


bool IncludingStruct::Equals(const IncludingStruct& other) const {
  if (!mojo::internal::ValueTraits<mojo::test::IncludedUnionPtr>::Equals(this->a, other.a))
    return false;
  return true;
}


// --- Union builder definitions ---// static
PodUnionPtr PodUnion::New() {
  PodUnionPtr rv;
  mojo::internal::StructHelper<PodUnion>::Initialize(&rv);
  return rv;
}

PodUnion::PodUnion() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

PodUnion::~PodUnion() {
  DestroyActive();
}


PodUnionPtr PodUnion::Clone() const {
  PodUnionPtr rv(New());
  switch (tag_) {

    case Tag::F_INT8:

      rv->set_f_int8(data_.f_int8);
      break;
    case Tag::F_INT8_OTHER:

      rv->set_f_int8_other(data_.f_int8_other);
      break;
    case Tag::F_UINT8:

      rv->set_f_uint8(data_.f_uint8);
      break;
    case Tag::F_INT16:

      rv->set_f_int16(data_.f_int16);
      break;
    case Tag::F_UINT16:

      rv->set_f_uint16(data_.f_uint16);
      break;
    case Tag::F_INT32:

      rv->set_f_int32(data_.f_int32);
      break;
    case Tag::F_UINT32:

      rv->set_f_uint32(data_.f_uint32);
      break;
    case Tag::F_INT64:

      rv->set_f_int64(data_.f_int64);
      break;
    case Tag::F_UINT64:

      rv->set_f_uint64(data_.f_uint64);
      break;
    case Tag::F_FLOAT:

      rv->set_f_float(data_.f_float);
      break;
    case Tag::F_DOUBLE:

      rv->set_f_double(data_.f_double);
      break;
    case Tag::F_BOOL:

      rv->set_f_bool(data_.f_bool);
      break;
    case Tag::F_ENUM:

      rv->set_f_enum(data_.f_enum);
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool PodUnion::Equals(const PodUnion& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::F_INT8:

      return mojo::internal::ValueTraits<int8_t>::Equals(data_.f_int8, other.data_.f_int8);
    case Tag::F_INT8_OTHER:

      return mojo::internal::ValueTraits<int8_t>::Equals(data_.f_int8_other, other.data_.f_int8_other);
    case Tag::F_UINT8:

      return mojo::internal::ValueTraits<uint8_t>::Equals(data_.f_uint8, other.data_.f_uint8);
    case Tag::F_INT16:

      return mojo::internal::ValueTraits<int16_t>::Equals(data_.f_int16, other.data_.f_int16);
    case Tag::F_UINT16:

      return mojo::internal::ValueTraits<uint16_t>::Equals(data_.f_uint16, other.data_.f_uint16);
    case Tag::F_INT32:

      return mojo::internal::ValueTraits<int32_t>::Equals(data_.f_int32, other.data_.f_int32);
    case Tag::F_UINT32:

      return mojo::internal::ValueTraits<uint32_t>::Equals(data_.f_uint32, other.data_.f_uint32);
    case Tag::F_INT64:

      return mojo::internal::ValueTraits<int64_t>::Equals(data_.f_int64, other.data_.f_int64);
    case Tag::F_UINT64:

      return mojo::internal::ValueTraits<uint64_t>::Equals(data_.f_uint64, other.data_.f_uint64);
    case Tag::F_FLOAT:

      return mojo::internal::ValueTraits<float>::Equals(data_.f_float, other.data_.f_float);
    case Tag::F_DOUBLE:

      return mojo::internal::ValueTraits<double>::Equals(data_.f_double, other.data_.f_double);
    case Tag::F_BOOL:

      return mojo::internal::ValueTraits<bool>::Equals(data_.f_bool, other.data_.f_bool);
    case Tag::F_ENUM:

      return mojo::internal::ValueTraits<AnEnum>::Equals(data_.f_enum, other.data_.f_enum);
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool PodUnion::is_f_int8() const {
  return tag_ == Tag::F_INT8;
}

int8_t PodUnion::get_f_int8() const {
  MOJO_DCHECK(tag_ == Tag::F_INT8);

  return data_.f_int8;
}

void PodUnion::set_f_int8(int8_t f_int8) {
  SwitchActive(Tag::F_INT8);

  data_.f_int8 = f_int8;
}
bool PodUnion::is_f_int8_other() const {
  return tag_ == Tag::F_INT8_OTHER;
}

int8_t PodUnion::get_f_int8_other() const {
  MOJO_DCHECK(tag_ == Tag::F_INT8_OTHER);

  return data_.f_int8_other;
}

void PodUnion::set_f_int8_other(int8_t f_int8_other) {
  SwitchActive(Tag::F_INT8_OTHER);

  data_.f_int8_other = f_int8_other;
}
bool PodUnion::is_f_uint8() const {
  return tag_ == Tag::F_UINT8;
}

uint8_t PodUnion::get_f_uint8() const {
  MOJO_DCHECK(tag_ == Tag::F_UINT8);

  return data_.f_uint8;
}

void PodUnion::set_f_uint8(uint8_t f_uint8) {
  SwitchActive(Tag::F_UINT8);

  data_.f_uint8 = f_uint8;
}
bool PodUnion::is_f_int16() const {
  return tag_ == Tag::F_INT16;
}

int16_t PodUnion::get_f_int16() const {
  MOJO_DCHECK(tag_ == Tag::F_INT16);

  return data_.f_int16;
}

void PodUnion::set_f_int16(int16_t f_int16) {
  SwitchActive(Tag::F_INT16);

  data_.f_int16 = f_int16;
}
bool PodUnion::is_f_uint16() const {
  return tag_ == Tag::F_UINT16;
}

uint16_t PodUnion::get_f_uint16() const {
  MOJO_DCHECK(tag_ == Tag::F_UINT16);

  return data_.f_uint16;
}

void PodUnion::set_f_uint16(uint16_t f_uint16) {
  SwitchActive(Tag::F_UINT16);

  data_.f_uint16 = f_uint16;
}
bool PodUnion::is_f_int32() const {
  return tag_ == Tag::F_INT32;
}

int32_t PodUnion::get_f_int32() const {
  MOJO_DCHECK(tag_ == Tag::F_INT32);

  return data_.f_int32;
}

void PodUnion::set_f_int32(int32_t f_int32) {
  SwitchActive(Tag::F_INT32);

  data_.f_int32 = f_int32;
}
bool PodUnion::is_f_uint32() const {
  return tag_ == Tag::F_UINT32;
}

uint32_t PodUnion::get_f_uint32() const {
  MOJO_DCHECK(tag_ == Tag::F_UINT32);

  return data_.f_uint32;
}

void PodUnion::set_f_uint32(uint32_t f_uint32) {
  SwitchActive(Tag::F_UINT32);

  data_.f_uint32 = f_uint32;
}
bool PodUnion::is_f_int64() const {
  return tag_ == Tag::F_INT64;
}

int64_t PodUnion::get_f_int64() const {
  MOJO_DCHECK(tag_ == Tag::F_INT64);

  return data_.f_int64;
}

void PodUnion::set_f_int64(int64_t f_int64) {
  SwitchActive(Tag::F_INT64);

  data_.f_int64 = f_int64;
}
bool PodUnion::is_f_uint64() const {
  return tag_ == Tag::F_UINT64;
}

uint64_t PodUnion::get_f_uint64() const {
  MOJO_DCHECK(tag_ == Tag::F_UINT64);

  return data_.f_uint64;
}

void PodUnion::set_f_uint64(uint64_t f_uint64) {
  SwitchActive(Tag::F_UINT64);

  data_.f_uint64 = f_uint64;
}
bool PodUnion::is_f_float() const {
  return tag_ == Tag::F_FLOAT;
}

float PodUnion::get_f_float() const {
  MOJO_DCHECK(tag_ == Tag::F_FLOAT);

  return data_.f_float;
}

void PodUnion::set_f_float(float f_float) {
  SwitchActive(Tag::F_FLOAT);

  data_.f_float = f_float;
}
bool PodUnion::is_f_double() const {
  return tag_ == Tag::F_DOUBLE;
}

double PodUnion::get_f_double() const {
  MOJO_DCHECK(tag_ == Tag::F_DOUBLE);

  return data_.f_double;
}

void PodUnion::set_f_double(double f_double) {
  SwitchActive(Tag::F_DOUBLE);

  data_.f_double = f_double;
}
bool PodUnion::is_f_bool() const {
  return tag_ == Tag::F_BOOL;
}

bool PodUnion::get_f_bool() const {
  MOJO_DCHECK(tag_ == Tag::F_BOOL);

  return data_.f_bool;
}

void PodUnion::set_f_bool(bool f_bool) {
  SwitchActive(Tag::F_BOOL);

  data_.f_bool = f_bool;
}
bool PodUnion::is_f_enum() const {
  return tag_ == Tag::F_ENUM;
}

AnEnum PodUnion::get_f_enum() const {
  MOJO_DCHECK(tag_ == Tag::F_ENUM);

  return data_.f_enum;
}

void PodUnion::set_f_enum(AnEnum f_enum) {
  SwitchActive(Tag::F_ENUM);

  data_.f_enum = f_enum;
}

bool PodUnion::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void PodUnion::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void PodUnion::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::F_INT8:

      break;
    case Tag::F_INT8_OTHER:

      break;
    case Tag::F_UINT8:

      break;
    case Tag::F_INT16:

      break;
    case Tag::F_UINT16:

      break;
    case Tag::F_INT32:

      break;
    case Tag::F_UINT32:

      break;
    case Tag::F_INT64:

      break;
    case Tag::F_UINT64:

      break;
    case Tag::F_FLOAT:

      break;
    case Tag::F_DOUBLE:

      break;
    case Tag::F_BOOL:

      break;
    case Tag::F_ENUM:

      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void PodUnion::DestroyActive() {
  switch (tag_) {

    case Tag::F_INT8:

      break;
    case Tag::F_INT8_OTHER:

      break;
    case Tag::F_UINT8:

      break;
    case Tag::F_INT16:

      break;
    case Tag::F_UINT16:

      break;
    case Tag::F_INT32:

      break;
    case Tag::F_UINT32:

      break;
    case Tag::F_INT64:

      break;
    case Tag::F_UINT64:

      break;
    case Tag::F_FLOAT:

      break;
    case Tag::F_DOUBLE:

      break;
    case Tag::F_BOOL:

      break;
    case Tag::F_ENUM:

      break;
    default:
      break;
  }
}
// static
UnionOfUnionsPtr UnionOfUnions::New() {
  UnionOfUnionsPtr rv;
  mojo::internal::StructHelper<UnionOfUnions>::Initialize(&rv);
  return rv;
}

UnionOfUnions::UnionOfUnions() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

UnionOfUnions::~UnionOfUnions() {
  DestroyActive();
}



bool UnionOfUnions::Equals(const UnionOfUnions& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::U:

      return mojo::internal::ValueTraits<ObjectUnionPtr>::Equals(*(data_.u), *(other.data_.u));
    case Tag::A_OU:

      return mojo::internal::ValueTraits<mojo::Array<ObjectUnionPtr>>::Equals(*(data_.a_ou), *(other.data_.a_ou));
    case Tag::A_HU:

      return mojo::internal::ValueTraits<mojo::Array<HandleUnionPtr>>::Equals(*(data_.a_hu), *(other.data_.a_hu));
    case Tag::M_OU:

      return mojo::internal::ValueTraits<mojo::Map<int64_t, ObjectUnionPtr>>::Equals(*(data_.m_ou), *(other.data_.m_ou));
    case Tag::M_HU:

      return mojo::internal::ValueTraits<mojo::Map<int64_t, HandleUnionPtr>>::Equals(*(data_.m_hu), *(other.data_.m_hu));
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool UnionOfUnions::is_u() const {
  return tag_ == Tag::U;
}

ObjectUnionPtr& UnionOfUnions::get_u() const {
  MOJO_DCHECK(tag_ == Tag::U);

  return *(data_.u);
}

void UnionOfUnions::set_u(ObjectUnionPtr u) {
  SwitchActive(Tag::U);

  *(data_.u) = u.Pass();

}
bool UnionOfUnions::is_a_ou() const {
  return tag_ == Tag::A_OU;
}

mojo::Array<ObjectUnionPtr>& UnionOfUnions::get_a_ou() const {
  MOJO_DCHECK(tag_ == Tag::A_OU);

  return *(data_.a_ou);
}

void UnionOfUnions::set_a_ou(mojo::Array<ObjectUnionPtr> a_ou) {
  SwitchActive(Tag::A_OU);

  *(data_.a_ou) = a_ou.Pass();

}
bool UnionOfUnions::is_a_hu() const {
  return tag_ == Tag::A_HU;
}

mojo::Array<HandleUnionPtr>& UnionOfUnions::get_a_hu() const {
  MOJO_DCHECK(tag_ == Tag::A_HU);

  return *(data_.a_hu);
}

void UnionOfUnions::set_a_hu(mojo::Array<HandleUnionPtr> a_hu) {
  SwitchActive(Tag::A_HU);

  *(data_.a_hu) = a_hu.Pass();

}
bool UnionOfUnions::is_m_ou() const {
  return tag_ == Tag::M_OU;
}

mojo::Map<int64_t, ObjectUnionPtr>& UnionOfUnions::get_m_ou() const {
  MOJO_DCHECK(tag_ == Tag::M_OU);

  return *(data_.m_ou);
}

void UnionOfUnions::set_m_ou(mojo::Map<int64_t, ObjectUnionPtr> m_ou) {
  SwitchActive(Tag::M_OU);

  *(data_.m_ou) = m_ou.Pass();

}
bool UnionOfUnions::is_m_hu() const {
  return tag_ == Tag::M_HU;
}

mojo::Map<int64_t, HandleUnionPtr>& UnionOfUnions::get_m_hu() const {
  MOJO_DCHECK(tag_ == Tag::M_HU);

  return *(data_.m_hu);
}

void UnionOfUnions::set_m_hu(mojo::Map<int64_t, HandleUnionPtr> m_hu) {
  SwitchActive(Tag::M_HU);

  *(data_.m_hu) = m_hu.Pass();

}

bool UnionOfUnions::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void UnionOfUnions::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void UnionOfUnions::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::U:

      data_.u = new ObjectUnionPtr();
      break;
    case Tag::A_OU:

      data_.a_ou = new mojo::Array<ObjectUnionPtr>();
      break;
    case Tag::A_HU:

      data_.a_hu = new mojo::Array<HandleUnionPtr>();
      break;
    case Tag::M_OU:

      data_.m_ou = new mojo::Map<int64_t, ObjectUnionPtr>();
      break;
    case Tag::M_HU:

      data_.m_hu = new mojo::Map<int64_t, HandleUnionPtr>();
      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void UnionOfUnions::DestroyActive() {
  switch (tag_) {

    case Tag::U:

      delete data_.u;
      break;
    case Tag::A_OU:

      delete data_.a_ou;
      break;
    case Tag::A_HU:

      delete data_.a_hu;
      break;
    case Tag::M_OU:

      delete data_.m_ou;
      break;
    case Tag::M_HU:

      delete data_.m_hu;
      break;
    default:
      break;
  }
}
// static
ObjectUnionPtr ObjectUnion::New() {
  ObjectUnionPtr rv;
  mojo::internal::StructHelper<ObjectUnion>::Initialize(&rv);
  return rv;
}

ObjectUnion::ObjectUnion() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

ObjectUnion::~ObjectUnion() {
  DestroyActive();
}


ObjectUnionPtr ObjectUnion::Clone() const {
  ObjectUnionPtr rv(New());
  switch (tag_) {

    case Tag::F_INT8:

      rv->set_f_int8(data_.f_int8);
      break;
    case Tag::F_STRING:

      rv->set_f_string(*(data_.f_string));

      break;
    case Tag::F_DUMMY:

      rv->set_f_dummy(data_.f_dummy->Clone());
      break;
    case Tag::F_NULLABLE:

      rv->set_f_nullable(data_.f_nullable->Clone());
      break;
    case Tag::F_ARRAY_INT8:

      rv->set_f_array_int8(data_.f_array_int8->Clone());
      break;
    case Tag::F_MAP_INT8:

      rv->set_f_map_int8(data_.f_map_int8->Clone());
      break;
    case Tag::F_POD_UNION:

      rv->set_f_pod_union(data_.f_pod_union->Clone());
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool ObjectUnion::Equals(const ObjectUnion& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::F_INT8:

      return mojo::internal::ValueTraits<int8_t>::Equals(data_.f_int8, other.data_.f_int8);
    case Tag::F_STRING:

      return mojo::internal::ValueTraits<mojo::String>::Equals(*(data_.f_string), *(other.data_.f_string));
    case Tag::F_DUMMY:

      return mojo::internal::ValueTraits<DummyStructPtr>::Equals(*(data_.f_dummy), *(other.data_.f_dummy));
    case Tag::F_NULLABLE:

      return mojo::internal::ValueTraits<DummyStructPtr>::Equals(*(data_.f_nullable), *(other.data_.f_nullable));
    case Tag::F_ARRAY_INT8:

      return mojo::internal::ValueTraits<mojo::Array<int8_t>>::Equals(*(data_.f_array_int8), *(other.data_.f_array_int8));
    case Tag::F_MAP_INT8:

      return mojo::internal::ValueTraits<mojo::Map<mojo::String, int8_t>>::Equals(*(data_.f_map_int8), *(other.data_.f_map_int8));
    case Tag::F_POD_UNION:

      return mojo::internal::ValueTraits<PodUnionPtr>::Equals(*(data_.f_pod_union), *(other.data_.f_pod_union));
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool ObjectUnion::is_f_int8() const {
  return tag_ == Tag::F_INT8;
}

int8_t ObjectUnion::get_f_int8() const {
  MOJO_DCHECK(tag_ == Tag::F_INT8);

  return data_.f_int8;
}

void ObjectUnion::set_f_int8(int8_t f_int8) {
  SwitchActive(Tag::F_INT8);

  data_.f_int8 = f_int8;
}
bool ObjectUnion::is_f_string() const {
  return tag_ == Tag::F_STRING;
}

mojo::String ObjectUnion::get_f_string() const {
  MOJO_DCHECK(tag_ == Tag::F_STRING);

  return *(data_.f_string);
}

void ObjectUnion::set_f_string(const mojo::String& f_string) {
  SwitchActive(Tag::F_STRING);

  *(data_.f_string) = f_string;

}
bool ObjectUnion::is_f_dummy() const {
  return tag_ == Tag::F_DUMMY;
}

DummyStructPtr& ObjectUnion::get_f_dummy() const {
  MOJO_DCHECK(tag_ == Tag::F_DUMMY);

  return *(data_.f_dummy);
}

void ObjectUnion::set_f_dummy(DummyStructPtr f_dummy) {
  SwitchActive(Tag::F_DUMMY);

  *(data_.f_dummy) = f_dummy.Pass();

}
bool ObjectUnion::is_f_nullable() const {
  return tag_ == Tag::F_NULLABLE;
}

DummyStructPtr& ObjectUnion::get_f_nullable() const {
  MOJO_DCHECK(tag_ == Tag::F_NULLABLE);

  return *(data_.f_nullable);
}

void ObjectUnion::set_f_nullable(DummyStructPtr f_nullable) {
  SwitchActive(Tag::F_NULLABLE);

  *(data_.f_nullable) = f_nullable.Pass();

}
bool ObjectUnion::is_f_array_int8() const {
  return tag_ == Tag::F_ARRAY_INT8;
}

mojo::Array<int8_t>& ObjectUnion::get_f_array_int8() const {
  MOJO_DCHECK(tag_ == Tag::F_ARRAY_INT8);

  return *(data_.f_array_int8);
}

void ObjectUnion::set_f_array_int8(mojo::Array<int8_t> f_array_int8) {
  SwitchActive(Tag::F_ARRAY_INT8);

  *(data_.f_array_int8) = f_array_int8.Pass();

}
bool ObjectUnion::is_f_map_int8() const {
  return tag_ == Tag::F_MAP_INT8;
}

mojo::Map<mojo::String, int8_t>& ObjectUnion::get_f_map_int8() const {
  MOJO_DCHECK(tag_ == Tag::F_MAP_INT8);

  return *(data_.f_map_int8);
}

void ObjectUnion::set_f_map_int8(mojo::Map<mojo::String, int8_t> f_map_int8) {
  SwitchActive(Tag::F_MAP_INT8);

  *(data_.f_map_int8) = f_map_int8.Pass();

}
bool ObjectUnion::is_f_pod_union() const {
  return tag_ == Tag::F_POD_UNION;
}

PodUnionPtr& ObjectUnion::get_f_pod_union() const {
  MOJO_DCHECK(tag_ == Tag::F_POD_UNION);

  return *(data_.f_pod_union);
}

void ObjectUnion::set_f_pod_union(PodUnionPtr f_pod_union) {
  SwitchActive(Tag::F_POD_UNION);

  *(data_.f_pod_union) = f_pod_union.Pass();

}

bool ObjectUnion::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void ObjectUnion::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void ObjectUnion::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::F_INT8:

      break;
    case Tag::F_STRING:

      data_.f_string = new mojo::String();
      break;
    case Tag::F_DUMMY:

      data_.f_dummy = new DummyStructPtr();
      break;
    case Tag::F_NULLABLE:

      data_.f_nullable = new DummyStructPtr();
      break;
    case Tag::F_ARRAY_INT8:

      data_.f_array_int8 = new mojo::Array<int8_t>();
      break;
    case Tag::F_MAP_INT8:

      data_.f_map_int8 = new mojo::Map<mojo::String, int8_t>();
      break;
    case Tag::F_POD_UNION:

      data_.f_pod_union = new PodUnionPtr();
      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void ObjectUnion::DestroyActive() {
  switch (tag_) {

    case Tag::F_INT8:

      break;
    case Tag::F_STRING:

      delete data_.f_string;
      break;
    case Tag::F_DUMMY:

      delete data_.f_dummy;
      break;
    case Tag::F_NULLABLE:

      delete data_.f_nullable;
      break;
    case Tag::F_ARRAY_INT8:

      delete data_.f_array_int8;
      break;
    case Tag::F_MAP_INT8:

      delete data_.f_map_int8;
      break;
    case Tag::F_POD_UNION:

      delete data_.f_pod_union;
      break;
    default:
      break;
  }
}
// static
HandleUnionPtr HandleUnion::New() {
  HandleUnionPtr rv;
  mojo::internal::StructHelper<HandleUnion>::Initialize(&rv);
  return rv;
}

HandleUnion::HandleUnion() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

HandleUnion::~HandleUnion() {
  DestroyActive();
}



bool HandleUnion::Equals(const HandleUnion& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::F_HANDLE:

      return mojo::internal::ValueTraits<mojo::ScopedHandle>::Equals(*(data_.f_handle), *(other.data_.f_handle));
    case Tag::F_MESSAGE_PIPE:

      return mojo::internal::ValueTraits<mojo::ScopedMessagePipeHandle>::Equals(*(data_.f_message_pipe), *(other.data_.f_message_pipe));
    case Tag::F_DATA_PIPE_CONSUMER:

      return mojo::internal::ValueTraits<mojo::ScopedDataPipeConsumerHandle>::Equals(*(data_.f_data_pipe_consumer), *(other.data_.f_data_pipe_consumer));
    case Tag::F_DATA_PIPE_PRODUCER:

      return mojo::internal::ValueTraits<mojo::ScopedDataPipeProducerHandle>::Equals(*(data_.f_data_pipe_producer), *(other.data_.f_data_pipe_producer));
    case Tag::F_SHARED_BUFFER:

      return mojo::internal::ValueTraits<mojo::ScopedSharedBufferHandle>::Equals(*(data_.f_shared_buffer), *(other.data_.f_shared_buffer));
    case Tag::F_SMALL_CACHE:

      return mojo::internal::ValueTraits<mojo::InterfaceHandle<SmallCache>>::Equals(*(data_.f_small_cache), *(other.data_.f_small_cache));
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool HandleUnion::is_f_handle() const {
  return tag_ == Tag::F_HANDLE;
}

mojo::ScopedHandle& HandleUnion::get_f_handle() const {
  MOJO_DCHECK(tag_ == Tag::F_HANDLE);

  return *(data_.f_handle);
}

void HandleUnion::set_f_handle(mojo::ScopedHandle f_handle) {
  SwitchActive(Tag::F_HANDLE);

  data_.f_handle->reset(f_handle.release());
}
bool HandleUnion::is_f_message_pipe() const {
  return tag_ == Tag::F_MESSAGE_PIPE;
}

mojo::ScopedMessagePipeHandle& HandleUnion::get_f_message_pipe() const {
  MOJO_DCHECK(tag_ == Tag::F_MESSAGE_PIPE);

  return *(data_.f_message_pipe);
}

void HandleUnion::set_f_message_pipe(mojo::ScopedMessagePipeHandle f_message_pipe) {
  SwitchActive(Tag::F_MESSAGE_PIPE);

  data_.f_message_pipe->reset(f_message_pipe.release());
}
bool HandleUnion::is_f_data_pipe_consumer() const {
  return tag_ == Tag::F_DATA_PIPE_CONSUMER;
}

mojo::ScopedDataPipeConsumerHandle& HandleUnion::get_f_data_pipe_consumer() const {
  MOJO_DCHECK(tag_ == Tag::F_DATA_PIPE_CONSUMER);

  return *(data_.f_data_pipe_consumer);
}

void HandleUnion::set_f_data_pipe_consumer(mojo::ScopedDataPipeConsumerHandle f_data_pipe_consumer) {
  SwitchActive(Tag::F_DATA_PIPE_CONSUMER);

  data_.f_data_pipe_consumer->reset(f_data_pipe_consumer.release());
}
bool HandleUnion::is_f_data_pipe_producer() const {
  return tag_ == Tag::F_DATA_PIPE_PRODUCER;
}

mojo::ScopedDataPipeProducerHandle& HandleUnion::get_f_data_pipe_producer() const {
  MOJO_DCHECK(tag_ == Tag::F_DATA_PIPE_PRODUCER);

  return *(data_.f_data_pipe_producer);
}

void HandleUnion::set_f_data_pipe_producer(mojo::ScopedDataPipeProducerHandle f_data_pipe_producer) {
  SwitchActive(Tag::F_DATA_PIPE_PRODUCER);

  data_.f_data_pipe_producer->reset(f_data_pipe_producer.release());
}
bool HandleUnion::is_f_shared_buffer() const {
  return tag_ == Tag::F_SHARED_BUFFER;
}

mojo::ScopedSharedBufferHandle& HandleUnion::get_f_shared_buffer() const {
  MOJO_DCHECK(tag_ == Tag::F_SHARED_BUFFER);

  return *(data_.f_shared_buffer);
}

void HandleUnion::set_f_shared_buffer(mojo::ScopedSharedBufferHandle f_shared_buffer) {
  SwitchActive(Tag::F_SHARED_BUFFER);

  data_.f_shared_buffer->reset(f_shared_buffer.release());
}
bool HandleUnion::is_f_small_cache() const {
  return tag_ == Tag::F_SMALL_CACHE;
}

mojo::InterfaceHandle<SmallCache>& HandleUnion::get_f_small_cache() const {
  MOJO_DCHECK(tag_ == Tag::F_SMALL_CACHE);

  return *(data_.f_small_cache);
}

void HandleUnion::set_f_small_cache(mojo::InterfaceHandle<SmallCache> f_small_cache) {
  SwitchActive(Tag::F_SMALL_CACHE);

  *(data_.f_small_cache) = f_small_cache.Pass();

}

bool HandleUnion::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void HandleUnion::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void HandleUnion::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::F_HANDLE:

      data_.f_handle = new mojo::ScopedHandle();
      break;
    case Tag::F_MESSAGE_PIPE:

      data_.f_message_pipe = new mojo::ScopedMessagePipeHandle();
      break;
    case Tag::F_DATA_PIPE_CONSUMER:

      data_.f_data_pipe_consumer = new mojo::ScopedDataPipeConsumerHandle();
      break;
    case Tag::F_DATA_PIPE_PRODUCER:

      data_.f_data_pipe_producer = new mojo::ScopedDataPipeProducerHandle();
      break;
    case Tag::F_SHARED_BUFFER:

      data_.f_shared_buffer = new mojo::ScopedSharedBufferHandle();
      break;
    case Tag::F_SMALL_CACHE:

      data_.f_small_cache = new mojo::InterfaceHandle<SmallCache>();
      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void HandleUnion::DestroyActive() {
  switch (tag_) {

    case Tag::F_HANDLE:

      delete data_.f_handle;
      break;
    case Tag::F_MESSAGE_PIPE:

      delete data_.f_message_pipe;
      break;
    case Tag::F_DATA_PIPE_CONSUMER:

      delete data_.f_data_pipe_consumer;
      break;
    case Tag::F_DATA_PIPE_PRODUCER:

      delete data_.f_data_pipe_producer;
      break;
    case Tag::F_SHARED_BUFFER:

      delete data_.f_shared_buffer;
      break;
    case Tag::F_SMALL_CACHE:

      delete data_.f_small_cache;
      break;
    default:
      break;
  }
}
// static
ObjectOnlyUnionPtr ObjectOnlyUnion::New() {
  ObjectOnlyUnionPtr rv;
  mojo::internal::StructHelper<ObjectOnlyUnion>::Initialize(&rv);
  return rv;
}

ObjectOnlyUnion::ObjectOnlyUnion() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

ObjectOnlyUnion::~ObjectOnlyUnion() {
  DestroyActive();
}


ObjectOnlyUnionPtr ObjectOnlyUnion::Clone() const {
  ObjectOnlyUnionPtr rv(New());
  switch (tag_) {

    case Tag::DUMMY1:

      rv->set_dummy1(data_.dummy1->Clone());
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool ObjectOnlyUnion::Equals(const ObjectOnlyUnion& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::DUMMY1:

      return mojo::internal::ValueTraits<DummyStructPtr>::Equals(*(data_.dummy1), *(other.data_.dummy1));
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool ObjectOnlyUnion::is_dummy1() const {
  return tag_ == Tag::DUMMY1;
}

DummyStructPtr& ObjectOnlyUnion::get_dummy1() const {
  MOJO_DCHECK(tag_ == Tag::DUMMY1);

  return *(data_.dummy1);
}

void ObjectOnlyUnion::set_dummy1(DummyStructPtr dummy1) {
  SwitchActive(Tag::DUMMY1);

  *(data_.dummy1) = dummy1.Pass();

}

bool ObjectOnlyUnion::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void ObjectOnlyUnion::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void ObjectOnlyUnion::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::DUMMY1:

      data_.dummy1 = new DummyStructPtr();
      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void ObjectOnlyUnion::DestroyActive() {
  switch (tag_) {

    case Tag::DUMMY1:

      delete data_.dummy1;
      break;
    default:
      break;
  }
}
// static
OldUnionPtr OldUnion::New() {
  OldUnionPtr rv;
  mojo::internal::StructHelper<OldUnion>::Initialize(&rv);
  return rv;
}

OldUnion::OldUnion() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

OldUnion::~OldUnion() {
  DestroyActive();
}


OldUnionPtr OldUnion::Clone() const {
  OldUnionPtr rv(New());
  switch (tag_) {

    case Tag::F_INT8:

      rv->set_f_int8(data_.f_int8);
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool OldUnion::Equals(const OldUnion& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::F_INT8:

      return mojo::internal::ValueTraits<int8_t>::Equals(data_.f_int8, other.data_.f_int8);
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool OldUnion::is_f_int8() const {
  return tag_ == Tag::F_INT8;
}

int8_t OldUnion::get_f_int8() const {
  MOJO_DCHECK(tag_ == Tag::F_INT8);

  return data_.f_int8;
}

void OldUnion::set_f_int8(int8_t f_int8) {
  SwitchActive(Tag::F_INT8);

  data_.f_int8 = f_int8;
}

bool OldUnion::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void OldUnion::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void OldUnion::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::F_INT8:

      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void OldUnion::DestroyActive() {
  switch (tag_) {

    case Tag::F_INT8:

      break;
    default:
      break;
  }
}
// static
NewUnionPtr NewUnion::New() {
  NewUnionPtr rv;
  mojo::internal::StructHelper<NewUnion>::Initialize(&rv);
  return rv;
}

NewUnion::NewUnion() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

NewUnion::~NewUnion() {
  DestroyActive();
}


NewUnionPtr NewUnion::Clone() const {
  NewUnionPtr rv(New());
  switch (tag_) {

    case Tag::F_INT8:

      rv->set_f_int8(data_.f_int8);
      break;
    case Tag::F_INT16:

      rv->set_f_int16(data_.f_int16);
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool NewUnion::Equals(const NewUnion& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::F_INT8:

      return mojo::internal::ValueTraits<int8_t>::Equals(data_.f_int8, other.data_.f_int8);
    case Tag::F_INT16:

      return mojo::internal::ValueTraits<int16_t>::Equals(data_.f_int16, other.data_.f_int16);
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool NewUnion::is_f_int8() const {
  return tag_ == Tag::F_INT8;
}

int8_t NewUnion::get_f_int8() const {
  MOJO_DCHECK(tag_ == Tag::F_INT8);

  return data_.f_int8;
}

void NewUnion::set_f_int8(int8_t f_int8) {
  SwitchActive(Tag::F_INT8);

  data_.f_int8 = f_int8;
}
bool NewUnion::is_f_int16() const {
  return tag_ == Tag::F_INT16;
}

int16_t NewUnion::get_f_int16() const {
  MOJO_DCHECK(tag_ == Tag::F_INT16);

  return data_.f_int16;
}

void NewUnion::set_f_int16(int16_t f_int16) {
  SwitchActive(Tag::F_INT16);

  data_.f_int16 = f_int16;
}

bool NewUnion::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void NewUnion::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void NewUnion::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::F_INT8:

      break;
    case Tag::F_INT16:

      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void NewUnion::DestroyActive() {
  switch (tag_) {

    case Tag::F_INT8:

      break;
    case Tag::F_INT16:

      break;
    default:
      break;
  }
}


// --- Struct Serialization Helpers ---

size_t StructOfUnions::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructOfUnions::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructOfUnions_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructOfUnions::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructOfUnions_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructOfUnions::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructOfUnions_Data* input =
      static_cast<internal::StructOfUnions_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructOfUnions& input) {
  size_t size = sizeof(internal::StructOfUnions_Data);
  size += GetSerializedSize_(input.u);
  size += GetSerializedSize_(input.a_ou);
  size += GetSerializedSize_(input.a_hu);
  size += GetSerializedSize_(input.m_ou);
  size += GetSerializedSize_(input.m_hu);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructOfUnions* input,
    mojo::internal::Buffer* buf,
    internal::StructOfUnions_Data** output) {
  if (input) {
    internal::StructOfUnions_Data* result =
        internal::StructOfUnions_Data::New(buf);
    internal::ObjectUnion_Data* u_ptr = &result->u;
    {
      auto retval =
        SerializeUnion_(input->u.get(),
                        buf,
                        &u_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->u.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null u in StructOfUnions struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams a_ou_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->a_ou, buf, &result->a_ou.ptr,
                            &a_ou_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->a_ou.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a_ou in StructOfUnions struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams a_hu_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->a_hu, buf, &result->a_hu.ptr,
                            &a_hu_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->a_hu.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a_hu in StructOfUnions struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams m_ou_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->m_ou, buf, &result->m_ou.ptr,
          &m_ou_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->m_ou.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null m_ou in StructOfUnions struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams m_hu_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->m_hu, buf, &result->m_hu.ptr,
          &m_hu_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->m_hu.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null m_hu in StructOfUnions struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructOfUnions_Data* input,
                  StructOfUnions* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (!input->u.is_null()) {
        result->u = ObjectUnion::New();
        Deserialize_(&input->u, result->u.get());
      }
      Deserialize_(input->a_ou.ptr, &result->a_ou);
      Deserialize_(input->a_hu.ptr, &result->a_hu);
      Deserialize_(input->m_ou.ptr, &result->m_ou);
      Deserialize_(input->m_hu.ptr, &result->m_hu);
    } while (false);
  }
}


size_t WrapperStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool WrapperStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::WrapperStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool WrapperStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::WrapperStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void WrapperStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::WrapperStruct_Data* input =
      static_cast<internal::WrapperStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const WrapperStruct& input) {
  size_t size = sizeof(internal::WrapperStruct_Data);
  size += GetSerializedSize_(input.object_union);
  size += GetSerializedSize_(input.pod_union);
  size += GetSerializedSize_(input.handle_union);
  return size;
}

mojo::internal::ValidationError Serialize_(
    WrapperStruct* input,
    mojo::internal::Buffer* buf,
    internal::WrapperStruct_Data** output) {
  if (input) {
    internal::WrapperStruct_Data* result =
        internal::WrapperStruct_Data::New(buf);
    internal::ObjectUnion_Data* object_union_ptr = &result->object_union;
    {
      auto retval =
        SerializeUnion_(input->object_union.get(),
                        buf,
                        &object_union_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    internal::PodUnion_Data* pod_union_ptr = &result->pod_union;
    {
      auto retval =
        SerializeUnion_(input->pod_union.get(),
                        buf,
                        &pod_union_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    internal::HandleUnion_Data* handle_union_ptr = &result->handle_union;
    {
      auto retval =
        SerializeUnion_(input->handle_union.get(),
                        buf,
                        &handle_union_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::WrapperStruct_Data* input,
                  WrapperStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (!input->object_union.is_null()) {
        result->object_union = ObjectUnion::New();
        Deserialize_(&input->object_union, result->object_union.get());
      }
      if (!input->pod_union.is_null()) {
        result->pod_union = PodUnion::New();
        Deserialize_(&input->pod_union, result->pod_union.get());
      }
      if (!input->handle_union.is_null()) {
        result->handle_union = HandleUnion::New();
        Deserialize_(&input->handle_union, result->handle_union.get());
      }
    } while (false);
  }
}


size_t DummyStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool DummyStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::DummyStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool DummyStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::DummyStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void DummyStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::DummyStruct_Data* input =
      static_cast<internal::DummyStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const DummyStruct& input) {
  size_t size = sizeof(internal::DummyStruct_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    DummyStruct* input,
    mojo::internal::Buffer* buf,
    internal::DummyStruct_Data** output) {
  if (input) {
    internal::DummyStruct_Data* result =
        internal::DummyStruct_Data::New(buf);
    result->f_int8 = input->f_int8;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::DummyStruct_Data* input,
                  DummyStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->f_int8 = input->f_int8;
    } while (false);
  }
}


size_t SmallStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool SmallStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::SmallStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool SmallStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::SmallStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void SmallStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::SmallStruct_Data* input =
      static_cast<internal::SmallStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const SmallStruct& input) {
  size_t size = sizeof(internal::SmallStruct_Data);
  size += input.dummy_struct.is_null()
              ? 0
              : GetSerializedSize_(*input.dummy_struct);
  size += GetSerializedSize_(input.pod_union);
  size += GetSerializedSize_(input.pod_union_array);
  size += GetSerializedSize_(input.nullable_pod_union_array);
  size += GetSerializedSize_(input.s_array);
  size += GetSerializedSize_(input.pod_union_map);
  size += GetSerializedSize_(input.nullable_pod_union_map);
  return size;
}

mojo::internal::ValidationError Serialize_(
    SmallStruct* input,
    mojo::internal::Buffer* buf,
    internal::SmallStruct_Data** output) {
  if (input) {
    internal::SmallStruct_Data* result =
        internal::SmallStruct_Data::New(buf);
    {auto retval =Serialize_(input->dummy_struct.get(),
                 buf,
                 &result->dummy_struct.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    internal::PodUnion_Data* pod_union_ptr = &result->pod_union;
    {
      auto retval =
        SerializeUnion_(input->pod_union.get(),
                        buf,
                        &pod_union_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams pod_union_array_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->pod_union_array, buf, &result->pod_union_array.ptr,
                            &pod_union_array_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams nullable_pod_union_array_validate_params(
        0, true, nullptr);auto retval =mojo::SerializeArray_(&input->nullable_pod_union_array, buf, &result->nullable_pod_union_array.ptr,
                            &nullable_pod_union_array_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams s_array_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->s_array, buf, &result->s_array.ptr,
                            &s_array_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams pod_union_map_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->pod_union_map, buf, &result->pod_union_map.ptr,
          &pod_union_map_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams nullable_pod_union_map_validate_params(
          0, true, nullptr);auto retval =mojo::SerializeMap_(
          &input->nullable_pod_union_map, buf, &result->nullable_pod_union_map.ptr,
          &nullable_pod_union_map_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::SmallStruct_Data* input,
                  SmallStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->dummy_struct.ptr) {
        result->dummy_struct = DummyStruct::New();
        Deserialize_(input->dummy_struct.ptr, result->dummy_struct.get());
      }
      if (!input->pod_union.is_null()) {
        result->pod_union = PodUnion::New();
        Deserialize_(&input->pod_union, result->pod_union.get());
      }
      Deserialize_(input->pod_union_array.ptr, &result->pod_union_array);
      Deserialize_(input->nullable_pod_union_array.ptr, &result->nullable_pod_union_array);
      Deserialize_(input->s_array.ptr, &result->s_array);
      Deserialize_(input->pod_union_map.ptr, &result->pod_union_map);
      Deserialize_(input->nullable_pod_union_map.ptr, &result->nullable_pod_union_map);
    } while (false);
  }
}


size_t SmallStructNonNullableUnion::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool SmallStructNonNullableUnion::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::SmallStructNonNullableUnion_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool SmallStructNonNullableUnion::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::SmallStructNonNullableUnion_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void SmallStructNonNullableUnion::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::SmallStructNonNullableUnion_Data* input =
      static_cast<internal::SmallStructNonNullableUnion_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const SmallStructNonNullableUnion& input) {
  size_t size = sizeof(internal::SmallStructNonNullableUnion_Data);
  size += GetSerializedSize_(input.pod_union);
  return size;
}

mojo::internal::ValidationError Serialize_(
    SmallStructNonNullableUnion* input,
    mojo::internal::Buffer* buf,
    internal::SmallStructNonNullableUnion_Data** output) {
  if (input) {
    internal::SmallStructNonNullableUnion_Data* result =
        internal::SmallStructNonNullableUnion_Data::New(buf);
    internal::PodUnion_Data* pod_union_ptr = &result->pod_union;
    {
      auto retval =
        SerializeUnion_(input->pod_union.get(),
                        buf,
                        &pod_union_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->pod_union.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null pod_union in SmallStructNonNullableUnion struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::SmallStructNonNullableUnion_Data* input,
                  SmallStructNonNullableUnion* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (!input->pod_union.is_null()) {
        result->pod_union = PodUnion::New();
        Deserialize_(&input->pod_union, result->pod_union.get());
      }
    } while (false);
  }
}


size_t StructNullObjectUnion::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructNullObjectUnion::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructNullObjectUnion_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructNullObjectUnion::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructNullObjectUnion_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructNullObjectUnion::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructNullObjectUnion_Data* input =
      static_cast<internal::StructNullObjectUnion_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructNullObjectUnion& input) {
  size_t size = sizeof(internal::StructNullObjectUnion_Data);
  size += GetSerializedSize_(input.obj_union);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructNullObjectUnion* input,
    mojo::internal::Buffer* buf,
    internal::StructNullObjectUnion_Data** output) {
  if (input) {
    internal::StructNullObjectUnion_Data* result =
        internal::StructNullObjectUnion_Data::New(buf);
    internal::ObjectOnlyUnion_Data* obj_union_ptr = &result->obj_union;
    {
      auto retval =
        SerializeUnion_(input->obj_union.get(),
                        buf,
                        &obj_union_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructNullObjectUnion_Data* input,
                  StructNullObjectUnion* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (!input->obj_union.is_null()) {
        result->obj_union = ObjectOnlyUnion::New();
        Deserialize_(&input->obj_union, result->obj_union.get());
      }
    } while (false);
  }
}


size_t SmallObjStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool SmallObjStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::SmallObjStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool SmallObjStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::SmallObjStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void SmallObjStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::SmallObjStruct_Data* input =
      static_cast<internal::SmallObjStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const SmallObjStruct& input) {
  size_t size = sizeof(internal::SmallObjStruct_Data);
  size += GetSerializedSize_(input.obj_union);
  return size;
}

mojo::internal::ValidationError Serialize_(
    SmallObjStruct* input,
    mojo::internal::Buffer* buf,
    internal::SmallObjStruct_Data** output) {
  if (input) {
    internal::SmallObjStruct_Data* result =
        internal::SmallObjStruct_Data::New(buf);
    internal::ObjectUnion_Data* obj_union_ptr = &result->obj_union;
    {
      auto retval =
        SerializeUnion_(input->obj_union.get(),
                        buf,
                        &obj_union_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->obj_union.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null obj_union in SmallObjStruct struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->f_int8 = input->f_int8;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::SmallObjStruct_Data* input,
                  SmallObjStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (!input->obj_union.is_null()) {
        result->obj_union = ObjectUnion::New();
        Deserialize_(&input->obj_union, result->obj_union.get());
      }
      result->f_int8 = input->f_int8;
    } while (false);
  }
}


size_t TryNonNullStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool TryNonNullStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::TryNonNullStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool TryNonNullStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::TryNonNullStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void TryNonNullStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::TryNonNullStruct_Data* input =
      static_cast<internal::TryNonNullStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const TryNonNullStruct& input) {
  size_t size = sizeof(internal::TryNonNullStruct_Data);
  size += input.nullable.is_null()
              ? 0
              : GetSerializedSize_(*input.nullable);
  size += input.non_nullable.is_null()
              ? 0
              : GetSerializedSize_(*input.non_nullable);
  return size;
}

mojo::internal::ValidationError Serialize_(
    TryNonNullStruct* input,
    mojo::internal::Buffer* buf,
    internal::TryNonNullStruct_Data** output) {
  if (input) {
    internal::TryNonNullStruct_Data* result =
        internal::TryNonNullStruct_Data::New(buf);
    {auto retval =Serialize_(input->nullable.get(),
                 buf,
                 &result->nullable.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->non_nullable.get(),
                 buf,
                 &result->non_nullable.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->non_nullable.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null non_nullable in TryNonNullStruct struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::TryNonNullStruct_Data* input,
                  TryNonNullStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->nullable.ptr) {
        result->nullable = DummyStruct::New();
        Deserialize_(input->nullable.ptr, result->nullable.get());
      }
      if (input->non_nullable.ptr) {
        result->non_nullable = DummyStruct::New();
        Deserialize_(input->non_nullable.ptr, result->non_nullable.get());
      }
    } while (false);
  }
}


size_t IncludingStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool IncludingStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::IncludingStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool IncludingStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::IncludingStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void IncludingStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::IncludingStruct_Data* input =
      static_cast<internal::IncludingStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const IncludingStruct& input) {
  size_t size = sizeof(internal::IncludingStruct_Data);
  size += GetSerializedSize_(input.a);
  return size;
}

mojo::internal::ValidationError Serialize_(
    IncludingStruct* input,
    mojo::internal::Buffer* buf,
    internal::IncludingStruct_Data** output) {
  if (input) {
    internal::IncludingStruct_Data* result =
        internal::IncludingStruct_Data::New(buf);
    internal::IncludedUnion_Data* a_ptr = &result->a;
    {
      auto retval =
        SerializeUnion_(input->a.get(),
                        buf,
                        &a_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->a.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a in IncludingStruct struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::IncludingStruct_Data* input,
                  IncludingStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (!input->a.is_null()) {
        result->a = mojo::test::IncludedUnion::New();
        Deserialize_(&input->a, result->a.get());
      }
    } while (false);
  }
}


// --- Union Serialization Helpers ---

size_t GetSerializedSize_(const PodUnionPtr& input) {
   size_t size = sizeof(internal::PodUnion_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<PodUnion> input_acc(input.get());
  switch (input->which()) {














    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    PodUnion* input,
    mojo::internal::Buffer* buf,
    internal::PodUnion_Data** output) {
  internal::PodUnion_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<PodUnion> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case PodUnion::Tag::F_INT8: {

        result->data.f_f_int8 = input_acc.data()->f_int8;
        break;
      }
      case PodUnion::Tag::F_INT8_OTHER: {

        result->data.f_f_int8_other = input_acc.data()->f_int8_other;
        break;
      }
      case PodUnion::Tag::F_UINT8: {

        result->data.f_f_uint8 = input_acc.data()->f_uint8;
        break;
      }
      case PodUnion::Tag::F_INT16: {

        result->data.f_f_int16 = input_acc.data()->f_int16;
        break;
      }
      case PodUnion::Tag::F_UINT16: {

        result->data.f_f_uint16 = input_acc.data()->f_uint16;
        break;
      }
      case PodUnion::Tag::F_INT32: {

        result->data.f_f_int32 = input_acc.data()->f_int32;
        break;
      }
      case PodUnion::Tag::F_UINT32: {

        result->data.f_f_uint32 = input_acc.data()->f_uint32;
        break;
      }
      case PodUnion::Tag::F_INT64: {

        result->data.f_f_int64 = input_acc.data()->f_int64;
        break;
      }
      case PodUnion::Tag::F_UINT64: {

        result->data.f_f_uint64 = input_acc.data()->f_uint64;
        break;
      }
      case PodUnion::Tag::F_FLOAT: {

        result->data.f_f_float = input_acc.data()->f_float;
        break;
      }
      case PodUnion::Tag::F_DOUBLE: {

        result->data.f_f_double = input_acc.data()->f_double;
        break;
      }
      case PodUnion::Tag::F_BOOL: {

        result->data.f_f_bool = input_acc.data()->f_bool;
        break;
      }
      case PodUnion::Tag::F_ENUM: {

        result->data.f_f_enum = 
          static_cast<int32_t>(input_acc.data()->f_enum);

        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::PodUnion_Data* input,
                  PodUnion* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<PodUnion> result_acc(output);
    switch (input->tag) {

      case PodUnion::Tag::F_INT8: {

        output->set_f_int8(input->data.f_f_int8);
        break;
      }
      case PodUnion::Tag::F_INT8_OTHER: {

        output->set_f_int8_other(input->data.f_f_int8_other);
        break;
      }
      case PodUnion::Tag::F_UINT8: {

        output->set_f_uint8(input->data.f_f_uint8);
        break;
      }
      case PodUnion::Tag::F_INT16: {

        output->set_f_int16(input->data.f_f_int16);
        break;
      }
      case PodUnion::Tag::F_UINT16: {

        output->set_f_uint16(input->data.f_f_uint16);
        break;
      }
      case PodUnion::Tag::F_INT32: {

        output->set_f_int32(input->data.f_f_int32);
        break;
      }
      case PodUnion::Tag::F_UINT32: {

        output->set_f_uint32(input->data.f_f_uint32);
        break;
      }
      case PodUnion::Tag::F_INT64: {

        output->set_f_int64(input->data.f_f_int64);
        break;
      }
      case PodUnion::Tag::F_UINT64: {

        output->set_f_uint64(input->data.f_f_uint64);
        break;
      }
      case PodUnion::Tag::F_FLOAT: {

        output->set_f_float(input->data.f_f_float);
        break;
      }
      case PodUnion::Tag::F_DOUBLE: {

        output->set_f_double(input->data.f_f_double);
        break;
      }
      case PodUnion::Tag::F_BOOL: {

        output->set_f_bool(input->data.f_f_bool);
        break;
      }
      case PodUnion::Tag::F_ENUM: {

        output->set_f_enum(static_cast<AnEnum>(input->data.f_f_enum));

        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing PodUnion with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


size_t GetSerializedSize_(const UnionOfUnionsPtr& input) {
   size_t size = sizeof(internal::UnionOfUnions_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<UnionOfUnions> input_acc(input.get());
  switch (input->which()) {


    case UnionOfUnions::Tag::U:

      if ((input_acc.data()->u)) {
        //size += sizeof(mojo::internal::UnionPointer<ObjectUnion::Data_>);
        size += GetSerializedSize_(*(input_acc.data()->u));
      }

      break;

    case UnionOfUnions::Tag::A_OU:

      size += GetSerializedSize_(*(input_acc.data()->a_ou));

      break;

    case UnionOfUnions::Tag::A_HU:

      size += GetSerializedSize_(*(input_acc.data()->a_hu));

      break;

    case UnionOfUnions::Tag::M_OU:

      size += GetSerializedSize_(*(input_acc.data()->m_ou));

      break;

    case UnionOfUnions::Tag::M_HU:

      size += GetSerializedSize_(*(input_acc.data()->m_hu));

      break;
    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    UnionOfUnions* input,
    mojo::internal::Buffer* buf,
    internal::UnionOfUnions_Data** output) {
  internal::UnionOfUnions_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<UnionOfUnions> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case UnionOfUnions::Tag::U: {


          // Point *output to newly allocated memory
          // SerializeUnion_ into newly allocated memory.
          if (!input_acc.data()->u->get()) {
            result->data.f_u.ptr = nullptr;
          } else {
            result->data.f_u.ptr =
              ObjectUnion::Data_::New(buf);
            {
            auto retval =
              SerializeUnion_(input_acc.data()->u->get(),
                              buf,
                              &result->data.f_u.ptr);
            if (retval != mojo::internal::ValidationError::NONE)
              return retval;
          }
          }


        break;
      }
      case UnionOfUnions::Tag::A_OU: {


          {
          const mojo::internal::ArrayValidateParams a_ou_validate_params(
            0, false, nullptr);auto retval =mojo::SerializeArray_(input_acc.data()->a_ou, buf, &result->data.f_a_ou.ptr,
                                &a_ou_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case UnionOfUnions::Tag::A_HU: {


          {
          const mojo::internal::ArrayValidateParams a_hu_validate_params(
            0, false, nullptr);auto retval =mojo::SerializeArray_(input_acc.data()->a_hu, buf, &result->data.f_a_hu.ptr,
                                &a_hu_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case UnionOfUnions::Tag::M_OU: {


          {
          const mojo::internal::ArrayValidateParams m_ou_validate_params(
              0, false, nullptr);auto retval =mojo::SerializeMap_(
              input_acc.data()->m_ou, buf, &result->data.f_m_ou.ptr,
              &m_ou_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }

        break;
      }
      case UnionOfUnions::Tag::M_HU: {


          {
          const mojo::internal::ArrayValidateParams m_hu_validate_params(
              0, false, nullptr);auto retval =mojo::SerializeMap_(
              input_acc.data()->m_hu, buf, &result->data.f_m_hu.ptr,
              &m_hu_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }

        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::UnionOfUnions_Data* input,
                  UnionOfUnions* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<UnionOfUnions> result_acc(output);
    switch (input->tag) {

      case UnionOfUnions::Tag::U: {

        result_acc.SwitchActive(UnionOfUnions::Tag::U);

        *result_acc.data()->u =
            ObjectUnion::New();
        Deserialize_(input->data.f_u.ptr,
            result_acc.data()->u->get());


        break;
      }
      case UnionOfUnions::Tag::A_OU: {

        result_acc.SwitchActive(UnionOfUnions::Tag::A_OU);

        Deserialize_(input->data.f_a_ou.ptr, result_acc.data()->a_ou);


        break;
      }
      case UnionOfUnions::Tag::A_HU: {

        result_acc.SwitchActive(UnionOfUnions::Tag::A_HU);

        Deserialize_(input->data.f_a_hu.ptr, result_acc.data()->a_hu);


        break;
      }
      case UnionOfUnions::Tag::M_OU: {

        result_acc.SwitchActive(UnionOfUnions::Tag::M_OU);

        Deserialize_(input->data.f_m_ou.ptr, result_acc.data()->m_ou);


        break;
      }
      case UnionOfUnions::Tag::M_HU: {

        result_acc.SwitchActive(UnionOfUnions::Tag::M_HU);

        Deserialize_(input->data.f_m_hu.ptr, result_acc.data()->m_hu);


        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing UnionOfUnions with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


size_t GetSerializedSize_(const ObjectUnionPtr& input) {
   size_t size = sizeof(internal::ObjectUnion_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<ObjectUnion> input_acc(input.get());
  switch (input->which()) {



    case ObjectUnion::Tag::F_STRING:

      size += GetSerializedSize_(*(input_acc.data()->f_string));

      break;

    case ObjectUnion::Tag::F_DUMMY:

      size += GetSerializedSize_(*(input_acc.data()->f_dummy->get()));

      break;

    case ObjectUnion::Tag::F_NULLABLE:

      size += GetSerializedSize_(*(input_acc.data()->f_nullable->get()));

      break;

    case ObjectUnion::Tag::F_ARRAY_INT8:

      size += GetSerializedSize_(*(input_acc.data()->f_array_int8));

      break;

    case ObjectUnion::Tag::F_MAP_INT8:

      size += GetSerializedSize_(*(input_acc.data()->f_map_int8));

      break;

    case ObjectUnion::Tag::F_POD_UNION:

      if ((input_acc.data()->f_pod_union)) {
        //size += sizeof(mojo::internal::UnionPointer<PodUnion::Data_>);
        size += GetSerializedSize_(*(input_acc.data()->f_pod_union));
      }

      break;
    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    ObjectUnion* input,
    mojo::internal::Buffer* buf,
    internal::ObjectUnion_Data** output) {
  internal::ObjectUnion_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<ObjectUnion> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case ObjectUnion::Tag::F_INT8: {

        result->data.f_f_int8 = input_acc.data()->f_int8;
        break;
      }
      case ObjectUnion::Tag::F_STRING: {


        SerializeString_(
            *input_acc.data()->f_string,
            buf, &result->data.f_f_string.ptr);


        break;
      }
      case ObjectUnion::Tag::F_DUMMY: {


          {auto retval =Serialize_(input_acc.data()->f_dummy->get(),
                     buf,
                     &result->data.f_f_dummy.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case ObjectUnion::Tag::F_NULLABLE: {


          {auto retval =Serialize_(input_acc.data()->f_nullable->get(),
                     buf,
                     &result->data.f_f_nullable.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case ObjectUnion::Tag::F_ARRAY_INT8: {


          {
          const mojo::internal::ArrayValidateParams f_array_int8_validate_params(
            0, false, nullptr);auto retval =mojo::SerializeArray_(input_acc.data()->f_array_int8, buf, &result->data.f_f_array_int8.ptr,
                                &f_array_int8_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case ObjectUnion::Tag::F_MAP_INT8: {


          {
          const mojo::internal::ArrayValidateParams f_map_int8_validate_params(
              0, false, nullptr);auto retval =mojo::SerializeMap_(
              input_acc.data()->f_map_int8, buf, &result->data.f_f_map_int8.ptr,
              &f_map_int8_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }

        break;
      }
      case ObjectUnion::Tag::F_POD_UNION: {


          // Point *output to newly allocated memory
          // SerializeUnion_ into newly allocated memory.
          if (!input_acc.data()->f_pod_union->get()) {
            result->data.f_f_pod_union.ptr = nullptr;
          } else {
            result->data.f_f_pod_union.ptr =
              PodUnion::Data_::New(buf);
            {
            auto retval =
              SerializeUnion_(input_acc.data()->f_pod_union->get(),
                              buf,
                              &result->data.f_f_pod_union.ptr);
            if (retval != mojo::internal::ValidationError::NONE)
              return retval;
          }
          }


        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ObjectUnion_Data* input,
                  ObjectUnion* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<ObjectUnion> result_acc(output);
    switch (input->tag) {

      case ObjectUnion::Tag::F_INT8: {

        output->set_f_int8(input->data.f_f_int8);
        break;
      }
      case ObjectUnion::Tag::F_STRING: {

        result_acc.SwitchActive(ObjectUnion::Tag::F_STRING);

        Deserialize_(input->data.f_f_string.ptr, result_acc.data()->f_string);


        break;
      }
      case ObjectUnion::Tag::F_DUMMY: {

        result_acc.SwitchActive(ObjectUnion::Tag::F_DUMMY);

        *result_acc.data()->f_dummy =
            DummyStruct::New();
        Deserialize_(input->data.f_f_dummy.ptr,
            result_acc.data()->f_dummy->get());


        break;
      }
      case ObjectUnion::Tag::F_NULLABLE: {

        result_acc.SwitchActive(ObjectUnion::Tag::F_NULLABLE);

        *result_acc.data()->f_nullable =
            DummyStruct::New();
        Deserialize_(input->data.f_f_nullable.ptr,
            result_acc.data()->f_nullable->get());


        break;
      }
      case ObjectUnion::Tag::F_ARRAY_INT8: {

        result_acc.SwitchActive(ObjectUnion::Tag::F_ARRAY_INT8);

        Deserialize_(input->data.f_f_array_int8.ptr, result_acc.data()->f_array_int8);


        break;
      }
      case ObjectUnion::Tag::F_MAP_INT8: {

        result_acc.SwitchActive(ObjectUnion::Tag::F_MAP_INT8);

        Deserialize_(input->data.f_f_map_int8.ptr, result_acc.data()->f_map_int8);


        break;
      }
      case ObjectUnion::Tag::F_POD_UNION: {

        result_acc.SwitchActive(ObjectUnion::Tag::F_POD_UNION);

        *result_acc.data()->f_pod_union =
            PodUnion::New();
        Deserialize_(input->data.f_f_pod_union.ptr,
            result_acc.data()->f_pod_union->get());


        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing ObjectUnion with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


size_t GetSerializedSize_(const HandleUnionPtr& input) {
   size_t size = sizeof(internal::HandleUnion_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<HandleUnion> input_acc(input.get());
  switch (input->which()) {







    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    HandleUnion* input,
    mojo::internal::Buffer* buf,
    internal::HandleUnion_Data** output) {
  internal::HandleUnion_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<HandleUnion> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case HandleUnion::Tag::F_HANDLE: {

        result->data.f_f_handle =
            input_acc.data()->f_handle->release().value();

        break;
      }
      case HandleUnion::Tag::F_MESSAGE_PIPE: {

        result->data.f_f_message_pipe =
            input_acc.data()->f_message_pipe->release().value();

        break;
      }
      case HandleUnion::Tag::F_DATA_PIPE_CONSUMER: {

        result->data.f_f_data_pipe_consumer =
            input_acc.data()->f_data_pipe_consumer->release().value();

        break;
      }
      case HandleUnion::Tag::F_DATA_PIPE_PRODUCER: {

        result->data.f_f_data_pipe_producer =
            input_acc.data()->f_data_pipe_producer->release().value();

        break;
      }
      case HandleUnion::Tag::F_SHARED_BUFFER: {

        result->data.f_f_shared_buffer =
            input_acc.data()->f_shared_buffer->release().value();

        break;
      }
      case HandleUnion::Tag::F_SMALL_CACHE: {

        mojo::internal::Interface_Data* f_small_cache =
            reinterpret_cast<mojo::internal::Interface_Data*>(
                &result->data.f_f_small_cache);
        mojo::internal::InterfaceHandleToData(
            input_acc.data()->f_small_cache->Pass(), f_small_cache);

        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::HandleUnion_Data* input,
                  HandleUnion* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<HandleUnion> result_acc(output);
    switch (input->tag) {

      case HandleUnion::Tag::F_HANDLE: {

        mojo::ScopedHandle* f_handle =
            reinterpret_cast<mojo::ScopedHandle*>(&input->data.f_f_handle);
        output->set_f_handle(f_handle->Pass());

        break;
      }
      case HandleUnion::Tag::F_MESSAGE_PIPE: {

        mojo::ScopedMessagePipeHandle* f_message_pipe =
            reinterpret_cast<mojo::ScopedMessagePipeHandle*>(&input->data.f_f_message_pipe);
        output->set_f_message_pipe(f_message_pipe->Pass());

        break;
      }
      case HandleUnion::Tag::F_DATA_PIPE_CONSUMER: {

        mojo::ScopedDataPipeConsumerHandle* f_data_pipe_consumer =
            reinterpret_cast<mojo::ScopedDataPipeConsumerHandle*>(&input->data.f_f_data_pipe_consumer);
        output->set_f_data_pipe_consumer(f_data_pipe_consumer->Pass());

        break;
      }
      case HandleUnion::Tag::F_DATA_PIPE_PRODUCER: {

        mojo::ScopedDataPipeProducerHandle* f_data_pipe_producer =
            reinterpret_cast<mojo::ScopedDataPipeProducerHandle*>(&input->data.f_f_data_pipe_producer);
        output->set_f_data_pipe_producer(f_data_pipe_producer->Pass());

        break;
      }
      case HandleUnion::Tag::F_SHARED_BUFFER: {

        mojo::ScopedSharedBufferHandle* f_shared_buffer =
            reinterpret_cast<mojo::ScopedSharedBufferHandle*>(&input->data.f_f_shared_buffer);
        output->set_f_shared_buffer(f_shared_buffer->Pass());

        break;
      }
      case HandleUnion::Tag::F_SMALL_CACHE: {

        mojo::InterfaceHandle<SmallCache> f_small_cache_out;
        mojo::internal::Interface_Data* f_small_cache_in =
            reinterpret_cast<mojo::internal::Interface_Data*>(
                &input->data.f_f_small_cache);
        mojo::internal::InterfaceDataToHandle(
            f_small_cache_in, &f_small_cache_out);
        output->set_f_small_cache(f_small_cache_out.Pass());

        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing HandleUnion with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


size_t GetSerializedSize_(const ObjectOnlyUnionPtr& input) {
   size_t size = sizeof(internal::ObjectOnlyUnion_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<ObjectOnlyUnion> input_acc(input.get());
  switch (input->which()) {


    case ObjectOnlyUnion::Tag::DUMMY1:

      size += GetSerializedSize_(*(input_acc.data()->dummy1->get()));

      break;
    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    ObjectOnlyUnion* input,
    mojo::internal::Buffer* buf,
    internal::ObjectOnlyUnion_Data** output) {
  internal::ObjectOnlyUnion_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<ObjectOnlyUnion> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case ObjectOnlyUnion::Tag::DUMMY1: {


          {auto retval =Serialize_(input_acc.data()->dummy1->get(),
                     buf,
                     &result->data.f_dummy1.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ObjectOnlyUnion_Data* input,
                  ObjectOnlyUnion* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<ObjectOnlyUnion> result_acc(output);
    switch (input->tag) {

      case ObjectOnlyUnion::Tag::DUMMY1: {

        result_acc.SwitchActive(ObjectOnlyUnion::Tag::DUMMY1);

        *result_acc.data()->dummy1 =
            DummyStruct::New();
        Deserialize_(input->data.f_dummy1.ptr,
            result_acc.data()->dummy1->get());


        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing ObjectOnlyUnion with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


size_t GetSerializedSize_(const OldUnionPtr& input) {
   size_t size = sizeof(internal::OldUnion_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<OldUnion> input_acc(input.get());
  switch (input->which()) {


    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    OldUnion* input,
    mojo::internal::Buffer* buf,
    internal::OldUnion_Data** output) {
  internal::OldUnion_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<OldUnion> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case OldUnion::Tag::F_INT8: {

        result->data.f_f_int8 = input_acc.data()->f_int8;
        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::OldUnion_Data* input,
                  OldUnion* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<OldUnion> result_acc(output);
    switch (input->tag) {

      case OldUnion::Tag::F_INT8: {

        output->set_f_int8(input->data.f_f_int8);
        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing OldUnion with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


size_t GetSerializedSize_(const NewUnionPtr& input) {
   size_t size = sizeof(internal::NewUnion_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<NewUnion> input_acc(input.get());
  switch (input->which()) {



    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    NewUnion* input,
    mojo::internal::Buffer* buf,
    internal::NewUnion_Data** output) {
  internal::NewUnion_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<NewUnion> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case NewUnion::Tag::F_INT8: {

        result->data.f_f_int8 = input_acc.data()->f_int8;
        break;
      }
      case NewUnion::Tag::F_INT16: {

        result->data.f_f_int16 = input_acc.data()->f_int16;
        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::NewUnion_Data* input,
                  NewUnion* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<NewUnion> result_acc(output);
    switch (input->tag) {

      case NewUnion::Tag::F_INT8: {

        output->set_f_int8(input->data.f_f_int8);
        break;
      }
      case NewUnion::Tag::F_INT16: {

        output->set_f_int16(input->data.f_f_int16);
        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing NewUnion with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


// --- Structs for interface method parameters ---


// static
SmallCache_SetIntValue_ParamsPtr SmallCache_SetIntValue_Params::New() {
  SmallCache_SetIntValue_ParamsPtr rv;
  mojo::internal::StructHelper<SmallCache_SetIntValue_Params>::Initialize(&rv);
  return rv;
}

SmallCache_SetIntValue_Params::SmallCache_SetIntValue_Params()
    : int_value() {
}

SmallCache_SetIntValue_Params::~SmallCache_SetIntValue_Params() {
}


SmallCache_SetIntValue_ParamsPtr SmallCache_SetIntValue_Params::Clone() const {
  SmallCache_SetIntValue_ParamsPtr rv(New());
  rv->int_value = int_value;
  return rv;
}


bool SmallCache_SetIntValue_Params::Equals(const SmallCache_SetIntValue_Params& other) const {
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->int_value, other.int_value))
    return false;
  return true;
}


size_t SmallCache_SetIntValue_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool SmallCache_SetIntValue_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::SmallCache_SetIntValue_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool SmallCache_SetIntValue_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::SmallCache_SetIntValue_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void SmallCache_SetIntValue_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::SmallCache_SetIntValue_Params_Data* input =
      static_cast<internal::SmallCache_SetIntValue_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const SmallCache_SetIntValue_Params& input) {
  size_t size = sizeof(internal::SmallCache_SetIntValue_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    SmallCache_SetIntValue_Params* input,
    mojo::internal::Buffer* buf,
    internal::SmallCache_SetIntValue_Params_Data** output) {
  if (input) {
    internal::SmallCache_SetIntValue_Params_Data* result =
        internal::SmallCache_SetIntValue_Params_Data::New(buf);
    result->int_value = input->int_value;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::SmallCache_SetIntValue_Params_Data* input,
                  SmallCache_SetIntValue_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->int_value = input->int_value;
    } while (false);
  }
}



// static
SmallCache_GetIntValue_ParamsPtr SmallCache_GetIntValue_Params::New() {
  SmallCache_GetIntValue_ParamsPtr rv;
  mojo::internal::StructHelper<SmallCache_GetIntValue_Params>::Initialize(&rv);
  return rv;
}

SmallCache_GetIntValue_Params::SmallCache_GetIntValue_Params() {
}

SmallCache_GetIntValue_Params::~SmallCache_GetIntValue_Params() {
}


SmallCache_GetIntValue_ParamsPtr SmallCache_GetIntValue_Params::Clone() const {
  SmallCache_GetIntValue_ParamsPtr rv(New());
  return rv;
}


bool SmallCache_GetIntValue_Params::Equals(const SmallCache_GetIntValue_Params& other) const {
  return true;
}


size_t SmallCache_GetIntValue_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool SmallCache_GetIntValue_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::SmallCache_GetIntValue_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool SmallCache_GetIntValue_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::SmallCache_GetIntValue_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void SmallCache_GetIntValue_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::SmallCache_GetIntValue_Params_Data* input =
      static_cast<internal::SmallCache_GetIntValue_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const SmallCache_GetIntValue_Params& input) {
  size_t size = sizeof(internal::SmallCache_GetIntValue_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    SmallCache_GetIntValue_Params* input,
    mojo::internal::Buffer* buf,
    internal::SmallCache_GetIntValue_Params_Data** output) {
  if (input) {
    internal::SmallCache_GetIntValue_Params_Data* result =
        internal::SmallCache_GetIntValue_Params_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::SmallCache_GetIntValue_Params_Data* input,
                  SmallCache_GetIntValue_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


// static
SmallCache_GetIntValue_ResponseParamsPtr SmallCache_GetIntValue_ResponseParams::New() {
  SmallCache_GetIntValue_ResponseParamsPtr rv;
  mojo::internal::StructHelper<SmallCache_GetIntValue_ResponseParams>::Initialize(&rv);
  return rv;
}

SmallCache_GetIntValue_ResponseParams::SmallCache_GetIntValue_ResponseParams()
    : int_value() {
}

SmallCache_GetIntValue_ResponseParams::~SmallCache_GetIntValue_ResponseParams() {
}


SmallCache_GetIntValue_ResponseParamsPtr SmallCache_GetIntValue_ResponseParams::Clone() const {
  SmallCache_GetIntValue_ResponseParamsPtr rv(New());
  rv->int_value = int_value;
  return rv;
}


bool SmallCache_GetIntValue_ResponseParams::Equals(const SmallCache_GetIntValue_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->int_value, other.int_value))
    return false;
  return true;
}


size_t SmallCache_GetIntValue_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool SmallCache_GetIntValue_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::SmallCache_GetIntValue_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool SmallCache_GetIntValue_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::SmallCache_GetIntValue_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void SmallCache_GetIntValue_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::SmallCache_GetIntValue_ResponseParams_Data* input =
      static_cast<internal::SmallCache_GetIntValue_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const SmallCache_GetIntValue_ResponseParams& input) {
  size_t size = sizeof(internal::SmallCache_GetIntValue_ResponseParams_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    SmallCache_GetIntValue_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::SmallCache_GetIntValue_ResponseParams_Data** output) {
  if (input) {
    internal::SmallCache_GetIntValue_ResponseParams_Data* result =
        internal::SmallCache_GetIntValue_ResponseParams_Data::New(buf);
    result->int_value = input->int_value;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::SmallCache_GetIntValue_ResponseParams_Data* input,
                  SmallCache_GetIntValue_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->int_value = input->int_value;
    } while (false);
  }
}



// static
UnionInterface_Echo_ParamsPtr UnionInterface_Echo_Params::New() {
  UnionInterface_Echo_ParamsPtr rv;
  mojo::internal::StructHelper<UnionInterface_Echo_Params>::Initialize(&rv);
  return rv;
}

UnionInterface_Echo_Params::UnionInterface_Echo_Params()
    : in_val() {
}

UnionInterface_Echo_Params::~UnionInterface_Echo_Params() {
}


UnionInterface_Echo_ParamsPtr UnionInterface_Echo_Params::Clone() const {
  UnionInterface_Echo_ParamsPtr rv(New());
  rv->in_val = in_val.Clone();
  return rv;
}


bool UnionInterface_Echo_Params::Equals(const UnionInterface_Echo_Params& other) const {
  if (!mojo::internal::ValueTraits<PodUnionPtr>::Equals(this->in_val, other.in_val))
    return false;
  return true;
}


size_t UnionInterface_Echo_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool UnionInterface_Echo_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::UnionInterface_Echo_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool UnionInterface_Echo_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::UnionInterface_Echo_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void UnionInterface_Echo_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::UnionInterface_Echo_Params_Data* input =
      static_cast<internal::UnionInterface_Echo_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const UnionInterface_Echo_Params& input) {
  size_t size = sizeof(internal::UnionInterface_Echo_Params_Data);
  size += GetSerializedSize_(input.in_val);
  return size;
}

mojo::internal::ValidationError Serialize_(
    UnionInterface_Echo_Params* input,
    mojo::internal::Buffer* buf,
    internal::UnionInterface_Echo_Params_Data** output) {
  if (input) {
    internal::UnionInterface_Echo_Params_Data* result =
        internal::UnionInterface_Echo_Params_Data::New(buf);
    internal::PodUnion_Data* in_val_ptr = &result->in_val;
    {
      auto retval =
        SerializeUnion_(input->in_val.get(),
                        buf,
                        &in_val_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->in_val.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null in_val in UnionInterface_Echo_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::UnionInterface_Echo_Params_Data* input,
                  UnionInterface_Echo_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (!input->in_val.is_null()) {
        result->in_val = PodUnion::New();
        Deserialize_(&input->in_val, result->in_val.get());
      }
    } while (false);
  }
}


// static
UnionInterface_Echo_ResponseParamsPtr UnionInterface_Echo_ResponseParams::New() {
  UnionInterface_Echo_ResponseParamsPtr rv;
  mojo::internal::StructHelper<UnionInterface_Echo_ResponseParams>::Initialize(&rv);
  return rv;
}

UnionInterface_Echo_ResponseParams::UnionInterface_Echo_ResponseParams()
    : out_val() {
}

UnionInterface_Echo_ResponseParams::~UnionInterface_Echo_ResponseParams() {
}


UnionInterface_Echo_ResponseParamsPtr UnionInterface_Echo_ResponseParams::Clone() const {
  UnionInterface_Echo_ResponseParamsPtr rv(New());
  rv->out_val = out_val.Clone();
  return rv;
}


bool UnionInterface_Echo_ResponseParams::Equals(const UnionInterface_Echo_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<PodUnionPtr>::Equals(this->out_val, other.out_val))
    return false;
  return true;
}


size_t UnionInterface_Echo_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool UnionInterface_Echo_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::UnionInterface_Echo_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool UnionInterface_Echo_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::UnionInterface_Echo_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void UnionInterface_Echo_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::UnionInterface_Echo_ResponseParams_Data* input =
      static_cast<internal::UnionInterface_Echo_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const UnionInterface_Echo_ResponseParams& input) {
  size_t size = sizeof(internal::UnionInterface_Echo_ResponseParams_Data);
  size += GetSerializedSize_(input.out_val);
  return size;
}

mojo::internal::ValidationError Serialize_(
    UnionInterface_Echo_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::UnionInterface_Echo_ResponseParams_Data** output) {
  if (input) {
    internal::UnionInterface_Echo_ResponseParams_Data* result =
        internal::UnionInterface_Echo_ResponseParams_Data::New(buf);
    internal::PodUnion_Data* out_val_ptr = &result->out_val;
    {
      auto retval =
        SerializeUnion_(input->out_val.get(),
                        buf,
                        &out_val_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->out_val.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null out_val in UnionInterface_Echo_ResponseParams struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::UnionInterface_Echo_ResponseParams_Data* input,
                  UnionInterface_Echo_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (!input->out_val.is_null()) {
        result->out_val = PodUnion::New();
        Deserialize_(&input->out_val, result->out_val.get());
      }
    } while (false);
  }
}

}  // namespace test
}  // namespace mojo
