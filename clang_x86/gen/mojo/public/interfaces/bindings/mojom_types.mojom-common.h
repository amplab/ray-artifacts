// NOTE: This file was generated by the Mojo bindings generator.
#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_MOJOM_TYPES_MOJOM_COMMON_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_MOJOM_TYPES_MOJOM_COMMON_H_

#include <stdint.h>
#include <iosfwd>

#include "mojo/public/cpp/bindings/array.h"
#include "mojo/public/cpp/bindings/callback.h"
#include "mojo/public/cpp/bindings/interface_handle.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/map.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/bindings/string.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/system/buffer.h"
#include "mojo/public/cpp/system/data_pipe.h"
#include "mojo/public/cpp/system/handle.h"
#include "mojo/public/cpp/system/message_pipe.h"
#include "mojo/public/interfaces/bindings/mojom_types.mojom-internal.h"
namespace mojo {
namespace bindings {
namespace types {

// --- Interface Forward Declarations ---

// --- Struct Forward Declarations ---
class StringType;

using StringTypePtr = mojo::InlinedStructPtr<StringType>;


class HandleType;

using HandleTypePtr = mojo::InlinedStructPtr<HandleType>;


class ArrayType;

using ArrayTypePtr = mojo::StructPtr<ArrayType>;


class MapType;

using MapTypePtr = mojo::StructPtr<MapType>;


class TypeReference;

using TypeReferencePtr = mojo::InlinedStructPtr<TypeReference>;


class StructField;

using StructFieldPtr = mojo::StructPtr<StructField>;


class DefaultKeyword;

using DefaultKeywordPtr = mojo::InlinedStructPtr<DefaultKeyword>;


class StructVersion;

using StructVersionPtr = mojo::InlinedStructPtr<StructVersion>;


class MojomStruct;

using MojomStructPtr = mojo::StructPtr<MojomStruct>;


class UnionField;

using UnionFieldPtr = mojo::StructPtr<UnionField>;


class MojomUnion;

using MojomUnionPtr = mojo::StructPtr<MojomUnion>;


class EnumValue;

using EnumValuePtr = mojo::StructPtr<EnumValue>;


class MojomEnum;

using MojomEnumPtr = mojo::StructPtr<MojomEnum>;


class MojomMethod;

using MojomMethodPtr = mojo::StructPtr<MojomMethod>;


class MojomInterface;

using MojomInterfacePtr = mojo::StructPtr<MojomInterface>;


class ConstantReference;

using ConstantReferencePtr = mojo::InlinedStructPtr<ConstantReference>;


class EnumValueReference;

using EnumValueReferencePtr = mojo::InlinedStructPtr<EnumValueReference>;


class DeclaredConstant;

using DeclaredConstantPtr = mojo::StructPtr<DeclaredConstant>;


class Attribute;

using AttributePtr = mojo::StructPtr<Attribute>;


class DeclarationData;

using DeclarationDataPtr = mojo::StructPtr<DeclarationData>;


class SourceFileInfo;

using SourceFileInfoPtr = mojo::InlinedStructPtr<SourceFileInfo>;


class ContainedDeclarations;

using ContainedDeclarationsPtr = mojo::StructPtr<ContainedDeclarations>;


class RuntimeTypeInfo;

using RuntimeTypeInfoPtr = mojo::StructPtr<RuntimeTypeInfo>;



// --- Union Forward Declarations ---
class Type;
typedef mojo::StructPtr<Type> TypePtr;
class UserDefinedType;
typedef mojo::StructPtr<UserDefinedType> UserDefinedTypePtr;
class DefaultFieldValue;
typedef mojo::StructPtr<DefaultFieldValue> DefaultFieldValuePtr;
class Value;
typedef mojo::StructPtr<Value> ValuePtr;
class LiteralValue;
typedef mojo::InlinedStructPtr<LiteralValue> LiteralValuePtr;

// --- Enums Declarations ---
  
enum class SimpleType : int32_t {
  BOOL,
  DOUBLE,
  FLOAT,
  INT8,
  INT16,
  INT32,
  INT64,
  UINT8,
  UINT16,
  UINT32,
  UINT64,
};

bool SimpleType_IsValidValue(SimpleType value);
  
std::ostream& operator<<(std::ostream& stream, const SimpleType& val);
  
enum class BuiltinConstantValue : int32_t {
  DOUBLE_INFINITY,
  DOUBLE_NEGATIVE_INFINITY,
  DOUBLE_NAN,
  FLOAT_INFINITY,
  FLOAT_NEGATIVE_INFINITY,
  FLOAT_NAN,
};

bool BuiltinConstantValue_IsValidValue(BuiltinConstantValue value);
  
std::ostream& operator<<(std::ostream& stream, const BuiltinConstantValue& val);

// --- Constants ---

// --- Interface declarations ---
}  // namespace types
}  // namespace bindings
}  // namespace mojo

// --- Internal Template Specializations ---

namespace mojo {
namespace internal {
template <>
struct WrapperTraits<mojo::bindings::types::StringTypePtr, true, false> {
  using DataType = mojo::bindings::types::internal::StringType_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::HandleTypePtr, true, false> {
  using DataType = mojo::bindings::types::internal::HandleType_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::ArrayTypePtr, true, false> {
  using DataType = mojo::bindings::types::internal::ArrayType_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::MapTypePtr, true, false> {
  using DataType = mojo::bindings::types::internal::MapType_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::TypeReferencePtr, true, false> {
  using DataType = mojo::bindings::types::internal::TypeReference_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::StructFieldPtr, true, false> {
  using DataType = mojo::bindings::types::internal::StructField_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::DefaultKeywordPtr, true, false> {
  using DataType = mojo::bindings::types::internal::DefaultKeyword_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::StructVersionPtr, true, false> {
  using DataType = mojo::bindings::types::internal::StructVersion_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::MojomStructPtr, true, false> {
  using DataType = mojo::bindings::types::internal::MojomStruct_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::UnionFieldPtr, true, false> {
  using DataType = mojo::bindings::types::internal::UnionField_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::MojomUnionPtr, true, false> {
  using DataType = mojo::bindings::types::internal::MojomUnion_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::EnumValuePtr, true, false> {
  using DataType = mojo::bindings::types::internal::EnumValue_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::MojomEnumPtr, true, false> {
  using DataType = mojo::bindings::types::internal::MojomEnum_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::MojomMethodPtr, true, false> {
  using DataType = mojo::bindings::types::internal::MojomMethod_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::MojomInterfacePtr, true, false> {
  using DataType = mojo::bindings::types::internal::MojomInterface_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::ConstantReferencePtr, true, false> {
  using DataType = mojo::bindings::types::internal::ConstantReference_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::EnumValueReferencePtr, true, false> {
  using DataType = mojo::bindings::types::internal::EnumValueReference_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::DeclaredConstantPtr, true, false> {
  using DataType = mojo::bindings::types::internal::DeclaredConstant_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::AttributePtr, true, false> {
  using DataType = mojo::bindings::types::internal::Attribute_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::DeclarationDataPtr, true, false> {
  using DataType = mojo::bindings::types::internal::DeclarationData_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::SourceFileInfoPtr, true, false> {
  using DataType = mojo::bindings::types::internal::SourceFileInfo_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::ContainedDeclarationsPtr, true, false> {
  using DataType = mojo::bindings::types::internal::ContainedDeclarations_Data*;
};
template <>
struct WrapperTraits<mojo::bindings::types::RuntimeTypeInfoPtr, true, false> {
  using DataType = mojo::bindings::types::internal::RuntimeTypeInfo_Data*;
};

}  // internal
}  // mojo
namespace mojo {
namespace bindings {
namespace types {

// --- Interface Request Validators ---

// --- Interface Response Validators ---

// --- Interface enum operators ---

// --- Unions ---
// Unions must be declared first because they can be members of structs.
class Type {
 public:
  using Data_ = internal::Type_Data;
  using Tag = Data_::Type_Tag;

  static TypePtr New();

  template <typename U>
  static TypePtr From(const U& u) {
    return mojo::TypeConverter<TypePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Type>::Convert(*this);
  }

  Type();
  ~Type();


  TypePtr Clone() const;
  bool Equals(const Type& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_simple_type() const;
  SimpleType get_simple_type() const;
  void set_simple_type(SimpleType simple_type);
  bool is_string_type() const;
  StringTypePtr& get_string_type() const;
  void set_string_type(StringTypePtr string_type);
  bool is_array_type() const;
  ArrayTypePtr& get_array_type() const;
  void set_array_type(ArrayTypePtr array_type);
  bool is_map_type() const;
  MapTypePtr& get_map_type() const;
  void set_map_type(MapTypePtr map_type);
  bool is_handle_type() const;
  HandleTypePtr& get_handle_type() const;
  void set_handle_type(HandleTypePtr handle_type);
  bool is_type_reference() const;
  TypeReferencePtr& get_type_reference() const;
  void set_type_reference(TypeReferencePtr type_reference);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<Type>;
  union Union_ {
    Union_() {}
    ~Union_() {}

SimpleType simple_type;

StringTypePtr* string_type;

ArrayTypePtr* array_type;

MapTypePtr* map_type;

HandleTypePtr* handle_type;

TypeReferencePtr* type_reference;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};

class UserDefinedType {
 public:
  using Data_ = internal::UserDefinedType_Data;
  using Tag = Data_::UserDefinedType_Tag;

  static UserDefinedTypePtr New();

  template <typename U>
  static UserDefinedTypePtr From(const U& u) {
    return mojo::TypeConverter<UserDefinedTypePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UserDefinedType>::Convert(*this);
  }

  UserDefinedType();
  ~UserDefinedType();


  UserDefinedTypePtr Clone() const;
  bool Equals(const UserDefinedType& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_enum_type() const;
  MojomEnumPtr& get_enum_type() const;
  void set_enum_type(MojomEnumPtr enum_type);
  bool is_struct_type() const;
  MojomStructPtr& get_struct_type() const;
  void set_struct_type(MojomStructPtr struct_type);
  bool is_union_type() const;
  MojomUnionPtr& get_union_type() const;
  void set_union_type(MojomUnionPtr union_type);
  bool is_interface_type() const;
  MojomInterfacePtr& get_interface_type() const;
  void set_interface_type(MojomInterfacePtr interface_type);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<UserDefinedType>;
  union Union_ {
    Union_() {}
    ~Union_() {}

MojomEnumPtr* enum_type;

MojomStructPtr* struct_type;

MojomUnionPtr* union_type;

MojomInterfacePtr* interface_type;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};

class DefaultFieldValue {
 public:
  using Data_ = internal::DefaultFieldValue_Data;
  using Tag = Data_::DefaultFieldValue_Tag;

  static DefaultFieldValuePtr New();

  template <typename U>
  static DefaultFieldValuePtr From(const U& u) {
    return mojo::TypeConverter<DefaultFieldValuePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DefaultFieldValue>::Convert(*this);
  }

  DefaultFieldValue();
  ~DefaultFieldValue();


  DefaultFieldValuePtr Clone() const;
  bool Equals(const DefaultFieldValue& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_value() const;
  ValuePtr& get_value() const;
  void set_value(ValuePtr value);
  bool is_default_keyword() const;
  DefaultKeywordPtr& get_default_keyword() const;
  void set_default_keyword(DefaultKeywordPtr default_keyword);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<DefaultFieldValue>;
  union Union_ {
    Union_() {}
    ~Union_() {}

ValuePtr* value;

DefaultKeywordPtr* default_keyword;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};

class Value {
 public:
  using Data_ = internal::Value_Data;
  using Tag = Data_::Value_Tag;

  static ValuePtr New();

  template <typename U>
  static ValuePtr From(const U& u) {
    return mojo::TypeConverter<ValuePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Value>::Convert(*this);
  }

  Value();
  ~Value();


  ValuePtr Clone() const;
  bool Equals(const Value& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_literal_value() const;
  LiteralValuePtr& get_literal_value() const;
  void set_literal_value(LiteralValuePtr literal_value);
  bool is_constant_reference() const;
  ConstantReferencePtr& get_constant_reference() const;
  void set_constant_reference(ConstantReferencePtr constant_reference);
  bool is_enum_value_reference() const;
  EnumValueReferencePtr& get_enum_value_reference() const;
  void set_enum_value_reference(EnumValueReferencePtr enum_value_reference);
  bool is_builtin_value() const;
  BuiltinConstantValue get_builtin_value() const;
  void set_builtin_value(BuiltinConstantValue builtin_value);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<Value>;
  union Union_ {
    Union_() {}
    ~Union_() {}

LiteralValuePtr* literal_value;

ConstantReferencePtr* constant_reference;

EnumValueReferencePtr* enum_value_reference;

BuiltinConstantValue builtin_value;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};

class LiteralValue {
 public:
  using Data_ = internal::LiteralValue_Data;
  using Tag = Data_::LiteralValue_Tag;

  static LiteralValuePtr New();

  template <typename U>
  static LiteralValuePtr From(const U& u) {
    return mojo::TypeConverter<LiteralValuePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, LiteralValue>::Convert(*this);
  }

  LiteralValue();
  ~LiteralValue();


  LiteralValuePtr Clone() const;
  bool Equals(const LiteralValue& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_bool_value() const;
  bool get_bool_value() const;
  void set_bool_value(bool bool_value);
  bool is_double_value() const;
  double get_double_value() const;
  void set_double_value(double double_value);
  bool is_float_value() const;
  float get_float_value() const;
  void set_float_value(float float_value);
  bool is_int8_value() const;
  int8_t get_int8_value() const;
  void set_int8_value(int8_t int8_value);
  bool is_int16_value() const;
  int16_t get_int16_value() const;
  void set_int16_value(int16_t int16_value);
  bool is_int32_value() const;
  int32_t get_int32_value() const;
  void set_int32_value(int32_t int32_value);
  bool is_int64_value() const;
  int64_t get_int64_value() const;
  void set_int64_value(int64_t int64_value);
  bool is_string_value() const;
  mojo::String get_string_value() const;
  void set_string_value(const mojo::String& string_value);
  bool is_uint8_value() const;
  uint8_t get_uint8_value() const;
  void set_uint8_value(uint8_t uint8_value);
  bool is_uint16_value() const;
  uint16_t get_uint16_value() const;
  void set_uint16_value(uint16_t uint16_value);
  bool is_uint32_value() const;
  uint32_t get_uint32_value() const;
  void set_uint32_value(uint32_t uint32_value);
  bool is_uint64_value() const;
  uint64_t get_uint64_value() const;
  void set_uint64_value(uint64_t uint64_value);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<LiteralValue>;
  union Union_ {
    Union_() {}
    ~Union_() {}

bool bool_value;

double double_value;

float float_value;

int8_t int8_value;

int16_t int16_value;

int32_t int32_value;

int64_t int64_value;

mojo::String* string_value;

uint8_t uint8_value;

uint16_t uint16_value;

uint32_t uint32_value;

uint64_t uint64_value;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};


// --- Inlined structs ---
class StringType {
 public:
  using Data_ = internal::StringType_Data;

  static StringTypePtr New();

  template <typename U>
  static StringTypePtr From(const U& u) {
    return mojo::TypeConverter<StringTypePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StringType>::Convert(*this);
  }

  StringType();
  ~StringType();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  StringTypePtr Clone() const;
  bool Equals(const StringType& other) const;

  bool nullable;
};


class HandleType {
 public:
  using Data_ = internal::HandleType_Data;
  enum class Kind : int32_t {
    UNSPECIFIED,
    MESSAGE_PIPE,
    DATA_PIPE_CONSUMER,
    DATA_PIPE_PRODUCER,
    SHARED_BUFFER,
  };
  
  static bool Kind_IsValidValue(Kind value);

  static HandleTypePtr New();

  template <typename U>
  static HandleTypePtr From(const U& u) {
    return mojo::TypeConverter<HandleTypePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HandleType>::Convert(*this);
  }

  HandleType();
  ~HandleType();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  HandleTypePtr Clone() const;
  bool Equals(const HandleType& other) const;

  bool nullable;
  HandleType::Kind kind;
};

  
std::ostream& operator<<(std::ostream& stream,
                         const HandleType::Kind& val);

class TypeReference {
 public:
  using Data_ = internal::TypeReference_Data;

  static TypeReferencePtr New();

  template <typename U>
  static TypeReferencePtr From(const U& u) {
    return mojo::TypeConverter<TypeReferencePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, TypeReference>::Convert(*this);
  }

  TypeReference();
  ~TypeReference();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  TypeReferencePtr Clone() const;
  bool Equals(const TypeReference& other) const;

  bool nullable;
  bool is_interface_request;
  mojo::String identifier;
  mojo::String type_key;
};


class DefaultKeyword {
 public:
  using Data_ = internal::DefaultKeyword_Data;

  static DefaultKeywordPtr New();

  template <typename U>
  static DefaultKeywordPtr From(const U& u) {
    return mojo::TypeConverter<DefaultKeywordPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DefaultKeyword>::Convert(*this);
  }

  DefaultKeyword();
  ~DefaultKeyword();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  DefaultKeywordPtr Clone() const;
  bool Equals(const DefaultKeyword& other) const;

};


class StructVersion {
 public:
  using Data_ = internal::StructVersion_Data;

  static StructVersionPtr New();

  template <typename U>
  static StructVersionPtr From(const U& u) {
    return mojo::TypeConverter<StructVersionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructVersion>::Convert(*this);
  }

  StructVersion();
  ~StructVersion();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  StructVersionPtr Clone() const;
  bool Equals(const StructVersion& other) const;

  uint32_t version_number;
  uint32_t num_fields;
  uint32_t num_bytes;
};


class ConstantReference {
 public:
  using Data_ = internal::ConstantReference_Data;

  static ConstantReferencePtr New();

  template <typename U>
  static ConstantReferencePtr From(const U& u) {
    return mojo::TypeConverter<ConstantReferencePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConstantReference>::Convert(*this);
  }

  ConstantReference();
  ~ConstantReference();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConstantReferencePtr Clone() const;
  bool Equals(const ConstantReference& other) const;

  mojo::String identifier;
  mojo::String constant_key;
};


class EnumValueReference {
 public:
  using Data_ = internal::EnumValueReference_Data;

  static EnumValueReferencePtr New();

  template <typename U>
  static EnumValueReferencePtr From(const U& u) {
    return mojo::TypeConverter<EnumValueReferencePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, EnumValueReference>::Convert(*this);
  }

  EnumValueReference();
  ~EnumValueReference();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  EnumValueReferencePtr Clone() const;
  bool Equals(const EnumValueReference& other) const;

  mojo::String identifier;
  mojo::String enum_type_key;
  uint32_t enum_value_index;
};


class SourceFileInfo {
 public:
  using Data_ = internal::SourceFileInfo_Data;

  static SourceFileInfoPtr New();

  template <typename U>
  static SourceFileInfoPtr From(const U& u) {
    return mojo::TypeConverter<SourceFileInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SourceFileInfo>::Convert(*this);
  }

  SourceFileInfo();
  ~SourceFileInfo();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  SourceFileInfoPtr Clone() const;
  bool Equals(const SourceFileInfo& other) const;

  mojo::String file_name;
  uint32_t line_number;
  uint32_t column_number;
};



// --- Non-inlined structs ---
class ArrayType {
 public:
  using Data_ = internal::ArrayType_Data;

  static ArrayTypePtr New();

  template <typename U>
  static ArrayTypePtr From(const U& u) {
    return mojo::TypeConverter<ArrayTypePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ArrayType>::Convert(*this);
  }

  ArrayType();
  ~ArrayType();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ArrayTypePtr Clone() const;
  bool Equals(const ArrayType& other) const;

  bool nullable;
  int32_t fixed_length;
  TypePtr element_type;
};


class MapType {
 public:
  using Data_ = internal::MapType_Data;

  static MapTypePtr New();

  template <typename U>
  static MapTypePtr From(const U& u) {
    return mojo::TypeConverter<MapTypePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MapType>::Convert(*this);
  }

  MapType();
  ~MapType();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  MapTypePtr Clone() const;
  bool Equals(const MapType& other) const;

  bool nullable;
  TypePtr key_type;
  TypePtr value_type;
};


class StructField {
 public:
  using Data_ = internal::StructField_Data;

  static StructFieldPtr New();

  template <typename U>
  static StructFieldPtr From(const U& u) {
    return mojo::TypeConverter<StructFieldPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructField>::Convert(*this);
  }

  StructField();
  ~StructField();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  StructFieldPtr Clone() const;
  bool Equals(const StructField& other) const;

  DeclarationDataPtr decl_data;
  TypePtr type;
  DefaultFieldValuePtr default_value;
  uint32_t offset;
  int8_t bit;
  uint32_t min_version;
};


class MojomStruct {
 public:
  using Data_ = internal::MojomStruct_Data;

  static MojomStructPtr New();

  template <typename U>
  static MojomStructPtr From(const U& u) {
    return mojo::TypeConverter<MojomStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MojomStruct>::Convert(*this);
  }

  MojomStruct();
  ~MojomStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  MojomStructPtr Clone() const;
  bool Equals(const MojomStruct& other) const;

  DeclarationDataPtr decl_data;
  mojo::Array<StructFieldPtr> fields;
  mojo::Array<StructVersionPtr> version_info;
};


class UnionField {
 public:
  using Data_ = internal::UnionField_Data;

  static UnionFieldPtr New();

  template <typename U>
  static UnionFieldPtr From(const U& u) {
    return mojo::TypeConverter<UnionFieldPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UnionField>::Convert(*this);
  }

  UnionField();
  ~UnionField();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  UnionFieldPtr Clone() const;
  bool Equals(const UnionField& other) const;

  DeclarationDataPtr decl_data;
  TypePtr type;
  uint32_t tag;
};


class MojomUnion {
 public:
  using Data_ = internal::MojomUnion_Data;

  static MojomUnionPtr New();

  template <typename U>
  static MojomUnionPtr From(const U& u) {
    return mojo::TypeConverter<MojomUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MojomUnion>::Convert(*this);
  }

  MojomUnion();
  ~MojomUnion();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  MojomUnionPtr Clone() const;
  bool Equals(const MojomUnion& other) const;

  DeclarationDataPtr decl_data;
  mojo::Array<UnionFieldPtr> fields;
};


class EnumValue {
 public:
  using Data_ = internal::EnumValue_Data;

  static EnumValuePtr New();

  template <typename U>
  static EnumValuePtr From(const U& u) {
    return mojo::TypeConverter<EnumValuePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, EnumValue>::Convert(*this);
  }

  EnumValue();
  ~EnumValue();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  EnumValuePtr Clone() const;
  bool Equals(const EnumValue& other) const;

  DeclarationDataPtr decl_data;
  ValuePtr initializer_value;
  int32_t int_value;
};


class MojomEnum {
 public:
  using Data_ = internal::MojomEnum_Data;

  static MojomEnumPtr New();

  template <typename U>
  static MojomEnumPtr From(const U& u) {
    return mojo::TypeConverter<MojomEnumPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MojomEnum>::Convert(*this);
  }

  MojomEnum();
  ~MojomEnum();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  MojomEnumPtr Clone() const;
  bool Equals(const MojomEnum& other) const;

  DeclarationDataPtr decl_data;
  mojo::Array<EnumValuePtr> values;
};


class MojomMethod {
 public:
  using Data_ = internal::MojomMethod_Data;

  static MojomMethodPtr New();

  template <typename U>
  static MojomMethodPtr From(const U& u) {
    return mojo::TypeConverter<MojomMethodPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MojomMethod>::Convert(*this);
  }

  MojomMethod();
  ~MojomMethod();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  MojomMethodPtr Clone() const;
  bool Equals(const MojomMethod& other) const;

  DeclarationDataPtr decl_data;
  MojomStructPtr parameters;
  MojomStructPtr response_params;
  uint32_t ordinal;
  uint32_t min_version;
};


class MojomInterface {
 public:
  using Data_ = internal::MojomInterface_Data;

  static MojomInterfacePtr New();

  template <typename U>
  static MojomInterfacePtr From(const U& u) {
    return mojo::TypeConverter<MojomInterfacePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MojomInterface>::Convert(*this);
  }

  MojomInterface();
  ~MojomInterface();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  MojomInterfacePtr Clone() const;
  bool Equals(const MojomInterface& other) const;

  DeclarationDataPtr decl_data;
  mojo::String service_name;
  mojo::Map<uint32_t, MojomMethodPtr> methods;
  uint32_t current_version;
};


class DeclaredConstant {
 public:
  using Data_ = internal::DeclaredConstant_Data;

  static DeclaredConstantPtr New();

  template <typename U>
  static DeclaredConstantPtr From(const U& u) {
    return mojo::TypeConverter<DeclaredConstantPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DeclaredConstant>::Convert(*this);
  }

  DeclaredConstant();
  ~DeclaredConstant();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  DeclaredConstantPtr Clone() const;
  bool Equals(const DeclaredConstant& other) const;

  DeclarationDataPtr decl_data;
  TypePtr type;
  ValuePtr value;
  ValuePtr resolved_concrete_value;
};


class Attribute {
 public:
  using Data_ = internal::Attribute_Data;

  static AttributePtr New();

  template <typename U>
  static AttributePtr From(const U& u) {
    return mojo::TypeConverter<AttributePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Attribute>::Convert(*this);
  }

  Attribute();
  ~Attribute();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  AttributePtr Clone() const;
  bool Equals(const Attribute& other) const;

  mojo::String key;
  LiteralValuePtr value;
};


class DeclarationData {
 public:
  using Data_ = internal::DeclarationData_Data;

  static DeclarationDataPtr New();

  template <typename U>
  static DeclarationDataPtr From(const U& u) {
    return mojo::TypeConverter<DeclarationDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DeclarationData>::Convert(*this);
  }

  DeclarationData();
  ~DeclarationData();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  DeclarationDataPtr Clone() const;
  bool Equals(const DeclarationData& other) const;

  mojo::Array<AttributePtr> attributes;
  mojo::String short_name;
  mojo::String full_identifier;
  int32_t declared_ordinal;
  int32_t declaration_order;
  SourceFileInfoPtr source_file_info;
  ContainedDeclarationsPtr contained_declarations;
  mojo::String container_type_key;
};


class ContainedDeclarations {
 public:
  using Data_ = internal::ContainedDeclarations_Data;

  static ContainedDeclarationsPtr New();

  template <typename U>
  static ContainedDeclarationsPtr From(const U& u) {
    return mojo::TypeConverter<ContainedDeclarationsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ContainedDeclarations>::Convert(*this);
  }

  ContainedDeclarations();
  ~ContainedDeclarations();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ContainedDeclarationsPtr Clone() const;
  bool Equals(const ContainedDeclarations& other) const;

  mojo::Array<mojo::String> enums;
  mojo::Array<mojo::String> constants;
};


class RuntimeTypeInfo {
 public:
  using Data_ = internal::RuntimeTypeInfo_Data;

  static RuntimeTypeInfoPtr New();

  template <typename U>
  static RuntimeTypeInfoPtr From(const U& u) {
    return mojo::TypeConverter<RuntimeTypeInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, RuntimeTypeInfo>::Convert(*this);
  }

  RuntimeTypeInfo();
  ~RuntimeTypeInfo();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  RuntimeTypeInfoPtr Clone() const;
  bool Equals(const RuntimeTypeInfo& other) const;

  mojo::Map<mojo::String, mojo::String> services;
  mojo::Map<mojo::String, UserDefinedTypePtr> type_map;
};



// --- Struct serialization helpers ---
size_t GetSerializedSize_(const StringType& input);
mojo::internal::ValidationError Serialize_(
    StringType* input,
    mojo::internal::Buffer* buffer,
    internal::StringType_Data** output);
void Deserialize_(internal::StringType_Data* input,
                  StringType* output);

size_t GetSerializedSize_(const HandleType& input);
mojo::internal::ValidationError Serialize_(
    HandleType* input,
    mojo::internal::Buffer* buffer,
    internal::HandleType_Data** output);
void Deserialize_(internal::HandleType_Data* input,
                  HandleType* output);

size_t GetSerializedSize_(const ArrayType& input);
mojo::internal::ValidationError Serialize_(
    ArrayType* input,
    mojo::internal::Buffer* buffer,
    internal::ArrayType_Data** output);
void Deserialize_(internal::ArrayType_Data* input,
                  ArrayType* output);

size_t GetSerializedSize_(const MapType& input);
mojo::internal::ValidationError Serialize_(
    MapType* input,
    mojo::internal::Buffer* buffer,
    internal::MapType_Data** output);
void Deserialize_(internal::MapType_Data* input,
                  MapType* output);

size_t GetSerializedSize_(const TypeReference& input);
mojo::internal::ValidationError Serialize_(
    TypeReference* input,
    mojo::internal::Buffer* buffer,
    internal::TypeReference_Data** output);
void Deserialize_(internal::TypeReference_Data* input,
                  TypeReference* output);

size_t GetSerializedSize_(const StructField& input);
mojo::internal::ValidationError Serialize_(
    StructField* input,
    mojo::internal::Buffer* buffer,
    internal::StructField_Data** output);
void Deserialize_(internal::StructField_Data* input,
                  StructField* output);

size_t GetSerializedSize_(const DefaultKeyword& input);
mojo::internal::ValidationError Serialize_(
    DefaultKeyword* input,
    mojo::internal::Buffer* buffer,
    internal::DefaultKeyword_Data** output);
void Deserialize_(internal::DefaultKeyword_Data* input,
                  DefaultKeyword* output);

size_t GetSerializedSize_(const StructVersion& input);
mojo::internal::ValidationError Serialize_(
    StructVersion* input,
    mojo::internal::Buffer* buffer,
    internal::StructVersion_Data** output);
void Deserialize_(internal::StructVersion_Data* input,
                  StructVersion* output);

size_t GetSerializedSize_(const MojomStruct& input);
mojo::internal::ValidationError Serialize_(
    MojomStruct* input,
    mojo::internal::Buffer* buffer,
    internal::MojomStruct_Data** output);
void Deserialize_(internal::MojomStruct_Data* input,
                  MojomStruct* output);

size_t GetSerializedSize_(const UnionField& input);
mojo::internal::ValidationError Serialize_(
    UnionField* input,
    mojo::internal::Buffer* buffer,
    internal::UnionField_Data** output);
void Deserialize_(internal::UnionField_Data* input,
                  UnionField* output);

size_t GetSerializedSize_(const MojomUnion& input);
mojo::internal::ValidationError Serialize_(
    MojomUnion* input,
    mojo::internal::Buffer* buffer,
    internal::MojomUnion_Data** output);
void Deserialize_(internal::MojomUnion_Data* input,
                  MojomUnion* output);

size_t GetSerializedSize_(const EnumValue& input);
mojo::internal::ValidationError Serialize_(
    EnumValue* input,
    mojo::internal::Buffer* buffer,
    internal::EnumValue_Data** output);
void Deserialize_(internal::EnumValue_Data* input,
                  EnumValue* output);

size_t GetSerializedSize_(const MojomEnum& input);
mojo::internal::ValidationError Serialize_(
    MojomEnum* input,
    mojo::internal::Buffer* buffer,
    internal::MojomEnum_Data** output);
void Deserialize_(internal::MojomEnum_Data* input,
                  MojomEnum* output);

size_t GetSerializedSize_(const MojomMethod& input);
mojo::internal::ValidationError Serialize_(
    MojomMethod* input,
    mojo::internal::Buffer* buffer,
    internal::MojomMethod_Data** output);
void Deserialize_(internal::MojomMethod_Data* input,
                  MojomMethod* output);

size_t GetSerializedSize_(const MojomInterface& input);
mojo::internal::ValidationError Serialize_(
    MojomInterface* input,
    mojo::internal::Buffer* buffer,
    internal::MojomInterface_Data** output);
void Deserialize_(internal::MojomInterface_Data* input,
                  MojomInterface* output);

size_t GetSerializedSize_(const ConstantReference& input);
mojo::internal::ValidationError Serialize_(
    ConstantReference* input,
    mojo::internal::Buffer* buffer,
    internal::ConstantReference_Data** output);
void Deserialize_(internal::ConstantReference_Data* input,
                  ConstantReference* output);

size_t GetSerializedSize_(const EnumValueReference& input);
mojo::internal::ValidationError Serialize_(
    EnumValueReference* input,
    mojo::internal::Buffer* buffer,
    internal::EnumValueReference_Data** output);
void Deserialize_(internal::EnumValueReference_Data* input,
                  EnumValueReference* output);

size_t GetSerializedSize_(const DeclaredConstant& input);
mojo::internal::ValidationError Serialize_(
    DeclaredConstant* input,
    mojo::internal::Buffer* buffer,
    internal::DeclaredConstant_Data** output);
void Deserialize_(internal::DeclaredConstant_Data* input,
                  DeclaredConstant* output);

size_t GetSerializedSize_(const Attribute& input);
mojo::internal::ValidationError Serialize_(
    Attribute* input,
    mojo::internal::Buffer* buffer,
    internal::Attribute_Data** output);
void Deserialize_(internal::Attribute_Data* input,
                  Attribute* output);

size_t GetSerializedSize_(const DeclarationData& input);
mojo::internal::ValidationError Serialize_(
    DeclarationData* input,
    mojo::internal::Buffer* buffer,
    internal::DeclarationData_Data** output);
void Deserialize_(internal::DeclarationData_Data* input,
                  DeclarationData* output);

size_t GetSerializedSize_(const SourceFileInfo& input);
mojo::internal::ValidationError Serialize_(
    SourceFileInfo* input,
    mojo::internal::Buffer* buffer,
    internal::SourceFileInfo_Data** output);
void Deserialize_(internal::SourceFileInfo_Data* input,
                  SourceFileInfo* output);

size_t GetSerializedSize_(const ContainedDeclarations& input);
mojo::internal::ValidationError Serialize_(
    ContainedDeclarations* input,
    mojo::internal::Buffer* buffer,
    internal::ContainedDeclarations_Data** output);
void Deserialize_(internal::ContainedDeclarations_Data* input,
                  ContainedDeclarations* output);

size_t GetSerializedSize_(const RuntimeTypeInfo& input);
mojo::internal::ValidationError Serialize_(
    RuntimeTypeInfo* input,
    mojo::internal::Buffer* buffer,
    internal::RuntimeTypeInfo_Data** output);
void Deserialize_(internal::RuntimeTypeInfo_Data* input,
                  RuntimeTypeInfo* output);


// --- Union serialization helpers ---
size_t GetSerializedSize_(const TypePtr& input);
mojo::internal::ValidationError SerializeUnion_(
    Type* input,
    mojo::internal::Buffer* buffer,
    internal::Type_Data** output);
void Deserialize_(internal::Type_Data* input,
                  Type* output);

size_t GetSerializedSize_(const UserDefinedTypePtr& input);
mojo::internal::ValidationError SerializeUnion_(
    UserDefinedType* input,
    mojo::internal::Buffer* buffer,
    internal::UserDefinedType_Data** output);
void Deserialize_(internal::UserDefinedType_Data* input,
                  UserDefinedType* output);

size_t GetSerializedSize_(const DefaultFieldValuePtr& input);
mojo::internal::ValidationError SerializeUnion_(
    DefaultFieldValue* input,
    mojo::internal::Buffer* buffer,
    internal::DefaultFieldValue_Data** output);
void Deserialize_(internal::DefaultFieldValue_Data* input,
                  DefaultFieldValue* output);

size_t GetSerializedSize_(const ValuePtr& input);
mojo::internal::ValidationError SerializeUnion_(
    Value* input,
    mojo::internal::Buffer* buffer,
    internal::Value_Data** output);
void Deserialize_(internal::Value_Data* input,
                  Value* output);

size_t GetSerializedSize_(const LiteralValuePtr& input);
mojo::internal::ValidationError SerializeUnion_(
    LiteralValue* input,
    mojo::internal::Buffer* buffer,
    internal::LiteralValue_Data** output);
void Deserialize_(internal::LiteralValue_Data* input,
                  LiteralValue* output);


// --- Request and response parameter structs for Interface methods ---
}  // namespace types
}  // namespace bindings
}  // namespace mojo

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_MOJOM_TYPES_MOJOM_COMMON_H_
