// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/public/interfaces/bindings/tests/test_included_unions.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace mojo {
namespace test {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// --- Union definitions ---
// static
IncludedUnion_Data* IncludedUnion_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(IncludedUnion_Data))) IncludedUnion_Data();
}


// static
mojo::internal::ValidationError IncludedUnion_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(IncludedUnion_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const IncludedUnion_Data* object = static_cast<const IncludedUnion_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case IncludedUnion_Tag::A: {

        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void IncludedUnion_Data::set_null() {
  size = 0U;
  tag = static_cast<IncludedUnion_Tag>(0);
  data.unknown = 0U;
}

IncludedUnion_Data::IncludedUnion_Data() {
}

void IncludedUnion_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case IncludedUnion_Tag::A: {
      return;
    }
    case IncludedUnion_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void IncludedUnion_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case IncludedUnion_Tag::A: {
      return;
    }
    default:
      return;
  }
}


// --- Definitions of the data structs for interface methods ---

}  // namespace internal

// --- Request and response validator definitions for interfaces --- 

// --- Enums ---

// Base interface definitions (Name_, Version_, Constants, Enums)

// Struct Constants

// --- Struct builder definitions ---

// --- Union builder definitions ---// static
IncludedUnionPtr IncludedUnion::New() {
  IncludedUnionPtr rv;
  mojo::internal::StructHelper<IncludedUnion>::Initialize(&rv);
  return rv;
}

IncludedUnion::IncludedUnion() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

IncludedUnion::~IncludedUnion() {
  DestroyActive();
}


IncludedUnionPtr IncludedUnion::Clone() const {
  IncludedUnionPtr rv(New());
  switch (tag_) {

    case Tag::A:

      rv->set_a(data_.a);
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool IncludedUnion::Equals(const IncludedUnion& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::A:

      return mojo::internal::ValueTraits<int8_t>::Equals(data_.a, other.data_.a);
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool IncludedUnion::is_a() const {
  return tag_ == Tag::A;
}

int8_t IncludedUnion::get_a() const {
  MOJO_DCHECK(tag_ == Tag::A);

  return data_.a;
}

void IncludedUnion::set_a(int8_t a) {
  SwitchActive(Tag::A);

  data_.a = a;
}

bool IncludedUnion::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void IncludedUnion::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void IncludedUnion::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::A:

      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void IncludedUnion::DestroyActive() {
  switch (tag_) {

    case Tag::A:

      break;
    default:
      break;
  }
}


// --- Struct Serialization Helpers ---

// --- Union Serialization Helpers ---

size_t GetSerializedSize_(const IncludedUnionPtr& input) {
   size_t size = sizeof(internal::IncludedUnion_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<IncludedUnion> input_acc(input.get());
  switch (input->which()) {


    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    IncludedUnion* input,
    mojo::internal::Buffer* buf,
    internal::IncludedUnion_Data** output) {
  internal::IncludedUnion_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<IncludedUnion> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case IncludedUnion::Tag::A: {

        result->data.f_a = input_acc.data()->a;
        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::IncludedUnion_Data* input,
                  IncludedUnion* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<IncludedUnion> result_acc(output);
    switch (input->tag) {

      case IncludedUnion::Tag::A: {

        output->set_a(input->data.f_a);
        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing IncludedUnion with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


// --- Structs for interface method parameters ---
}  // namespace test
}  // namespace mojo
