// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/services/gpu/interfaces/command_buffer.mojom
//

package command_buffer

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	fmt "fmt"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
	gpu_capabilities "mojo/services/gpu/interfaces/gpu_capabilities"
)


type CommandBufferSyncClient interface {
	DidInitialize(inSuccess bool, inCapabilities gpu_capabilities.GpuCapabilities) (err error)
	DidMakeProgress(inState CommandBufferState) (err error)
}




type CommandBufferSyncClient_Request bindings.InterfaceRequest



type CommandBufferSyncClient_Pointer bindings.InterfacePointer


type CommandBufferSyncClient_ServiceFactory struct{
	Delegate CommandBufferSyncClient_Factory
}

type CommandBufferSyncClient_Factory interface {
	Create(request CommandBufferSyncClient_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *CommandBufferSyncClient_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &CommandBufferSyncClient_ServiceDescription{}
}

func (f *CommandBufferSyncClient_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := CommandBufferSyncClient_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForCommandBufferSyncClient creates a message pipe for use with the
// CommandBufferSyncClient interface with a CommandBufferSyncClient_Request on one end and a CommandBufferSyncClient_Pointer on the other.
func CreateMessagePipeForCommandBufferSyncClient() (CommandBufferSyncClient_Request, CommandBufferSyncClient_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return CommandBufferSyncClient_Request(r), CommandBufferSyncClient_Pointer(p)
}

const commandBufferSyncClient_DidInitialize_Name uint32 = 0
const commandBufferSyncClient_DidMakeProgress_Name uint32 = 1

type CommandBufferSyncClient_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewCommandBufferSyncClientProxy(p CommandBufferSyncClient_Pointer, waiter bindings.AsyncWaiter) *CommandBufferSyncClient_Proxy {
	return &CommandBufferSyncClient_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *CommandBufferSyncClient_Proxy) Close_Proxy() {
	p.router.Close()
}

type commandBufferSyncClient_DidInitialize_Params struct {
	inSuccess bool
	inCapabilities gpu_capabilities.GpuCapabilities
}


func (s *commandBufferSyncClient_DidInitialize_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteBool(s.inSuccess); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inCapabilities.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBufferSyncClient_DidInitialize_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *commandBufferSyncClient_DidInitialize_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBufferSyncClient_DidInitialize_Params_Versions), func(i int) bool {
		return commandBufferSyncClient_DidInitialize_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBufferSyncClient_DidInitialize_Params_Versions) {
		if commandBufferSyncClient_DidInitialize_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBufferSyncClient_DidInitialize_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.inSuccess = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inCapabilities.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CommandBufferSyncClient_Proxy) DidInitialize(inSuccess bool, inCapabilities gpu_capabilities.GpuCapabilities) (err error) {
	payload := &commandBufferSyncClient_DidInitialize_Params{
		inSuccess,
		inCapabilities,
	}
	header := bindings.MessageHeader{
		Type: commandBufferSyncClient_DidInitialize_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type commandBufferSyncClient_DidMakeProgress_Params struct {
	inState CommandBufferState
}


func (s *commandBufferSyncClient_DidMakeProgress_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inState.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBufferSyncClient_DidMakeProgress_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *commandBufferSyncClient_DidMakeProgress_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBufferSyncClient_DidMakeProgress_Params_Versions), func(i int) bool {
		return commandBufferSyncClient_DidMakeProgress_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBufferSyncClient_DidMakeProgress_Params_Versions) {
		if commandBufferSyncClient_DidMakeProgress_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBufferSyncClient_DidMakeProgress_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inState.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CommandBufferSyncClient_Proxy) DidMakeProgress(inState CommandBufferState) (err error) {
	payload := &commandBufferSyncClient_DidMakeProgress_Params{
		inState,
	}
	header := bindings.MessageHeader{
		Type: commandBufferSyncClient_DidMakeProgress_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type commandBufferSyncClient_Stub struct {
	connector *bindings.Connector
	impl CommandBufferSyncClient
}

func NewCommandBufferSyncClientStub(r CommandBufferSyncClient_Request, impl CommandBufferSyncClient, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &commandBufferSyncClient_Stub{connector, impl})
}


func (f *CommandBufferSyncClient_Request) ServiceDescription() service_describer.ServiceDescription {
	return &CommandBufferSyncClient_ServiceDescription{}
}


type CommandBufferSyncClient_ServiceDescription struct{}

func (sd *CommandBufferSyncClient_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *CommandBufferSyncClient_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *CommandBufferSyncClient_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*CommandBufferSyncClient_ServiceDescription)(nil)


func (s *commandBufferSyncClient_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case commandBufferSyncClient_DidInitialize_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request commandBufferSyncClient_DidInitialize_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.DidInitialize(request.inSuccess, request.inCapabilities)
		if err != nil {
			return
		}
	case commandBufferSyncClient_DidMakeProgress_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request commandBufferSyncClient_DidMakeProgress_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.DidMakeProgress(request.inState)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type CommandBufferSyncPointClient interface {
	DidInsertSyncPoint(inSyncPoint uint32) (err error)
}




type CommandBufferSyncPointClient_Request bindings.InterfaceRequest



type CommandBufferSyncPointClient_Pointer bindings.InterfacePointer


type CommandBufferSyncPointClient_ServiceFactory struct{
	Delegate CommandBufferSyncPointClient_Factory
}

type CommandBufferSyncPointClient_Factory interface {
	Create(request CommandBufferSyncPointClient_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *CommandBufferSyncPointClient_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &CommandBufferSyncPointClient_ServiceDescription{}
}

func (f *CommandBufferSyncPointClient_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := CommandBufferSyncPointClient_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForCommandBufferSyncPointClient creates a message pipe for use with the
// CommandBufferSyncPointClient interface with a CommandBufferSyncPointClient_Request on one end and a CommandBufferSyncPointClient_Pointer on the other.
func CreateMessagePipeForCommandBufferSyncPointClient() (CommandBufferSyncPointClient_Request, CommandBufferSyncPointClient_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return CommandBufferSyncPointClient_Request(r), CommandBufferSyncPointClient_Pointer(p)
}

const commandBufferSyncPointClient_DidInsertSyncPoint_Name uint32 = 0

type CommandBufferSyncPointClient_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewCommandBufferSyncPointClientProxy(p CommandBufferSyncPointClient_Pointer, waiter bindings.AsyncWaiter) *CommandBufferSyncPointClient_Proxy {
	return &CommandBufferSyncPointClient_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *CommandBufferSyncPointClient_Proxy) Close_Proxy() {
	p.router.Close()
}

type commandBufferSyncPointClient_DidInsertSyncPoint_Params struct {
	inSyncPoint uint32
}


func (s *commandBufferSyncPointClient_DidInsertSyncPoint_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteUint32(s.inSyncPoint); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBufferSyncPointClient_DidInsertSyncPoint_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *commandBufferSyncPointClient_DidInsertSyncPoint_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBufferSyncPointClient_DidInsertSyncPoint_Params_Versions), func(i int) bool {
		return commandBufferSyncPointClient_DidInsertSyncPoint_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBufferSyncPointClient_DidInsertSyncPoint_Params_Versions) {
		if commandBufferSyncPointClient_DidInsertSyncPoint_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBufferSyncPointClient_DidInsertSyncPoint_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.inSyncPoint = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CommandBufferSyncPointClient_Proxy) DidInsertSyncPoint(inSyncPoint uint32) (err error) {
	payload := &commandBufferSyncPointClient_DidInsertSyncPoint_Params{
		inSyncPoint,
	}
	header := bindings.MessageHeader{
		Type: commandBufferSyncPointClient_DidInsertSyncPoint_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type commandBufferSyncPointClient_Stub struct {
	connector *bindings.Connector
	impl CommandBufferSyncPointClient
}

func NewCommandBufferSyncPointClientStub(r CommandBufferSyncPointClient_Request, impl CommandBufferSyncPointClient, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &commandBufferSyncPointClient_Stub{connector, impl})
}


func (f *CommandBufferSyncPointClient_Request) ServiceDescription() service_describer.ServiceDescription {
	return &CommandBufferSyncPointClient_ServiceDescription{}
}


type CommandBufferSyncPointClient_ServiceDescription struct{}

func (sd *CommandBufferSyncPointClient_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *CommandBufferSyncPointClient_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *CommandBufferSyncPointClient_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*CommandBufferSyncPointClient_ServiceDescription)(nil)


func (s *commandBufferSyncPointClient_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case commandBufferSyncPointClient_DidInsertSyncPoint_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request commandBufferSyncPointClient_DidInsertSyncPoint_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.DidInsertSyncPoint(request.inSyncPoint)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type CommandBufferLostContextObserver interface {
	DidLoseContext(inContextLostReason int32) (err error)
}




type CommandBufferLostContextObserver_Request bindings.InterfaceRequest



type CommandBufferLostContextObserver_Pointer bindings.InterfacePointer


type CommandBufferLostContextObserver_ServiceFactory struct{
	Delegate CommandBufferLostContextObserver_Factory
}

type CommandBufferLostContextObserver_Factory interface {
	Create(request CommandBufferLostContextObserver_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *CommandBufferLostContextObserver_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &CommandBufferLostContextObserver_ServiceDescription{}
}

func (f *CommandBufferLostContextObserver_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := CommandBufferLostContextObserver_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForCommandBufferLostContextObserver creates a message pipe for use with the
// CommandBufferLostContextObserver interface with a CommandBufferLostContextObserver_Request on one end and a CommandBufferLostContextObserver_Pointer on the other.
func CreateMessagePipeForCommandBufferLostContextObserver() (CommandBufferLostContextObserver_Request, CommandBufferLostContextObserver_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return CommandBufferLostContextObserver_Request(r), CommandBufferLostContextObserver_Pointer(p)
}

const commandBufferLostContextObserver_DidLoseContext_Name uint32 = 0

type CommandBufferLostContextObserver_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewCommandBufferLostContextObserverProxy(p CommandBufferLostContextObserver_Pointer, waiter bindings.AsyncWaiter) *CommandBufferLostContextObserver_Proxy {
	return &CommandBufferLostContextObserver_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *CommandBufferLostContextObserver_Proxy) Close_Proxy() {
	p.router.Close()
}

type commandBufferLostContextObserver_DidLoseContext_Params struct {
	inContextLostReason int32
}


func (s *commandBufferLostContextObserver_DidLoseContext_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.inContextLostReason); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBufferLostContextObserver_DidLoseContext_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *commandBufferLostContextObserver_DidLoseContext_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBufferLostContextObserver_DidLoseContext_Params_Versions), func(i int) bool {
		return commandBufferLostContextObserver_DidLoseContext_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBufferLostContextObserver_DidLoseContext_Params_Versions) {
		if commandBufferLostContextObserver_DidLoseContext_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBufferLostContextObserver_DidLoseContext_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inContextLostReason = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CommandBufferLostContextObserver_Proxy) DidLoseContext(inContextLostReason int32) (err error) {
	payload := &commandBufferLostContextObserver_DidLoseContext_Params{
		inContextLostReason,
	}
	header := bindings.MessageHeader{
		Type: commandBufferLostContextObserver_DidLoseContext_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type commandBufferLostContextObserver_Stub struct {
	connector *bindings.Connector
	impl CommandBufferLostContextObserver
}

func NewCommandBufferLostContextObserverStub(r CommandBufferLostContextObserver_Request, impl CommandBufferLostContextObserver, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &commandBufferLostContextObserver_Stub{connector, impl})
}


func (f *CommandBufferLostContextObserver_Request) ServiceDescription() service_describer.ServiceDescription {
	return &CommandBufferLostContextObserver_ServiceDescription{}
}


type CommandBufferLostContextObserver_ServiceDescription struct{}

func (sd *CommandBufferLostContextObserver_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *CommandBufferLostContextObserver_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *CommandBufferLostContextObserver_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*CommandBufferLostContextObserver_ServiceDescription)(nil)


func (s *commandBufferLostContextObserver_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case commandBufferLostContextObserver_DidLoseContext_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request commandBufferLostContextObserver_DidLoseContext_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.DidLoseContext(request.inContextLostReason)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type CommandBuffer interface {
	Initialize(inSyncClient CommandBufferSyncClient_Pointer, inSyncPointClient CommandBufferSyncPointClient_Pointer, inLostObserver CommandBufferLostContextObserver_Pointer, inSharedState system.SharedBufferHandle) (err error)
	SetGetBuffer(inBuffer int32) (err error)
	Flush(inPutOffset int32) (err error)
	MakeProgress(inLastGetOffset int32) (err error)
	RegisterTransferBuffer(inId int32, inTransferBuffer system.SharedBufferHandle, inSize uint32) (err error)
	DestroyTransferBuffer(inId int32) (err error)
	InsertSyncPoint(inRetire bool) (err error)
	RetireSyncPoint(inSyncPoint uint32) (err error)
	Echo() (err error)
}




type CommandBuffer_Request bindings.InterfaceRequest



type CommandBuffer_Pointer bindings.InterfacePointer


type CommandBuffer_ServiceFactory struct{
	Delegate CommandBuffer_Factory
}

type CommandBuffer_Factory interface {
	Create(request CommandBuffer_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *CommandBuffer_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &CommandBuffer_ServiceDescription{}
}

func (f *CommandBuffer_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := CommandBuffer_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForCommandBuffer creates a message pipe for use with the
// CommandBuffer interface with a CommandBuffer_Request on one end and a CommandBuffer_Pointer on the other.
func CreateMessagePipeForCommandBuffer() (CommandBuffer_Request, CommandBuffer_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return CommandBuffer_Request(r), CommandBuffer_Pointer(p)
}

const commandBuffer_Initialize_Name uint32 = 0
const commandBuffer_SetGetBuffer_Name uint32 = 1
const commandBuffer_Flush_Name uint32 = 2
const commandBuffer_MakeProgress_Name uint32 = 3
const commandBuffer_RegisterTransferBuffer_Name uint32 = 4
const commandBuffer_DestroyTransferBuffer_Name uint32 = 5
const commandBuffer_InsertSyncPoint_Name uint32 = 6
const commandBuffer_RetireSyncPoint_Name uint32 = 7
const commandBuffer_Echo_Name uint32 = 8

type CommandBuffer_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewCommandBufferProxy(p CommandBuffer_Pointer, waiter bindings.AsyncWaiter) *CommandBuffer_Proxy {
	return &CommandBuffer_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *CommandBuffer_Proxy) Close_Proxy() {
	p.router.Close()
}

type commandBuffer_Initialize_Params struct {
	inSyncClient CommandBufferSyncClient_Pointer
	inSyncPointClient CommandBufferSyncPointClient_Pointer
	inLostObserver CommandBufferLostContextObserver_Pointer
	inSharedState system.SharedBufferHandle
}


func (s *commandBuffer_Initialize_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WriteInterface(s.inSyncClient.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.WriteInterface(s.inSyncPointClient.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.WriteInterface(s.inLostObserver.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.WriteHandle(s.inSharedState); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBuffer_Initialize_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *commandBuffer_Initialize_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBuffer_Initialize_Params_Versions), func(i int) bool {
		return commandBuffer_Initialize_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBuffer_Initialize_Params_Versions) {
		if commandBuffer_Initialize_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBuffer_Initialize_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadInterface()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inSyncClient = CommandBufferSyncClient_Pointer{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadInterface()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inSyncPointClient = CommandBufferSyncPointClient_Pointer{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadInterface()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inLostObserver = CommandBufferLostContextObserver_Pointer{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadSharedBufferHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.inSharedState = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CommandBuffer_Proxy) Initialize(inSyncClient CommandBufferSyncClient_Pointer, inSyncPointClient CommandBufferSyncPointClient_Pointer, inLostObserver CommandBufferLostContextObserver_Pointer, inSharedState system.SharedBufferHandle) (err error) {
	payload := &commandBuffer_Initialize_Params{
		inSyncClient,
		inSyncPointClient,
		inLostObserver,
		inSharedState,
	}
	header := bindings.MessageHeader{
		Type: commandBuffer_Initialize_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type commandBuffer_SetGetBuffer_Params struct {
	inBuffer int32
}


func (s *commandBuffer_SetGetBuffer_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.inBuffer); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBuffer_SetGetBuffer_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *commandBuffer_SetGetBuffer_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBuffer_SetGetBuffer_Params_Versions), func(i int) bool {
		return commandBuffer_SetGetBuffer_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBuffer_SetGetBuffer_Params_Versions) {
		if commandBuffer_SetGetBuffer_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBuffer_SetGetBuffer_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inBuffer = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CommandBuffer_Proxy) SetGetBuffer(inBuffer int32) (err error) {
	payload := &commandBuffer_SetGetBuffer_Params{
		inBuffer,
	}
	header := bindings.MessageHeader{
		Type: commandBuffer_SetGetBuffer_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type commandBuffer_Flush_Params struct {
	inPutOffset int32
}


func (s *commandBuffer_Flush_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.inPutOffset); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBuffer_Flush_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *commandBuffer_Flush_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBuffer_Flush_Params_Versions), func(i int) bool {
		return commandBuffer_Flush_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBuffer_Flush_Params_Versions) {
		if commandBuffer_Flush_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBuffer_Flush_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inPutOffset = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CommandBuffer_Proxy) Flush(inPutOffset int32) (err error) {
	payload := &commandBuffer_Flush_Params{
		inPutOffset,
	}
	header := bindings.MessageHeader{
		Type: commandBuffer_Flush_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type commandBuffer_MakeProgress_Params struct {
	inLastGetOffset int32
}


func (s *commandBuffer_MakeProgress_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.inLastGetOffset); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBuffer_MakeProgress_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *commandBuffer_MakeProgress_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBuffer_MakeProgress_Params_Versions), func(i int) bool {
		return commandBuffer_MakeProgress_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBuffer_MakeProgress_Params_Versions) {
		if commandBuffer_MakeProgress_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBuffer_MakeProgress_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inLastGetOffset = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CommandBuffer_Proxy) MakeProgress(inLastGetOffset int32) (err error) {
	payload := &commandBuffer_MakeProgress_Params{
		inLastGetOffset,
	}
	header := bindings.MessageHeader{
		Type: commandBuffer_MakeProgress_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type commandBuffer_RegisterTransferBuffer_Params struct {
	inId int32
	inTransferBuffer system.SharedBufferHandle
	inSize uint32
}


func (s *commandBuffer_RegisterTransferBuffer_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInt32(s.inId); err != nil {
		return err
	}
	if err := encoder.WriteHandle(s.inTransferBuffer); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.inSize); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBuffer_RegisterTransferBuffer_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *commandBuffer_RegisterTransferBuffer_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBuffer_RegisterTransferBuffer_Params_Versions), func(i int) bool {
		return commandBuffer_RegisterTransferBuffer_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBuffer_RegisterTransferBuffer_Params_Versions) {
		if commandBuffer_RegisterTransferBuffer_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBuffer_RegisterTransferBuffer_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inId = value0
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadSharedBufferHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.inTransferBuffer = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.inSize = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CommandBuffer_Proxy) RegisterTransferBuffer(inId int32, inTransferBuffer system.SharedBufferHandle, inSize uint32) (err error) {
	payload := &commandBuffer_RegisterTransferBuffer_Params{
		inId,
		inTransferBuffer,
		inSize,
	}
	header := bindings.MessageHeader{
		Type: commandBuffer_RegisterTransferBuffer_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type commandBuffer_DestroyTransferBuffer_Params struct {
	inId int32
}


func (s *commandBuffer_DestroyTransferBuffer_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.inId); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBuffer_DestroyTransferBuffer_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *commandBuffer_DestroyTransferBuffer_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBuffer_DestroyTransferBuffer_Params_Versions), func(i int) bool {
		return commandBuffer_DestroyTransferBuffer_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBuffer_DestroyTransferBuffer_Params_Versions) {
		if commandBuffer_DestroyTransferBuffer_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBuffer_DestroyTransferBuffer_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inId = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CommandBuffer_Proxy) DestroyTransferBuffer(inId int32) (err error) {
	payload := &commandBuffer_DestroyTransferBuffer_Params{
		inId,
	}
	header := bindings.MessageHeader{
		Type: commandBuffer_DestroyTransferBuffer_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type commandBuffer_InsertSyncPoint_Params struct {
	inRetire bool
}


func (s *commandBuffer_InsertSyncPoint_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteBool(s.inRetire); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBuffer_InsertSyncPoint_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *commandBuffer_InsertSyncPoint_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBuffer_InsertSyncPoint_Params_Versions), func(i int) bool {
		return commandBuffer_InsertSyncPoint_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBuffer_InsertSyncPoint_Params_Versions) {
		if commandBuffer_InsertSyncPoint_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBuffer_InsertSyncPoint_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.inRetire = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CommandBuffer_Proxy) InsertSyncPoint(inRetire bool) (err error) {
	payload := &commandBuffer_InsertSyncPoint_Params{
		inRetire,
	}
	header := bindings.MessageHeader{
		Type: commandBuffer_InsertSyncPoint_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type commandBuffer_RetireSyncPoint_Params struct {
	inSyncPoint uint32
}


func (s *commandBuffer_RetireSyncPoint_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteUint32(s.inSyncPoint); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBuffer_RetireSyncPoint_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *commandBuffer_RetireSyncPoint_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBuffer_RetireSyncPoint_Params_Versions), func(i int) bool {
		return commandBuffer_RetireSyncPoint_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBuffer_RetireSyncPoint_Params_Versions) {
		if commandBuffer_RetireSyncPoint_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBuffer_RetireSyncPoint_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.inSyncPoint = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CommandBuffer_Proxy) RetireSyncPoint(inSyncPoint uint32) (err error) {
	payload := &commandBuffer_RetireSyncPoint_Params{
		inSyncPoint,
	}
	header := bindings.MessageHeader{
		Type: commandBuffer_RetireSyncPoint_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type commandBuffer_Echo_Params struct {
}


func (s *commandBuffer_Echo_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBuffer_Echo_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *commandBuffer_Echo_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBuffer_Echo_Params_Versions), func(i int) bool {
		return commandBuffer_Echo_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBuffer_Echo_Params_Versions) {
		if commandBuffer_Echo_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBuffer_Echo_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type commandBuffer_Echo_ResponseParams struct {
}


func (s *commandBuffer_Echo_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBuffer_Echo_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *commandBuffer_Echo_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBuffer_Echo_ResponseParams_Versions), func(i int) bool {
		return commandBuffer_Echo_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBuffer_Echo_ResponseParams_Versions) {
		if commandBuffer_Echo_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBuffer_Echo_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CommandBuffer_Proxy) Echo() (err error) {
	payload := &commandBuffer_Echo_Params{
	}
	header := bindings.MessageHeader{
		Type: commandBuffer_Echo_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, commandBuffer_Echo_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response commandBuffer_Echo_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type commandBuffer_Stub struct {
	connector *bindings.Connector
	impl CommandBuffer
}

func NewCommandBufferStub(r CommandBuffer_Request, impl CommandBuffer, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &commandBuffer_Stub{connector, impl})
}


func (f *CommandBuffer_Request) ServiceDescription() service_describer.ServiceDescription {
	return &CommandBuffer_ServiceDescription{}
}


type CommandBuffer_ServiceDescription struct{}

func (sd *CommandBuffer_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *CommandBuffer_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *CommandBuffer_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*CommandBuffer_ServiceDescription)(nil)


func (s *commandBuffer_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case commandBuffer_Initialize_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request commandBuffer_Initialize_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Initialize(request.inSyncClient, request.inSyncPointClient, request.inLostObserver, request.inSharedState)
		if err != nil {
			return
		}
	case commandBuffer_SetGetBuffer_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request commandBuffer_SetGetBuffer_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SetGetBuffer(request.inBuffer)
		if err != nil {
			return
		}
	case commandBuffer_Flush_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request commandBuffer_Flush_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Flush(request.inPutOffset)
		if err != nil {
			return
		}
	case commandBuffer_MakeProgress_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request commandBuffer_MakeProgress_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.MakeProgress(request.inLastGetOffset)
		if err != nil {
			return
		}
	case commandBuffer_RegisterTransferBuffer_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request commandBuffer_RegisterTransferBuffer_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.RegisterTransferBuffer(request.inId, request.inTransferBuffer, request.inSize)
		if err != nil {
			return
		}
	case commandBuffer_DestroyTransferBuffer_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request commandBuffer_DestroyTransferBuffer_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.DestroyTransferBuffer(request.inId)
		if err != nil {
			return
		}
	case commandBuffer_InsertSyncPoint_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request commandBuffer_InsertSyncPoint_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.InsertSyncPoint(request.inRetire)
		if err != nil {
			return
		}
	case commandBuffer_RetireSyncPoint_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request commandBuffer_RetireSyncPoint_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.RetireSyncPoint(request.inSyncPoint)
		if err != nil {
			return
		}
	case commandBuffer_Echo_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request commandBuffer_Echo_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response commandBuffer_Echo_ResponseParams
		err = s.impl.Echo()
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: commandBuffer_Echo_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type CommandBufferState struct {
	NumEntries int32
	GetOffset int32
	PutOffset int32
	Token int32
	Error int32
	ContextLostReason int32
	Generation uint32
}


func (s *CommandBufferState) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WriteInt32(s.NumEntries); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.GetOffset); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.PutOffset); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.Token); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.Error); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.ContextLostReason); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.Generation); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var commandBufferState_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *CommandBufferState) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(commandBufferState_Versions), func(i int) bool {
		return commandBufferState_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(commandBufferState_Versions) {
		if commandBufferState_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := commandBufferState_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.NumEntries = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.GetOffset = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.PutOffset = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Token = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Error = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.ContextLostReason = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.Generation = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

