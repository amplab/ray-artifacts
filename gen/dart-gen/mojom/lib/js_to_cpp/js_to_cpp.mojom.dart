// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library js_to_cpp_mojom;
import 'dart:async';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;



class EchoArgs extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(104, 0)
  ];
  int si64 = 0;
  int si32 = 0;
  int si16 = 0;
  int si8 = 0;
  int ui8 = 0;
  int ui64 = 0;
  int ui32 = 0;
  int ui16 = 0;
  double floatVal = 0.0;
  double floatInf = 0.0;
  double floatNan = 0.0;
  core.MojoMessagePipeEndpoint messageHandle = null;
  double doubleVal = 0.0;
  double doubleInf = 0.0;
  double doubleNan = 0.0;
  String name = null;
  List<String> stringArray = null;
  core.MojoDataPipeConsumer dataHandle = null;

  EchoArgs() : super(kVersions.last.size);

  EchoArgs.init(
    int this.si64, 
    int this.si32, 
    int this.si16, 
    int this.si8, 
    int this.ui8, 
    int this.ui64, 
    int this.ui32, 
    int this.ui16, 
    double this.floatVal, 
    double this.floatInf, 
    double this.floatNan, 
    core.MojoMessagePipeEndpoint this.messageHandle, 
    double this.doubleVal, 
    double this.doubleInf, 
    double this.doubleNan, 
    String this.name, 
    List<String> this.stringArray, 
    core.MojoDataPipeConsumer this.dataHandle
  ) : super(kVersions.last.size);

  static EchoArgs deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static EchoArgs decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    EchoArgs result = new EchoArgs();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.si64 = decoder0.decodeInt64(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.si32 = decoder0.decodeInt32(16);
    }
    if (mainDataHeader.version >= 0) {
      
      result.si16 = decoder0.decodeInt16(20);
    }
    if (mainDataHeader.version >= 0) {
      
      result.si8 = decoder0.decodeInt8(22);
    }
    if (mainDataHeader.version >= 0) {
      
      result.ui8 = decoder0.decodeUint8(23);
    }
    if (mainDataHeader.version >= 0) {
      
      result.ui64 = decoder0.decodeUint64(24);
    }
    if (mainDataHeader.version >= 0) {
      
      result.ui32 = decoder0.decodeUint32(32);
    }
    if (mainDataHeader.version >= 0) {
      
      result.ui16 = decoder0.decodeUint16(36);
    }
    if (mainDataHeader.version >= 0) {
      
      result.floatVal = decoder0.decodeFloat(40);
    }
    if (mainDataHeader.version >= 0) {
      
      result.floatInf = decoder0.decodeFloat(44);
    }
    if (mainDataHeader.version >= 0) {
      
      result.floatNan = decoder0.decodeFloat(48);
    }
    if (mainDataHeader.version >= 0) {
      
      result.messageHandle = decoder0.decodeMessagePipeHandle(52, true);
    }
    if (mainDataHeader.version >= 0) {
      
      result.doubleVal = decoder0.decodeDouble(56);
    }
    if (mainDataHeader.version >= 0) {
      
      result.doubleInf = decoder0.decodeDouble(64);
    }
    if (mainDataHeader.version >= 0) {
      
      result.doubleNan = decoder0.decodeDouble(72);
    }
    if (mainDataHeader.version >= 0) {
      
      result.name = decoder0.decodeString(80, true);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(88, true);
      if (decoder1 == null) {
        result.stringArray = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.stringArray = new List<String>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.stringArray[i1] = decoder1.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      result.dataHandle = decoder0.decodeConsumerHandle(96, true);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "EchoArgs";
    String fieldName;
    try {
      fieldName = "si64";
      encoder0.encodeInt64(si64, 8);
      fieldName = "si32";
      encoder0.encodeInt32(si32, 16);
      fieldName = "si16";
      encoder0.encodeInt16(si16, 20);
      fieldName = "si8";
      encoder0.encodeInt8(si8, 22);
      fieldName = "ui8";
      encoder0.encodeUint8(ui8, 23);
      fieldName = "ui64";
      encoder0.encodeUint64(ui64, 24);
      fieldName = "ui32";
      encoder0.encodeUint32(ui32, 32);
      fieldName = "ui16";
      encoder0.encodeUint16(ui16, 36);
      fieldName = "floatVal";
      encoder0.encodeFloat(floatVal, 40);
      fieldName = "floatInf";
      encoder0.encodeFloat(floatInf, 44);
      fieldName = "floatNan";
      encoder0.encodeFloat(floatNan, 48);
      fieldName = "messageHandle";
      encoder0.encodeMessagePipeHandle(messageHandle, 52, true);
      fieldName = "doubleVal";
      encoder0.encodeDouble(doubleVal, 56);
      fieldName = "doubleInf";
      encoder0.encodeDouble(doubleInf, 64);
      fieldName = "doubleNan";
      encoder0.encodeDouble(doubleNan, 72);
      fieldName = "name";
      encoder0.encodeString(name, 80, true);
      fieldName = "stringArray";
      if (stringArray == null) {
        encoder0.encodeNullPointer(88, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(stringArray.length, 88, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < stringArray.length; ++i0) {
          encoder1.encodeString(stringArray[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
      fieldName = "dataHandle";
      encoder0.encodeConsumerHandle(dataHandle, 96, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "EchoArgs("
           "si64: $si64" ", "
           "si32: $si32" ", "
           "si16: $si16" ", "
           "si8: $si8" ", "
           "ui8: $ui8" ", "
           "ui64: $ui64" ", "
           "ui32: $ui32" ", "
           "ui16: $ui16" ", "
           "floatVal: $floatVal" ", "
           "floatInf: $floatInf" ", "
           "floatNan: $floatNan" ", "
           "messageHandle: $messageHandle" ", "
           "doubleVal: $doubleVal" ", "
           "doubleInf: $doubleInf" ", "
           "doubleNan: $doubleNan" ", "
           "name: $name" ", "
           "stringArray: $stringArray" ", "
           "dataHandle: $dataHandle" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class EchoArgsList extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  EchoArgsList next = null;
  EchoArgs item = null;

  EchoArgsList() : super(kVersions.last.size);

  EchoArgsList.init(
    EchoArgsList this.next, 
    EchoArgs this.item
  ) : super(kVersions.last.size);

  static EchoArgsList deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static EchoArgsList decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    EchoArgsList result = new EchoArgsList();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.next = EchoArgsList.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.item = EchoArgs.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "EchoArgsList";
    String fieldName;
    try {
      fieldName = "next";
      encoder0.encodeStruct(next, 8, true);
      fieldName = "item";
      encoder0.encodeStruct(item, 16, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "EchoArgsList("
           "next: $next" ", "
           "item: $item" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _CppSideStartTestParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _CppSideStartTestParams() : super(kVersions.last.size);

  _CppSideStartTestParams.init(
  ) : super(kVersions.last.size);

  static _CppSideStartTestParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CppSideStartTestParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CppSideStartTestParams result = new _CppSideStartTestParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CppSideStartTestParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CppSideStartTestParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CppSideTestFinishedParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _CppSideTestFinishedParams() : super(kVersions.last.size);

  _CppSideTestFinishedParams.init(
  ) : super(kVersions.last.size);

  static _CppSideTestFinishedParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CppSideTestFinishedParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CppSideTestFinishedParams result = new _CppSideTestFinishedParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CppSideTestFinishedParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CppSideTestFinishedParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CppSidePingResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _CppSidePingResponseParams() : super(kVersions.last.size);

  _CppSidePingResponseParams.init(
  ) : super(kVersions.last.size);

  static _CppSidePingResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CppSidePingResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CppSidePingResponseParams result = new _CppSidePingResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CppSidePingResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CppSidePingResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CppSideEchoResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EchoArgsList list = null;

  _CppSideEchoResponseParams() : super(kVersions.last.size);

  _CppSideEchoResponseParams.init(
    EchoArgsList this.list
  ) : super(kVersions.last.size);

  static _CppSideEchoResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CppSideEchoResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CppSideEchoResponseParams result = new _CppSideEchoResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.list = EchoArgsList.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CppSideEchoResponseParams";
    String fieldName;
    try {
      fieldName = "list";
      encoder0.encodeStruct(list, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CppSideEchoResponseParams("
           "list: $list" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _CppSideBitFlipResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EchoArgsList arg = null;

  _CppSideBitFlipResponseParams() : super(kVersions.last.size);

  _CppSideBitFlipResponseParams.init(
    EchoArgsList this.arg
  ) : super(kVersions.last.size);

  static _CppSideBitFlipResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CppSideBitFlipResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CppSideBitFlipResponseParams result = new _CppSideBitFlipResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.arg = EchoArgsList.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CppSideBitFlipResponseParams";
    String fieldName;
    try {
      fieldName = "arg";
      encoder0.encodeStruct(arg, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CppSideBitFlipResponseParams("
           "arg: $arg" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _CppSideBackPointerResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EchoArgsList arg = null;

  _CppSideBackPointerResponseParams() : super(kVersions.last.size);

  _CppSideBackPointerResponseParams.init(
    EchoArgsList this.arg
  ) : super(kVersions.last.size);

  static _CppSideBackPointerResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CppSideBackPointerResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CppSideBackPointerResponseParams result = new _CppSideBackPointerResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.arg = EchoArgsList.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CppSideBackPointerResponseParams";
    String fieldName;
    try {
      fieldName = "arg";
      encoder0.encodeStruct(arg, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CppSideBackPointerResponseParams("
           "arg: $arg" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _JsSideSetCppSideParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  CppSideInterface cpp = null;

  _JsSideSetCppSideParams() : super(kVersions.last.size);

  _JsSideSetCppSideParams.init(
    CppSideInterface this.cpp
  ) : super(kVersions.last.size);

  static _JsSideSetCppSideParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _JsSideSetCppSideParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _JsSideSetCppSideParams result = new _JsSideSetCppSideParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.cpp = decoder0.decodeServiceInterface(8, false, CppSideProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_JsSideSetCppSideParams";
    String fieldName;
    try {
      fieldName = "cpp";
      encoder0.encodeInterface(cpp, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_JsSideSetCppSideParams("
           "cpp: $cpp" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _JsSidePingParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _JsSidePingParams() : super(kVersions.last.size);

  _JsSidePingParams.init(
  ) : super(kVersions.last.size);

  static _JsSidePingParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _JsSidePingParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _JsSidePingParams result = new _JsSidePingParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_JsSidePingParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_JsSidePingParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _JsSideEchoParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  int numIterations = 0;
  EchoArgs arg = null;

  _JsSideEchoParams() : super(kVersions.last.size);

  _JsSideEchoParams.init(
    int this.numIterations, 
    EchoArgs this.arg
  ) : super(kVersions.last.size);

  static _JsSideEchoParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _JsSideEchoParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _JsSideEchoParams result = new _JsSideEchoParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.numIterations = decoder0.decodeInt32(8);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, false);
      result.arg = EchoArgs.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_JsSideEchoParams";
    String fieldName;
    try {
      fieldName = "numIterations";
      encoder0.encodeInt32(numIterations, 8);
      fieldName = "arg";
      encoder0.encodeStruct(arg, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_JsSideEchoParams("
           "numIterations: $numIterations" ", "
           "arg: $arg" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _JsSideBitFlipParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EchoArgs arg = null;

  _JsSideBitFlipParams() : super(kVersions.last.size);

  _JsSideBitFlipParams.init(
    EchoArgs this.arg
  ) : super(kVersions.last.size);

  static _JsSideBitFlipParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _JsSideBitFlipParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _JsSideBitFlipParams result = new _JsSideBitFlipParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.arg = EchoArgs.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_JsSideBitFlipParams";
    String fieldName;
    try {
      fieldName = "arg";
      encoder0.encodeStruct(arg, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_JsSideBitFlipParams("
           "arg: $arg" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _JsSideBackPointerParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EchoArgs arg = null;

  _JsSideBackPointerParams() : super(kVersions.last.size);

  _JsSideBackPointerParams.init(
    EchoArgs this.arg
  ) : super(kVersions.last.size);

  static _JsSideBackPointerParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _JsSideBackPointerParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _JsSideBackPointerParams result = new _JsSideBackPointerParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.arg = EchoArgs.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_JsSideBackPointerParams";
    String fieldName;
    try {
      fieldName = "arg";
      encoder0.encodeStruct(arg, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_JsSideBackPointerParams("
           "arg: $arg" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}

const int _cppSideMethodStartTestName = 88888888;
const int _cppSideMethodTestFinishedName = 99999999;
const int _cppSideMethodPingResponseName = 100000000;
const int _cppSideMethodEchoResponseName = 100000001;
const int _cppSideMethodBitFlipResponseName = 100000002;
const int _cppSideMethodBackPointerResponseName = 100000003;

class _CppSideServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CppSide {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CppSideServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CppSideProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CppSideProxy p = new CppSideProxy.unbound();
    String name = serviceName ?? CppSide.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void startTest();
  void testFinished();
  void pingResponse();
  void echoResponse(EchoArgsList list);
  void bitFlipResponse(EchoArgsList arg);
  void backPointerResponse(EchoArgsList arg);
}

abstract class CppSideInterface
    implements bindings.MojoInterface<CppSide>,
               CppSide {
  factory CppSideInterface([CppSide impl]) =>
      new CppSideStub.unbound(impl);

  factory CppSideInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CppSide impl]) =>
      new CppSideStub.fromEndpoint(endpoint, impl);

  factory CppSideInterface.fromMock(
      CppSide mock) =>
      new CppSideProxy.fromMock(mock);
}

abstract class CppSideInterfaceRequest
    implements bindings.MojoInterface<CppSide>,
               CppSide {
  factory CppSideInterfaceRequest() =>
      new CppSideProxy.unbound();
}

class _CppSideProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CppSide> {
  CppSide impl;

  _CppSideProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CppSideProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CppSideProxyControl.unbound() : super.unbound();

  String get serviceName => CppSide.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CppSideProxyControl($superString)";
  }
}

class CppSideProxy
    extends bindings.Proxy<CppSide>
    implements CppSide,
               CppSideInterface,
               CppSideInterfaceRequest {
  CppSideProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CppSideProxyControl.fromEndpoint(endpoint));

  CppSideProxy.fromHandle(core.MojoHandle handle)
      : super(new _CppSideProxyControl.fromHandle(handle));

  CppSideProxy.unbound()
      : super(new _CppSideProxyControl.unbound());

  factory CppSideProxy.fromMock(CppSide mock) {
    CppSideProxy newMockedProxy =
        new CppSideProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CppSideProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CppSideProxy"));
    return new CppSideProxy.fromEndpoint(endpoint);
  }


  void startTest() {
    if (impl != null) {
      impl.startTest();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CppSideStartTestParams();
    ctrl.sendMessage(params,
        _cppSideMethodStartTestName);
  }
  void testFinished() {
    if (impl != null) {
      impl.testFinished();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CppSideTestFinishedParams();
    ctrl.sendMessage(params,
        _cppSideMethodTestFinishedName);
  }
  void pingResponse() {
    if (impl != null) {
      impl.pingResponse();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CppSidePingResponseParams();
    ctrl.sendMessage(params,
        _cppSideMethodPingResponseName);
  }
  void echoResponse(EchoArgsList list) {
    if (impl != null) {
      impl.echoResponse(list);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CppSideEchoResponseParams();
    params.list = list;
    ctrl.sendMessage(params,
        _cppSideMethodEchoResponseName);
  }
  void bitFlipResponse(EchoArgsList arg) {
    if (impl != null) {
      impl.bitFlipResponse(arg);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CppSideBitFlipResponseParams();
    params.arg = arg;
    ctrl.sendMessage(params,
        _cppSideMethodBitFlipResponseName);
  }
  void backPointerResponse(EchoArgsList arg) {
    if (impl != null) {
      impl.backPointerResponse(arg);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CppSideBackPointerResponseParams();
    params.arg = arg;
    ctrl.sendMessage(params,
        _cppSideMethodBackPointerResponseName);
  }
}

class _CppSideStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CppSide> {
  CppSide _impl;

  _CppSideStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CppSide impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CppSideStubControl.fromHandle(
      core.MojoHandle handle, [CppSide impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CppSideStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CppSide.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _cppSideMethodStartTestName:
        _impl.startTest();
        break;
      case _cppSideMethodTestFinishedName:
        _impl.testFinished();
        break;
      case _cppSideMethodPingResponseName:
        _impl.pingResponse();
        break;
      case _cppSideMethodEchoResponseName:
        var params = _CppSideEchoResponseParams.deserialize(
            message.payload);
        _impl.echoResponse(params.list);
        break;
      case _cppSideMethodBitFlipResponseName:
        var params = _CppSideBitFlipResponseParams.deserialize(
            message.payload);
        _impl.bitFlipResponse(params.arg);
        break;
      case _cppSideMethodBackPointerResponseName:
        var params = _CppSideBackPointerResponseParams.deserialize(
            message.payload);
        _impl.backPointerResponse(params.arg);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CppSide get impl => _impl;
  set impl(CppSide d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CppSideStubControl($superString)";
  }

  int get version => 0;
}

class CppSideStub
    extends bindings.Stub<CppSide>
    implements CppSide,
               CppSideInterface,
               CppSideInterfaceRequest {
  CppSideStub.unbound([CppSide impl])
      : super(new _CppSideStubControl.unbound(impl));

  CppSideStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CppSide impl])
      : super(new _CppSideStubControl.fromEndpoint(endpoint, impl));

  CppSideStub.fromHandle(
      core.MojoHandle handle, [CppSide impl])
      : super(new _CppSideStubControl.fromHandle(handle, impl));

  static CppSideStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CppSideStub"));
    return new CppSideStub.fromEndpoint(endpoint);
  }


  void startTest() {
    return impl.startTest();
  }
  void testFinished() {
    return impl.testFinished();
  }
  void pingResponse() {
    return impl.pingResponse();
  }
  void echoResponse(EchoArgsList list) {
    return impl.echoResponse(list);
  }
  void bitFlipResponse(EchoArgsList arg) {
    return impl.bitFlipResponse(arg);
  }
  void backPointerResponse(EchoArgsList arg) {
    return impl.backPointerResponse(arg);
  }
}

const int _jsSideMethodSetCppSideName = 0;
const int _jsSideMethodPingName = 1;
const int _jsSideMethodEchoName = 2;
const int _jsSideMethodBitFlipName = 3;
const int _jsSideMethodBackPointerName = 4;

class _JsSideServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class JsSide {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _JsSideServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static JsSideProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    JsSideProxy p = new JsSideProxy.unbound();
    String name = serviceName ?? JsSide.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void setCppSide(CppSideInterface cpp);
  void ping();
  void echo(int numIterations, EchoArgs arg);
  void bitFlip(EchoArgs arg);
  void backPointer(EchoArgs arg);
}

abstract class JsSideInterface
    implements bindings.MojoInterface<JsSide>,
               JsSide {
  factory JsSideInterface([JsSide impl]) =>
      new JsSideStub.unbound(impl);

  factory JsSideInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [JsSide impl]) =>
      new JsSideStub.fromEndpoint(endpoint, impl);

  factory JsSideInterface.fromMock(
      JsSide mock) =>
      new JsSideProxy.fromMock(mock);
}

abstract class JsSideInterfaceRequest
    implements bindings.MojoInterface<JsSide>,
               JsSide {
  factory JsSideInterfaceRequest() =>
      new JsSideProxy.unbound();
}

class _JsSideProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<JsSide> {
  JsSide impl;

  _JsSideProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _JsSideProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _JsSideProxyControl.unbound() : super.unbound();

  String get serviceName => JsSide.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_JsSideProxyControl($superString)";
  }
}

class JsSideProxy
    extends bindings.Proxy<JsSide>
    implements JsSide,
               JsSideInterface,
               JsSideInterfaceRequest {
  JsSideProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _JsSideProxyControl.fromEndpoint(endpoint));

  JsSideProxy.fromHandle(core.MojoHandle handle)
      : super(new _JsSideProxyControl.fromHandle(handle));

  JsSideProxy.unbound()
      : super(new _JsSideProxyControl.unbound());

  factory JsSideProxy.fromMock(JsSide mock) {
    JsSideProxy newMockedProxy =
        new JsSideProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static JsSideProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For JsSideProxy"));
    return new JsSideProxy.fromEndpoint(endpoint);
  }


  void setCppSide(CppSideInterface cpp) {
    if (impl != null) {
      impl.setCppSide(cpp);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _JsSideSetCppSideParams();
    params.cpp = cpp;
    ctrl.sendMessage(params,
        _jsSideMethodSetCppSideName);
  }
  void ping() {
    if (impl != null) {
      impl.ping();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _JsSidePingParams();
    ctrl.sendMessage(params,
        _jsSideMethodPingName);
  }
  void echo(int numIterations, EchoArgs arg) {
    if (impl != null) {
      impl.echo(numIterations, arg);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _JsSideEchoParams();
    params.numIterations = numIterations;
    params.arg = arg;
    ctrl.sendMessage(params,
        _jsSideMethodEchoName);
  }
  void bitFlip(EchoArgs arg) {
    if (impl != null) {
      impl.bitFlip(arg);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _JsSideBitFlipParams();
    params.arg = arg;
    ctrl.sendMessage(params,
        _jsSideMethodBitFlipName);
  }
  void backPointer(EchoArgs arg) {
    if (impl != null) {
      impl.backPointer(arg);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _JsSideBackPointerParams();
    params.arg = arg;
    ctrl.sendMessage(params,
        _jsSideMethodBackPointerName);
  }
}

class _JsSideStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<JsSide> {
  JsSide _impl;

  _JsSideStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [JsSide impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _JsSideStubControl.fromHandle(
      core.MojoHandle handle, [JsSide impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _JsSideStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => JsSide.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _jsSideMethodSetCppSideName:
        var params = _JsSideSetCppSideParams.deserialize(
            message.payload);
        _impl.setCppSide(params.cpp);
        break;
      case _jsSideMethodPingName:
        _impl.ping();
        break;
      case _jsSideMethodEchoName:
        var params = _JsSideEchoParams.deserialize(
            message.payload);
        _impl.echo(params.numIterations, params.arg);
        break;
      case _jsSideMethodBitFlipName:
        var params = _JsSideBitFlipParams.deserialize(
            message.payload);
        _impl.bitFlip(params.arg);
        break;
      case _jsSideMethodBackPointerName:
        var params = _JsSideBackPointerParams.deserialize(
            message.payload);
        _impl.backPointer(params.arg);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  JsSide get impl => _impl;
  set impl(JsSide d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_JsSideStubControl($superString)";
  }

  int get version => 0;
}

class JsSideStub
    extends bindings.Stub<JsSide>
    implements JsSide,
               JsSideInterface,
               JsSideInterfaceRequest {
  JsSideStub.unbound([JsSide impl])
      : super(new _JsSideStubControl.unbound(impl));

  JsSideStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [JsSide impl])
      : super(new _JsSideStubControl.fromEndpoint(endpoint, impl));

  JsSideStub.fromHandle(
      core.MojoHandle handle, [JsSide impl])
      : super(new _JsSideStubControl.fromHandle(handle, impl));

  static JsSideStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For JsSideStub"));
    return new JsSideStub.fromEndpoint(endpoint);
  }


  void setCppSide(CppSideInterface cpp) {
    return impl.setCppSide(cpp);
  }
  void ping() {
    return impl.ping();
  }
  void echo(int numIterations, EchoArgs arg) {
    return impl.echo(numIterations, arg);
  }
  void bitFlip(EchoArgs arg) {
    return impl.bitFlip(arg);
  }
  void backPointer(EchoArgs arg) {
    return impl.backPointer(arg);
  }
}



