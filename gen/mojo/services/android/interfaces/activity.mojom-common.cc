// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/services/android/interfaces/activity.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace activity {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// static
StringExtra_Data* StringExtra_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StringExtra_Data))) StringExtra_Data();
}

// static
mojo::internal::ValidationError StringExtra_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StringExtra_Data* object = static_cast<const StringExtra_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->name.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null name field in StringExtra struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->name.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams name_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->name.offset),
          bounds_checker, &name_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->value.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null value field in StringExtra struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->value.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams value_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->value.offset),
          bounds_checker, &value_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StringExtra_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->name, handles);
  mojo::internal::Encode(&this->value, handles);
}

void StringExtra_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->name, handles);
  mojo::internal::Decode(&this->value, handles);
}

StringExtra_Data::StringExtra_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
ComponentName_Data* ComponentName_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ComponentName_Data))) ComponentName_Data();
}

// static
mojo::internal::ValidationError ComponentName_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ComponentName_Data* object = static_cast<const ComponentName_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->package_name.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null package_name field in ComponentName struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->package_name.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams package_name_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->package_name.offset),
          bounds_checker, &package_name_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->class_name.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null class_name field in ComponentName struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->class_name.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams class_name_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->class_name.offset),
          bounds_checker, &class_name_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ComponentName_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->package_name, handles);
  mojo::internal::Encode(&this->class_name, handles);
}

void ComponentName_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->package_name, handles);
  mojo::internal::Decode(&this->class_name, handles);
}

ComponentName_Data::ComponentName_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
Intent_Data* Intent_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Intent_Data))) Intent_Data();
}

// static
mojo::internal::ValidationError Intent_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Intent_Data* object = static_cast<const Intent_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 56 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->action.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null action field in Intent struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->action.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams action_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->action.offset),
          bounds_checker, &action_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->url.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null url field in Intent struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->url.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams url_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->url.offset),
          bounds_checker, &url_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->component.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = ComponentName::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->component.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->string_extras.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams string_extras_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<StringExtraPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->string_extras.offset),
          bounds_checker, &string_extras_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->type.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams type_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->type.offset),
          bounds_checker, &type_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Intent_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->action, handles);
  mojo::internal::Encode(&this->url, handles);
  mojo::internal::Encode(&this->component, handles);
  mojo::internal::Encode(&this->string_extras, handles);
  mojo::internal::Encode(&this->type, handles);
}

void Intent_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->action, handles);
  mojo::internal::Decode(&this->url, handles);
  mojo::internal::Decode(&this->component, handles);
  mojo::internal::Decode(&this->string_extras, handles);
  mojo::internal::Decode(&this->type, handles);
}

Intent_Data::Intent_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
TaskDescription_Data* TaskDescription_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(TaskDescription_Data))) TaskDescription_Data();
}

// static
mojo::internal::ValidationError TaskDescription_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const TaskDescription_Data* object = static_cast<const TaskDescription_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->label.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams label_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->label.offset),
          bounds_checker, &label_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void TaskDescription_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->label, handles);
}

void TaskDescription_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->label, handles);
}

TaskDescription_Data::TaskDescription_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// --- Union definitions ---


// --- Definitions of the data structs for interface methods ---


// static
Activity_GetUserFeedback_Params_Data* Activity_GetUserFeedback_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Activity_GetUserFeedback_Params_Data))) Activity_GetUserFeedback_Params_Data();
}

// static
mojo::internal::ValidationError Activity_GetUserFeedback_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Activity_GetUserFeedback_Params_Data* object = static_cast<const Activity_GetUserFeedback_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle user_feedback_handle = object->user_feedback;
  if (user_feedback_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid user_feedback field in Activity_GetUserFeedback_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(user_feedback_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Activity_GetUserFeedback_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->user_feedback, handles);
}

void Activity_GetUserFeedback_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->user_feedback, handles);
}

Activity_GetUserFeedback_Params_Data::Activity_GetUserFeedback_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
Activity_StartActivity_Params_Data* Activity_StartActivity_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Activity_StartActivity_Params_Data))) Activity_StartActivity_Params_Data();
}

// static
mojo::internal::ValidationError Activity_StartActivity_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Activity_StartActivity_Params_Data* object = static_cast<const Activity_StartActivity_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->intent.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null intent field in Activity_StartActivity_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->intent.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = Intent::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->intent.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Activity_StartActivity_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->intent, handles);
}

void Activity_StartActivity_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->intent, handles);
}

Activity_StartActivity_Params_Data::Activity_StartActivity_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
Activity_FinishCurrentActivity_Params_Data* Activity_FinishCurrentActivity_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Activity_FinishCurrentActivity_Params_Data))) Activity_FinishCurrentActivity_Params_Data();
}

// static
mojo::internal::ValidationError Activity_FinishCurrentActivity_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Activity_FinishCurrentActivity_Params_Data* object = static_cast<const Activity_FinishCurrentActivity_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void Activity_FinishCurrentActivity_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void Activity_FinishCurrentActivity_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

Activity_FinishCurrentActivity_Params_Data::Activity_FinishCurrentActivity_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
Activity_SetTaskDescription_Params_Data* Activity_SetTaskDescription_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Activity_SetTaskDescription_Params_Data))) Activity_SetTaskDescription_Params_Data();
}

// static
mojo::internal::ValidationError Activity_SetTaskDescription_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Activity_SetTaskDescription_Params_Data* object = static_cast<const Activity_SetTaskDescription_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->description.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null description field in Activity_SetTaskDescription_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->description.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = TaskDescription::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->description.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Activity_SetTaskDescription_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->description, handles);
}

void Activity_SetTaskDescription_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->description, handles);
}

Activity_SetTaskDescription_Params_Data::Activity_SetTaskDescription_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
Activity_SetSystemUIVisibility_Params_Data* Activity_SetSystemUIVisibility_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Activity_SetSystemUIVisibility_Params_Data))) Activity_SetSystemUIVisibility_Params_Data();
}

// static
mojo::internal::ValidationError Activity_SetSystemUIVisibility_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Activity_SetSystemUIVisibility_Params_Data* object = static_cast<const Activity_SetSystemUIVisibility_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void Activity_SetSystemUIVisibility_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void Activity_SetSystemUIVisibility_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

Activity_SetSystemUIVisibility_Params_Data::Activity_SetSystemUIVisibility_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
Activity_SetRequestedOrientation_Params_Data* Activity_SetRequestedOrientation_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Activity_SetRequestedOrientation_Params_Data))) Activity_SetRequestedOrientation_Params_Data();
}

// static
mojo::internal::ValidationError Activity_SetRequestedOrientation_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Activity_SetRequestedOrientation_Params_Data* object = static_cast<const Activity_SetRequestedOrientation_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void Activity_SetRequestedOrientation_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void Activity_SetRequestedOrientation_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

Activity_SetRequestedOrientation_Params_Data::Activity_SetRequestedOrientation_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
PathService_GetAppDataDir_Params_Data* PathService_GetAppDataDir_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(PathService_GetAppDataDir_Params_Data))) PathService_GetAppDataDir_Params_Data();
}

// static
mojo::internal::ValidationError PathService_GetAppDataDir_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const PathService_GetAppDataDir_Params_Data* object = static_cast<const PathService_GetAppDataDir_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void PathService_GetAppDataDir_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void PathService_GetAppDataDir_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

PathService_GetAppDataDir_Params_Data::PathService_GetAppDataDir_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
PathService_GetAppDataDir_ResponseParams_Data* PathService_GetAppDataDir_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(PathService_GetAppDataDir_ResponseParams_Data))) PathService_GetAppDataDir_ResponseParams_Data();
}

// static
mojo::internal::ValidationError PathService_GetAppDataDir_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const PathService_GetAppDataDir_ResponseParams_Data* object = static_cast<const PathService_GetAppDataDir_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->path.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null path field in PathService_GetAppDataDir_ResponseParams struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->path.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams path_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->path.offset),
          bounds_checker, &path_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void PathService_GetAppDataDir_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->path, handles);
}

void PathService_GetAppDataDir_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->path, handles);
}

PathService_GetAppDataDir_ResponseParams_Data::PathService_GetAppDataDir_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
PathService_GetFilesDir_Params_Data* PathService_GetFilesDir_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(PathService_GetFilesDir_Params_Data))) PathService_GetFilesDir_Params_Data();
}

// static
mojo::internal::ValidationError PathService_GetFilesDir_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const PathService_GetFilesDir_Params_Data* object = static_cast<const PathService_GetFilesDir_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void PathService_GetFilesDir_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void PathService_GetFilesDir_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

PathService_GetFilesDir_Params_Data::PathService_GetFilesDir_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
PathService_GetFilesDir_ResponseParams_Data* PathService_GetFilesDir_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(PathService_GetFilesDir_ResponseParams_Data))) PathService_GetFilesDir_ResponseParams_Data();
}

// static
mojo::internal::ValidationError PathService_GetFilesDir_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const PathService_GetFilesDir_ResponseParams_Data* object = static_cast<const PathService_GetFilesDir_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->path.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null path field in PathService_GetFilesDir_ResponseParams struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->path.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams path_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->path.offset),
          bounds_checker, &path_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void PathService_GetFilesDir_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->path, handles);
}

void PathService_GetFilesDir_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->path, handles);
}

PathService_GetFilesDir_ResponseParams_Data::PathService_GetFilesDir_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
PathService_GetCacheDir_Params_Data* PathService_GetCacheDir_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(PathService_GetCacheDir_Params_Data))) PathService_GetCacheDir_Params_Data();
}

// static
mojo::internal::ValidationError PathService_GetCacheDir_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const PathService_GetCacheDir_Params_Data* object = static_cast<const PathService_GetCacheDir_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void PathService_GetCacheDir_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void PathService_GetCacheDir_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

PathService_GetCacheDir_Params_Data::PathService_GetCacheDir_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
PathService_GetCacheDir_ResponseParams_Data* PathService_GetCacheDir_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(PathService_GetCacheDir_ResponseParams_Data))) PathService_GetCacheDir_ResponseParams_Data();
}

// static
mojo::internal::ValidationError PathService_GetCacheDir_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const PathService_GetCacheDir_ResponseParams_Data* object = static_cast<const PathService_GetCacheDir_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->path.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null path field in PathService_GetCacheDir_ResponseParams struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->path.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams path_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->path.offset),
          bounds_checker, &path_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void PathService_GetCacheDir_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->path, handles);
}

void PathService_GetCacheDir_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->path, handles);
}

PathService_GetCacheDir_ResponseParams_Data::PathService_GetCacheDir_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
UserFeedback_PerformHapticFeedback_Params_Data* UserFeedback_PerformHapticFeedback_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(UserFeedback_PerformHapticFeedback_Params_Data))) UserFeedback_PerformHapticFeedback_Params_Data();
}

// static
mojo::internal::ValidationError UserFeedback_PerformHapticFeedback_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const UserFeedback_PerformHapticFeedback_Params_Data* object = static_cast<const UserFeedback_PerformHapticFeedback_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void UserFeedback_PerformHapticFeedback_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void UserFeedback_PerformHapticFeedback_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

UserFeedback_PerformHapticFeedback_Params_Data::UserFeedback_PerformHapticFeedback_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
UserFeedback_PerformAuralFeedback_Params_Data* UserFeedback_PerformAuralFeedback_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(UserFeedback_PerformAuralFeedback_Params_Data))) UserFeedback_PerformAuralFeedback_Params_Data();
}

// static
mojo::internal::ValidationError UserFeedback_PerformAuralFeedback_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const UserFeedback_PerformAuralFeedback_Params_Data* object = static_cast<const UserFeedback_PerformAuralFeedback_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void UserFeedback_PerformAuralFeedback_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void UserFeedback_PerformAuralFeedback_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

UserFeedback_PerformAuralFeedback_Params_Data::UserFeedback_PerformAuralFeedback_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


}  // namespace internal

// --- Request and response validator definitions for interfaces ---
mojo::internal::ValidationError ActivityRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'Activity', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::Activity_Base::MessageOrdinals method_ordinal =
      static_cast<internal::Activity_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::Activity_Base::MessageOrdinals::GetUserFeedback: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'Activity', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::Activity_GetUserFeedback_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'Activity', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::Activity_Base::MessageOrdinals::StartActivity: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'Activity', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::Activity_StartActivity_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'Activity', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::Activity_Base::MessageOrdinals::FinishCurrentActivity: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'Activity', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::Activity_FinishCurrentActivity_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'Activity', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::Activity_Base::MessageOrdinals::SetTaskDescription: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'Activity', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::Activity_SetTaskDescription_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'Activity', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::Activity_Base::MessageOrdinals::SetSystemUIVisibility: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'Activity', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::Activity_SetSystemUIVisibility_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'Activity', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::Activity_Base::MessageOrdinals::SetRequestedOrientation: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'Activity', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::Activity_SetRequestedOrientation_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'Activity', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'Activity'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError PathServiceRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'PathService', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::PathService_Base::MessageOrdinals method_ordinal =
      static_cast<internal::PathService_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::PathService_Base::MessageOrdinals::GetAppDataDir: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'PathService', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::PathService_GetAppDataDir_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'PathService', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::PathService_Base::MessageOrdinals::GetFilesDir: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'PathService', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::PathService_GetFilesDir_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'PathService', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::PathService_Base::MessageOrdinals::GetCacheDir: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'PathService', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::PathService_GetCacheDir_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'PathService', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'PathService'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError PathServiceResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'PathService', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'PathService', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::PathService_Base::MessageOrdinals method_ordinal =
      static_cast<internal::PathService_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::PathService_Base::MessageOrdinals::GetAppDataDir: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::PathService_GetAppDataDir_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'PathService',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::PathService_Base::MessageOrdinals::GetFilesDir: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::PathService_GetFilesDir_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'PathService',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::PathService_Base::MessageOrdinals::GetCacheDir: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::PathService_GetCacheDir_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'PathService',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'PathService'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError UserFeedbackRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'UserFeedback', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::UserFeedback_Base::MessageOrdinals method_ordinal =
      static_cast<internal::UserFeedback_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::UserFeedback_Base::MessageOrdinals::PerformHapticFeedback: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'UserFeedback', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::UserFeedback_PerformHapticFeedback_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'UserFeedback', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::UserFeedback_Base::MessageOrdinals::PerformAuralFeedback: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'UserFeedback', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::UserFeedback_PerformAuralFeedback_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'UserFeedback', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'UserFeedback'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
} 

// --- Enums ---
bool SystemUIVisibility_IsValidValue(SystemUIVisibility value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const SystemUIVisibility& val) {
  return (stream << static_cast<int32_t>(val));
}
bool ScreenOrientation_IsValidValue(ScreenOrientation value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const ScreenOrientation& val) {
  return (stream << static_cast<int32_t>(val));
}
bool HapticFeedbackType_IsValidValue(HapticFeedbackType value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const HapticFeedbackType& val) {
  return (stream << static_cast<int32_t>(val));
}
bool AuralFeedbackType_IsValidValue(AuralFeedbackType value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const AuralFeedbackType& val) {
  return (stream << static_cast<int32_t>(val));
}

// Base interface definitions (Name_, Version_, Constants, Enums)
const char internal::Activity_Base::Name_[] = "activity::Activity";
const uint32_t internal::Activity_Base::Version_;

// Constants

// Enums
const char internal::PathService_Base::Name_[] = "activity::PathService";
const uint32_t internal::PathService_Base::Version_;

// Constants

// Enums
const uint32_t internal::UserFeedback_Base::Version_;

// Constants

// Enums

// Struct Constants

// --- Struct builder definitions ---

// static
StringExtraPtr StringExtra::New() {
  StringExtraPtr rv;
  mojo::internal::StructHelper<StringExtra>::Initialize(&rv);
  return rv;
}

StringExtra::StringExtra()
    : name(),
      value() {
}

StringExtra::~StringExtra() {
}


StringExtraPtr StringExtra::Clone() const {
  StringExtraPtr rv(New());
  rv->name = name;
  rv->value = value;
  return rv;
}


bool StringExtra::Equals(const StringExtra& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->name, other.name))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->value, other.value))
    return false;
  return true;
}


// static
ComponentNamePtr ComponentName::New() {
  ComponentNamePtr rv;
  mojo::internal::StructHelper<ComponentName>::Initialize(&rv);
  return rv;
}

ComponentName::ComponentName()
    : package_name(),
      class_name() {
}

ComponentName::~ComponentName() {
}


ComponentNamePtr ComponentName::Clone() const {
  ComponentNamePtr rv(New());
  rv->package_name = package_name;
  rv->class_name = class_name;
  return rv;
}


bool ComponentName::Equals(const ComponentName& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->package_name, other.package_name))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->class_name, other.class_name))
    return false;
  return true;
}


// static
IntentPtr Intent::New() {
  IntentPtr rv;
  mojo::internal::StructHelper<Intent>::Initialize(&rv);
  return rv;
}

Intent::Intent()
    : action(),
      url(),
      flags(),
      component(),
      string_extras(),
      type() {
}

Intent::~Intent() {
}


IntentPtr Intent::Clone() const {
  IntentPtr rv(New());
  rv->action = action;
  rv->url = url;
  rv->flags = flags;
  rv->component = component.Clone();
  rv->string_extras = string_extras.Clone();
  rv->type = type;
  return rv;
}


bool Intent::Equals(const Intent& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->action, other.action))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->url, other.url))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->flags, other.flags))
    return false;
  if (!mojo::internal::ValueTraits<ComponentNamePtr>::Equals(this->component, other.component))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<StringExtraPtr>>::Equals(this->string_extras, other.string_extras))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->type, other.type))
    return false;
  return true;
}


// static
TaskDescriptionPtr TaskDescription::New() {
  TaskDescriptionPtr rv;
  mojo::internal::StructHelper<TaskDescription>::Initialize(&rv);
  return rv;
}

TaskDescription::TaskDescription()
    : label(),
      primaryColor() {
}

TaskDescription::~TaskDescription() {
}


TaskDescriptionPtr TaskDescription::Clone() const {
  TaskDescriptionPtr rv(New());
  rv->label = label;
  rv->primaryColor = primaryColor;
  return rv;
}


bool TaskDescription::Equals(const TaskDescription& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->label, other.label))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->primaryColor, other.primaryColor))
    return false;
  return true;
}


// --- Union builder definitions ---

// --- Struct Serialization Helpers ---

size_t StringExtra::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StringExtra::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StringExtra_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StringExtra::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StringExtra_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StringExtra::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StringExtra_Data* input =
      static_cast<internal::StringExtra_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StringExtra& input) {
  size_t size = sizeof(internal::StringExtra_Data);
  size += GetSerializedSize_(input.name);
  size += GetSerializedSize_(input.value);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StringExtra* input,
    mojo::internal::Buffer* buf,
    internal::StringExtra_Data** output) {
  if (input) {
    internal::StringExtra_Data* result =
        internal::StringExtra_Data::New(buf);
    SerializeString_(input->name, buf, &result->name.ptr);
    if (!result->name.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null name in StringExtra struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    SerializeString_(input->value, buf, &result->value.ptr);
    if (!result->value.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null value in StringExtra struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StringExtra_Data* input,
                  StringExtra* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->name.ptr, &result->name);
      Deserialize_(input->value.ptr, &result->value);
    } while (false);
  }
}


size_t ComponentName::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ComponentName::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ComponentName_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ComponentName::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ComponentName_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ComponentName::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ComponentName_Data* input =
      static_cast<internal::ComponentName_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ComponentName& input) {
  size_t size = sizeof(internal::ComponentName_Data);
  size += GetSerializedSize_(input.package_name);
  size += GetSerializedSize_(input.class_name);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ComponentName* input,
    mojo::internal::Buffer* buf,
    internal::ComponentName_Data** output) {
  if (input) {
    internal::ComponentName_Data* result =
        internal::ComponentName_Data::New(buf);
    SerializeString_(input->package_name, buf, &result->package_name.ptr);
    if (!result->package_name.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null package_name in ComponentName struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    SerializeString_(input->class_name, buf, &result->class_name.ptr);
    if (!result->class_name.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null class_name in ComponentName struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ComponentName_Data* input,
                  ComponentName* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->package_name.ptr, &result->package_name);
      Deserialize_(input->class_name.ptr, &result->class_name);
    } while (false);
  }
}


size_t Intent::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Intent::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Intent_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Intent::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Intent_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Intent::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Intent_Data* input =
      static_cast<internal::Intent_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Intent& input) {
  size_t size = sizeof(internal::Intent_Data);
  size += GetSerializedSize_(input.action);
  size += GetSerializedSize_(input.url);
  size += input.component.is_null()
              ? 0
              : GetSerializedSize_(*input.component);
  size += GetSerializedSize_(input.string_extras);
  size += GetSerializedSize_(input.type);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Intent* input,
    mojo::internal::Buffer* buf,
    internal::Intent_Data** output) {
  if (input) {
    internal::Intent_Data* result =
        internal::Intent_Data::New(buf);
    SerializeString_(input->action, buf, &result->action.ptr);
    if (!result->action.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null action in Intent struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    SerializeString_(input->url, buf, &result->url.ptr);
    if (!result->url.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null url in Intent struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->flags = input->flags;
    {auto retval =Serialize_(input->component.get(),
                 buf,
                 &result->component.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams string_extras_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->string_extras, buf, &result->string_extras.ptr,
                            &string_extras_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    SerializeString_(input->type, buf, &result->type.ptr);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Intent_Data* input,
                  Intent* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->action.ptr, &result->action);
      Deserialize_(input->url.ptr, &result->url);
      result->flags = input->flags;
      if (input->component.ptr) {
        result->component = ComponentName::New();
        Deserialize_(input->component.ptr, result->component.get());
      }
      Deserialize_(input->string_extras.ptr, &result->string_extras);
      Deserialize_(input->type.ptr, &result->type);
    } while (false);
  }
}


size_t TaskDescription::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool TaskDescription::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::TaskDescription_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool TaskDescription::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::TaskDescription_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void TaskDescription::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::TaskDescription_Data* input =
      static_cast<internal::TaskDescription_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const TaskDescription& input) {
  size_t size = sizeof(internal::TaskDescription_Data);
  size += GetSerializedSize_(input.label);
  return size;
}

mojo::internal::ValidationError Serialize_(
    TaskDescription* input,
    mojo::internal::Buffer* buf,
    internal::TaskDescription_Data** output) {
  if (input) {
    internal::TaskDescription_Data* result =
        internal::TaskDescription_Data::New(buf);
    SerializeString_(input->label, buf, &result->label.ptr);
    result->primaryColor = input->primaryColor;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::TaskDescription_Data* input,
                  TaskDescription* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->label.ptr, &result->label);
      result->primaryColor = input->primaryColor;
    } while (false);
  }
}


// --- Union Serialization Helpers ---

// --- Structs for interface method parameters ---


// static
Activity_GetUserFeedback_ParamsPtr Activity_GetUserFeedback_Params::New() {
  Activity_GetUserFeedback_ParamsPtr rv;
  mojo::internal::StructHelper<Activity_GetUserFeedback_Params>::Initialize(&rv);
  return rv;
}

Activity_GetUserFeedback_Params::Activity_GetUserFeedback_Params()
    : user_feedback() {
}

Activity_GetUserFeedback_Params::~Activity_GetUserFeedback_Params() {
}



bool Activity_GetUserFeedback_Params::Equals(const Activity_GetUserFeedback_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::InterfaceRequest<UserFeedback>>::Equals(this->user_feedback, other.user_feedback))
    return false;
  return true;
}


size_t Activity_GetUserFeedback_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Activity_GetUserFeedback_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Activity_GetUserFeedback_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Activity_GetUserFeedback_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Activity_GetUserFeedback_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Activity_GetUserFeedback_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Activity_GetUserFeedback_Params_Data* input =
      static_cast<internal::Activity_GetUserFeedback_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Activity_GetUserFeedback_Params& input) {
  size_t size = sizeof(internal::Activity_GetUserFeedback_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Activity_GetUserFeedback_Params* input,
    mojo::internal::Buffer* buf,
    internal::Activity_GetUserFeedback_Params_Data** output) {
  if (input) {
    internal::Activity_GetUserFeedback_Params_Data* result =
        internal::Activity_GetUserFeedback_Params_Data::New(buf);
    result->user_feedback = input->user_feedback.PassMessagePipe().release();
    if (!result->user_feedback.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid user_feedback in Activity_GetUserFeedback_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Activity_GetUserFeedback_Params_Data* input,
                  Activity_GetUserFeedback_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->user_feedback.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&input->user_feedback)));
    } while (false);
  }
}



// static
Activity_StartActivity_ParamsPtr Activity_StartActivity_Params::New() {
  Activity_StartActivity_ParamsPtr rv;
  mojo::internal::StructHelper<Activity_StartActivity_Params>::Initialize(&rv);
  return rv;
}

Activity_StartActivity_Params::Activity_StartActivity_Params()
    : intent() {
}

Activity_StartActivity_Params::~Activity_StartActivity_Params() {
}


Activity_StartActivity_ParamsPtr Activity_StartActivity_Params::Clone() const {
  Activity_StartActivity_ParamsPtr rv(New());
  rv->intent = intent.Clone();
  return rv;
}


bool Activity_StartActivity_Params::Equals(const Activity_StartActivity_Params& other) const {
  if (!mojo::internal::ValueTraits<IntentPtr>::Equals(this->intent, other.intent))
    return false;
  return true;
}


size_t Activity_StartActivity_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Activity_StartActivity_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Activity_StartActivity_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Activity_StartActivity_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Activity_StartActivity_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Activity_StartActivity_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Activity_StartActivity_Params_Data* input =
      static_cast<internal::Activity_StartActivity_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Activity_StartActivity_Params& input) {
  size_t size = sizeof(internal::Activity_StartActivity_Params_Data);
  size += input.intent.is_null()
              ? 0
              : GetSerializedSize_(*input.intent);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Activity_StartActivity_Params* input,
    mojo::internal::Buffer* buf,
    internal::Activity_StartActivity_Params_Data** output) {
  if (input) {
    internal::Activity_StartActivity_Params_Data* result =
        internal::Activity_StartActivity_Params_Data::New(buf);
    {auto retval =Serialize_(input->intent.get(),
                 buf,
                 &result->intent.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->intent.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null intent in Activity_StartActivity_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Activity_StartActivity_Params_Data* input,
                  Activity_StartActivity_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->intent.ptr) {
        result->intent = Intent::New();
        Deserialize_(input->intent.ptr, result->intent.get());
      }
    } while (false);
  }
}



// static
Activity_FinishCurrentActivity_ParamsPtr Activity_FinishCurrentActivity_Params::New() {
  Activity_FinishCurrentActivity_ParamsPtr rv;
  mojo::internal::StructHelper<Activity_FinishCurrentActivity_Params>::Initialize(&rv);
  return rv;
}

Activity_FinishCurrentActivity_Params::Activity_FinishCurrentActivity_Params() {
}

Activity_FinishCurrentActivity_Params::~Activity_FinishCurrentActivity_Params() {
}


Activity_FinishCurrentActivity_ParamsPtr Activity_FinishCurrentActivity_Params::Clone() const {
  Activity_FinishCurrentActivity_ParamsPtr rv(New());
  return rv;
}


bool Activity_FinishCurrentActivity_Params::Equals(const Activity_FinishCurrentActivity_Params& other) const {
  return true;
}


size_t Activity_FinishCurrentActivity_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Activity_FinishCurrentActivity_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Activity_FinishCurrentActivity_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Activity_FinishCurrentActivity_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Activity_FinishCurrentActivity_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Activity_FinishCurrentActivity_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Activity_FinishCurrentActivity_Params_Data* input =
      static_cast<internal::Activity_FinishCurrentActivity_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Activity_FinishCurrentActivity_Params& input) {
  size_t size = sizeof(internal::Activity_FinishCurrentActivity_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Activity_FinishCurrentActivity_Params* input,
    mojo::internal::Buffer* buf,
    internal::Activity_FinishCurrentActivity_Params_Data** output) {
  if (input) {
    internal::Activity_FinishCurrentActivity_Params_Data* result =
        internal::Activity_FinishCurrentActivity_Params_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Activity_FinishCurrentActivity_Params_Data* input,
                  Activity_FinishCurrentActivity_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}



// static
Activity_SetTaskDescription_ParamsPtr Activity_SetTaskDescription_Params::New() {
  Activity_SetTaskDescription_ParamsPtr rv;
  mojo::internal::StructHelper<Activity_SetTaskDescription_Params>::Initialize(&rv);
  return rv;
}

Activity_SetTaskDescription_Params::Activity_SetTaskDescription_Params()
    : description() {
}

Activity_SetTaskDescription_Params::~Activity_SetTaskDescription_Params() {
}


Activity_SetTaskDescription_ParamsPtr Activity_SetTaskDescription_Params::Clone() const {
  Activity_SetTaskDescription_ParamsPtr rv(New());
  rv->description = description.Clone();
  return rv;
}


bool Activity_SetTaskDescription_Params::Equals(const Activity_SetTaskDescription_Params& other) const {
  if (!mojo::internal::ValueTraits<TaskDescriptionPtr>::Equals(this->description, other.description))
    return false;
  return true;
}


size_t Activity_SetTaskDescription_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Activity_SetTaskDescription_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Activity_SetTaskDescription_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Activity_SetTaskDescription_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Activity_SetTaskDescription_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Activity_SetTaskDescription_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Activity_SetTaskDescription_Params_Data* input =
      static_cast<internal::Activity_SetTaskDescription_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Activity_SetTaskDescription_Params& input) {
  size_t size = sizeof(internal::Activity_SetTaskDescription_Params_Data);
  size += input.description.is_null()
              ? 0
              : GetSerializedSize_(*input.description);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Activity_SetTaskDescription_Params* input,
    mojo::internal::Buffer* buf,
    internal::Activity_SetTaskDescription_Params_Data** output) {
  if (input) {
    internal::Activity_SetTaskDescription_Params_Data* result =
        internal::Activity_SetTaskDescription_Params_Data::New(buf);
    {auto retval =Serialize_(input->description.get(),
                 buf,
                 &result->description.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->description.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null description in Activity_SetTaskDescription_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Activity_SetTaskDescription_Params_Data* input,
                  Activity_SetTaskDescription_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->description.ptr) {
        result->description = TaskDescription::New();
        Deserialize_(input->description.ptr, result->description.get());
      }
    } while (false);
  }
}



// static
Activity_SetSystemUIVisibility_ParamsPtr Activity_SetSystemUIVisibility_Params::New() {
  Activity_SetSystemUIVisibility_ParamsPtr rv;
  mojo::internal::StructHelper<Activity_SetSystemUIVisibility_Params>::Initialize(&rv);
  return rv;
}

Activity_SetSystemUIVisibility_Params::Activity_SetSystemUIVisibility_Params()
    : visibility() {
}

Activity_SetSystemUIVisibility_Params::~Activity_SetSystemUIVisibility_Params() {
}


Activity_SetSystemUIVisibility_ParamsPtr Activity_SetSystemUIVisibility_Params::Clone() const {
  Activity_SetSystemUIVisibility_ParamsPtr rv(New());
  rv->visibility = visibility;
  return rv;
}


bool Activity_SetSystemUIVisibility_Params::Equals(const Activity_SetSystemUIVisibility_Params& other) const {
  if (!mojo::internal::ValueTraits<SystemUIVisibility>::Equals(this->visibility, other.visibility))
    return false;
  return true;
}


size_t Activity_SetSystemUIVisibility_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Activity_SetSystemUIVisibility_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Activity_SetSystemUIVisibility_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Activity_SetSystemUIVisibility_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Activity_SetSystemUIVisibility_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Activity_SetSystemUIVisibility_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Activity_SetSystemUIVisibility_Params_Data* input =
      static_cast<internal::Activity_SetSystemUIVisibility_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Activity_SetSystemUIVisibility_Params& input) {
  size_t size = sizeof(internal::Activity_SetSystemUIVisibility_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Activity_SetSystemUIVisibility_Params* input,
    mojo::internal::Buffer* buf,
    internal::Activity_SetSystemUIVisibility_Params_Data** output) {
  if (input) {
    internal::Activity_SetSystemUIVisibility_Params_Data* result =
        internal::Activity_SetSystemUIVisibility_Params_Data::New(buf);
    result->visibility =
      static_cast<int32_t>(input->visibility);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Activity_SetSystemUIVisibility_Params_Data* input,
                  Activity_SetSystemUIVisibility_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->visibility = static_cast<SystemUIVisibility>(input->visibility);
    } while (false);
  }
}



// static
Activity_SetRequestedOrientation_ParamsPtr Activity_SetRequestedOrientation_Params::New() {
  Activity_SetRequestedOrientation_ParamsPtr rv;
  mojo::internal::StructHelper<Activity_SetRequestedOrientation_Params>::Initialize(&rv);
  return rv;
}

Activity_SetRequestedOrientation_Params::Activity_SetRequestedOrientation_Params()
    : orientation() {
}

Activity_SetRequestedOrientation_Params::~Activity_SetRequestedOrientation_Params() {
}


Activity_SetRequestedOrientation_ParamsPtr Activity_SetRequestedOrientation_Params::Clone() const {
  Activity_SetRequestedOrientation_ParamsPtr rv(New());
  rv->orientation = orientation;
  return rv;
}


bool Activity_SetRequestedOrientation_Params::Equals(const Activity_SetRequestedOrientation_Params& other) const {
  if (!mojo::internal::ValueTraits<ScreenOrientation>::Equals(this->orientation, other.orientation))
    return false;
  return true;
}


size_t Activity_SetRequestedOrientation_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Activity_SetRequestedOrientation_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Activity_SetRequestedOrientation_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Activity_SetRequestedOrientation_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Activity_SetRequestedOrientation_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Activity_SetRequestedOrientation_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Activity_SetRequestedOrientation_Params_Data* input =
      static_cast<internal::Activity_SetRequestedOrientation_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Activity_SetRequestedOrientation_Params& input) {
  size_t size = sizeof(internal::Activity_SetRequestedOrientation_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Activity_SetRequestedOrientation_Params* input,
    mojo::internal::Buffer* buf,
    internal::Activity_SetRequestedOrientation_Params_Data** output) {
  if (input) {
    internal::Activity_SetRequestedOrientation_Params_Data* result =
        internal::Activity_SetRequestedOrientation_Params_Data::New(buf);
    result->orientation =
      static_cast<int32_t>(input->orientation);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Activity_SetRequestedOrientation_Params_Data* input,
                  Activity_SetRequestedOrientation_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->orientation = static_cast<ScreenOrientation>(input->orientation);
    } while (false);
  }
}



// static
PathService_GetAppDataDir_ParamsPtr PathService_GetAppDataDir_Params::New() {
  PathService_GetAppDataDir_ParamsPtr rv;
  mojo::internal::StructHelper<PathService_GetAppDataDir_Params>::Initialize(&rv);
  return rv;
}

PathService_GetAppDataDir_Params::PathService_GetAppDataDir_Params() {
}

PathService_GetAppDataDir_Params::~PathService_GetAppDataDir_Params() {
}


PathService_GetAppDataDir_ParamsPtr PathService_GetAppDataDir_Params::Clone() const {
  PathService_GetAppDataDir_ParamsPtr rv(New());
  return rv;
}


bool PathService_GetAppDataDir_Params::Equals(const PathService_GetAppDataDir_Params& other) const {
  return true;
}


size_t PathService_GetAppDataDir_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool PathService_GetAppDataDir_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::PathService_GetAppDataDir_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool PathService_GetAppDataDir_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::PathService_GetAppDataDir_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void PathService_GetAppDataDir_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::PathService_GetAppDataDir_Params_Data* input =
      static_cast<internal::PathService_GetAppDataDir_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const PathService_GetAppDataDir_Params& input) {
  size_t size = sizeof(internal::PathService_GetAppDataDir_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    PathService_GetAppDataDir_Params* input,
    mojo::internal::Buffer* buf,
    internal::PathService_GetAppDataDir_Params_Data** output) {
  if (input) {
    internal::PathService_GetAppDataDir_Params_Data* result =
        internal::PathService_GetAppDataDir_Params_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::PathService_GetAppDataDir_Params_Data* input,
                  PathService_GetAppDataDir_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


// static
PathService_GetAppDataDir_ResponseParamsPtr PathService_GetAppDataDir_ResponseParams::New() {
  PathService_GetAppDataDir_ResponseParamsPtr rv;
  mojo::internal::StructHelper<PathService_GetAppDataDir_ResponseParams>::Initialize(&rv);
  return rv;
}

PathService_GetAppDataDir_ResponseParams::PathService_GetAppDataDir_ResponseParams()
    : path() {
}

PathService_GetAppDataDir_ResponseParams::~PathService_GetAppDataDir_ResponseParams() {
}


PathService_GetAppDataDir_ResponseParamsPtr PathService_GetAppDataDir_ResponseParams::Clone() const {
  PathService_GetAppDataDir_ResponseParamsPtr rv(New());
  rv->path = path;
  return rv;
}


bool PathService_GetAppDataDir_ResponseParams::Equals(const PathService_GetAppDataDir_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->path, other.path))
    return false;
  return true;
}


size_t PathService_GetAppDataDir_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool PathService_GetAppDataDir_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::PathService_GetAppDataDir_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool PathService_GetAppDataDir_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::PathService_GetAppDataDir_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void PathService_GetAppDataDir_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::PathService_GetAppDataDir_ResponseParams_Data* input =
      static_cast<internal::PathService_GetAppDataDir_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const PathService_GetAppDataDir_ResponseParams& input) {
  size_t size = sizeof(internal::PathService_GetAppDataDir_ResponseParams_Data);
  size += GetSerializedSize_(input.path);
  return size;
}

mojo::internal::ValidationError Serialize_(
    PathService_GetAppDataDir_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::PathService_GetAppDataDir_ResponseParams_Data** output) {
  if (input) {
    internal::PathService_GetAppDataDir_ResponseParams_Data* result =
        internal::PathService_GetAppDataDir_ResponseParams_Data::New(buf);
    SerializeString_(input->path, buf, &result->path.ptr);
    if (!result->path.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null path in PathService_GetAppDataDir_ResponseParams struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::PathService_GetAppDataDir_ResponseParams_Data* input,
                  PathService_GetAppDataDir_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->path.ptr, &result->path);
    } while (false);
  }
}



// static
PathService_GetFilesDir_ParamsPtr PathService_GetFilesDir_Params::New() {
  PathService_GetFilesDir_ParamsPtr rv;
  mojo::internal::StructHelper<PathService_GetFilesDir_Params>::Initialize(&rv);
  return rv;
}

PathService_GetFilesDir_Params::PathService_GetFilesDir_Params() {
}

PathService_GetFilesDir_Params::~PathService_GetFilesDir_Params() {
}


PathService_GetFilesDir_ParamsPtr PathService_GetFilesDir_Params::Clone() const {
  PathService_GetFilesDir_ParamsPtr rv(New());
  return rv;
}


bool PathService_GetFilesDir_Params::Equals(const PathService_GetFilesDir_Params& other) const {
  return true;
}


size_t PathService_GetFilesDir_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool PathService_GetFilesDir_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::PathService_GetFilesDir_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool PathService_GetFilesDir_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::PathService_GetFilesDir_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void PathService_GetFilesDir_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::PathService_GetFilesDir_Params_Data* input =
      static_cast<internal::PathService_GetFilesDir_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const PathService_GetFilesDir_Params& input) {
  size_t size = sizeof(internal::PathService_GetFilesDir_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    PathService_GetFilesDir_Params* input,
    mojo::internal::Buffer* buf,
    internal::PathService_GetFilesDir_Params_Data** output) {
  if (input) {
    internal::PathService_GetFilesDir_Params_Data* result =
        internal::PathService_GetFilesDir_Params_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::PathService_GetFilesDir_Params_Data* input,
                  PathService_GetFilesDir_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


// static
PathService_GetFilesDir_ResponseParamsPtr PathService_GetFilesDir_ResponseParams::New() {
  PathService_GetFilesDir_ResponseParamsPtr rv;
  mojo::internal::StructHelper<PathService_GetFilesDir_ResponseParams>::Initialize(&rv);
  return rv;
}

PathService_GetFilesDir_ResponseParams::PathService_GetFilesDir_ResponseParams()
    : path() {
}

PathService_GetFilesDir_ResponseParams::~PathService_GetFilesDir_ResponseParams() {
}


PathService_GetFilesDir_ResponseParamsPtr PathService_GetFilesDir_ResponseParams::Clone() const {
  PathService_GetFilesDir_ResponseParamsPtr rv(New());
  rv->path = path;
  return rv;
}


bool PathService_GetFilesDir_ResponseParams::Equals(const PathService_GetFilesDir_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->path, other.path))
    return false;
  return true;
}


size_t PathService_GetFilesDir_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool PathService_GetFilesDir_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::PathService_GetFilesDir_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool PathService_GetFilesDir_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::PathService_GetFilesDir_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void PathService_GetFilesDir_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::PathService_GetFilesDir_ResponseParams_Data* input =
      static_cast<internal::PathService_GetFilesDir_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const PathService_GetFilesDir_ResponseParams& input) {
  size_t size = sizeof(internal::PathService_GetFilesDir_ResponseParams_Data);
  size += GetSerializedSize_(input.path);
  return size;
}

mojo::internal::ValidationError Serialize_(
    PathService_GetFilesDir_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::PathService_GetFilesDir_ResponseParams_Data** output) {
  if (input) {
    internal::PathService_GetFilesDir_ResponseParams_Data* result =
        internal::PathService_GetFilesDir_ResponseParams_Data::New(buf);
    SerializeString_(input->path, buf, &result->path.ptr);
    if (!result->path.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null path in PathService_GetFilesDir_ResponseParams struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::PathService_GetFilesDir_ResponseParams_Data* input,
                  PathService_GetFilesDir_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->path.ptr, &result->path);
    } while (false);
  }
}



// static
PathService_GetCacheDir_ParamsPtr PathService_GetCacheDir_Params::New() {
  PathService_GetCacheDir_ParamsPtr rv;
  mojo::internal::StructHelper<PathService_GetCacheDir_Params>::Initialize(&rv);
  return rv;
}

PathService_GetCacheDir_Params::PathService_GetCacheDir_Params() {
}

PathService_GetCacheDir_Params::~PathService_GetCacheDir_Params() {
}


PathService_GetCacheDir_ParamsPtr PathService_GetCacheDir_Params::Clone() const {
  PathService_GetCacheDir_ParamsPtr rv(New());
  return rv;
}


bool PathService_GetCacheDir_Params::Equals(const PathService_GetCacheDir_Params& other) const {
  return true;
}


size_t PathService_GetCacheDir_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool PathService_GetCacheDir_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::PathService_GetCacheDir_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool PathService_GetCacheDir_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::PathService_GetCacheDir_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void PathService_GetCacheDir_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::PathService_GetCacheDir_Params_Data* input =
      static_cast<internal::PathService_GetCacheDir_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const PathService_GetCacheDir_Params& input) {
  size_t size = sizeof(internal::PathService_GetCacheDir_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    PathService_GetCacheDir_Params* input,
    mojo::internal::Buffer* buf,
    internal::PathService_GetCacheDir_Params_Data** output) {
  if (input) {
    internal::PathService_GetCacheDir_Params_Data* result =
        internal::PathService_GetCacheDir_Params_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::PathService_GetCacheDir_Params_Data* input,
                  PathService_GetCacheDir_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


// static
PathService_GetCacheDir_ResponseParamsPtr PathService_GetCacheDir_ResponseParams::New() {
  PathService_GetCacheDir_ResponseParamsPtr rv;
  mojo::internal::StructHelper<PathService_GetCacheDir_ResponseParams>::Initialize(&rv);
  return rv;
}

PathService_GetCacheDir_ResponseParams::PathService_GetCacheDir_ResponseParams()
    : path() {
}

PathService_GetCacheDir_ResponseParams::~PathService_GetCacheDir_ResponseParams() {
}


PathService_GetCacheDir_ResponseParamsPtr PathService_GetCacheDir_ResponseParams::Clone() const {
  PathService_GetCacheDir_ResponseParamsPtr rv(New());
  rv->path = path;
  return rv;
}


bool PathService_GetCacheDir_ResponseParams::Equals(const PathService_GetCacheDir_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->path, other.path))
    return false;
  return true;
}


size_t PathService_GetCacheDir_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool PathService_GetCacheDir_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::PathService_GetCacheDir_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool PathService_GetCacheDir_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::PathService_GetCacheDir_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void PathService_GetCacheDir_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::PathService_GetCacheDir_ResponseParams_Data* input =
      static_cast<internal::PathService_GetCacheDir_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const PathService_GetCacheDir_ResponseParams& input) {
  size_t size = sizeof(internal::PathService_GetCacheDir_ResponseParams_Data);
  size += GetSerializedSize_(input.path);
  return size;
}

mojo::internal::ValidationError Serialize_(
    PathService_GetCacheDir_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::PathService_GetCacheDir_ResponseParams_Data** output) {
  if (input) {
    internal::PathService_GetCacheDir_ResponseParams_Data* result =
        internal::PathService_GetCacheDir_ResponseParams_Data::New(buf);
    SerializeString_(input->path, buf, &result->path.ptr);
    if (!result->path.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null path in PathService_GetCacheDir_ResponseParams struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::PathService_GetCacheDir_ResponseParams_Data* input,
                  PathService_GetCacheDir_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->path.ptr, &result->path);
    } while (false);
  }
}



// static
UserFeedback_PerformHapticFeedback_ParamsPtr UserFeedback_PerformHapticFeedback_Params::New() {
  UserFeedback_PerformHapticFeedback_ParamsPtr rv;
  mojo::internal::StructHelper<UserFeedback_PerformHapticFeedback_Params>::Initialize(&rv);
  return rv;
}

UserFeedback_PerformHapticFeedback_Params::UserFeedback_PerformHapticFeedback_Params()
    : type() {
}

UserFeedback_PerformHapticFeedback_Params::~UserFeedback_PerformHapticFeedback_Params() {
}


UserFeedback_PerformHapticFeedback_ParamsPtr UserFeedback_PerformHapticFeedback_Params::Clone() const {
  UserFeedback_PerformHapticFeedback_ParamsPtr rv(New());
  rv->type = type;
  return rv;
}


bool UserFeedback_PerformHapticFeedback_Params::Equals(const UserFeedback_PerformHapticFeedback_Params& other) const {
  if (!mojo::internal::ValueTraits<HapticFeedbackType>::Equals(this->type, other.type))
    return false;
  return true;
}


size_t UserFeedback_PerformHapticFeedback_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool UserFeedback_PerformHapticFeedback_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::UserFeedback_PerformHapticFeedback_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool UserFeedback_PerformHapticFeedback_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::UserFeedback_PerformHapticFeedback_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void UserFeedback_PerformHapticFeedback_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::UserFeedback_PerformHapticFeedback_Params_Data* input =
      static_cast<internal::UserFeedback_PerformHapticFeedback_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const UserFeedback_PerformHapticFeedback_Params& input) {
  size_t size = sizeof(internal::UserFeedback_PerformHapticFeedback_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    UserFeedback_PerformHapticFeedback_Params* input,
    mojo::internal::Buffer* buf,
    internal::UserFeedback_PerformHapticFeedback_Params_Data** output) {
  if (input) {
    internal::UserFeedback_PerformHapticFeedback_Params_Data* result =
        internal::UserFeedback_PerformHapticFeedback_Params_Data::New(buf);
    result->type =
      static_cast<int32_t>(input->type);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::UserFeedback_PerformHapticFeedback_Params_Data* input,
                  UserFeedback_PerformHapticFeedback_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->type = static_cast<HapticFeedbackType>(input->type);
    } while (false);
  }
}



// static
UserFeedback_PerformAuralFeedback_ParamsPtr UserFeedback_PerformAuralFeedback_Params::New() {
  UserFeedback_PerformAuralFeedback_ParamsPtr rv;
  mojo::internal::StructHelper<UserFeedback_PerformAuralFeedback_Params>::Initialize(&rv);
  return rv;
}

UserFeedback_PerformAuralFeedback_Params::UserFeedback_PerformAuralFeedback_Params()
    : type() {
}

UserFeedback_PerformAuralFeedback_Params::~UserFeedback_PerformAuralFeedback_Params() {
}


UserFeedback_PerformAuralFeedback_ParamsPtr UserFeedback_PerformAuralFeedback_Params::Clone() const {
  UserFeedback_PerformAuralFeedback_ParamsPtr rv(New());
  rv->type = type;
  return rv;
}


bool UserFeedback_PerformAuralFeedback_Params::Equals(const UserFeedback_PerformAuralFeedback_Params& other) const {
  if (!mojo::internal::ValueTraits<AuralFeedbackType>::Equals(this->type, other.type))
    return false;
  return true;
}


size_t UserFeedback_PerformAuralFeedback_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool UserFeedback_PerformAuralFeedback_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::UserFeedback_PerformAuralFeedback_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool UserFeedback_PerformAuralFeedback_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::UserFeedback_PerformAuralFeedback_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void UserFeedback_PerformAuralFeedback_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::UserFeedback_PerformAuralFeedback_Params_Data* input =
      static_cast<internal::UserFeedback_PerformAuralFeedback_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const UserFeedback_PerformAuralFeedback_Params& input) {
  size_t size = sizeof(internal::UserFeedback_PerformAuralFeedback_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    UserFeedback_PerformAuralFeedback_Params* input,
    mojo::internal::Buffer* buf,
    internal::UserFeedback_PerformAuralFeedback_Params_Data** output) {
  if (input) {
    internal::UserFeedback_PerformAuralFeedback_Params_Data* result =
        internal::UserFeedback_PerformAuralFeedback_Params_Data::New(buf);
    result->type =
      static_cast<int32_t>(input->type);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::UserFeedback_PerformAuralFeedback_Params_Data* input,
                  UserFeedback_PerformAuralFeedback_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->type = static_cast<AuralFeedbackType>(input->type);
    } while (false);
  }
}

}  // namespace activity
