// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/services/surfaces/interfaces/quads.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace mojo {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// static
Color_Data* Color_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Color_Data))) Color_Data();
}

// static
mojo::internal::ValidationError Color_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Color_Data* object = static_cast<const Color_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void Color_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void Color_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

Color_Data::Color_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
CheckerboardQuadState_Data* CheckerboardQuadState_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(CheckerboardQuadState_Data))) CheckerboardQuadState_Data();
}

// static
mojo::internal::ValidationError CheckerboardQuadState_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const CheckerboardQuadState_Data* object = static_cast<const CheckerboardQuadState_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void CheckerboardQuadState_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void CheckerboardQuadState_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

CheckerboardQuadState_Data::CheckerboardQuadState_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
DebugBorderQuadState_Data* DebugBorderQuadState_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(DebugBorderQuadState_Data))) DebugBorderQuadState_Data();
}

// static
mojo::internal::ValidationError DebugBorderQuadState_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const DebugBorderQuadState_Data* object = static_cast<const DebugBorderQuadState_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void DebugBorderQuadState_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void DebugBorderQuadState_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

DebugBorderQuadState_Data::DebugBorderQuadState_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
IoSurfaceContentQuadState_Data* IoSurfaceContentQuadState_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(IoSurfaceContentQuadState_Data))) IoSurfaceContentQuadState_Data();
}

// static
mojo::internal::ValidationError IoSurfaceContentQuadState_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const IoSurfaceContentQuadState_Data* object = static_cast<const IoSurfaceContentQuadState_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void IoSurfaceContentQuadState_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void IoSurfaceContentQuadState_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

IoSurfaceContentQuadState_Data::IoSurfaceContentQuadState_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
RenderPassId_Data* RenderPassId_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(RenderPassId_Data))) RenderPassId_Data();
}

// static
mojo::internal::ValidationError RenderPassId_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const RenderPassId_Data* object = static_cast<const RenderPassId_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void RenderPassId_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void RenderPassId_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

RenderPassId_Data::RenderPassId_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
RenderPassQuadState_Data* RenderPassQuadState_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(RenderPassQuadState_Data))) RenderPassQuadState_Data();
}

// static
mojo::internal::ValidationError RenderPassQuadState_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const RenderPassQuadState_Data* object = static_cast<const RenderPassQuadState_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 48 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->render_pass_id.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null render_pass_id field in RenderPassQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->render_pass_id.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = RenderPassId::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->render_pass_id.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->mask_uv_scale.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null mask_uv_scale field in RenderPassQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->mask_uv_scale.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::PointF::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->mask_uv_scale.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->mask_texture_size.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null mask_texture_size field in RenderPassQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->mask_texture_size.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::Size::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->mask_texture_size.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->filters_scale.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null filters_scale field in RenderPassQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->filters_scale.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::PointF::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->filters_scale.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void RenderPassQuadState_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->render_pass_id, handles);
  mojo::internal::Encode(&this->mask_uv_scale, handles);
  mojo::internal::Encode(&this->mask_texture_size, handles);
  mojo::internal::Encode(&this->filters_scale, handles);
}

void RenderPassQuadState_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->render_pass_id, handles);
  mojo::internal::Decode(&this->mask_uv_scale, handles);
  mojo::internal::Decode(&this->mask_texture_size, handles);
  mojo::internal::Decode(&this->filters_scale, handles);
}

RenderPassQuadState_Data::RenderPassQuadState_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
SolidColorQuadState_Data* SolidColorQuadState_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(SolidColorQuadState_Data))) SolidColorQuadState_Data();
}

// static
mojo::internal::ValidationError SolidColorQuadState_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const SolidColorQuadState_Data* object = static_cast<const SolidColorQuadState_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->color.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null color field in SolidColorQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->color.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = Color::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->color.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void SolidColorQuadState_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->color, handles);
}

void SolidColorQuadState_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->color, handles);
}

SolidColorQuadState_Data::SolidColorQuadState_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
SurfaceQuadState_Data* SurfaceQuadState_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(SurfaceQuadState_Data))) SurfaceQuadState_Data();
}

// static
mojo::internal::ValidationError SurfaceQuadState_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const SurfaceQuadState_Data* object = static_cast<const SurfaceQuadState_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->surface.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null surface field in SurfaceQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->surface.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::SurfaceId::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->surface.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void SurfaceQuadState_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->surface, handles);
}

void SurfaceQuadState_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->surface, handles);
}

SurfaceQuadState_Data::SurfaceQuadState_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
TextureQuadState_Data* TextureQuadState_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(TextureQuadState_Data))) TextureQuadState_Data();
}

// static
mojo::internal::ValidationError TextureQuadState_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const TextureQuadState_Data* object = static_cast<const TextureQuadState_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 48 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->uv_top_left.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null uv_top_left field in TextureQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->uv_top_left.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::PointF::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->uv_top_left.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->uv_bottom_right.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null uv_bottom_right field in TextureQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->uv_bottom_right.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::PointF::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->uv_bottom_right.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->background_color.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null background_color field in TextureQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->background_color.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = Color::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->background_color.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->vertex_opacity.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null vertex_opacity field in TextureQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->vertex_opacity.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams vertex_opacity_validate_params(
      4, false, nullptr);
  auto validate_retval =
      mojo::Array<float>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->vertex_opacity.offset),
          bounds_checker, &vertex_opacity_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void TextureQuadState_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->uv_top_left, handles);
  mojo::internal::Encode(&this->uv_bottom_right, handles);
  mojo::internal::Encode(&this->background_color, handles);
  mojo::internal::Encode(&this->vertex_opacity, handles);
}

void TextureQuadState_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->uv_top_left, handles);
  mojo::internal::Decode(&this->uv_bottom_right, handles);
  mojo::internal::Decode(&this->background_color, handles);
  mojo::internal::Decode(&this->vertex_opacity, handles);
}

TextureQuadState_Data::TextureQuadState_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
TileQuadState_Data* TileQuadState_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(TileQuadState_Data))) TileQuadState_Data();
}

// static
mojo::internal::ValidationError TileQuadState_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const TileQuadState_Data* object = static_cast<const TileQuadState_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->tex_coord_rect.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null tex_coord_rect field in TileQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->tex_coord_rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::RectF::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->tex_coord_rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->texture_size.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null texture_size field in TileQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->texture_size.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::Size::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->texture_size.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void TileQuadState_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->tex_coord_rect, handles);
  mojo::internal::Encode(&this->texture_size, handles);
}

void TileQuadState_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->tex_coord_rect, handles);
  mojo::internal::Decode(&this->texture_size, handles);
}

TileQuadState_Data::TileQuadState_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StreamVideoQuadState_Data* StreamVideoQuadState_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StreamVideoQuadState_Data))) StreamVideoQuadState_Data();
}

// static
mojo::internal::ValidationError StreamVideoQuadState_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StreamVideoQuadState_Data* object = static_cast<const StreamVideoQuadState_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void StreamVideoQuadState_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void StreamVideoQuadState_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

StreamVideoQuadState_Data::StreamVideoQuadState_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
YUVVideoQuadState_Data* YUVVideoQuadState_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(YUVVideoQuadState_Data))) YUVVideoQuadState_Data();
}

// static
mojo::internal::ValidationError YUVVideoQuadState_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const YUVVideoQuadState_Data* object = static_cast<const YUVVideoQuadState_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 40 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->tex_coord_rect.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null tex_coord_rect field in YUVVideoQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->tex_coord_rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::RectF::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->tex_coord_rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void YUVVideoQuadState_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->tex_coord_rect, handles);
}

void YUVVideoQuadState_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->tex_coord_rect, handles);
}

YUVVideoQuadState_Data::YUVVideoQuadState_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
Quad_Data* Quad_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Quad_Data))) Quad_Data();
}

// static
mojo::internal::ValidationError Quad_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Quad_Data* object = static_cast<const Quad_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 128 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->rect.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null rect field in Quad struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->opaque_rect.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null opaque_rect field in Quad struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->opaque_rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->opaque_rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->visible_rect.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null visible_rect field in Quad struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->visible_rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->visible_rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->checkerboard_quad_state.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = CheckerboardQuadState::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->checkerboard_quad_state.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->debug_border_quad_state.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = DebugBorderQuadState::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->debug_border_quad_state.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->io_surface_quad_state.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = IoSurfaceContentQuadState::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->io_surface_quad_state.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->render_pass_quad_state.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = RenderPassQuadState::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->render_pass_quad_state.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->solid_color_quad_state.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = SolidColorQuadState::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->solid_color_quad_state.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->surface_quad_state.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = SurfaceQuadState::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->surface_quad_state.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->texture_quad_state.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = TextureQuadState::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->texture_quad_state.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->tile_quad_state.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = TileQuadState::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->tile_quad_state.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->stream_video_quad_state.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = StreamVideoQuadState::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->stream_video_quad_state.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->yuv_video_quad_state.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = YUVVideoQuadState::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->yuv_video_quad_state.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Quad_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->rect, handles);
  mojo::internal::Encode(&this->opaque_rect, handles);
  mojo::internal::Encode(&this->visible_rect, handles);
  mojo::internal::Encode(&this->checkerboard_quad_state, handles);
  mojo::internal::Encode(&this->debug_border_quad_state, handles);
  mojo::internal::Encode(&this->io_surface_quad_state, handles);
  mojo::internal::Encode(&this->render_pass_quad_state, handles);
  mojo::internal::Encode(&this->solid_color_quad_state, handles);
  mojo::internal::Encode(&this->surface_quad_state, handles);
  mojo::internal::Encode(&this->texture_quad_state, handles);
  mojo::internal::Encode(&this->tile_quad_state, handles);
  mojo::internal::Encode(&this->stream_video_quad_state, handles);
  mojo::internal::Encode(&this->yuv_video_quad_state, handles);
}

void Quad_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->rect, handles);
  mojo::internal::Decode(&this->opaque_rect, handles);
  mojo::internal::Decode(&this->visible_rect, handles);
  mojo::internal::Decode(&this->checkerboard_quad_state, handles);
  mojo::internal::Decode(&this->debug_border_quad_state, handles);
  mojo::internal::Decode(&this->io_surface_quad_state, handles);
  mojo::internal::Decode(&this->render_pass_quad_state, handles);
  mojo::internal::Decode(&this->solid_color_quad_state, handles);
  mojo::internal::Decode(&this->surface_quad_state, handles);
  mojo::internal::Decode(&this->texture_quad_state, handles);
  mojo::internal::Decode(&this->tile_quad_state, handles);
  mojo::internal::Decode(&this->stream_video_quad_state, handles);
  mojo::internal::Decode(&this->yuv_video_quad_state, handles);
}

Quad_Data::Quad_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
SharedQuadState_Data* SharedQuadState_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(SharedQuadState_Data))) SharedQuadState_Data();
}

// static
mojo::internal::ValidationError SharedQuadState_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const SharedQuadState_Data* object = static_cast<const SharedQuadState_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 56 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->content_to_target_transform.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null content_to_target_transform field in SharedQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->content_to_target_transform.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::Transform::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->content_to_target_transform.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->content_bounds.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null content_bounds field in SharedQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->content_bounds.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::Size::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->content_bounds.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->visible_content_rect.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null visible_content_rect field in SharedQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->visible_content_rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->visible_content_rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->clip_rect.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null clip_rect field in SharedQuadState struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->clip_rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->clip_rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void SharedQuadState_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->content_to_target_transform, handles);
  mojo::internal::Encode(&this->content_bounds, handles);
  mojo::internal::Encode(&this->visible_content_rect, handles);
  mojo::internal::Encode(&this->clip_rect, handles);
}

void SharedQuadState_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->content_to_target_transform, handles);
  mojo::internal::Decode(&this->content_bounds, handles);
  mojo::internal::Decode(&this->visible_content_rect, handles);
  mojo::internal::Decode(&this->clip_rect, handles);
}

SharedQuadState_Data::SharedQuadState_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
Pass_Data* Pass_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Pass_Data))) Pass_Data();
}

// static
mojo::internal::ValidationError Pass_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Pass_Data* object = static_cast<const Pass_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 56 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->output_rect.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null output_rect field in Pass struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->output_rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->output_rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->damage_rect.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null damage_rect field in Pass struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->damage_rect.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::Rect::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->damage_rect.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->transform_to_root_target.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null transform_to_root_target field in Pass struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->transform_to_root_target.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = mojo::Transform::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->transform_to_root_target.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->quads.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null quads field in Pass struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->quads.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams quads_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<QuadPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->quads.offset),
          bounds_checker, &quads_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->shared_quad_states.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null shared_quad_states field in Pass struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->shared_quad_states.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams shared_quad_states_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<SharedQuadStatePtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->shared_quad_states.offset),
          bounds_checker, &shared_quad_states_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Pass_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->output_rect, handles);
  mojo::internal::Encode(&this->damage_rect, handles);
  mojo::internal::Encode(&this->transform_to_root_target, handles);
  mojo::internal::Encode(&this->quads, handles);
  mojo::internal::Encode(&this->shared_quad_states, handles);
}

void Pass_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->output_rect, handles);
  mojo::internal::Decode(&this->damage_rect, handles);
  mojo::internal::Decode(&this->transform_to_root_target, handles);
  mojo::internal::Decode(&this->quads, handles);
  mojo::internal::Decode(&this->shared_quad_states, handles);
}

Pass_Data::Pass_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// --- Union definitions ---


// --- Definitions of the data structs for interface methods ---

}  // namespace internal

// --- Request and response validator definitions for interfaces --- 

// --- Enums ---
bool YUVColorSpace_IsValidValue(YUVColorSpace value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const YUVColorSpace& val) {
  return (stream << static_cast<int32_t>(val));
}
bool Material_IsValidValue(Material value) {
  switch (static_cast<int32_t>(value)) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const Material& val) {
  return (stream << static_cast<int32_t>(val));
}
bool SkXfermode_IsValidValue(SkXfermode value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const SkXfermode& val) {
  return (stream << static_cast<int32_t>(val));
}

// Base interface definitions (Name_, Version_, Constants, Enums)

// Struct Constants

// --- Struct builder definitions ---

// static
ColorPtr Color::New() {
  ColorPtr rv;
  mojo::internal::StructHelper<Color>::Initialize(&rv);
  return rv;
}

Color::Color()
    : rgba() {
}

Color::~Color() {
}


ColorPtr Color::Clone() const {
  ColorPtr rv(New());
  rv->rgba = rgba;
  return rv;
}


bool Color::Equals(const Color& other) const {
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->rgba, other.rgba))
    return false;
  return true;
}


// static
CheckerboardQuadStatePtr CheckerboardQuadState::New() {
  CheckerboardQuadStatePtr rv;
  mojo::internal::StructHelper<CheckerboardQuadState>::Initialize(&rv);
  return rv;
}

CheckerboardQuadState::CheckerboardQuadState() {
}

CheckerboardQuadState::~CheckerboardQuadState() {
}


CheckerboardQuadStatePtr CheckerboardQuadState::Clone() const {
  CheckerboardQuadStatePtr rv(New());
  return rv;
}


bool CheckerboardQuadState::Equals(const CheckerboardQuadState& other) const {
  return true;
}


// static
DebugBorderQuadStatePtr DebugBorderQuadState::New() {
  DebugBorderQuadStatePtr rv;
  mojo::internal::StructHelper<DebugBorderQuadState>::Initialize(&rv);
  return rv;
}

DebugBorderQuadState::DebugBorderQuadState() {
}

DebugBorderQuadState::~DebugBorderQuadState() {
}


DebugBorderQuadStatePtr DebugBorderQuadState::Clone() const {
  DebugBorderQuadStatePtr rv(New());
  return rv;
}


bool DebugBorderQuadState::Equals(const DebugBorderQuadState& other) const {
  return true;
}


// static
IoSurfaceContentQuadStatePtr IoSurfaceContentQuadState::New() {
  IoSurfaceContentQuadStatePtr rv;
  mojo::internal::StructHelper<IoSurfaceContentQuadState>::Initialize(&rv);
  return rv;
}

IoSurfaceContentQuadState::IoSurfaceContentQuadState() {
}

IoSurfaceContentQuadState::~IoSurfaceContentQuadState() {
}


IoSurfaceContentQuadStatePtr IoSurfaceContentQuadState::Clone() const {
  IoSurfaceContentQuadStatePtr rv(New());
  return rv;
}


bool IoSurfaceContentQuadState::Equals(const IoSurfaceContentQuadState& other) const {
  return true;
}


// static
RenderPassIdPtr RenderPassId::New() {
  RenderPassIdPtr rv;
  mojo::internal::StructHelper<RenderPassId>::Initialize(&rv);
  return rv;
}

RenderPassId::RenderPassId()
    : layer_id(),
      index() {
}

RenderPassId::~RenderPassId() {
}


RenderPassIdPtr RenderPassId::Clone() const {
  RenderPassIdPtr rv(New());
  rv->layer_id = layer_id;
  rv->index = index;
  return rv;
}


bool RenderPassId::Equals(const RenderPassId& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->layer_id, other.layer_id))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->index, other.index))
    return false;
  return true;
}


// static
RenderPassQuadStatePtr RenderPassQuadState::New() {
  RenderPassQuadStatePtr rv;
  mojo::internal::StructHelper<RenderPassQuadState>::Initialize(&rv);
  return rv;
}

RenderPassQuadState::RenderPassQuadState()
    : render_pass_id(),
      mask_resource_id(),
      mask_uv_scale(),
      mask_texture_size(),
      filters_scale() {
}

RenderPassQuadState::~RenderPassQuadState() {
}


RenderPassQuadStatePtr RenderPassQuadState::Clone() const {
  RenderPassQuadStatePtr rv(New());
  rv->render_pass_id = render_pass_id.Clone();
  rv->mask_resource_id = mask_resource_id;
  rv->mask_uv_scale = mask_uv_scale.Clone();
  rv->mask_texture_size = mask_texture_size.Clone();
  rv->filters_scale = filters_scale.Clone();
  return rv;
}


bool RenderPassQuadState::Equals(const RenderPassQuadState& other) const {
  if (!mojo::internal::ValueTraits<RenderPassIdPtr>::Equals(this->render_pass_id, other.render_pass_id))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->mask_resource_id, other.mask_resource_id))
    return false;
  if (!mojo::internal::ValueTraits<mojo::PointFPtr>::Equals(this->mask_uv_scale, other.mask_uv_scale))
    return false;
  if (!mojo::internal::ValueTraits<mojo::SizePtr>::Equals(this->mask_texture_size, other.mask_texture_size))
    return false;
  if (!mojo::internal::ValueTraits<mojo::PointFPtr>::Equals(this->filters_scale, other.filters_scale))
    return false;
  return true;
}


// static
SolidColorQuadStatePtr SolidColorQuadState::New() {
  SolidColorQuadStatePtr rv;
  mojo::internal::StructHelper<SolidColorQuadState>::Initialize(&rv);
  return rv;
}

SolidColorQuadState::SolidColorQuadState()
    : color(),
      force_anti_aliasing_off() {
}

SolidColorQuadState::~SolidColorQuadState() {
}


SolidColorQuadStatePtr SolidColorQuadState::Clone() const {
  SolidColorQuadStatePtr rv(New());
  rv->color = color.Clone();
  rv->force_anti_aliasing_off = force_anti_aliasing_off;
  return rv;
}


bool SolidColorQuadState::Equals(const SolidColorQuadState& other) const {
  if (!mojo::internal::ValueTraits<ColorPtr>::Equals(this->color, other.color))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->force_anti_aliasing_off, other.force_anti_aliasing_off))
    return false;
  return true;
}


// static
SurfaceQuadStatePtr SurfaceQuadState::New() {
  SurfaceQuadStatePtr rv;
  mojo::internal::StructHelper<SurfaceQuadState>::Initialize(&rv);
  return rv;
}

SurfaceQuadState::SurfaceQuadState()
    : surface() {
}

SurfaceQuadState::~SurfaceQuadState() {
}


SurfaceQuadStatePtr SurfaceQuadState::Clone() const {
  SurfaceQuadStatePtr rv(New());
  rv->surface = surface.Clone();
  return rv;
}


bool SurfaceQuadState::Equals(const SurfaceQuadState& other) const {
  if (!mojo::internal::ValueTraits<mojo::SurfaceIdPtr>::Equals(this->surface, other.surface))
    return false;
  return true;
}


// static
TextureQuadStatePtr TextureQuadState::New() {
  TextureQuadStatePtr rv;
  mojo::internal::StructHelper<TextureQuadState>::Initialize(&rv);
  return rv;
}

TextureQuadState::TextureQuadState()
    : resource_id(),
      premultiplied_alpha(),
      uv_top_left(),
      uv_bottom_right(),
      background_color(),
      vertex_opacity(),
      flipped(),
      nearest_neighbor() {
}

TextureQuadState::~TextureQuadState() {
}


TextureQuadStatePtr TextureQuadState::Clone() const {
  TextureQuadStatePtr rv(New());
  rv->resource_id = resource_id;
  rv->premultiplied_alpha = premultiplied_alpha;
  rv->uv_top_left = uv_top_left.Clone();
  rv->uv_bottom_right = uv_bottom_right.Clone();
  rv->background_color = background_color.Clone();
  rv->vertex_opacity = vertex_opacity.Clone();
  rv->flipped = flipped;
  rv->nearest_neighbor = nearest_neighbor;
  return rv;
}


bool TextureQuadState::Equals(const TextureQuadState& other) const {
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->resource_id, other.resource_id))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->premultiplied_alpha, other.premultiplied_alpha))
    return false;
  if (!mojo::internal::ValueTraits<mojo::PointFPtr>::Equals(this->uv_top_left, other.uv_top_left))
    return false;
  if (!mojo::internal::ValueTraits<mojo::PointFPtr>::Equals(this->uv_bottom_right, other.uv_bottom_right))
    return false;
  if (!mojo::internal::ValueTraits<ColorPtr>::Equals(this->background_color, other.background_color))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<float>>::Equals(this->vertex_opacity, other.vertex_opacity))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->flipped, other.flipped))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->nearest_neighbor, other.nearest_neighbor))
    return false;
  return true;
}


// static
TileQuadStatePtr TileQuadState::New() {
  TileQuadStatePtr rv;
  mojo::internal::StructHelper<TileQuadState>::Initialize(&rv);
  return rv;
}

TileQuadState::TileQuadState()
    : tex_coord_rect(),
      texture_size(),
      swizzle_contents(),
      resource_id(),
      nearest_neighbor() {
}

TileQuadState::~TileQuadState() {
}


TileQuadStatePtr TileQuadState::Clone() const {
  TileQuadStatePtr rv(New());
  rv->tex_coord_rect = tex_coord_rect.Clone();
  rv->texture_size = texture_size.Clone();
  rv->swizzle_contents = swizzle_contents;
  rv->resource_id = resource_id;
  rv->nearest_neighbor = nearest_neighbor;
  return rv;
}


bool TileQuadState::Equals(const TileQuadState& other) const {
  if (!mojo::internal::ValueTraits<mojo::RectFPtr>::Equals(this->tex_coord_rect, other.tex_coord_rect))
    return false;
  if (!mojo::internal::ValueTraits<mojo::SizePtr>::Equals(this->texture_size, other.texture_size))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->swizzle_contents, other.swizzle_contents))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->resource_id, other.resource_id))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->nearest_neighbor, other.nearest_neighbor))
    return false;
  return true;
}


// static
StreamVideoQuadStatePtr StreamVideoQuadState::New() {
  StreamVideoQuadStatePtr rv;
  mojo::internal::StructHelper<StreamVideoQuadState>::Initialize(&rv);
  return rv;
}

StreamVideoQuadState::StreamVideoQuadState() {
}

StreamVideoQuadState::~StreamVideoQuadState() {
}


StreamVideoQuadStatePtr StreamVideoQuadState::Clone() const {
  StreamVideoQuadStatePtr rv(New());
  return rv;
}


bool StreamVideoQuadState::Equals(const StreamVideoQuadState& other) const {
  return true;
}


// static
YUVVideoQuadStatePtr YUVVideoQuadState::New() {
  YUVVideoQuadStatePtr rv;
  mojo::internal::StructHelper<YUVVideoQuadState>::Initialize(&rv);
  return rv;
}

YUVVideoQuadState::YUVVideoQuadState()
    : tex_coord_rect(),
      y_plane_resource_id(),
      u_plane_resource_id(),
      v_plane_resource_id(),
      a_plane_resource_id(),
      color_space() {
}

YUVVideoQuadState::~YUVVideoQuadState() {
}


YUVVideoQuadStatePtr YUVVideoQuadState::Clone() const {
  YUVVideoQuadStatePtr rv(New());
  rv->tex_coord_rect = tex_coord_rect.Clone();
  rv->y_plane_resource_id = y_plane_resource_id;
  rv->u_plane_resource_id = u_plane_resource_id;
  rv->v_plane_resource_id = v_plane_resource_id;
  rv->a_plane_resource_id = a_plane_resource_id;
  rv->color_space = color_space;
  return rv;
}


bool YUVVideoQuadState::Equals(const YUVVideoQuadState& other) const {
  if (!mojo::internal::ValueTraits<mojo::RectFPtr>::Equals(this->tex_coord_rect, other.tex_coord_rect))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->y_plane_resource_id, other.y_plane_resource_id))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->u_plane_resource_id, other.u_plane_resource_id))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->v_plane_resource_id, other.v_plane_resource_id))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->a_plane_resource_id, other.a_plane_resource_id))
    return false;
  if (!mojo::internal::ValueTraits<YUVColorSpace>::Equals(this->color_space, other.color_space))
    return false;
  return true;
}


// static
QuadPtr Quad::New() {
  QuadPtr rv;
  mojo::internal::StructHelper<Quad>::Initialize(&rv);
  return rv;
}

Quad::Quad()
    : material(),
      rect(),
      opaque_rect(),
      visible_rect(),
      needs_blending(),
      shared_quad_state_index(),
      checkerboard_quad_state(),
      debug_border_quad_state(),
      io_surface_quad_state(),
      render_pass_quad_state(),
      solid_color_quad_state(),
      surface_quad_state(),
      texture_quad_state(),
      tile_quad_state(),
      stream_video_quad_state(),
      yuv_video_quad_state() {
}

Quad::~Quad() {
}


QuadPtr Quad::Clone() const {
  QuadPtr rv(New());
  rv->material = material;
  rv->rect = rect.Clone();
  rv->opaque_rect = opaque_rect.Clone();
  rv->visible_rect = visible_rect.Clone();
  rv->needs_blending = needs_blending;
  rv->shared_quad_state_index = shared_quad_state_index;
  rv->checkerboard_quad_state = checkerboard_quad_state.Clone();
  rv->debug_border_quad_state = debug_border_quad_state.Clone();
  rv->io_surface_quad_state = io_surface_quad_state.Clone();
  rv->render_pass_quad_state = render_pass_quad_state.Clone();
  rv->solid_color_quad_state = solid_color_quad_state.Clone();
  rv->surface_quad_state = surface_quad_state.Clone();
  rv->texture_quad_state = texture_quad_state.Clone();
  rv->tile_quad_state = tile_quad_state.Clone();
  rv->stream_video_quad_state = stream_video_quad_state.Clone();
  rv->yuv_video_quad_state = yuv_video_quad_state.Clone();
  return rv;
}


bool Quad::Equals(const Quad& other) const {
  if (!mojo::internal::ValueTraits<Material>::Equals(this->material, other.material))
    return false;
  if (!mojo::internal::ValueTraits<mojo::RectPtr>::Equals(this->rect, other.rect))
    return false;
  if (!mojo::internal::ValueTraits<mojo::RectPtr>::Equals(this->opaque_rect, other.opaque_rect))
    return false;
  if (!mojo::internal::ValueTraits<mojo::RectPtr>::Equals(this->visible_rect, other.visible_rect))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->needs_blending, other.needs_blending))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->shared_quad_state_index, other.shared_quad_state_index))
    return false;
  if (!mojo::internal::ValueTraits<CheckerboardQuadStatePtr>::Equals(this->checkerboard_quad_state, other.checkerboard_quad_state))
    return false;
  if (!mojo::internal::ValueTraits<DebugBorderQuadStatePtr>::Equals(this->debug_border_quad_state, other.debug_border_quad_state))
    return false;
  if (!mojo::internal::ValueTraits<IoSurfaceContentQuadStatePtr>::Equals(this->io_surface_quad_state, other.io_surface_quad_state))
    return false;
  if (!mojo::internal::ValueTraits<RenderPassQuadStatePtr>::Equals(this->render_pass_quad_state, other.render_pass_quad_state))
    return false;
  if (!mojo::internal::ValueTraits<SolidColorQuadStatePtr>::Equals(this->solid_color_quad_state, other.solid_color_quad_state))
    return false;
  if (!mojo::internal::ValueTraits<SurfaceQuadStatePtr>::Equals(this->surface_quad_state, other.surface_quad_state))
    return false;
  if (!mojo::internal::ValueTraits<TextureQuadStatePtr>::Equals(this->texture_quad_state, other.texture_quad_state))
    return false;
  if (!mojo::internal::ValueTraits<TileQuadStatePtr>::Equals(this->tile_quad_state, other.tile_quad_state))
    return false;
  if (!mojo::internal::ValueTraits<StreamVideoQuadStatePtr>::Equals(this->stream_video_quad_state, other.stream_video_quad_state))
    return false;
  if (!mojo::internal::ValueTraits<YUVVideoQuadStatePtr>::Equals(this->yuv_video_quad_state, other.yuv_video_quad_state))
    return false;
  return true;
}


// static
SharedQuadStatePtr SharedQuadState::New() {
  SharedQuadStatePtr rv;
  mojo::internal::StructHelper<SharedQuadState>::Initialize(&rv);
  return rv;
}

SharedQuadState::SharedQuadState()
    : content_to_target_transform(),
      content_bounds(),
      visible_content_rect(),
      clip_rect(),
      is_clipped(),
      opacity(),
      blend_mode(),
      sorting_context_id() {
}

SharedQuadState::~SharedQuadState() {
}


SharedQuadStatePtr SharedQuadState::Clone() const {
  SharedQuadStatePtr rv(New());
  rv->content_to_target_transform = content_to_target_transform.Clone();
  rv->content_bounds = content_bounds.Clone();
  rv->visible_content_rect = visible_content_rect.Clone();
  rv->clip_rect = clip_rect.Clone();
  rv->is_clipped = is_clipped;
  rv->opacity = opacity;
  rv->blend_mode = blend_mode;
  rv->sorting_context_id = sorting_context_id;
  return rv;
}


bool SharedQuadState::Equals(const SharedQuadState& other) const {
  if (!mojo::internal::ValueTraits<mojo::TransformPtr>::Equals(this->content_to_target_transform, other.content_to_target_transform))
    return false;
  if (!mojo::internal::ValueTraits<mojo::SizePtr>::Equals(this->content_bounds, other.content_bounds))
    return false;
  if (!mojo::internal::ValueTraits<mojo::RectPtr>::Equals(this->visible_content_rect, other.visible_content_rect))
    return false;
  if (!mojo::internal::ValueTraits<mojo::RectPtr>::Equals(this->clip_rect, other.clip_rect))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->is_clipped, other.is_clipped))
    return false;
  if (!mojo::internal::ValueTraits<float>::Equals(this->opacity, other.opacity))
    return false;
  if (!mojo::internal::ValueTraits<SkXfermode>::Equals(this->blend_mode, other.blend_mode))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->sorting_context_id, other.sorting_context_id))
    return false;
  return true;
}


// static
PassPtr Pass::New() {
  PassPtr rv;
  mojo::internal::StructHelper<Pass>::Initialize(&rv);
  return rv;
}

Pass::Pass()
    : id(),
      output_rect(),
      damage_rect(),
      transform_to_root_target(),
      has_transparent_background(),
      quads(),
      shared_quad_states() {
}

Pass::~Pass() {
}


PassPtr Pass::Clone() const {
  PassPtr rv(New());
  rv->id = id;
  rv->output_rect = output_rect.Clone();
  rv->damage_rect = damage_rect.Clone();
  rv->transform_to_root_target = transform_to_root_target.Clone();
  rv->has_transparent_background = has_transparent_background;
  rv->quads = quads.Clone();
  rv->shared_quad_states = shared_quad_states.Clone();
  return rv;
}


bool Pass::Equals(const Pass& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->id, other.id))
    return false;
  if (!mojo::internal::ValueTraits<mojo::RectPtr>::Equals(this->output_rect, other.output_rect))
    return false;
  if (!mojo::internal::ValueTraits<mojo::RectPtr>::Equals(this->damage_rect, other.damage_rect))
    return false;
  if (!mojo::internal::ValueTraits<mojo::TransformPtr>::Equals(this->transform_to_root_target, other.transform_to_root_target))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->has_transparent_background, other.has_transparent_background))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<QuadPtr>>::Equals(this->quads, other.quads))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<SharedQuadStatePtr>>::Equals(this->shared_quad_states, other.shared_quad_states))
    return false;
  return true;
}


// --- Union builder definitions ---

// --- Struct Serialization Helpers ---

size_t Color::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Color::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Color_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Color::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Color_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Color::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Color_Data* input =
      static_cast<internal::Color_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Color& input) {
  size_t size = sizeof(internal::Color_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Color* input,
    mojo::internal::Buffer* buf,
    internal::Color_Data** output) {
  if (input) {
    internal::Color_Data* result =
        internal::Color_Data::New(buf);
    result->rgba = input->rgba;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Color_Data* input,
                  Color* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->rgba = input->rgba;
    } while (false);
  }
}


size_t CheckerboardQuadState::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool CheckerboardQuadState::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::CheckerboardQuadState_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool CheckerboardQuadState::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::CheckerboardQuadState_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void CheckerboardQuadState::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::CheckerboardQuadState_Data* input =
      static_cast<internal::CheckerboardQuadState_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const CheckerboardQuadState& input) {
  size_t size = sizeof(internal::CheckerboardQuadState_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    CheckerboardQuadState* input,
    mojo::internal::Buffer* buf,
    internal::CheckerboardQuadState_Data** output) {
  if (input) {
    internal::CheckerboardQuadState_Data* result =
        internal::CheckerboardQuadState_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::CheckerboardQuadState_Data* input,
                  CheckerboardQuadState* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


size_t DebugBorderQuadState::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool DebugBorderQuadState::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::DebugBorderQuadState_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool DebugBorderQuadState::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::DebugBorderQuadState_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void DebugBorderQuadState::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::DebugBorderQuadState_Data* input =
      static_cast<internal::DebugBorderQuadState_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const DebugBorderQuadState& input) {
  size_t size = sizeof(internal::DebugBorderQuadState_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    DebugBorderQuadState* input,
    mojo::internal::Buffer* buf,
    internal::DebugBorderQuadState_Data** output) {
  if (input) {
    internal::DebugBorderQuadState_Data* result =
        internal::DebugBorderQuadState_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::DebugBorderQuadState_Data* input,
                  DebugBorderQuadState* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


size_t IoSurfaceContentQuadState::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool IoSurfaceContentQuadState::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::IoSurfaceContentQuadState_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool IoSurfaceContentQuadState::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::IoSurfaceContentQuadState_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void IoSurfaceContentQuadState::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::IoSurfaceContentQuadState_Data* input =
      static_cast<internal::IoSurfaceContentQuadState_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const IoSurfaceContentQuadState& input) {
  size_t size = sizeof(internal::IoSurfaceContentQuadState_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    IoSurfaceContentQuadState* input,
    mojo::internal::Buffer* buf,
    internal::IoSurfaceContentQuadState_Data** output) {
  if (input) {
    internal::IoSurfaceContentQuadState_Data* result =
        internal::IoSurfaceContentQuadState_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::IoSurfaceContentQuadState_Data* input,
                  IoSurfaceContentQuadState* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


size_t RenderPassId::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool RenderPassId::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::RenderPassId_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool RenderPassId::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::RenderPassId_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void RenderPassId::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::RenderPassId_Data* input =
      static_cast<internal::RenderPassId_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const RenderPassId& input) {
  size_t size = sizeof(internal::RenderPassId_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    RenderPassId* input,
    mojo::internal::Buffer* buf,
    internal::RenderPassId_Data** output) {
  if (input) {
    internal::RenderPassId_Data* result =
        internal::RenderPassId_Data::New(buf);
    result->layer_id = input->layer_id;
    result->index = input->index;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::RenderPassId_Data* input,
                  RenderPassId* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->layer_id = input->layer_id;
      result->index = input->index;
    } while (false);
  }
}


size_t RenderPassQuadState::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool RenderPassQuadState::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::RenderPassQuadState_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool RenderPassQuadState::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::RenderPassQuadState_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void RenderPassQuadState::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::RenderPassQuadState_Data* input =
      static_cast<internal::RenderPassQuadState_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const RenderPassQuadState& input) {
  size_t size = sizeof(internal::RenderPassQuadState_Data);
  size += input.render_pass_id.is_null()
              ? 0
              : GetSerializedSize_(*input.render_pass_id);
  size += input.mask_uv_scale.is_null()
              ? 0
              : GetSerializedSize_(*input.mask_uv_scale);
  size += input.mask_texture_size.is_null()
              ? 0
              : GetSerializedSize_(*input.mask_texture_size);
  size += input.filters_scale.is_null()
              ? 0
              : GetSerializedSize_(*input.filters_scale);
  return size;
}

mojo::internal::ValidationError Serialize_(
    RenderPassQuadState* input,
    mojo::internal::Buffer* buf,
    internal::RenderPassQuadState_Data** output) {
  if (input) {
    internal::RenderPassQuadState_Data* result =
        internal::RenderPassQuadState_Data::New(buf);
    {auto retval =Serialize_(input->render_pass_id.get(),
                 buf,
                 &result->render_pass_id.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->render_pass_id.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null render_pass_id in RenderPassQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->mask_resource_id = input->mask_resource_id;
    {auto retval =Serialize_(input->mask_uv_scale.get(),
                 buf,
                 &result->mask_uv_scale.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->mask_uv_scale.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null mask_uv_scale in RenderPassQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->mask_texture_size.get(),
                 buf,
                 &result->mask_texture_size.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->mask_texture_size.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null mask_texture_size in RenderPassQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->filters_scale.get(),
                 buf,
                 &result->filters_scale.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->filters_scale.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null filters_scale in RenderPassQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::RenderPassQuadState_Data* input,
                  RenderPassQuadState* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->render_pass_id.ptr) {
        result->render_pass_id = RenderPassId::New();
        Deserialize_(input->render_pass_id.ptr, result->render_pass_id.get());
      }
      result->mask_resource_id = input->mask_resource_id;
      if (input->mask_uv_scale.ptr) {
        result->mask_uv_scale = mojo::PointF::New();
        Deserialize_(input->mask_uv_scale.ptr, result->mask_uv_scale.get());
      }
      if (input->mask_texture_size.ptr) {
        result->mask_texture_size = mojo::Size::New();
        Deserialize_(input->mask_texture_size.ptr, result->mask_texture_size.get());
      }
      if (input->filters_scale.ptr) {
        result->filters_scale = mojo::PointF::New();
        Deserialize_(input->filters_scale.ptr, result->filters_scale.get());
      }
    } while (false);
  }
}


size_t SolidColorQuadState::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool SolidColorQuadState::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::SolidColorQuadState_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool SolidColorQuadState::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::SolidColorQuadState_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void SolidColorQuadState::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::SolidColorQuadState_Data* input =
      static_cast<internal::SolidColorQuadState_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const SolidColorQuadState& input) {
  size_t size = sizeof(internal::SolidColorQuadState_Data);
  size += input.color.is_null()
              ? 0
              : GetSerializedSize_(*input.color);
  return size;
}

mojo::internal::ValidationError Serialize_(
    SolidColorQuadState* input,
    mojo::internal::Buffer* buf,
    internal::SolidColorQuadState_Data** output) {
  if (input) {
    internal::SolidColorQuadState_Data* result =
        internal::SolidColorQuadState_Data::New(buf);
    {auto retval =Serialize_(input->color.get(),
                 buf,
                 &result->color.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->color.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null color in SolidColorQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->force_anti_aliasing_off = input->force_anti_aliasing_off;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::SolidColorQuadState_Data* input,
                  SolidColorQuadState* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->color.ptr) {
        result->color = Color::New();
        Deserialize_(input->color.ptr, result->color.get());
      }
      result->force_anti_aliasing_off = input->force_anti_aliasing_off;
    } while (false);
  }
}


size_t SurfaceQuadState::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool SurfaceQuadState::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::SurfaceQuadState_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool SurfaceQuadState::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::SurfaceQuadState_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void SurfaceQuadState::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::SurfaceQuadState_Data* input =
      static_cast<internal::SurfaceQuadState_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const SurfaceQuadState& input) {
  size_t size = sizeof(internal::SurfaceQuadState_Data);
  size += input.surface.is_null()
              ? 0
              : GetSerializedSize_(*input.surface);
  return size;
}

mojo::internal::ValidationError Serialize_(
    SurfaceQuadState* input,
    mojo::internal::Buffer* buf,
    internal::SurfaceQuadState_Data** output) {
  if (input) {
    internal::SurfaceQuadState_Data* result =
        internal::SurfaceQuadState_Data::New(buf);
    {auto retval =Serialize_(input->surface.get(),
                 buf,
                 &result->surface.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->surface.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null surface in SurfaceQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::SurfaceQuadState_Data* input,
                  SurfaceQuadState* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->surface.ptr) {
        result->surface = mojo::SurfaceId::New();
        Deserialize_(input->surface.ptr, result->surface.get());
      }
    } while (false);
  }
}


size_t TextureQuadState::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool TextureQuadState::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::TextureQuadState_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool TextureQuadState::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::TextureQuadState_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void TextureQuadState::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::TextureQuadState_Data* input =
      static_cast<internal::TextureQuadState_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const TextureQuadState& input) {
  size_t size = sizeof(internal::TextureQuadState_Data);
  size += input.uv_top_left.is_null()
              ? 0
              : GetSerializedSize_(*input.uv_top_left);
  size += input.uv_bottom_right.is_null()
              ? 0
              : GetSerializedSize_(*input.uv_bottom_right);
  size += input.background_color.is_null()
              ? 0
              : GetSerializedSize_(*input.background_color);
  size += GetSerializedSize_(input.vertex_opacity);
  return size;
}

mojo::internal::ValidationError Serialize_(
    TextureQuadState* input,
    mojo::internal::Buffer* buf,
    internal::TextureQuadState_Data** output) {
  if (input) {
    internal::TextureQuadState_Data* result =
        internal::TextureQuadState_Data::New(buf);
    result->resource_id = input->resource_id;
    result->premultiplied_alpha = input->premultiplied_alpha;
    {auto retval =Serialize_(input->uv_top_left.get(),
                 buf,
                 &result->uv_top_left.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->uv_top_left.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null uv_top_left in TextureQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->uv_bottom_right.get(),
                 buf,
                 &result->uv_bottom_right.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->uv_bottom_right.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null uv_bottom_right in TextureQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->background_color.get(),
                 buf,
                 &result->background_color.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->background_color.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null background_color in TextureQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams vertex_opacity_validate_params(
        4, false, nullptr);auto retval =mojo::SerializeArray_(&input->vertex_opacity, buf, &result->vertex_opacity.ptr,
                            &vertex_opacity_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->vertex_opacity.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null vertex_opacity in TextureQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->flipped = input->flipped;
    result->nearest_neighbor = input->nearest_neighbor;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::TextureQuadState_Data* input,
                  TextureQuadState* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->resource_id = input->resource_id;
      result->premultiplied_alpha = input->premultiplied_alpha;
      if (input->uv_top_left.ptr) {
        result->uv_top_left = mojo::PointF::New();
        Deserialize_(input->uv_top_left.ptr, result->uv_top_left.get());
      }
      if (input->uv_bottom_right.ptr) {
        result->uv_bottom_right = mojo::PointF::New();
        Deserialize_(input->uv_bottom_right.ptr, result->uv_bottom_right.get());
      }
      if (input->background_color.ptr) {
        result->background_color = Color::New();
        Deserialize_(input->background_color.ptr, result->background_color.get());
      }
      Deserialize_(input->vertex_opacity.ptr, &result->vertex_opacity);
      result->flipped = input->flipped;
      result->nearest_neighbor = input->nearest_neighbor;
    } while (false);
  }
}


size_t TileQuadState::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool TileQuadState::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::TileQuadState_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool TileQuadState::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::TileQuadState_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void TileQuadState::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::TileQuadState_Data* input =
      static_cast<internal::TileQuadState_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const TileQuadState& input) {
  size_t size = sizeof(internal::TileQuadState_Data);
  size += input.tex_coord_rect.is_null()
              ? 0
              : GetSerializedSize_(*input.tex_coord_rect);
  size += input.texture_size.is_null()
              ? 0
              : GetSerializedSize_(*input.texture_size);
  return size;
}

mojo::internal::ValidationError Serialize_(
    TileQuadState* input,
    mojo::internal::Buffer* buf,
    internal::TileQuadState_Data** output) {
  if (input) {
    internal::TileQuadState_Data* result =
        internal::TileQuadState_Data::New(buf);
    {auto retval =Serialize_(input->tex_coord_rect.get(),
                 buf,
                 &result->tex_coord_rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->tex_coord_rect.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null tex_coord_rect in TileQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->texture_size.get(),
                 buf,
                 &result->texture_size.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->texture_size.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null texture_size in TileQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->swizzle_contents = input->swizzle_contents;
    result->resource_id = input->resource_id;
    result->nearest_neighbor = input->nearest_neighbor;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::TileQuadState_Data* input,
                  TileQuadState* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->tex_coord_rect.ptr) {
        result->tex_coord_rect = mojo::RectF::New();
        Deserialize_(input->tex_coord_rect.ptr, result->tex_coord_rect.get());
      }
      if (input->texture_size.ptr) {
        result->texture_size = mojo::Size::New();
        Deserialize_(input->texture_size.ptr, result->texture_size.get());
      }
      result->swizzle_contents = input->swizzle_contents;
      result->resource_id = input->resource_id;
      result->nearest_neighbor = input->nearest_neighbor;
    } while (false);
  }
}


size_t StreamVideoQuadState::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StreamVideoQuadState::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StreamVideoQuadState_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StreamVideoQuadState::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StreamVideoQuadState_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StreamVideoQuadState::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StreamVideoQuadState_Data* input =
      static_cast<internal::StreamVideoQuadState_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StreamVideoQuadState& input) {
  size_t size = sizeof(internal::StreamVideoQuadState_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StreamVideoQuadState* input,
    mojo::internal::Buffer* buf,
    internal::StreamVideoQuadState_Data** output) {
  if (input) {
    internal::StreamVideoQuadState_Data* result =
        internal::StreamVideoQuadState_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StreamVideoQuadState_Data* input,
                  StreamVideoQuadState* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


size_t YUVVideoQuadState::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool YUVVideoQuadState::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::YUVVideoQuadState_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool YUVVideoQuadState::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::YUVVideoQuadState_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void YUVVideoQuadState::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::YUVVideoQuadState_Data* input =
      static_cast<internal::YUVVideoQuadState_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const YUVVideoQuadState& input) {
  size_t size = sizeof(internal::YUVVideoQuadState_Data);
  size += input.tex_coord_rect.is_null()
              ? 0
              : GetSerializedSize_(*input.tex_coord_rect);
  return size;
}

mojo::internal::ValidationError Serialize_(
    YUVVideoQuadState* input,
    mojo::internal::Buffer* buf,
    internal::YUVVideoQuadState_Data** output) {
  if (input) {
    internal::YUVVideoQuadState_Data* result =
        internal::YUVVideoQuadState_Data::New(buf);
    {auto retval =Serialize_(input->tex_coord_rect.get(),
                 buf,
                 &result->tex_coord_rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->tex_coord_rect.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null tex_coord_rect in YUVVideoQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->y_plane_resource_id = input->y_plane_resource_id;
    result->u_plane_resource_id = input->u_plane_resource_id;
    result->v_plane_resource_id = input->v_plane_resource_id;
    result->a_plane_resource_id = input->a_plane_resource_id;
    result->color_space =
      static_cast<int32_t>(input->color_space);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::YUVVideoQuadState_Data* input,
                  YUVVideoQuadState* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->tex_coord_rect.ptr) {
        result->tex_coord_rect = mojo::RectF::New();
        Deserialize_(input->tex_coord_rect.ptr, result->tex_coord_rect.get());
      }
      result->y_plane_resource_id = input->y_plane_resource_id;
      result->u_plane_resource_id = input->u_plane_resource_id;
      result->v_plane_resource_id = input->v_plane_resource_id;
      result->a_plane_resource_id = input->a_plane_resource_id;
      result->color_space = static_cast<YUVColorSpace>(input->color_space);
    } while (false);
  }
}


size_t Quad::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Quad::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Quad_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Quad::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Quad_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Quad::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Quad_Data* input =
      static_cast<internal::Quad_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Quad& input) {
  size_t size = sizeof(internal::Quad_Data);
  size += input.rect.is_null()
              ? 0
              : GetSerializedSize_(*input.rect);
  size += input.opaque_rect.is_null()
              ? 0
              : GetSerializedSize_(*input.opaque_rect);
  size += input.visible_rect.is_null()
              ? 0
              : GetSerializedSize_(*input.visible_rect);
  size += input.checkerboard_quad_state.is_null()
              ? 0
              : GetSerializedSize_(*input.checkerboard_quad_state);
  size += input.debug_border_quad_state.is_null()
              ? 0
              : GetSerializedSize_(*input.debug_border_quad_state);
  size += input.io_surface_quad_state.is_null()
              ? 0
              : GetSerializedSize_(*input.io_surface_quad_state);
  size += input.render_pass_quad_state.is_null()
              ? 0
              : GetSerializedSize_(*input.render_pass_quad_state);
  size += input.solid_color_quad_state.is_null()
              ? 0
              : GetSerializedSize_(*input.solid_color_quad_state);
  size += input.surface_quad_state.is_null()
              ? 0
              : GetSerializedSize_(*input.surface_quad_state);
  size += input.texture_quad_state.is_null()
              ? 0
              : GetSerializedSize_(*input.texture_quad_state);
  size += input.tile_quad_state.is_null()
              ? 0
              : GetSerializedSize_(*input.tile_quad_state);
  size += input.stream_video_quad_state.is_null()
              ? 0
              : GetSerializedSize_(*input.stream_video_quad_state);
  size += input.yuv_video_quad_state.is_null()
              ? 0
              : GetSerializedSize_(*input.yuv_video_quad_state);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Quad* input,
    mojo::internal::Buffer* buf,
    internal::Quad_Data** output) {
  if (input) {
    internal::Quad_Data* result =
        internal::Quad_Data::New(buf);
    result->material =
      static_cast<int32_t>(input->material);
    {auto retval =Serialize_(input->rect.get(),
                 buf,
                 &result->rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->rect.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null rect in Quad struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->opaque_rect.get(),
                 buf,
                 &result->opaque_rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->opaque_rect.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null opaque_rect in Quad struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->visible_rect.get(),
                 buf,
                 &result->visible_rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->visible_rect.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null visible_rect in Quad struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->needs_blending = input->needs_blending;
    result->shared_quad_state_index = input->shared_quad_state_index;
    {auto retval =Serialize_(input->checkerboard_quad_state.get(),
                 buf,
                 &result->checkerboard_quad_state.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->debug_border_quad_state.get(),
                 buf,
                 &result->debug_border_quad_state.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->io_surface_quad_state.get(),
                 buf,
                 &result->io_surface_quad_state.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->render_pass_quad_state.get(),
                 buf,
                 &result->render_pass_quad_state.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->solid_color_quad_state.get(),
                 buf,
                 &result->solid_color_quad_state.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->surface_quad_state.get(),
                 buf,
                 &result->surface_quad_state.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->texture_quad_state.get(),
                 buf,
                 &result->texture_quad_state.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->tile_quad_state.get(),
                 buf,
                 &result->tile_quad_state.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->stream_video_quad_state.get(),
                 buf,
                 &result->stream_video_quad_state.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->yuv_video_quad_state.get(),
                 buf,
                 &result->yuv_video_quad_state.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Quad_Data* input,
                  Quad* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->material = static_cast<Material>(input->material);
      if (input->rect.ptr) {
        result->rect = mojo::Rect::New();
        Deserialize_(input->rect.ptr, result->rect.get());
      }
      if (input->opaque_rect.ptr) {
        result->opaque_rect = mojo::Rect::New();
        Deserialize_(input->opaque_rect.ptr, result->opaque_rect.get());
      }
      if (input->visible_rect.ptr) {
        result->visible_rect = mojo::Rect::New();
        Deserialize_(input->visible_rect.ptr, result->visible_rect.get());
      }
      result->needs_blending = input->needs_blending;
      result->shared_quad_state_index = input->shared_quad_state_index;
      if (input->checkerboard_quad_state.ptr) {
        result->checkerboard_quad_state = CheckerboardQuadState::New();
        Deserialize_(input->checkerboard_quad_state.ptr, result->checkerboard_quad_state.get());
      }
      if (input->debug_border_quad_state.ptr) {
        result->debug_border_quad_state = DebugBorderQuadState::New();
        Deserialize_(input->debug_border_quad_state.ptr, result->debug_border_quad_state.get());
      }
      if (input->io_surface_quad_state.ptr) {
        result->io_surface_quad_state = IoSurfaceContentQuadState::New();
        Deserialize_(input->io_surface_quad_state.ptr, result->io_surface_quad_state.get());
      }
      if (input->render_pass_quad_state.ptr) {
        result->render_pass_quad_state = RenderPassQuadState::New();
        Deserialize_(input->render_pass_quad_state.ptr, result->render_pass_quad_state.get());
      }
      if (input->solid_color_quad_state.ptr) {
        result->solid_color_quad_state = SolidColorQuadState::New();
        Deserialize_(input->solid_color_quad_state.ptr, result->solid_color_quad_state.get());
      }
      if (input->surface_quad_state.ptr) {
        result->surface_quad_state = SurfaceQuadState::New();
        Deserialize_(input->surface_quad_state.ptr, result->surface_quad_state.get());
      }
      if (input->texture_quad_state.ptr) {
        result->texture_quad_state = TextureQuadState::New();
        Deserialize_(input->texture_quad_state.ptr, result->texture_quad_state.get());
      }
      if (input->tile_quad_state.ptr) {
        result->tile_quad_state = TileQuadState::New();
        Deserialize_(input->tile_quad_state.ptr, result->tile_quad_state.get());
      }
      if (input->stream_video_quad_state.ptr) {
        result->stream_video_quad_state = StreamVideoQuadState::New();
        Deserialize_(input->stream_video_quad_state.ptr, result->stream_video_quad_state.get());
      }
      if (input->yuv_video_quad_state.ptr) {
        result->yuv_video_quad_state = YUVVideoQuadState::New();
        Deserialize_(input->yuv_video_quad_state.ptr, result->yuv_video_quad_state.get());
      }
    } while (false);
  }
}


size_t SharedQuadState::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool SharedQuadState::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::SharedQuadState_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool SharedQuadState::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::SharedQuadState_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void SharedQuadState::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::SharedQuadState_Data* input =
      static_cast<internal::SharedQuadState_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const SharedQuadState& input) {
  size_t size = sizeof(internal::SharedQuadState_Data);
  size += input.content_to_target_transform.is_null()
              ? 0
              : GetSerializedSize_(*input.content_to_target_transform);
  size += input.content_bounds.is_null()
              ? 0
              : GetSerializedSize_(*input.content_bounds);
  size += input.visible_content_rect.is_null()
              ? 0
              : GetSerializedSize_(*input.visible_content_rect);
  size += input.clip_rect.is_null()
              ? 0
              : GetSerializedSize_(*input.clip_rect);
  return size;
}

mojo::internal::ValidationError Serialize_(
    SharedQuadState* input,
    mojo::internal::Buffer* buf,
    internal::SharedQuadState_Data** output) {
  if (input) {
    internal::SharedQuadState_Data* result =
        internal::SharedQuadState_Data::New(buf);
    {auto retval =Serialize_(input->content_to_target_transform.get(),
                 buf,
                 &result->content_to_target_transform.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->content_to_target_transform.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null content_to_target_transform in SharedQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->content_bounds.get(),
                 buf,
                 &result->content_bounds.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->content_bounds.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null content_bounds in SharedQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->visible_content_rect.get(),
                 buf,
                 &result->visible_content_rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->visible_content_rect.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null visible_content_rect in SharedQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->clip_rect.get(),
                 buf,
                 &result->clip_rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->clip_rect.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null clip_rect in SharedQuadState struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->is_clipped = input->is_clipped;
    result->opacity = input->opacity;
    result->blend_mode =
      static_cast<int32_t>(input->blend_mode);
    result->sorting_context_id = input->sorting_context_id;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::SharedQuadState_Data* input,
                  SharedQuadState* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->content_to_target_transform.ptr) {
        result->content_to_target_transform = mojo::Transform::New();
        Deserialize_(input->content_to_target_transform.ptr, result->content_to_target_transform.get());
      }
      if (input->content_bounds.ptr) {
        result->content_bounds = mojo::Size::New();
        Deserialize_(input->content_bounds.ptr, result->content_bounds.get());
      }
      if (input->visible_content_rect.ptr) {
        result->visible_content_rect = mojo::Rect::New();
        Deserialize_(input->visible_content_rect.ptr, result->visible_content_rect.get());
      }
      if (input->clip_rect.ptr) {
        result->clip_rect = mojo::Rect::New();
        Deserialize_(input->clip_rect.ptr, result->clip_rect.get());
      }
      result->is_clipped = input->is_clipped;
      result->opacity = input->opacity;
      result->blend_mode = static_cast<SkXfermode>(input->blend_mode);
      result->sorting_context_id = input->sorting_context_id;
    } while (false);
  }
}


size_t Pass::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Pass::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Pass_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Pass::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Pass_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Pass::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Pass_Data* input =
      static_cast<internal::Pass_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Pass& input) {
  size_t size = sizeof(internal::Pass_Data);
  size += input.output_rect.is_null()
              ? 0
              : GetSerializedSize_(*input.output_rect);
  size += input.damage_rect.is_null()
              ? 0
              : GetSerializedSize_(*input.damage_rect);
  size += input.transform_to_root_target.is_null()
              ? 0
              : GetSerializedSize_(*input.transform_to_root_target);
  size += GetSerializedSize_(input.quads);
  size += GetSerializedSize_(input.shared_quad_states);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Pass* input,
    mojo::internal::Buffer* buf,
    internal::Pass_Data** output) {
  if (input) {
    internal::Pass_Data* result =
        internal::Pass_Data::New(buf);
    result->id = input->id;
    {auto retval =Serialize_(input->output_rect.get(),
                 buf,
                 &result->output_rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->output_rect.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null output_rect in Pass struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->damage_rect.get(),
                 buf,
                 &result->damage_rect.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->damage_rect.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null damage_rect in Pass struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->transform_to_root_target.get(),
                 buf,
                 &result->transform_to_root_target.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->transform_to_root_target.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null transform_to_root_target in Pass struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->has_transparent_background = input->has_transparent_background;
    {
      const mojo::internal::ArrayValidateParams quads_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->quads, buf, &result->quads.ptr,
                            &quads_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->quads.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null quads in Pass struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams shared_quad_states_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->shared_quad_states, buf, &result->shared_quad_states.ptr,
                            &shared_quad_states_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->shared_quad_states.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null shared_quad_states in Pass struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Pass_Data* input,
                  Pass* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->id = input->id;
      if (input->output_rect.ptr) {
        result->output_rect = mojo::Rect::New();
        Deserialize_(input->output_rect.ptr, result->output_rect.get());
      }
      if (input->damage_rect.ptr) {
        result->damage_rect = mojo::Rect::New();
        Deserialize_(input->damage_rect.ptr, result->damage_rect.get());
      }
      if (input->transform_to_root_target.ptr) {
        result->transform_to_root_target = mojo::Transform::New();
        Deserialize_(input->transform_to_root_target.ptr, result->transform_to_root_target.get());
      }
      result->has_transparent_background = input->has_transparent_background;
      Deserialize_(input->quads.ptr, &result->quads);
      Deserialize_(input->shared_quad_states.ptr, &result->shared_quad_states);
    } while (false);
  }
}


// --- Union Serialization Helpers ---

// --- Structs for interface method parameters ---
}  // namespace mojo
