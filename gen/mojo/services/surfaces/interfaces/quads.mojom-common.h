// NOTE: This file was generated by the Mojo bindings generator.
#ifndef MOJO_SERVICES_SURFACES_INTERFACES_QUADS_MOJOM_COMMON_H_
#define MOJO_SERVICES_SURFACES_INTERFACES_QUADS_MOJOM_COMMON_H_

#include <stdint.h>
#include <iosfwd>

#include "mojo/public/cpp/bindings/array.h"
#include "mojo/public/cpp/bindings/callback.h"
#include "mojo/public/cpp/bindings/interface_handle.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/map.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/bindings/string.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/system/buffer.h"
#include "mojo/public/cpp/system/data_pipe.h"
#include "mojo/public/cpp/system/handle.h"
#include "mojo/public/cpp/system/message_pipe.h"
#include "mojo/services/surfaces/interfaces/quads.mojom-internal.h"
#include "mojo/services/geometry/interfaces/geometry.mojom-common.h"
#include "mojo/services/surfaces/interfaces/surface_id.mojom-common.h"
namespace mojo {

// --- Interface Forward Declarations ---

// --- Struct Forward Declarations ---
class Color;

using ColorPtr = mojo::InlinedStructPtr<Color>;


class CheckerboardQuadState;

using CheckerboardQuadStatePtr = mojo::InlinedStructPtr<CheckerboardQuadState>;


class DebugBorderQuadState;

using DebugBorderQuadStatePtr = mojo::InlinedStructPtr<DebugBorderQuadState>;


class IoSurfaceContentQuadState;

using IoSurfaceContentQuadStatePtr = mojo::InlinedStructPtr<IoSurfaceContentQuadState>;


class RenderPassId;

using RenderPassIdPtr = mojo::InlinedStructPtr<RenderPassId>;


class RenderPassQuadState;

using RenderPassQuadStatePtr = mojo::StructPtr<RenderPassQuadState>;


class SolidColorQuadState;

using SolidColorQuadStatePtr = mojo::StructPtr<SolidColorQuadState>;


class SurfaceQuadState;

using SurfaceQuadStatePtr = mojo::StructPtr<SurfaceQuadState>;


class TextureQuadState;

using TextureQuadStatePtr = mojo::StructPtr<TextureQuadState>;


class TileQuadState;

using TileQuadStatePtr = mojo::StructPtr<TileQuadState>;


class StreamVideoQuadState;

using StreamVideoQuadStatePtr = mojo::InlinedStructPtr<StreamVideoQuadState>;


class YUVVideoQuadState;

using YUVVideoQuadStatePtr = mojo::StructPtr<YUVVideoQuadState>;


class Quad;

using QuadPtr = mojo::StructPtr<Quad>;


class SharedQuadState;

using SharedQuadStatePtr = mojo::StructPtr<SharedQuadState>;


class Pass;

using PassPtr = mojo::StructPtr<Pass>;



// --- Union Forward Declarations ---

// --- Enums Declarations ---
  
enum class YUVColorSpace : int32_t {
  REC_601,
  REC_709,
  JPEG,
};

bool YUVColorSpace_IsValidValue(YUVColorSpace value);
  
std::ostream& operator<<(std::ostream& stream, const YUVColorSpace& val);
  
enum class Material : int32_t {
  CHECKERBOARD = 1,
  DEBUG_BORDER,
  IO_SURFACE_CONTENT,
  PICTURE_CONTENT,
  RENDER_PASS,
  SOLID_COLOR,
  STREAM_VIDEO_CONTENT,
  SURFACE_CONTENT,
  TEXTURE_CONTENT,
  TILED_CONTENT,
  YUV_VIDEO_CONTENT,
};

bool Material_IsValidValue(Material value);
  
std::ostream& operator<<(std::ostream& stream, const Material& val);
  
enum class SkXfermode : int32_t {
  kClear_Mode = 0,
  kSrc_Mode,
  kDst_Mode,
  kSrcOver_Mode,
  kDstOver_Mode,
  kSrcIn_Mode,
  kDstIn_Mode,
  kSrcOut_Mode,
  kDstOut_Mode,
  kSrcATop_Mode,
  kDstATop_Mode,
  kXor_Mode,
  kPlus_Mode,
  kModulate_Mode,
  kScreen_Mode,
  kLastCoeffMode = SkXfermode::kScreen_Mode,
  kOverlay_Mode,
  kDarken_Mode,
  kLighten_Mode,
  kColorDodge_Mode,
  kColorBurn_Mode,
  kHardLight_Mode,
  kSoftLight_Mode,
  kDifference_Mode,
  kExclusion_Mode,
  kMultiply_Mode,
  kLastSeparableMode = SkXfermode::kMultiply_Mode,
  kHue_Mode,
  kSaturation_Mode,
  kColor_Mode,
  kLuminosity_Mode,
  kLastMode = SkXfermode::kLuminosity_Mode,
};

bool SkXfermode_IsValidValue(SkXfermode value);
  
std::ostream& operator<<(std::ostream& stream, const SkXfermode& val);

// --- Constants ---

// --- Interface declarations ---
}  // namespace mojo

// --- Internal Template Specializations ---

namespace mojo {
namespace internal {
template <>
struct WrapperTraits<mojo::ColorPtr, true, false> {
  using DataType = mojo::internal::Color_Data*;
};
template <>
struct WrapperTraits<mojo::CheckerboardQuadStatePtr, true, false> {
  using DataType = mojo::internal::CheckerboardQuadState_Data*;
};
template <>
struct WrapperTraits<mojo::DebugBorderQuadStatePtr, true, false> {
  using DataType = mojo::internal::DebugBorderQuadState_Data*;
};
template <>
struct WrapperTraits<mojo::IoSurfaceContentQuadStatePtr, true, false> {
  using DataType = mojo::internal::IoSurfaceContentQuadState_Data*;
};
template <>
struct WrapperTraits<mojo::RenderPassIdPtr, true, false> {
  using DataType = mojo::internal::RenderPassId_Data*;
};
template <>
struct WrapperTraits<mojo::RenderPassQuadStatePtr, true, false> {
  using DataType = mojo::internal::RenderPassQuadState_Data*;
};
template <>
struct WrapperTraits<mojo::SolidColorQuadStatePtr, true, false> {
  using DataType = mojo::internal::SolidColorQuadState_Data*;
};
template <>
struct WrapperTraits<mojo::SurfaceQuadStatePtr, true, false> {
  using DataType = mojo::internal::SurfaceQuadState_Data*;
};
template <>
struct WrapperTraits<mojo::TextureQuadStatePtr, true, false> {
  using DataType = mojo::internal::TextureQuadState_Data*;
};
template <>
struct WrapperTraits<mojo::TileQuadStatePtr, true, false> {
  using DataType = mojo::internal::TileQuadState_Data*;
};
template <>
struct WrapperTraits<mojo::StreamVideoQuadStatePtr, true, false> {
  using DataType = mojo::internal::StreamVideoQuadState_Data*;
};
template <>
struct WrapperTraits<mojo::YUVVideoQuadStatePtr, true, false> {
  using DataType = mojo::internal::YUVVideoQuadState_Data*;
};
template <>
struct WrapperTraits<mojo::QuadPtr, true, false> {
  using DataType = mojo::internal::Quad_Data*;
};
template <>
struct WrapperTraits<mojo::SharedQuadStatePtr, true, false> {
  using DataType = mojo::internal::SharedQuadState_Data*;
};
template <>
struct WrapperTraits<mojo::PassPtr, true, false> {
  using DataType = mojo::internal::Pass_Data*;
};

}  // internal
}  // mojo
namespace mojo {

// --- Interface Request Validators ---

// --- Interface Response Validators ---

// --- Interface enum operators ---

// --- Unions ---
// Unions must be declared first because they can be members of structs.

// --- Inlined structs ---
class Color {
 public:
  using Data_ = internal::Color_Data;

  static ColorPtr New();

  template <typename U>
  static ColorPtr From(const U& u) {
    return mojo::TypeConverter<ColorPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Color>::Convert(*this);
  }

  Color();
  ~Color();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ColorPtr Clone() const;
  bool Equals(const Color& other) const;

  uint32_t rgba;
};


class CheckerboardQuadState {
 public:
  using Data_ = internal::CheckerboardQuadState_Data;

  static CheckerboardQuadStatePtr New();

  template <typename U>
  static CheckerboardQuadStatePtr From(const U& u) {
    return mojo::TypeConverter<CheckerboardQuadStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CheckerboardQuadState>::Convert(*this);
  }

  CheckerboardQuadState();
  ~CheckerboardQuadState();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CheckerboardQuadStatePtr Clone() const;
  bool Equals(const CheckerboardQuadState& other) const;

};


class DebugBorderQuadState {
 public:
  using Data_ = internal::DebugBorderQuadState_Data;

  static DebugBorderQuadStatePtr New();

  template <typename U>
  static DebugBorderQuadStatePtr From(const U& u) {
    return mojo::TypeConverter<DebugBorderQuadStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DebugBorderQuadState>::Convert(*this);
  }

  DebugBorderQuadState();
  ~DebugBorderQuadState();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  DebugBorderQuadStatePtr Clone() const;
  bool Equals(const DebugBorderQuadState& other) const;

};


class IoSurfaceContentQuadState {
 public:
  using Data_ = internal::IoSurfaceContentQuadState_Data;

  static IoSurfaceContentQuadStatePtr New();

  template <typename U>
  static IoSurfaceContentQuadStatePtr From(const U& u) {
    return mojo::TypeConverter<IoSurfaceContentQuadStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, IoSurfaceContentQuadState>::Convert(*this);
  }

  IoSurfaceContentQuadState();
  ~IoSurfaceContentQuadState();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  IoSurfaceContentQuadStatePtr Clone() const;
  bool Equals(const IoSurfaceContentQuadState& other) const;

};


class RenderPassId {
 public:
  using Data_ = internal::RenderPassId_Data;

  static RenderPassIdPtr New();

  template <typename U>
  static RenderPassIdPtr From(const U& u) {
    return mojo::TypeConverter<RenderPassIdPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, RenderPassId>::Convert(*this);
  }

  RenderPassId();
  ~RenderPassId();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  RenderPassIdPtr Clone() const;
  bool Equals(const RenderPassId& other) const;

  int32_t layer_id;
  int32_t index;
};


class StreamVideoQuadState {
 public:
  using Data_ = internal::StreamVideoQuadState_Data;

  static StreamVideoQuadStatePtr New();

  template <typename U>
  static StreamVideoQuadStatePtr From(const U& u) {
    return mojo::TypeConverter<StreamVideoQuadStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StreamVideoQuadState>::Convert(*this);
  }

  StreamVideoQuadState();
  ~StreamVideoQuadState();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  StreamVideoQuadStatePtr Clone() const;
  bool Equals(const StreamVideoQuadState& other) const;

};



// --- Non-inlined structs ---
class RenderPassQuadState {
 public:
  using Data_ = internal::RenderPassQuadState_Data;

  static RenderPassQuadStatePtr New();

  template <typename U>
  static RenderPassQuadStatePtr From(const U& u) {
    return mojo::TypeConverter<RenderPassQuadStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, RenderPassQuadState>::Convert(*this);
  }

  RenderPassQuadState();
  ~RenderPassQuadState();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  RenderPassQuadStatePtr Clone() const;
  bool Equals(const RenderPassQuadState& other) const;

  RenderPassIdPtr render_pass_id;
  uint32_t mask_resource_id;
  mojo::PointFPtr mask_uv_scale;
  mojo::SizePtr mask_texture_size;
  mojo::PointFPtr filters_scale;
};


class SolidColorQuadState {
 public:
  using Data_ = internal::SolidColorQuadState_Data;

  static SolidColorQuadStatePtr New();

  template <typename U>
  static SolidColorQuadStatePtr From(const U& u) {
    return mojo::TypeConverter<SolidColorQuadStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SolidColorQuadState>::Convert(*this);
  }

  SolidColorQuadState();
  ~SolidColorQuadState();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  SolidColorQuadStatePtr Clone() const;
  bool Equals(const SolidColorQuadState& other) const;

  ColorPtr color;
  bool force_anti_aliasing_off;
};


class SurfaceQuadState {
 public:
  using Data_ = internal::SurfaceQuadState_Data;

  static SurfaceQuadStatePtr New();

  template <typename U>
  static SurfaceQuadStatePtr From(const U& u) {
    return mojo::TypeConverter<SurfaceQuadStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SurfaceQuadState>::Convert(*this);
  }

  SurfaceQuadState();
  ~SurfaceQuadState();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  SurfaceQuadStatePtr Clone() const;
  bool Equals(const SurfaceQuadState& other) const;

  mojo::SurfaceIdPtr surface;
};


class TextureQuadState {
 public:
  using Data_ = internal::TextureQuadState_Data;

  static TextureQuadStatePtr New();

  template <typename U>
  static TextureQuadStatePtr From(const U& u) {
    return mojo::TypeConverter<TextureQuadStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, TextureQuadState>::Convert(*this);
  }

  TextureQuadState();
  ~TextureQuadState();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  TextureQuadStatePtr Clone() const;
  bool Equals(const TextureQuadState& other) const;

  uint32_t resource_id;
  bool premultiplied_alpha;
  mojo::PointFPtr uv_top_left;
  mojo::PointFPtr uv_bottom_right;
  ColorPtr background_color;
  mojo::Array<float> vertex_opacity;
  bool flipped;
  bool nearest_neighbor;
};


class TileQuadState {
 public:
  using Data_ = internal::TileQuadState_Data;

  static TileQuadStatePtr New();

  template <typename U>
  static TileQuadStatePtr From(const U& u) {
    return mojo::TypeConverter<TileQuadStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, TileQuadState>::Convert(*this);
  }

  TileQuadState();
  ~TileQuadState();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  TileQuadStatePtr Clone() const;
  bool Equals(const TileQuadState& other) const;

  mojo::RectFPtr tex_coord_rect;
  mojo::SizePtr texture_size;
  bool swizzle_contents;
  uint32_t resource_id;
  bool nearest_neighbor;
};


class YUVVideoQuadState {
 public:
  using Data_ = internal::YUVVideoQuadState_Data;

  static YUVVideoQuadStatePtr New();

  template <typename U>
  static YUVVideoQuadStatePtr From(const U& u) {
    return mojo::TypeConverter<YUVVideoQuadStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, YUVVideoQuadState>::Convert(*this);
  }

  YUVVideoQuadState();
  ~YUVVideoQuadState();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  YUVVideoQuadStatePtr Clone() const;
  bool Equals(const YUVVideoQuadState& other) const;

  mojo::RectFPtr tex_coord_rect;
  uint32_t y_plane_resource_id;
  uint32_t u_plane_resource_id;
  uint32_t v_plane_resource_id;
  uint32_t a_plane_resource_id;
  YUVColorSpace color_space;
};


class Quad {
 public:
  using Data_ = internal::Quad_Data;

  static QuadPtr New();

  template <typename U>
  static QuadPtr From(const U& u) {
    return mojo::TypeConverter<QuadPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Quad>::Convert(*this);
  }

  Quad();
  ~Quad();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  QuadPtr Clone() const;
  bool Equals(const Quad& other) const;

  Material material;
  mojo::RectPtr rect;
  mojo::RectPtr opaque_rect;
  mojo::RectPtr visible_rect;
  bool needs_blending;
  uint32_t shared_quad_state_index;
  CheckerboardQuadStatePtr checkerboard_quad_state;
  DebugBorderQuadStatePtr debug_border_quad_state;
  IoSurfaceContentQuadStatePtr io_surface_quad_state;
  RenderPassQuadStatePtr render_pass_quad_state;
  SolidColorQuadStatePtr solid_color_quad_state;
  SurfaceQuadStatePtr surface_quad_state;
  TextureQuadStatePtr texture_quad_state;
  TileQuadStatePtr tile_quad_state;
  StreamVideoQuadStatePtr stream_video_quad_state;
  YUVVideoQuadStatePtr yuv_video_quad_state;
};


class SharedQuadState {
 public:
  using Data_ = internal::SharedQuadState_Data;

  static SharedQuadStatePtr New();

  template <typename U>
  static SharedQuadStatePtr From(const U& u) {
    return mojo::TypeConverter<SharedQuadStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SharedQuadState>::Convert(*this);
  }

  SharedQuadState();
  ~SharedQuadState();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  SharedQuadStatePtr Clone() const;
  bool Equals(const SharedQuadState& other) const;

  mojo::TransformPtr content_to_target_transform;
  mojo::SizePtr content_bounds;
  mojo::RectPtr visible_content_rect;
  mojo::RectPtr clip_rect;
  bool is_clipped;
  float opacity;
  SkXfermode blend_mode;
  int32_t sorting_context_id;
};


class Pass {
 public:
  using Data_ = internal::Pass_Data;

  static PassPtr New();

  template <typename U>
  static PassPtr From(const U& u) {
    return mojo::TypeConverter<PassPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Pass>::Convert(*this);
  }

  Pass();
  ~Pass();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  PassPtr Clone() const;
  bool Equals(const Pass& other) const;

  int32_t id;
  mojo::RectPtr output_rect;
  mojo::RectPtr damage_rect;
  mojo::TransformPtr transform_to_root_target;
  bool has_transparent_background;
  mojo::Array<QuadPtr> quads;
  mojo::Array<SharedQuadStatePtr> shared_quad_states;
};



// --- Struct serialization helpers ---
size_t GetSerializedSize_(const Color& input);
mojo::internal::ValidationError Serialize_(
    Color* input,
    mojo::internal::Buffer* buffer,
    internal::Color_Data** output);
void Deserialize_(internal::Color_Data* input,
                  Color* output);

size_t GetSerializedSize_(const CheckerboardQuadState& input);
mojo::internal::ValidationError Serialize_(
    CheckerboardQuadState* input,
    mojo::internal::Buffer* buffer,
    internal::CheckerboardQuadState_Data** output);
void Deserialize_(internal::CheckerboardQuadState_Data* input,
                  CheckerboardQuadState* output);

size_t GetSerializedSize_(const DebugBorderQuadState& input);
mojo::internal::ValidationError Serialize_(
    DebugBorderQuadState* input,
    mojo::internal::Buffer* buffer,
    internal::DebugBorderQuadState_Data** output);
void Deserialize_(internal::DebugBorderQuadState_Data* input,
                  DebugBorderQuadState* output);

size_t GetSerializedSize_(const IoSurfaceContentQuadState& input);
mojo::internal::ValidationError Serialize_(
    IoSurfaceContentQuadState* input,
    mojo::internal::Buffer* buffer,
    internal::IoSurfaceContentQuadState_Data** output);
void Deserialize_(internal::IoSurfaceContentQuadState_Data* input,
                  IoSurfaceContentQuadState* output);

size_t GetSerializedSize_(const RenderPassId& input);
mojo::internal::ValidationError Serialize_(
    RenderPassId* input,
    mojo::internal::Buffer* buffer,
    internal::RenderPassId_Data** output);
void Deserialize_(internal::RenderPassId_Data* input,
                  RenderPassId* output);

size_t GetSerializedSize_(const RenderPassQuadState& input);
mojo::internal::ValidationError Serialize_(
    RenderPassQuadState* input,
    mojo::internal::Buffer* buffer,
    internal::RenderPassQuadState_Data** output);
void Deserialize_(internal::RenderPassQuadState_Data* input,
                  RenderPassQuadState* output);

size_t GetSerializedSize_(const SolidColorQuadState& input);
mojo::internal::ValidationError Serialize_(
    SolidColorQuadState* input,
    mojo::internal::Buffer* buffer,
    internal::SolidColorQuadState_Data** output);
void Deserialize_(internal::SolidColorQuadState_Data* input,
                  SolidColorQuadState* output);

size_t GetSerializedSize_(const SurfaceQuadState& input);
mojo::internal::ValidationError Serialize_(
    SurfaceQuadState* input,
    mojo::internal::Buffer* buffer,
    internal::SurfaceQuadState_Data** output);
void Deserialize_(internal::SurfaceQuadState_Data* input,
                  SurfaceQuadState* output);

size_t GetSerializedSize_(const TextureQuadState& input);
mojo::internal::ValidationError Serialize_(
    TextureQuadState* input,
    mojo::internal::Buffer* buffer,
    internal::TextureQuadState_Data** output);
void Deserialize_(internal::TextureQuadState_Data* input,
                  TextureQuadState* output);

size_t GetSerializedSize_(const TileQuadState& input);
mojo::internal::ValidationError Serialize_(
    TileQuadState* input,
    mojo::internal::Buffer* buffer,
    internal::TileQuadState_Data** output);
void Deserialize_(internal::TileQuadState_Data* input,
                  TileQuadState* output);

size_t GetSerializedSize_(const StreamVideoQuadState& input);
mojo::internal::ValidationError Serialize_(
    StreamVideoQuadState* input,
    mojo::internal::Buffer* buffer,
    internal::StreamVideoQuadState_Data** output);
void Deserialize_(internal::StreamVideoQuadState_Data* input,
                  StreamVideoQuadState* output);

size_t GetSerializedSize_(const YUVVideoQuadState& input);
mojo::internal::ValidationError Serialize_(
    YUVVideoQuadState* input,
    mojo::internal::Buffer* buffer,
    internal::YUVVideoQuadState_Data** output);
void Deserialize_(internal::YUVVideoQuadState_Data* input,
                  YUVVideoQuadState* output);

size_t GetSerializedSize_(const Quad& input);
mojo::internal::ValidationError Serialize_(
    Quad* input,
    mojo::internal::Buffer* buffer,
    internal::Quad_Data** output);
void Deserialize_(internal::Quad_Data* input,
                  Quad* output);

size_t GetSerializedSize_(const SharedQuadState& input);
mojo::internal::ValidationError Serialize_(
    SharedQuadState* input,
    mojo::internal::Buffer* buffer,
    internal::SharedQuadState_Data** output);
void Deserialize_(internal::SharedQuadState_Data* input,
                  SharedQuadState* output);

size_t GetSerializedSize_(const Pass& input);
mojo::internal::ValidationError Serialize_(
    Pass* input,
    mojo::internal::Buffer* buffer,
    internal::Pass_Data** output);
void Deserialize_(internal::Pass_Data* input,
                  Pass* output);


// --- Union serialization helpers ---

// --- Request and response parameter structs for Interface methods ---
}  // namespace mojo

#endif  // MOJO_SERVICES_SURFACES_INTERFACES_QUADS_MOJOM_COMMON_H_
