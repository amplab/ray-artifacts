// NOTE: This file was generated by the Mojo bindings generator.
#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_VALIDATION_TEST_INTERFACES_MOJOM_COMMON_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_VALIDATION_TEST_INTERFACES_MOJOM_COMMON_H_

#include <stdint.h>
#include <iosfwd>

#include "mojo/public/cpp/bindings/array.h"
#include "mojo/public/cpp/bindings/callback.h"
#include "mojo/public/cpp/bindings/interface_handle.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/map.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/bindings/string.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/system/buffer.h"
#include "mojo/public/cpp/system/data_pipe.h"
#include "mojo/public/cpp/system/handle.h"
#include "mojo/public/cpp/system/message_pipe.h"
#include "mojo/public/interfaces/bindings/tests/validation_test_interfaces.mojom-internal.h"
namespace mojo {
namespace test {

// --- Interface Forward Declarations ---
class InterfaceA;
class InterfaceARequestValidator;
class InterfaceA_Synchronous;
class BoundsCheckTestInterface;
class BoundsCheckTestInterfaceRequestValidator;
class BoundsCheckTestInterfaceResponseValidator;
class BoundsCheckTestInterface_Synchronous;
class ConformanceTestInterface;
class ConformanceTestInterfaceRequestValidator;
class ConformanceTestInterfaceResponseValidator;
class ConformanceTestInterface_Synchronous;
class IntegrationTestInterface;
class IntegrationTestInterfaceRequestValidator;
class IntegrationTestInterfaceResponseValidator;
class IntegrationTestInterface_Synchronous;

// --- Struct Forward Declarations ---
class StructA;

using StructAPtr = mojo::InlinedStructPtr<StructA>;


class StructB;

using StructBPtr = mojo::StructPtr<StructB>;


class StructC;

using StructCPtr = mojo::StructPtr<StructC>;


class StructD;

using StructDPtr = mojo::StructPtr<StructD>;


class StructE;

using StructEPtr = mojo::StructPtr<StructE>;


class StructF;

using StructFPtr = mojo::StructPtr<StructF>;


class StructG;

using StructGPtr = mojo::StructPtr<StructG>;


class StructH;

using StructHPtr = mojo::StructPtr<StructH>;


class BasicStruct;

using BasicStructPtr = mojo::InlinedStructPtr<BasicStruct>;


class StructWithEnum;

using StructWithEnumPtr = mojo::InlinedStructPtr<StructWithEnum>;



// --- Union Forward Declarations ---
class UnionA;
typedef mojo::StructPtr<UnionA> UnionAPtr;
class UnionB;
typedef mojo::InlinedStructPtr<UnionB> UnionBPtr;

// --- Enums Declarations ---
  
enum class BasicEnum : int32_t {
  A,
  B,
  C = BasicEnum::A,
  D = -3,
  E = 10,
};

bool BasicEnum_IsValidValue(BasicEnum value);
  
std::ostream& operator<<(std::ostream& stream, const BasicEnum& val);

// --- Constants ---

// --- Interface declarations ---
namespace internal {
class InterfaceA_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = InterfaceARequestValidator;
  using ResponseValidator_ = mojo::internal::PassThroughValidator;
  using Synchronous_ = InterfaceA_Synchronous;
  enum class MessageOrdinals : uint32_t {
  };


  virtual ~InterfaceA_Base() {}
};

}  // namespace internal

// Async interface declaration

class InterfaceAProxy;
class InterfaceAStub;
class InterfaceA_Synchronous;

class InterfaceARequestValidator;

class InterfaceA : public internal::InterfaceA_Base {
 public:
  virtual ~InterfaceA() override {}

  using Proxy_ = InterfaceAProxy;
  using Stub_ = InterfaceAStub;
};

namespace internal {
class BoundsCheckTestInterface_Base {
 public:
  static const char Name_[];
  static const uint32_t Version_ = 0;

  using RequestValidator_ = BoundsCheckTestInterfaceRequestValidator;
  using ResponseValidator_ = BoundsCheckTestInterfaceResponseValidator;
  using Synchronous_ = BoundsCheckTestInterface_Synchronous;
  enum class MessageOrdinals : uint32_t {
    Method0 = 0,
    Method1 = 1,
  };


  virtual ~BoundsCheckTestInterface_Base() {}
};

}  // namespace internal

// Async interface declaration

class BoundsCheckTestInterfaceProxy;
class BoundsCheckTestInterfaceStub;
class BoundsCheckTestInterface_Synchronous;

class BoundsCheckTestInterfaceRequestValidator;
class BoundsCheckTestInterfaceResponseValidator;

class BoundsCheckTestInterface : public internal::BoundsCheckTestInterface_Base {
 public:
  virtual ~BoundsCheckTestInterface() override {}

  using Proxy_ = BoundsCheckTestInterfaceProxy;
  using Stub_ = BoundsCheckTestInterfaceStub;
  using Method0Callback = mojo::Callback<void(uint8_t)>;
  virtual void Method0(uint8_t param0, const Method0Callback& callback) = 0;
  virtual void Method1(uint8_t param0) = 0;
};

namespace internal {
class ConformanceTestInterface_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = ConformanceTestInterfaceRequestValidator;
  using ResponseValidator_ = ConformanceTestInterfaceResponseValidator;
  using Synchronous_ = ConformanceTestInterface_Synchronous;
  enum class MessageOrdinals : uint32_t {
    Method0 = 0,
    Method1 = 1,
    Method2 = 2,
    Method3 = 3,
    Method4 = 4,
    Method5 = 5,
    Method6 = 6,
    Method7 = 7,
    Method8 = 8,
    Method9 = 9,
    Method10 = 10,
    Method11 = 11,
    Method12 = 12,
    Method13 = 13,
    Method14 = 14,
    Method15 = 15,
  };


  virtual ~ConformanceTestInterface_Base() {}
};

}  // namespace internal

// Async interface declaration

class ConformanceTestInterfaceProxy;
class ConformanceTestInterfaceStub;
class ConformanceTestInterface_Synchronous;

class ConformanceTestInterfaceRequestValidator;
class ConformanceTestInterfaceResponseValidator;

class ConformanceTestInterface : public internal::ConformanceTestInterface_Base {
 public:
  virtual ~ConformanceTestInterface() override {}

  using Proxy_ = ConformanceTestInterfaceProxy;
  using Stub_ = ConformanceTestInterfaceStub;
  virtual void Method0(float param0) = 0;
  virtual void Method1(StructAPtr param0) = 0;
  virtual void Method2(StructBPtr param0, StructAPtr param1) = 0;
  virtual void Method3(mojo::Array<bool> param0) = 0;
  virtual void Method4(StructCPtr param0, mojo::Array<uint8_t> param1) = 0;
  virtual void Method5(StructEPtr param0, mojo::ScopedDataPipeProducerHandle param1) = 0;
  virtual void Method6(mojo::Array<mojo::Array<uint8_t> > param0) = 0;
  virtual void Method7(StructFPtr param0, mojo::Array<mojo::Array<uint8_t> > param1) = 0;
  virtual void Method8(mojo::Array<mojo::Array<mojo::String> > param0) = 0;
  virtual void Method9(mojo::Array<mojo::Array<mojo::ScopedHandle> > param0) = 0;
  virtual void Method10(mojo::Map<mojo::String, uint8_t> param0) = 0;
  virtual void Method11(StructGPtr param0) = 0;
  using Method12Callback = mojo::Callback<void(float)>;
  virtual void Method12(float param0, const Method12Callback& callback) = 0;
  virtual void Method13(mojo::InterfaceHandle<InterfaceA> param0, uint32_t param1, mojo::InterfaceHandle<InterfaceA> param2) = 0;
  virtual void Method14(UnionAPtr param0) = 0;
  virtual void Method15(StructHPtr param0) = 0;
};

namespace internal {
class IntegrationTestInterface_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = IntegrationTestInterfaceRequestValidator;
  using ResponseValidator_ = IntegrationTestInterfaceResponseValidator;
  using Synchronous_ = IntegrationTestInterface_Synchronous;
  enum class MessageOrdinals : uint32_t {
    Method0 = 0,
  };


  virtual ~IntegrationTestInterface_Base() {}
};

}  // namespace internal

// Async interface declaration

class IntegrationTestInterfaceProxy;
class IntegrationTestInterfaceStub;
class IntegrationTestInterface_Synchronous;

class IntegrationTestInterfaceRequestValidator;
class IntegrationTestInterfaceResponseValidator;

class IntegrationTestInterface : public internal::IntegrationTestInterface_Base {
 public:
  virtual ~IntegrationTestInterface() override {}

  using Proxy_ = IntegrationTestInterfaceProxy;
  using Stub_ = IntegrationTestInterfaceStub;
  using Method0Callback = mojo::Callback<void(mojo::Array<uint8_t>)>;
  virtual void Method0(BasicStructPtr param0, const Method0Callback& callback) = 0;
};

}  // namespace test
}  // namespace mojo

// --- Internal Template Specializations ---

namespace mojo {
namespace internal {
template <>
struct WrapperTraits<mojo::test::StructAPtr, true, false> {
  using DataType = mojo::test::internal::StructA_Data*;
};
template <>
struct WrapperTraits<mojo::test::StructBPtr, true, false> {
  using DataType = mojo::test::internal::StructB_Data*;
};
template <>
struct WrapperTraits<mojo::test::StructCPtr, true, false> {
  using DataType = mojo::test::internal::StructC_Data*;
};
template <>
struct WrapperTraits<mojo::test::StructDPtr, true, false> {
  using DataType = mojo::test::internal::StructD_Data*;
};
template <>
struct WrapperTraits<mojo::test::StructEPtr, true, false> {
  using DataType = mojo::test::internal::StructE_Data*;
};
template <>
struct WrapperTraits<mojo::test::StructFPtr, true, false> {
  using DataType = mojo::test::internal::StructF_Data*;
};
template <>
struct WrapperTraits<mojo::test::StructGPtr, true, false> {
  using DataType = mojo::test::internal::StructG_Data*;
};
template <>
struct WrapperTraits<mojo::test::StructHPtr, true, false> {
  using DataType = mojo::test::internal::StructH_Data*;
};
template <>
struct WrapperTraits<mojo::test::BasicStructPtr, true, false> {
  using DataType = mojo::test::internal::BasicStruct_Data*;
};
template <>
struct WrapperTraits<mojo::test::StructWithEnumPtr, true, false> {
  using DataType = mojo::test::internal::StructWithEnum_Data*;
};

}  // internal
}  // mojo
namespace mojo {
namespace test {

// --- Interface Request Validators ---
class InterfaceARequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class BoundsCheckTestInterfaceRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class ConformanceTestInterfaceRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class IntegrationTestInterfaceRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface Response Validators ---
class BoundsCheckTestInterfaceResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class ConformanceTestInterfaceResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class IntegrationTestInterfaceResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface enum operators ---

// --- Unions ---
// Unions must be declared first because they can be members of structs.
class UnionA {
 public:
  using Data_ = internal::UnionA_Data;
  using Tag = Data_::UnionA_Tag;

  static UnionAPtr New();

  template <typename U>
  static UnionAPtr From(const U& u) {
    return mojo::TypeConverter<UnionAPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UnionA>::Convert(*this);
  }

  UnionA();
  ~UnionA();


  UnionAPtr Clone() const;
  bool Equals(const UnionA& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_a() const;
  uint16_t get_a() const;
  void set_a(uint16_t a);
  bool is_b() const;
  uint32_t get_b() const;
  void set_b(uint32_t b);
  bool is_c() const;
  StructAPtr& get_c() const;
  void set_c(StructAPtr c);
  bool is_d() const;
  mojo::Array<uint8_t>& get_d() const;
  void set_d(mojo::Array<uint8_t> d);
  bool is_e() const;
  mojo::Map<mojo::String, uint8_t>& get_e() const;
  void set_e(mojo::Map<mojo::String, uint8_t> e);
  bool is_f() const;
  UnionBPtr& get_f() const;
  void set_f(UnionBPtr f);
  bool is_g() const;
  StructAPtr& get_g() const;
  void set_g(StructAPtr g);
  bool is_h() const;
  mojo::Array<uint8_t>& get_h() const;
  void set_h(mojo::Array<uint8_t> h);
  bool is_i() const;
  mojo::Map<mojo::String, uint8_t>& get_i() const;
  void set_i(mojo::Map<mojo::String, uint8_t> i);
  bool is_j() const;
  UnionBPtr& get_j() const;
  void set_j(UnionBPtr j);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<UnionA>;
  union Union_ {
    Union_() {}
    ~Union_() {}

uint16_t a;

uint32_t b;

StructAPtr* c;

mojo::Array<uint8_t>* d;

mojo::Map<mojo::String, uint8_t>* e;

UnionBPtr* f;

StructAPtr* g;

mojo::Array<uint8_t>* h;

mojo::Map<mojo::String, uint8_t>* i;

UnionBPtr* j;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};

class UnionB {
 public:
  using Data_ = internal::UnionB_Data;
  using Tag = Data_::UnionB_Tag;

  static UnionBPtr New();

  template <typename U>
  static UnionBPtr From(const U& u) {
    return mojo::TypeConverter<UnionBPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UnionB>::Convert(*this);
  }

  UnionB();
  ~UnionB();


  UnionBPtr Clone() const;
  bool Equals(const UnionB& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_a() const;
  uint16_t get_a() const;
  void set_a(uint16_t a);
  bool is_b() const;
  uint32_t get_b() const;
  void set_b(uint32_t b);
  bool is_c() const;
  uint64_t get_c() const;
  void set_c(uint64_t c);
  bool is_d() const;
  uint32_t get_d() const;
  void set_d(uint32_t d);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<UnionB>;
  union Union_ {
    Union_() {}
    ~Union_() {}

uint16_t a;

uint32_t b;

uint64_t c;

uint32_t d;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};


// --- Inlined structs ---
class StructA {
 public:
  using Data_ = internal::StructA_Data;

  static StructAPtr New();

  template <typename U>
  static StructAPtr From(const U& u) {
    return mojo::TypeConverter<StructAPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructA>::Convert(*this);
  }

  StructA();
  ~StructA();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  StructAPtr Clone() const;
  bool Equals(const StructA& other) const;

  uint64_t i;
};


class BasicStruct {
 public:
  using Data_ = internal::BasicStruct_Data;

  static BasicStructPtr New();

  template <typename U>
  static BasicStructPtr From(const U& u) {
    return mojo::TypeConverter<BasicStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BasicStruct>::Convert(*this);
  }

  BasicStruct();
  ~BasicStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  BasicStructPtr Clone() const;
  bool Equals(const BasicStruct& other) const;

  int32_t a;
};


class StructWithEnum {
 public:
  using Data_ = internal::StructWithEnum_Data;
  enum class EnumWithin : int32_t {
    A,
    B,
    C,
    D,
  };
  
  static bool EnumWithin_IsValidValue(EnumWithin value);

  static StructWithEnumPtr New();

  template <typename U>
  static StructWithEnumPtr From(const U& u) {
    return mojo::TypeConverter<StructWithEnumPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructWithEnum>::Convert(*this);
  }

  StructWithEnum();
  ~StructWithEnum();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  StructWithEnumPtr Clone() const;
  bool Equals(const StructWithEnum& other) const;

};

  
std::ostream& operator<<(std::ostream& stream,
                         const StructWithEnum::EnumWithin& val);


// --- Non-inlined structs ---
class StructB {
 public:
  using Data_ = internal::StructB_Data;

  static StructBPtr New();

  template <typename U>
  static StructBPtr From(const U& u) {
    return mojo::TypeConverter<StructBPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructB>::Convert(*this);
  }

  StructB();
  ~StructB();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  StructBPtr Clone() const;
  bool Equals(const StructB& other) const;

  StructAPtr struct_a;
};


class StructC {
 public:
  using Data_ = internal::StructC_Data;

  static StructCPtr New();

  template <typename U>
  static StructCPtr From(const U& u) {
    return mojo::TypeConverter<StructCPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructC>::Convert(*this);
  }

  StructC();
  ~StructC();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  StructCPtr Clone() const;
  bool Equals(const StructC& other) const;

  mojo::Array<uint8_t> data;
};


class StructD {
 public:
  using Data_ = internal::StructD_Data;

  static StructDPtr New();

  template <typename U>
  static StructDPtr From(const U& u) {
    return mojo::TypeConverter<StructDPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructD>::Convert(*this);
  }

  StructD();
  ~StructD();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const StructD& other) const;

  mojo::Array<mojo::ScopedMessagePipeHandle> message_pipes;
};


class StructE {
 public:
  using Data_ = internal::StructE_Data;

  static StructEPtr New();

  template <typename U>
  static StructEPtr From(const U& u) {
    return mojo::TypeConverter<StructEPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructE>::Convert(*this);
  }

  StructE();
  ~StructE();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const StructE& other) const;

  StructDPtr struct_d;
  mojo::ScopedDataPipeConsumerHandle data_pipe_consumer;
};


class StructF {
 public:
  using Data_ = internal::StructF_Data;

  static StructFPtr New();

  template <typename U>
  static StructFPtr From(const U& u) {
    return mojo::TypeConverter<StructFPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructF>::Convert(*this);
  }

  StructF();
  ~StructF();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  StructFPtr Clone() const;
  bool Equals(const StructF& other) const;

  mojo::Array<uint8_t> fixed_size_array;
};


class StructG {
 public:
  using Data_ = internal::StructG_Data;

  static StructGPtr New();

  template <typename U>
  static StructGPtr From(const U& u) {
    return mojo::TypeConverter<StructGPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructG>::Convert(*this);
  }

  StructG();
  ~StructG();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  StructGPtr Clone() const;
  bool Equals(const StructG& other) const;

  int32_t i;
  StructAPtr struct_a;
  mojo::String str;
  bool b;
};


class StructH {
 public:
  using Data_ = internal::StructH_Data;

  static StructHPtr New();

  template <typename U>
  static StructHPtr From(const U& u) {
    return mojo::TypeConverter<StructHPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructH>::Convert(*this);
  }

  StructH();
  ~StructH();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  StructHPtr Clone() const;
  bool Equals(const StructH& other) const;

  bool a;
  uint8_t b;
  UnionAPtr c;
  mojo::Array<UnionAPtr> d;
  mojo::Map<uint8_t, UnionAPtr> e;
};



// --- Struct serialization helpers ---
size_t GetSerializedSize_(const StructA& input);
mojo::internal::ValidationError Serialize_(
    StructA* input,
    mojo::internal::Buffer* buffer,
    internal::StructA_Data** output);
void Deserialize_(internal::StructA_Data* input,
                  StructA* output);

size_t GetSerializedSize_(const StructB& input);
mojo::internal::ValidationError Serialize_(
    StructB* input,
    mojo::internal::Buffer* buffer,
    internal::StructB_Data** output);
void Deserialize_(internal::StructB_Data* input,
                  StructB* output);

size_t GetSerializedSize_(const StructC& input);
mojo::internal::ValidationError Serialize_(
    StructC* input,
    mojo::internal::Buffer* buffer,
    internal::StructC_Data** output);
void Deserialize_(internal::StructC_Data* input,
                  StructC* output);

size_t GetSerializedSize_(const StructD& input);
mojo::internal::ValidationError Serialize_(
    StructD* input,
    mojo::internal::Buffer* buffer,
    internal::StructD_Data** output);
void Deserialize_(internal::StructD_Data* input,
                  StructD* output);

size_t GetSerializedSize_(const StructE& input);
mojo::internal::ValidationError Serialize_(
    StructE* input,
    mojo::internal::Buffer* buffer,
    internal::StructE_Data** output);
void Deserialize_(internal::StructE_Data* input,
                  StructE* output);

size_t GetSerializedSize_(const StructF& input);
mojo::internal::ValidationError Serialize_(
    StructF* input,
    mojo::internal::Buffer* buffer,
    internal::StructF_Data** output);
void Deserialize_(internal::StructF_Data* input,
                  StructF* output);

size_t GetSerializedSize_(const StructG& input);
mojo::internal::ValidationError Serialize_(
    StructG* input,
    mojo::internal::Buffer* buffer,
    internal::StructG_Data** output);
void Deserialize_(internal::StructG_Data* input,
                  StructG* output);

size_t GetSerializedSize_(const StructH& input);
mojo::internal::ValidationError Serialize_(
    StructH* input,
    mojo::internal::Buffer* buffer,
    internal::StructH_Data** output);
void Deserialize_(internal::StructH_Data* input,
                  StructH* output);

size_t GetSerializedSize_(const BasicStruct& input);
mojo::internal::ValidationError Serialize_(
    BasicStruct* input,
    mojo::internal::Buffer* buffer,
    internal::BasicStruct_Data** output);
void Deserialize_(internal::BasicStruct_Data* input,
                  BasicStruct* output);

size_t GetSerializedSize_(const StructWithEnum& input);
mojo::internal::ValidationError Serialize_(
    StructWithEnum* input,
    mojo::internal::Buffer* buffer,
    internal::StructWithEnum_Data** output);
void Deserialize_(internal::StructWithEnum_Data* input,
                  StructWithEnum* output);


// --- Union serialization helpers ---
size_t GetSerializedSize_(const UnionAPtr& input);
mojo::internal::ValidationError SerializeUnion_(
    UnionA* input,
    mojo::internal::Buffer* buffer,
    internal::UnionA_Data** output);
void Deserialize_(internal::UnionA_Data* input,
                  UnionA* output);

size_t GetSerializedSize_(const UnionBPtr& input);
mojo::internal::ValidationError SerializeUnion_(
    UnionB* input,
    mojo::internal::Buffer* buffer,
    internal::UnionB_Data** output);
void Deserialize_(internal::UnionB_Data* input,
                  UnionB* output);


// --- Request and response parameter structs for Interface methods ---
      
      

class BoundsCheckTestInterface_Method0_Params;

using BoundsCheckTestInterface_Method0_ParamsPtr = mojo::InlinedStructPtr<BoundsCheckTestInterface_Method0_Params>;


size_t GetSerializedSize_(const BoundsCheckTestInterface_Method0_Params& input);
mojo::internal::ValidationError Serialize_(
    BoundsCheckTestInterface_Method0_Params* input,
    mojo::internal::Buffer* buffer,
    internal::BoundsCheckTestInterface_Method0_Params_Data** output);
void Deserialize_(internal::BoundsCheckTestInterface_Method0_Params_Data* input,
                  BoundsCheckTestInterface_Method0_Params* output);

class BoundsCheckTestInterface_Method0_Params {
 public:
  using Data_ = internal::BoundsCheckTestInterface_Method0_Params_Data;

  static BoundsCheckTestInterface_Method0_ParamsPtr New();

  template <typename U>
  static BoundsCheckTestInterface_Method0_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<BoundsCheckTestInterface_Method0_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BoundsCheckTestInterface_Method0_Params>::Convert(*this);
  }

  BoundsCheckTestInterface_Method0_Params();
  ~BoundsCheckTestInterface_Method0_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  BoundsCheckTestInterface_Method0_ParamsPtr Clone() const;
  bool Equals(const BoundsCheckTestInterface_Method0_Params& other) const;

  uint8_t param0;
};



class BoundsCheckTestInterface_Method0_ResponseParams;

using BoundsCheckTestInterface_Method0_ResponseParamsPtr = mojo::InlinedStructPtr<BoundsCheckTestInterface_Method0_ResponseParams>;


size_t GetSerializedSize_(const BoundsCheckTestInterface_Method0_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    BoundsCheckTestInterface_Method0_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::BoundsCheckTestInterface_Method0_ResponseParams_Data** output);
void Deserialize_(internal::BoundsCheckTestInterface_Method0_ResponseParams_Data* input,
                  BoundsCheckTestInterface_Method0_ResponseParams* output);

class BoundsCheckTestInterface_Method0_ResponseParams {
 public:
  using Data_ = internal::BoundsCheckTestInterface_Method0_ResponseParams_Data;

  static BoundsCheckTestInterface_Method0_ResponseParamsPtr New();

  template <typename U>
  static BoundsCheckTestInterface_Method0_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<BoundsCheckTestInterface_Method0_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BoundsCheckTestInterface_Method0_ResponseParams>::Convert(*this);
  }

  BoundsCheckTestInterface_Method0_ResponseParams();
  ~BoundsCheckTestInterface_Method0_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  BoundsCheckTestInterface_Method0_ResponseParamsPtr Clone() const;
  bool Equals(const BoundsCheckTestInterface_Method0_ResponseParams& other) const;

  uint8_t param0;
};



class BoundsCheckTestInterface_Method1_Params;

using BoundsCheckTestInterface_Method1_ParamsPtr = mojo::InlinedStructPtr<BoundsCheckTestInterface_Method1_Params>;


size_t GetSerializedSize_(const BoundsCheckTestInterface_Method1_Params& input);
mojo::internal::ValidationError Serialize_(
    BoundsCheckTestInterface_Method1_Params* input,
    mojo::internal::Buffer* buffer,
    internal::BoundsCheckTestInterface_Method1_Params_Data** output);
void Deserialize_(internal::BoundsCheckTestInterface_Method1_Params_Data* input,
                  BoundsCheckTestInterface_Method1_Params* output);

class BoundsCheckTestInterface_Method1_Params {
 public:
  using Data_ = internal::BoundsCheckTestInterface_Method1_Params_Data;

  static BoundsCheckTestInterface_Method1_ParamsPtr New();

  template <typename U>
  static BoundsCheckTestInterface_Method1_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<BoundsCheckTestInterface_Method1_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BoundsCheckTestInterface_Method1_Params>::Convert(*this);
  }

  BoundsCheckTestInterface_Method1_Params();
  ~BoundsCheckTestInterface_Method1_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  BoundsCheckTestInterface_Method1_ParamsPtr Clone() const;
  bool Equals(const BoundsCheckTestInterface_Method1_Params& other) const;

  uint8_t param0;
};



      

class ConformanceTestInterface_Method0_Params;

using ConformanceTestInterface_Method0_ParamsPtr = mojo::InlinedStructPtr<ConformanceTestInterface_Method0_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method0_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method0_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method0_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method0_Params_Data* input,
                  ConformanceTestInterface_Method0_Params* output);

class ConformanceTestInterface_Method0_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method0_Params_Data;

  static ConformanceTestInterface_Method0_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method0_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method0_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method0_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method0_Params();
  ~ConformanceTestInterface_Method0_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method0_ParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method0_Params& other) const;

  float param0;
};




class ConformanceTestInterface_Method1_Params;

using ConformanceTestInterface_Method1_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method1_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method1_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method1_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method1_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method1_Params_Data* input,
                  ConformanceTestInterface_Method1_Params* output);

class ConformanceTestInterface_Method1_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method1_Params_Data;

  static ConformanceTestInterface_Method1_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method1_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method1_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method1_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method1_Params();
  ~ConformanceTestInterface_Method1_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method1_ParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method1_Params& other) const;

  StructAPtr param0;
};




class ConformanceTestInterface_Method2_Params;

using ConformanceTestInterface_Method2_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method2_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method2_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method2_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method2_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method2_Params_Data* input,
                  ConformanceTestInterface_Method2_Params* output);

class ConformanceTestInterface_Method2_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method2_Params_Data;

  static ConformanceTestInterface_Method2_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method2_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method2_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method2_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method2_Params();
  ~ConformanceTestInterface_Method2_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method2_ParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method2_Params& other) const;

  StructBPtr param0;
  StructAPtr param1;
};




class ConformanceTestInterface_Method3_Params;

using ConformanceTestInterface_Method3_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method3_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method3_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method3_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method3_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method3_Params_Data* input,
                  ConformanceTestInterface_Method3_Params* output);

class ConformanceTestInterface_Method3_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method3_Params_Data;

  static ConformanceTestInterface_Method3_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method3_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method3_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method3_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method3_Params();
  ~ConformanceTestInterface_Method3_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method3_ParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method3_Params& other) const;

  mojo::Array<bool> param0;
};




class ConformanceTestInterface_Method4_Params;

using ConformanceTestInterface_Method4_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method4_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method4_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method4_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method4_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method4_Params_Data* input,
                  ConformanceTestInterface_Method4_Params* output);

class ConformanceTestInterface_Method4_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method4_Params_Data;

  static ConformanceTestInterface_Method4_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method4_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method4_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method4_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method4_Params();
  ~ConformanceTestInterface_Method4_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method4_ParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method4_Params& other) const;

  StructCPtr param0;
  mojo::Array<uint8_t> param1;
};




class ConformanceTestInterface_Method5_Params;

using ConformanceTestInterface_Method5_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method5_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method5_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method5_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method5_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method5_Params_Data* input,
                  ConformanceTestInterface_Method5_Params* output);

class ConformanceTestInterface_Method5_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method5_Params_Data;

  static ConformanceTestInterface_Method5_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method5_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method5_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method5_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method5_Params();
  ~ConformanceTestInterface_Method5_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const ConformanceTestInterface_Method5_Params& other) const;

  StructEPtr param0;
  mojo::ScopedDataPipeProducerHandle param1;
};




class ConformanceTestInterface_Method6_Params;

using ConformanceTestInterface_Method6_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method6_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method6_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method6_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method6_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method6_Params_Data* input,
                  ConformanceTestInterface_Method6_Params* output);

class ConformanceTestInterface_Method6_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method6_Params_Data;

  static ConformanceTestInterface_Method6_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method6_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method6_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method6_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method6_Params();
  ~ConformanceTestInterface_Method6_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method6_ParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method6_Params& other) const;

  mojo::Array<mojo::Array<uint8_t> > param0;
};




class ConformanceTestInterface_Method7_Params;

using ConformanceTestInterface_Method7_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method7_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method7_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method7_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method7_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method7_Params_Data* input,
                  ConformanceTestInterface_Method7_Params* output);

class ConformanceTestInterface_Method7_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method7_Params_Data;

  static ConformanceTestInterface_Method7_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method7_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method7_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method7_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method7_Params();
  ~ConformanceTestInterface_Method7_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method7_ParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method7_Params& other) const;

  StructFPtr param0;
  mojo::Array<mojo::Array<uint8_t> > param1;
};




class ConformanceTestInterface_Method8_Params;

using ConformanceTestInterface_Method8_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method8_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method8_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method8_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method8_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method8_Params_Data* input,
                  ConformanceTestInterface_Method8_Params* output);

class ConformanceTestInterface_Method8_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method8_Params_Data;

  static ConformanceTestInterface_Method8_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method8_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method8_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method8_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method8_Params();
  ~ConformanceTestInterface_Method8_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method8_ParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method8_Params& other) const;

  mojo::Array<mojo::Array<mojo::String> > param0;
};




class ConformanceTestInterface_Method9_Params;

using ConformanceTestInterface_Method9_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method9_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method9_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method9_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method9_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method9_Params_Data* input,
                  ConformanceTestInterface_Method9_Params* output);

class ConformanceTestInterface_Method9_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method9_Params_Data;

  static ConformanceTestInterface_Method9_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method9_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method9_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method9_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method9_Params();
  ~ConformanceTestInterface_Method9_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const ConformanceTestInterface_Method9_Params& other) const;

  mojo::Array<mojo::Array<mojo::ScopedHandle> > param0;
};




class ConformanceTestInterface_Method10_Params;

using ConformanceTestInterface_Method10_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method10_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method10_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method10_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method10_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method10_Params_Data* input,
                  ConformanceTestInterface_Method10_Params* output);

class ConformanceTestInterface_Method10_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method10_Params_Data;

  static ConformanceTestInterface_Method10_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method10_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method10_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method10_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method10_Params();
  ~ConformanceTestInterface_Method10_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method10_ParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method10_Params& other) const;

  mojo::Map<mojo::String, uint8_t> param0;
};




class ConformanceTestInterface_Method11_Params;

using ConformanceTestInterface_Method11_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method11_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method11_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method11_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method11_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method11_Params_Data* input,
                  ConformanceTestInterface_Method11_Params* output);

class ConformanceTestInterface_Method11_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method11_Params_Data;

  static ConformanceTestInterface_Method11_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method11_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method11_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method11_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method11_Params();
  ~ConformanceTestInterface_Method11_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method11_ParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method11_Params& other) const;

  StructGPtr param0;
};




class ConformanceTestInterface_Method12_Params;

using ConformanceTestInterface_Method12_ParamsPtr = mojo::InlinedStructPtr<ConformanceTestInterface_Method12_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method12_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method12_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method12_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method12_Params_Data* input,
                  ConformanceTestInterface_Method12_Params* output);

class ConformanceTestInterface_Method12_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method12_Params_Data;

  static ConformanceTestInterface_Method12_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method12_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method12_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method12_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method12_Params();
  ~ConformanceTestInterface_Method12_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method12_ParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method12_Params& other) const;

  float param0;
};



class ConformanceTestInterface_Method12_ResponseParams;

using ConformanceTestInterface_Method12_ResponseParamsPtr = mojo::InlinedStructPtr<ConformanceTestInterface_Method12_ResponseParams>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method12_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method12_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method12_ResponseParams_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method12_ResponseParams_Data* input,
                  ConformanceTestInterface_Method12_ResponseParams* output);

class ConformanceTestInterface_Method12_ResponseParams {
 public:
  using Data_ = internal::ConformanceTestInterface_Method12_ResponseParams_Data;

  static ConformanceTestInterface_Method12_ResponseParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method12_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method12_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method12_ResponseParams>::Convert(*this);
  }

  ConformanceTestInterface_Method12_ResponseParams();
  ~ConformanceTestInterface_Method12_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method12_ResponseParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method12_ResponseParams& other) const;

  float param0;
};



class ConformanceTestInterface_Method13_Params;

using ConformanceTestInterface_Method13_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method13_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method13_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method13_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method13_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method13_Params_Data* input,
                  ConformanceTestInterface_Method13_Params* output);

class ConformanceTestInterface_Method13_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method13_Params_Data;

  static ConformanceTestInterface_Method13_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method13_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method13_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method13_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method13_Params();
  ~ConformanceTestInterface_Method13_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const ConformanceTestInterface_Method13_Params& other) const;

  mojo::InterfaceHandle<InterfaceA> param0;
  uint32_t param1;
  mojo::InterfaceHandle<InterfaceA> param2;
};




class ConformanceTestInterface_Method14_Params;

using ConformanceTestInterface_Method14_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method14_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method14_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method14_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method14_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method14_Params_Data* input,
                  ConformanceTestInterface_Method14_Params* output);

class ConformanceTestInterface_Method14_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method14_Params_Data;

  static ConformanceTestInterface_Method14_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method14_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method14_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method14_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method14_Params();
  ~ConformanceTestInterface_Method14_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method14_ParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method14_Params& other) const;

  UnionAPtr param0;
};




class ConformanceTestInterface_Method15_Params;

using ConformanceTestInterface_Method15_ParamsPtr = mojo::StructPtr<ConformanceTestInterface_Method15_Params>;


size_t GetSerializedSize_(const ConformanceTestInterface_Method15_Params& input);
mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method15_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ConformanceTestInterface_Method15_Params_Data** output);
void Deserialize_(internal::ConformanceTestInterface_Method15_Params_Data* input,
                  ConformanceTestInterface_Method15_Params* output);

class ConformanceTestInterface_Method15_Params {
 public:
  using Data_ = internal::ConformanceTestInterface_Method15_Params_Data;

  static ConformanceTestInterface_Method15_ParamsPtr New();

  template <typename U>
  static ConformanceTestInterface_Method15_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ConformanceTestInterface_Method15_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConformanceTestInterface_Method15_Params>::Convert(*this);
  }

  ConformanceTestInterface_Method15_Params();
  ~ConformanceTestInterface_Method15_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ConformanceTestInterface_Method15_ParamsPtr Clone() const;
  bool Equals(const ConformanceTestInterface_Method15_Params& other) const;

  StructHPtr param0;
};



      

class IntegrationTestInterface_Method0_Params;

using IntegrationTestInterface_Method0_ParamsPtr = mojo::StructPtr<IntegrationTestInterface_Method0_Params>;


size_t GetSerializedSize_(const IntegrationTestInterface_Method0_Params& input);
mojo::internal::ValidationError Serialize_(
    IntegrationTestInterface_Method0_Params* input,
    mojo::internal::Buffer* buffer,
    internal::IntegrationTestInterface_Method0_Params_Data** output);
void Deserialize_(internal::IntegrationTestInterface_Method0_Params_Data* input,
                  IntegrationTestInterface_Method0_Params* output);

class IntegrationTestInterface_Method0_Params {
 public:
  using Data_ = internal::IntegrationTestInterface_Method0_Params_Data;

  static IntegrationTestInterface_Method0_ParamsPtr New();

  template <typename U>
  static IntegrationTestInterface_Method0_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<IntegrationTestInterface_Method0_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, IntegrationTestInterface_Method0_Params>::Convert(*this);
  }

  IntegrationTestInterface_Method0_Params();
  ~IntegrationTestInterface_Method0_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  IntegrationTestInterface_Method0_ParamsPtr Clone() const;
  bool Equals(const IntegrationTestInterface_Method0_Params& other) const;

  BasicStructPtr param0;
};



class IntegrationTestInterface_Method0_ResponseParams;

using IntegrationTestInterface_Method0_ResponseParamsPtr = mojo::StructPtr<IntegrationTestInterface_Method0_ResponseParams>;


size_t GetSerializedSize_(const IntegrationTestInterface_Method0_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    IntegrationTestInterface_Method0_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::IntegrationTestInterface_Method0_ResponseParams_Data** output);
void Deserialize_(internal::IntegrationTestInterface_Method0_ResponseParams_Data* input,
                  IntegrationTestInterface_Method0_ResponseParams* output);

class IntegrationTestInterface_Method0_ResponseParams {
 public:
  using Data_ = internal::IntegrationTestInterface_Method0_ResponseParams_Data;

  static IntegrationTestInterface_Method0_ResponseParamsPtr New();

  template <typename U>
  static IntegrationTestInterface_Method0_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<IntegrationTestInterface_Method0_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, IntegrationTestInterface_Method0_ResponseParams>::Convert(*this);
  }

  IntegrationTestInterface_Method0_ResponseParams();
  ~IntegrationTestInterface_Method0_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  IntegrationTestInterface_Method0_ResponseParamsPtr Clone() const;
  bool Equals(const IntegrationTestInterface_Method0_ResponseParams& other) const;

  mojo::Array<uint8_t> param0;
};


}  // namespace test
}  // namespace mojo

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_VALIDATION_TEST_INTERFACES_MOJOM_COMMON_H_
