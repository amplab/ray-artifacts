// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/services/files/interfaces/directory.mojom.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
namespace mojo {
namespace files {

// --- Interface definitions ---
class Directory_Read_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Directory_Read_ForwardToCallback(
      const Directory::ReadCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Directory::ReadCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_Read_ForwardToCallback);
};
bool Directory_Read_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Directory_Read_ResponseParams_Data* params =
      reinterpret_cast<internal::Directory_Read_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::files::Error p_error {};
  mojo::Array<mojo::files::DirectoryEntryPtr> p_directory_contents {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    p_error = static_cast<mojo::files::Error>(params->error);
    Deserialize_(params->directory_contents.ptr, &p_directory_contents);
  } while (false);
  callback_.Run(p_error, p_directory_contents.Pass());
  return true;
}
class Directory_Stat_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Directory_Stat_ForwardToCallback(
      const Directory::StatCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Directory::StatCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_Stat_ForwardToCallback);
};
bool Directory_Stat_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Directory_Stat_ResponseParams_Data* params =
      reinterpret_cast<internal::Directory_Stat_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::files::Error p_error {};
  mojo::files::FileInformationPtr p_file_information {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    p_error = static_cast<mojo::files::Error>(params->error);
    if (params->file_information.ptr) {
      p_file_information = mojo::files::FileInformation::New();
      Deserialize_(params->file_information.ptr, p_file_information.get());
    }
  } while (false);
  callback_.Run(p_error, p_file_information.Pass());
  return true;
}
class Directory_Touch_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Directory_Touch_ForwardToCallback(
      const Directory::TouchCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Directory::TouchCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_Touch_ForwardToCallback);
};
bool Directory_Touch_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Directory_Touch_ResponseParams_Data* params =
      reinterpret_cast<internal::Directory_Touch_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::files::Error p_error {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    p_error = static_cast<mojo::files::Error>(params->error);
  } while (false);
  callback_.Run(p_error);
  return true;
}
class Directory_OpenFile_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Directory_OpenFile_ForwardToCallback(
      const Directory::OpenFileCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Directory::OpenFileCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_OpenFile_ForwardToCallback);
};
bool Directory_OpenFile_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Directory_OpenFile_ResponseParams_Data* params =
      reinterpret_cast<internal::Directory_OpenFile_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::files::Error p_error {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    p_error = static_cast<mojo::files::Error>(params->error);
  } while (false);
  callback_.Run(p_error);
  return true;
}
class Directory_OpenDirectory_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Directory_OpenDirectory_ForwardToCallback(
      const Directory::OpenDirectoryCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Directory::OpenDirectoryCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_OpenDirectory_ForwardToCallback);
};
bool Directory_OpenDirectory_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Directory_OpenDirectory_ResponseParams_Data* params =
      reinterpret_cast<internal::Directory_OpenDirectory_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::files::Error p_error {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    p_error = static_cast<mojo::files::Error>(params->error);
  } while (false);
  callback_.Run(p_error);
  return true;
}
class Directory_Rename_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Directory_Rename_ForwardToCallback(
      const Directory::RenameCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Directory::RenameCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_Rename_ForwardToCallback);
};
bool Directory_Rename_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Directory_Rename_ResponseParams_Data* params =
      reinterpret_cast<internal::Directory_Rename_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::files::Error p_error {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    p_error = static_cast<mojo::files::Error>(params->error);
  } while (false);
  callback_.Run(p_error);
  return true;
}
class Directory_Delete_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Directory_Delete_ForwardToCallback(
      const Directory::DeleteCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Directory::DeleteCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_Delete_ForwardToCallback);
};
bool Directory_Delete_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Directory_Delete_ResponseParams_Data* params =
      reinterpret_cast<internal::Directory_Delete_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::files::Error p_error {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    p_error = static_cast<mojo::files::Error>(params->error);
  } while (false);
  callback_.Run(p_error);
  return true;
}

DirectoryProxy::DirectoryProxy(mojo::MessageReceiverWithResponder* receiver)
    : ControlMessageProxy(receiver) {
}
void DirectoryProxy::Read(
    const ReadCallback& callback) {
  size_t size = sizeof(internal::Directory_Read_Params_Data);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::Read), size);

  internal::Directory_Read_Params_Data* params =
      internal::Directory_Read_Params_Data::New(builder.buffer());
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Directory_Read_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void DirectoryProxy::Stat(
    const StatCallback& callback) {
  size_t size = sizeof(internal::Directory_Stat_Params_Data);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::Stat), size);

  internal::Directory_Stat_Params_Data* params =
      internal::Directory_Stat_Params_Data::New(builder.buffer());
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Directory_Stat_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void DirectoryProxy::Touch(
    mojo::files::TimespecOrNowPtr in_atime, mojo::files::TimespecOrNowPtr in_mtime, const TouchCallback& callback) {
  size_t size = sizeof(internal::Directory_Touch_Params_Data);
  size += in_atime.is_null()
              ? 0
              : GetSerializedSize_(*in_atime);
  size += in_mtime.is_null()
              ? 0
              : GetSerializedSize_(*in_mtime);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::Touch), size);

  internal::Directory_Touch_Params_Data* params =
      internal::Directory_Touch_Params_Data::New(builder.buffer());
  {Serialize_(in_atime.get(),
               builder.buffer(),
               &params->atime.ptr);
  }
  {Serialize_(in_mtime.get(),
               builder.buffer(),
               &params->mtime.ptr);
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Directory_Touch_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void DirectoryProxy::OpenFile(
    const mojo::String& in_path, mojo::InterfaceRequest<mojo::files::File> in_file, uint32_t in_open_flags, const OpenFileCallback& callback) {
  size_t size = sizeof(internal::Directory_OpenFile_Params_Data);
  size += GetSerializedSize_(in_path);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::OpenFile), size);

  internal::Directory_OpenFile_Params_Data* params =
      internal::Directory_OpenFile_Params_Data::New(builder.buffer());
  SerializeString_(in_path, builder.buffer(), &params->path.ptr);
  if (!params->path.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null path in Directory.OpenFile request");
  }
  params->file = in_file.PassMessagePipe().release();
  params->open_flags = in_open_flags;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Directory_OpenFile_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void DirectoryProxy::OpenDirectory(
    const mojo::String& in_path, mojo::InterfaceRequest<Directory> in_directory, uint32_t in_open_flags, const OpenDirectoryCallback& callback) {
  size_t size = sizeof(internal::Directory_OpenDirectory_Params_Data);
  size += GetSerializedSize_(in_path);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::OpenDirectory), size);

  internal::Directory_OpenDirectory_Params_Data* params =
      internal::Directory_OpenDirectory_Params_Data::New(builder.buffer());
  SerializeString_(in_path, builder.buffer(), &params->path.ptr);
  if (!params->path.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null path in Directory.OpenDirectory request");
  }
  params->directory = in_directory.PassMessagePipe().release();
  params->open_flags = in_open_flags;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Directory_OpenDirectory_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void DirectoryProxy::Rename(
    const mojo::String& in_path, const mojo::String& in_new_path, const RenameCallback& callback) {
  size_t size = sizeof(internal::Directory_Rename_Params_Data);
  size += GetSerializedSize_(in_path);
  size += GetSerializedSize_(in_new_path);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::Rename), size);

  internal::Directory_Rename_Params_Data* params =
      internal::Directory_Rename_Params_Data::New(builder.buffer());
  SerializeString_(in_path, builder.buffer(), &params->path.ptr);
  if (!params->path.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null path in Directory.Rename request");
  }
  SerializeString_(in_new_path, builder.buffer(), &params->new_path.ptr);
  if (!params->new_path.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null new_path in Directory.Rename request");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Directory_Rename_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void DirectoryProxy::Delete(
    const mojo::String& in_path, uint32_t in_delete_flags, const DeleteCallback& callback) {
  size_t size = sizeof(internal::Directory_Delete_Params_Data);
  size += GetSerializedSize_(in_path);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::Delete), size);

  internal::Directory_Delete_Params_Data* params =
      internal::Directory_Delete_Params_Data::New(builder.buffer());
  SerializeString_(in_path, builder.buffer(), &params->path.ptr);
  if (!params->path.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null path in Directory.Delete request");
  }
  params->delete_flags = in_delete_flags;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Directory_Delete_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Directory_Read_ProxyToResponder
    : public Directory::ReadCallback::Runnable {
 public:
  ~Directory_Read_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Directory::Read(callback) "
        "was never run.";
  }

  Directory_Read_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(mojo::files::Error in_error, mojo::Array<mojo::files::DirectoryEntryPtr> in_directory_contents) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_Read_ProxyToResponder);
};

void Directory_Read_ProxyToResponder::Run(
    mojo::files::Error in_error, mojo::Array<mojo::files::DirectoryEntryPtr> in_directory_contents) const {
  size_t size = sizeof(internal::Directory_Read_ResponseParams_Data);
  size += GetSerializedSize_(in_directory_contents);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::Read), size, request_id_);
  internal::Directory_Read_ResponseParams_Data* params =
      internal::Directory_Read_ResponseParams_Data::New(builder.buffer());
  params->error =
    static_cast<int32_t>(in_error);
  {
    const mojo::internal::ArrayValidateParams directory_contents_validate_params(
      0, false, nullptr);mojo::SerializeArray_(&in_directory_contents, builder.buffer(), &params->directory_contents.ptr,
                          &directory_contents_validate_params);
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Directory_Stat_ProxyToResponder
    : public Directory::StatCallback::Runnable {
 public:
  ~Directory_Stat_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Directory::Stat(callback) "
        "was never run.";
  }

  Directory_Stat_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(mojo::files::Error in_error, mojo::files::FileInformationPtr in_file_information) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_Stat_ProxyToResponder);
};

void Directory_Stat_ProxyToResponder::Run(
    mojo::files::Error in_error, mojo::files::FileInformationPtr in_file_information) const {
  size_t size = sizeof(internal::Directory_Stat_ResponseParams_Data);
  size += in_file_information.is_null()
              ? 0
              : GetSerializedSize_(*in_file_information);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::Stat), size, request_id_);
  internal::Directory_Stat_ResponseParams_Data* params =
      internal::Directory_Stat_ResponseParams_Data::New(builder.buffer());
  params->error =
    static_cast<int32_t>(in_error);
  {Serialize_(in_file_information.get(),
               builder.buffer(),
               &params->file_information.ptr);
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Directory_Touch_ProxyToResponder
    : public Directory::TouchCallback::Runnable {
 public:
  ~Directory_Touch_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Directory::Touch(p_atime.Pass(), p_mtime.Pass(), callback) "
        "was never run.";
  }

  Directory_Touch_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(mojo::files::Error in_error) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_Touch_ProxyToResponder);
};

void Directory_Touch_ProxyToResponder::Run(
    mojo::files::Error in_error) const {
  size_t size = sizeof(internal::Directory_Touch_ResponseParams_Data);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::Touch), size, request_id_);
  internal::Directory_Touch_ResponseParams_Data* params =
      internal::Directory_Touch_ResponseParams_Data::New(builder.buffer());
  params->error =
    static_cast<int32_t>(in_error);
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Directory_OpenFile_ProxyToResponder
    : public Directory::OpenFileCallback::Runnable {
 public:
  ~Directory_OpenFile_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Directory::OpenFile(p_path, p_file.Pass(), p_open_flags, callback) "
        "was never run.";
  }

  Directory_OpenFile_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(mojo::files::Error in_error) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_OpenFile_ProxyToResponder);
};

void Directory_OpenFile_ProxyToResponder::Run(
    mojo::files::Error in_error) const {
  size_t size = sizeof(internal::Directory_OpenFile_ResponseParams_Data);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::OpenFile), size, request_id_);
  internal::Directory_OpenFile_ResponseParams_Data* params =
      internal::Directory_OpenFile_ResponseParams_Data::New(builder.buffer());
  params->error =
    static_cast<int32_t>(in_error);
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Directory_OpenDirectory_ProxyToResponder
    : public Directory::OpenDirectoryCallback::Runnable {
 public:
  ~Directory_OpenDirectory_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Directory::OpenDirectory(p_path, p_directory.Pass(), p_open_flags, callback) "
        "was never run.";
  }

  Directory_OpenDirectory_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(mojo::files::Error in_error) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_OpenDirectory_ProxyToResponder);
};

void Directory_OpenDirectory_ProxyToResponder::Run(
    mojo::files::Error in_error) const {
  size_t size = sizeof(internal::Directory_OpenDirectory_ResponseParams_Data);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::OpenDirectory), size, request_id_);
  internal::Directory_OpenDirectory_ResponseParams_Data* params =
      internal::Directory_OpenDirectory_ResponseParams_Data::New(builder.buffer());
  params->error =
    static_cast<int32_t>(in_error);
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Directory_Rename_ProxyToResponder
    : public Directory::RenameCallback::Runnable {
 public:
  ~Directory_Rename_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Directory::Rename(p_path, p_new_path, callback) "
        "was never run.";
  }

  Directory_Rename_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(mojo::files::Error in_error) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_Rename_ProxyToResponder);
};

void Directory_Rename_ProxyToResponder::Run(
    mojo::files::Error in_error) const {
  size_t size = sizeof(internal::Directory_Rename_ResponseParams_Data);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::Rename), size, request_id_);
  internal::Directory_Rename_ResponseParams_Data* params =
      internal::Directory_Rename_ResponseParams_Data::New(builder.buffer());
  params->error =
    static_cast<int32_t>(in_error);
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Directory_Delete_ProxyToResponder
    : public Directory::DeleteCallback::Runnable {
 public:
  ~Directory_Delete_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Directory::Delete(p_path, p_delete_flags, callback) "
        "was never run.";
  }

  Directory_Delete_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(mojo::files::Error in_error) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Directory_Delete_ProxyToResponder);
};

void Directory_Delete_ProxyToResponder::Run(
    mojo::files::Error in_error) const {
  size_t size = sizeof(internal::Directory_Delete_ResponseParams_Data);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Directory_Base::MessageOrdinals::Delete), size, request_id_);
  internal::Directory_Delete_ResponseParams_Data* params =
      internal::Directory_Delete_ResponseParams_Data::New(builder.buffer());
  params->error =
    static_cast<int32_t>(in_error);
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}

DirectoryStub::DirectoryStub()
    : sink_(nullptr),
      control_message_handler_(Directory::Version_) {
}

DirectoryStub::~DirectoryStub() {}

bool DirectoryStub::Accept(mojo::Message* message) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.Accept(message);
  internal::Directory_Base::MessageOrdinals method_ordinal =
      static_cast<internal::Directory_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::Directory_Base::MessageOrdinals::Read: {
      break;
    }
    case internal::Directory_Base::MessageOrdinals::Stat: {
      break;
    }
    case internal::Directory_Base::MessageOrdinals::Touch: {
      break;
    }
    case internal::Directory_Base::MessageOrdinals::OpenFile: {
      break;
    }
    case internal::Directory_Base::MessageOrdinals::OpenDirectory: {
      break;
    }
    case internal::Directory_Base::MessageOrdinals::Rename: {
      break;
    }
    case internal::Directory_Base::MessageOrdinals::Delete: {
      break;
    }
  }
  return false;
}

bool DirectoryStub::AcceptWithResponder(
    mojo::Message* message, mojo::MessageReceiverWithStatus* responder) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.AcceptWithResponder(message, responder);
  internal::Directory_Base::MessageOrdinals method_ordinal =
      static_cast<internal::Directory_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::Directory_Base::MessageOrdinals::Read: {
      internal::Directory_Read_Params_Data* params =
          reinterpret_cast<internal::Directory_Read_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Directory::ReadCallback::Runnable* runnable =
          new Directory_Read_ProxyToResponder(
              message->request_id(), responder);
      Directory::ReadCallback callback(runnable);
      
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->Read(callback);
      return true;
    }
    case internal::Directory_Base::MessageOrdinals::Stat: {
      internal::Directory_Stat_Params_Data* params =
          reinterpret_cast<internal::Directory_Stat_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Directory::StatCallback::Runnable* runnable =
          new Directory_Stat_ProxyToResponder(
              message->request_id(), responder);
      Directory::StatCallback callback(runnable);
      
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->Stat(callback);
      return true;
    }
    case internal::Directory_Base::MessageOrdinals::Touch: {
      internal::Directory_Touch_Params_Data* params =
          reinterpret_cast<internal::Directory_Touch_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Directory::TouchCallback::Runnable* runnable =
          new Directory_Touch_ProxyToResponder(
              message->request_id(), responder);
      Directory::TouchCallback callback(runnable);
      
      mojo::files::TimespecOrNowPtr p_atime {};
      mojo::files::TimespecOrNowPtr p_mtime {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        if (params->atime.ptr) {
          p_atime = mojo::files::TimespecOrNow::New();
          Deserialize_(params->atime.ptr, p_atime.get());
        }
        if (params->mtime.ptr) {
          p_mtime = mojo::files::TimespecOrNow::New();
          Deserialize_(params->mtime.ptr, p_mtime.get());
        }
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->Touch(p_atime.Pass(), p_mtime.Pass(), callback);
      return true;
    }
    case internal::Directory_Base::MessageOrdinals::OpenFile: {
      internal::Directory_OpenFile_Params_Data* params =
          reinterpret_cast<internal::Directory_OpenFile_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Directory::OpenFileCallback::Runnable* runnable =
          new Directory_OpenFile_ProxyToResponder(
              message->request_id(), responder);
      Directory::OpenFileCallback callback(runnable);
      
      mojo::String p_path {};
      mojo::InterfaceRequest<mojo::files::File> p_file {};
      uint32_t p_open_flags {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        Deserialize_(params->path.ptr, &p_path);
        p_file.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&params->file)));
        p_open_flags = params->open_flags;
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->OpenFile(p_path, p_file.Pass(), p_open_flags, callback);
      return true;
    }
    case internal::Directory_Base::MessageOrdinals::OpenDirectory: {
      internal::Directory_OpenDirectory_Params_Data* params =
          reinterpret_cast<internal::Directory_OpenDirectory_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Directory::OpenDirectoryCallback::Runnable* runnable =
          new Directory_OpenDirectory_ProxyToResponder(
              message->request_id(), responder);
      Directory::OpenDirectoryCallback callback(runnable);
      
      mojo::String p_path {};
      mojo::InterfaceRequest<Directory> p_directory {};
      uint32_t p_open_flags {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        Deserialize_(params->path.ptr, &p_path);
        p_directory.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&params->directory)));
        p_open_flags = params->open_flags;
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->OpenDirectory(p_path, p_directory.Pass(), p_open_flags, callback);
      return true;
    }
    case internal::Directory_Base::MessageOrdinals::Rename: {
      internal::Directory_Rename_Params_Data* params =
          reinterpret_cast<internal::Directory_Rename_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Directory::RenameCallback::Runnable* runnable =
          new Directory_Rename_ProxyToResponder(
              message->request_id(), responder);
      Directory::RenameCallback callback(runnable);
      
      mojo::String p_path {};
      mojo::String p_new_path {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        Deserialize_(params->path.ptr, &p_path);
        Deserialize_(params->new_path.ptr, &p_new_path);
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->Rename(p_path, p_new_path, callback);
      return true;
    }
    case internal::Directory_Base::MessageOrdinals::Delete: {
      internal::Directory_Delete_Params_Data* params =
          reinterpret_cast<internal::Directory_Delete_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Directory::DeleteCallback::Runnable* runnable =
          new Directory_Delete_ProxyToResponder(
              message->request_id(), responder);
      Directory::DeleteCallback callback(runnable);
      
      mojo::String p_path {};
      uint32_t p_delete_flags {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        Deserialize_(params->path.ptr, &p_path);
        p_delete_flags = params->delete_flags;
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->Delete(p_path, p_delete_flags, callback);
      return true;
    }
  }
  return false;
}

}  // namespace files
}  // namespace mojo
