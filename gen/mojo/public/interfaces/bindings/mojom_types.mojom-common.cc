// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/public/interfaces/bindings/mojom_types.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace mojo {
namespace bindings {
namespace types {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// static
StringType_Data* StringType_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StringType_Data))) StringType_Data();
}

// static
mojo::internal::ValidationError StringType_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StringType_Data* object = static_cast<const StringType_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void StringType_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void StringType_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

StringType_Data::StringType_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
HandleType_Data* HandleType_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(HandleType_Data))) HandleType_Data();
}

// static
mojo::internal::ValidationError HandleType_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const HandleType_Data* object = static_cast<const HandleType_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void HandleType_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void HandleType_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

HandleType_Data::HandleType_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
ArrayType_Data* ArrayType_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ArrayType_Data))) ArrayType_Data();
}

// static
mojo::internal::ValidationError ArrayType_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ArrayType_Data* object = static_cast<const ArrayType_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (object->element_type.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null element_type field in ArrayType struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = Type::Data_::Validate(
          &object->element_type, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ArrayType_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  element_type.EncodePointersAndHandles(handles);
}

void ArrayType_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  element_type.DecodePointersAndHandles(handles);
}

ArrayType_Data::ArrayType_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
MapType_Data* MapType_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MapType_Data))) MapType_Data();
}

// static
mojo::internal::ValidationError MapType_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MapType_Data* object = static_cast<const MapType_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 48 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (object->key_type.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null key_type field in MapType struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = Type::Data_::Validate(
          &object->key_type, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (object->value_type.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null value_type field in MapType struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = Type::Data_::Validate(
          &object->value_type, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MapType_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  key_type.EncodePointersAndHandles(handles);
  value_type.EncodePointersAndHandles(handles);
}

void MapType_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  key_type.DecodePointersAndHandles(handles);
  value_type.DecodePointersAndHandles(handles);
}

MapType_Data::MapType_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
TypeReference_Data* TypeReference_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(TypeReference_Data))) TypeReference_Data();
}

// static
mojo::internal::ValidationError TypeReference_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const TypeReference_Data* object = static_cast<const TypeReference_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->identifier.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams identifier_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->identifier.offset),
          bounds_checker, &identifier_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->type_key.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams type_key_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->type_key.offset),
          bounds_checker, &type_key_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void TypeReference_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->identifier, handles);
  mojo::internal::Encode(&this->type_key, handles);
}

void TypeReference_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->identifier, handles);
  mojo::internal::Decode(&this->type_key, handles);
}

TypeReference_Data::TypeReference_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructField_Data* StructField_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructField_Data))) StructField_Data();
}

// static
mojo::internal::ValidationError StructField_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructField_Data* object = static_cast<const StructField_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 64 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->decl_data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = DeclarationData::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->decl_data.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (object->type.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null type field in StructField struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = Type::Data_::Validate(
          &object->type, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  auto validate_retval = DefaultFieldValue::Data_::Validate(
          &object->default_value, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructField_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->decl_data, handles);
  type.EncodePointersAndHandles(handles);
  default_value.EncodePointersAndHandles(handles);
}

void StructField_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->decl_data, handles);
  type.DecodePointersAndHandles(handles);
  default_value.DecodePointersAndHandles(handles);
}

StructField_Data::StructField_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
DefaultKeyword_Data* DefaultKeyword_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(DefaultKeyword_Data))) DefaultKeyword_Data();
}

// static
mojo::internal::ValidationError DefaultKeyword_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const DefaultKeyword_Data* object = static_cast<const DefaultKeyword_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void DefaultKeyword_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void DefaultKeyword_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

DefaultKeyword_Data::DefaultKeyword_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructVersion_Data* StructVersion_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructVersion_Data))) StructVersion_Data();
}

// static
mojo::internal::ValidationError StructVersion_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructVersion_Data* object = static_cast<const StructVersion_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void StructVersion_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void StructVersion_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

StructVersion_Data::StructVersion_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
MojomStruct_Data* MojomStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MojomStruct_Data))) MojomStruct_Data();
}

// static
mojo::internal::ValidationError MojomStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MojomStruct_Data* object = static_cast<const MojomStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->decl_data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = DeclarationData::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->decl_data.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->fields.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null fields field in MojomStruct struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->fields.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams fields_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<StructFieldPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->fields.offset),
          bounds_checker, &fields_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->version_info.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams version_info_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<StructVersionPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->version_info.offset),
          bounds_checker, &version_info_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MojomStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->decl_data, handles);
  mojo::internal::Encode(&this->fields, handles);
  mojo::internal::Encode(&this->version_info, handles);
}

void MojomStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->decl_data, handles);
  mojo::internal::Decode(&this->fields, handles);
  mojo::internal::Decode(&this->version_info, handles);
}

MojomStruct_Data::MojomStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
UnionField_Data* UnionField_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(UnionField_Data))) UnionField_Data();
}

// static
mojo::internal::ValidationError UnionField_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const UnionField_Data* object = static_cast<const UnionField_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 40 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->decl_data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = DeclarationData::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->decl_data.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (object->type.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null type field in UnionField struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = Type::Data_::Validate(
          &object->type, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void UnionField_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->decl_data, handles);
  type.EncodePointersAndHandles(handles);
}

void UnionField_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->decl_data, handles);
  type.DecodePointersAndHandles(handles);
}

UnionField_Data::UnionField_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
MojomUnion_Data* MojomUnion_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MojomUnion_Data))) MojomUnion_Data();
}

// static
mojo::internal::ValidationError MojomUnion_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MojomUnion_Data* object = static_cast<const MojomUnion_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->decl_data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = DeclarationData::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->decl_data.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->fields.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null fields field in MojomUnion struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->fields.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams fields_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<UnionFieldPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->fields.offset),
          bounds_checker, &fields_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MojomUnion_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->decl_data, handles);
  mojo::internal::Encode(&this->fields, handles);
}

void MojomUnion_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->decl_data, handles);
  mojo::internal::Decode(&this->fields, handles);
}

MojomUnion_Data::MojomUnion_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
EnumValue_Data* EnumValue_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(EnumValue_Data))) EnumValue_Data();
}

// static
mojo::internal::ValidationError EnumValue_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const EnumValue_Data* object = static_cast<const EnumValue_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 40 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->decl_data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = DeclarationData::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->decl_data.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  auto validate_retval = Value::Data_::Validate(
          &object->initializer_value, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void EnumValue_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->decl_data, handles);
  initializer_value.EncodePointersAndHandles(handles);
}

void EnumValue_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->decl_data, handles);
  initializer_value.DecodePointersAndHandles(handles);
}

EnumValue_Data::EnumValue_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
MojomEnum_Data* MojomEnum_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MojomEnum_Data))) MojomEnum_Data();
}

// static
mojo::internal::ValidationError MojomEnum_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MojomEnum_Data* object = static_cast<const MojomEnum_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->decl_data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = DeclarationData::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->decl_data.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->values.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null values field in MojomEnum struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->values.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams values_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<EnumValuePtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->values.offset),
          bounds_checker, &values_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MojomEnum_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->decl_data, handles);
  mojo::internal::Encode(&this->values, handles);
}

void MojomEnum_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->decl_data, handles);
  mojo::internal::Decode(&this->values, handles);
}

MojomEnum_Data::MojomEnum_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
MojomMethod_Data* MojomMethod_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MojomMethod_Data))) MojomMethod_Data();
}

// static
mojo::internal::ValidationError MojomMethod_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MojomMethod_Data* object = static_cast<const MojomMethod_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 40 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->decl_data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = DeclarationData::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->decl_data.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->parameters.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null parameters field in MojomMethod struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->parameters.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = MojomStruct::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->parameters.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->response_params.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = MojomStruct::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->response_params.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MojomMethod_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->decl_data, handles);
  mojo::internal::Encode(&this->parameters, handles);
  mojo::internal::Encode(&this->response_params, handles);
}

void MojomMethod_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->decl_data, handles);
  mojo::internal::Decode(&this->parameters, handles);
  mojo::internal::Decode(&this->response_params, handles);
}

MojomMethod_Data::MojomMethod_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
MojomInterface_Data* MojomInterface_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(MojomInterface_Data))) MojomInterface_Data();
}

// static
mojo::internal::ValidationError MojomInterface_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MojomInterface_Data* object = static_cast<const MojomInterface_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 40 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->decl_data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = DeclarationData::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->decl_data.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->service_name.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams service_name_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->service_name.offset),
          bounds_checker, &service_name_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->methods.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null methods field in MojomInterface struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->methods.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams methods_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<uint32_t, MojomMethodPtr>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->methods.offset),
              bounds_checker, &methods_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void MojomInterface_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->decl_data, handles);
  mojo::internal::Encode(&this->service_name, handles);
  mojo::internal::Encode(&this->methods, handles);
}

void MojomInterface_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->decl_data, handles);
  mojo::internal::Decode(&this->service_name, handles);
  mojo::internal::Decode(&this->methods, handles);
}

MojomInterface_Data::MojomInterface_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
ConstantReference_Data* ConstantReference_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConstantReference_Data))) ConstantReference_Data();
}

// static
mojo::internal::ValidationError ConstantReference_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConstantReference_Data* object = static_cast<const ConstantReference_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->identifier.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null identifier field in ConstantReference struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->identifier.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams identifier_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->identifier.offset),
          bounds_checker, &identifier_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->constant_key.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null constant_key field in ConstantReference struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->constant_key.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams constant_key_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->constant_key.offset),
          bounds_checker, &constant_key_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConstantReference_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->identifier, handles);
  mojo::internal::Encode(&this->constant_key, handles);
}

void ConstantReference_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->identifier, handles);
  mojo::internal::Decode(&this->constant_key, handles);
}

ConstantReference_Data::ConstantReference_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
EnumValueReference_Data* EnumValueReference_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(EnumValueReference_Data))) EnumValueReference_Data();
}

// static
mojo::internal::ValidationError EnumValueReference_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const EnumValueReference_Data* object = static_cast<const EnumValueReference_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->identifier.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null identifier field in EnumValueReference struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->identifier.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams identifier_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->identifier.offset),
          bounds_checker, &identifier_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->enum_type_key.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null enum_type_key field in EnumValueReference struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->enum_type_key.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams enum_type_key_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->enum_type_key.offset),
          bounds_checker, &enum_type_key_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void EnumValueReference_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->identifier, handles);
  mojo::internal::Encode(&this->enum_type_key, handles);
}

void EnumValueReference_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->identifier, handles);
  mojo::internal::Decode(&this->enum_type_key, handles);
}

EnumValueReference_Data::EnumValueReference_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
DeclaredConstant_Data* DeclaredConstant_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(DeclaredConstant_Data))) DeclaredConstant_Data();
}

// static
mojo::internal::ValidationError DeclaredConstant_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const DeclaredConstant_Data* object = static_cast<const DeclaredConstant_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 64 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->decl_data.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null decl_data field in DeclaredConstant struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->decl_data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = DeclarationData::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->decl_data.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (object->type.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null type field in DeclaredConstant struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = Type::Data_::Validate(
          &object->type, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (object->value.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null value field in DeclaredConstant struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = Value::Data_::Validate(
          &object->value, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  auto validate_retval = Value::Data_::Validate(
          &object->resolved_concrete_value, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void DeclaredConstant_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->decl_data, handles);
  type.EncodePointersAndHandles(handles);
  value.EncodePointersAndHandles(handles);
  resolved_concrete_value.EncodePointersAndHandles(handles);
}

void DeclaredConstant_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->decl_data, handles);
  type.DecodePointersAndHandles(handles);
  value.DecodePointersAndHandles(handles);
  resolved_concrete_value.DecodePointersAndHandles(handles);
}

DeclaredConstant_Data::DeclaredConstant_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
Attribute_Data* Attribute_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Attribute_Data))) Attribute_Data();
}

// static
mojo::internal::ValidationError Attribute_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Attribute_Data* object = static_cast<const Attribute_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->key.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null key field in Attribute struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->key.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams key_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->key.offset),
          bounds_checker, &key_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (object->value.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null value field in Attribute struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = LiteralValue::Data_::Validate(
          &object->value, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Attribute_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->key, handles);
  value.EncodePointersAndHandles(handles);
}

void Attribute_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->key, handles);
  value.DecodePointersAndHandles(handles);
}

Attribute_Data::Attribute_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
DeclarationData_Data* DeclarationData_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(DeclarationData_Data))) DeclarationData_Data();
}

// static
mojo::internal::ValidationError DeclarationData_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const DeclarationData_Data* object = static_cast<const DeclarationData_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 64 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->attributes.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams attributes_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<AttributePtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->attributes.offset),
          bounds_checker, &attributes_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->short_name.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams short_name_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->short_name.offset),
          bounds_checker, &short_name_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->full_identifier.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams full_identifier_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->full_identifier.offset),
          bounds_checker, &full_identifier_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->source_file_info.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = SourceFileInfo::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->source_file_info.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->contained_declarations.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = ContainedDeclarations::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->contained_declarations.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->container_type_key.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams container_type_key_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->container_type_key.offset),
          bounds_checker, &container_type_key_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void DeclarationData_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->attributes, handles);
  mojo::internal::Encode(&this->short_name, handles);
  mojo::internal::Encode(&this->full_identifier, handles);
  mojo::internal::Encode(&this->source_file_info, handles);
  mojo::internal::Encode(&this->contained_declarations, handles);
  mojo::internal::Encode(&this->container_type_key, handles);
}

void DeclarationData_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->attributes, handles);
  mojo::internal::Decode(&this->short_name, handles);
  mojo::internal::Decode(&this->full_identifier, handles);
  mojo::internal::Decode(&this->source_file_info, handles);
  mojo::internal::Decode(&this->contained_declarations, handles);
  mojo::internal::Decode(&this->container_type_key, handles);
}

DeclarationData_Data::DeclarationData_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
SourceFileInfo_Data* SourceFileInfo_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(SourceFileInfo_Data))) SourceFileInfo_Data();
}

// static
mojo::internal::ValidationError SourceFileInfo_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const SourceFileInfo_Data* object = static_cast<const SourceFileInfo_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->file_name.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null file_name field in SourceFileInfo struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->file_name.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams file_name_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->file_name.offset),
          bounds_checker, &file_name_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void SourceFileInfo_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->file_name, handles);
}

void SourceFileInfo_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->file_name, handles);
}

SourceFileInfo_Data::SourceFileInfo_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
ContainedDeclarations_Data* ContainedDeclarations_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ContainedDeclarations_Data))) ContainedDeclarations_Data();
}

// static
mojo::internal::ValidationError ContainedDeclarations_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ContainedDeclarations_Data* object = static_cast<const ContainedDeclarations_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->enums.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams enums_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->enums.offset),
          bounds_checker, &enums_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->constants.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams constants_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::String>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->constants.offset),
          bounds_checker, &constants_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ContainedDeclarations_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->enums, handles);
  mojo::internal::Encode(&this->constants, handles);
}

void ContainedDeclarations_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->enums, handles);
  mojo::internal::Decode(&this->constants, handles);
}

ContainedDeclarations_Data::ContainedDeclarations_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
RuntimeTypeInfo_Data* RuntimeTypeInfo_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(RuntimeTypeInfo_Data))) RuntimeTypeInfo_Data();
}

// static
mojo::internal::ValidationError RuntimeTypeInfo_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const RuntimeTypeInfo_Data* object = static_cast<const RuntimeTypeInfo_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->services.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null services field in RuntimeTypeInfo struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->services.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams services_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval = mojo::Map<mojo::String, mojo::String>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->services.offset),
              bounds_checker, &services_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->type_map.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null type_map field in RuntimeTypeInfo struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->type_map.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams type_map_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<mojo::String, UserDefinedTypePtr>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->type_map.offset),
              bounds_checker, &type_map_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void RuntimeTypeInfo_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->services, handles);
  mojo::internal::Encode(&this->type_map, handles);
}

void RuntimeTypeInfo_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->services, handles);
  mojo::internal::Decode(&this->type_map, handles);
}

RuntimeTypeInfo_Data::RuntimeTypeInfo_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// --- Union definitions ---
// static
Type_Data* Type_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Type_Data))) Type_Data();
}


// static
mojo::internal::ValidationError Type_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(Type_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const Type_Data* object = static_cast<const Type_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case Type_Tag::SIMPLE_TYPE: {

        return mojo::internal::ValidationError::NONE;
    }
    case Type_Tag::STRING_TYPE: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::StringType_Data>*>(&object->data.f_string_type))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'string_type' in 'Type'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::StringType_Data>*>(&object->data.f_string_type))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case Type_Tag::ARRAY_TYPE: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::ArrayType_Data>*>(&object->data.f_array_type))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'array_type' in 'Type'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::ArrayType_Data>*>(&object->data.f_array_type))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case Type_Tag::MAP_TYPE: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::MapType_Data>*>(&object->data.f_map_type))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'map_type' in 'Type'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::MapType_Data>*>(&object->data.f_map_type))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case Type_Tag::HANDLE_TYPE: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::HandleType_Data>*>(&object->data.f_handle_type))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'handle_type' in 'Type'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::HandleType_Data>*>(&object->data.f_handle_type))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case Type_Tag::TYPE_REFERENCE: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::TypeReference_Data>*>(&object->data.f_type_reference))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'type_reference' in 'Type'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::TypeReference_Data>*>(&object->data.f_type_reference))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void Type_Data::set_null() {
  size = 0U;
  tag = static_cast<Type_Tag>(0);
  data.unknown = 0U;
}

Type_Data::Type_Data() {
}

void Type_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case Type_Tag::SIMPLE_TYPE: {
      return;
    }
    case Type_Tag::STRING_TYPE: {
      mojo::internal::Encode(&data.f_string_type, handles);
      return;
    }
    case Type_Tag::ARRAY_TYPE: {
      mojo::internal::Encode(&data.f_array_type, handles);
      return;
    }
    case Type_Tag::MAP_TYPE: {
      mojo::internal::Encode(&data.f_map_type, handles);
      return;
    }
    case Type_Tag::HANDLE_TYPE: {
      mojo::internal::Encode(&data.f_handle_type, handles);
      return;
    }
    case Type_Tag::TYPE_REFERENCE: {
      mojo::internal::Encode(&data.f_type_reference, handles);
      return;
    }
    case Type_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void Type_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case Type_Tag::SIMPLE_TYPE: {
      return;
    }
    case Type_Tag::STRING_TYPE: {
      mojo::internal::Decode(&data.f_string_type, handles);
      return;
    }
    case Type_Tag::ARRAY_TYPE: {
      mojo::internal::Decode(&data.f_array_type, handles);
      return;
    }
    case Type_Tag::MAP_TYPE: {
      mojo::internal::Decode(&data.f_map_type, handles);
      return;
    }
    case Type_Tag::HANDLE_TYPE: {
      mojo::internal::Decode(&data.f_handle_type, handles);
      return;
    }
    case Type_Tag::TYPE_REFERENCE: {
      mojo::internal::Decode(&data.f_type_reference, handles);
      return;
    }
    default:
      return;
  }
}
// static
UserDefinedType_Data* UserDefinedType_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(UserDefinedType_Data))) UserDefinedType_Data();
}


// static
mojo::internal::ValidationError UserDefinedType_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(UserDefinedType_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const UserDefinedType_Data* object = static_cast<const UserDefinedType_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case UserDefinedType_Tag::ENUM_TYPE: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::MojomEnum_Data>*>(&object->data.f_enum_type))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'enum_type' in 'UserDefinedType'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::MojomEnum_Data>*>(&object->data.f_enum_type))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UserDefinedType_Tag::STRUCT_TYPE: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::MojomStruct_Data>*>(&object->data.f_struct_type))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'struct_type' in 'UserDefinedType'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::MojomStruct_Data>*>(&object->data.f_struct_type))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UserDefinedType_Tag::UNION_TYPE: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::MojomUnion_Data>*>(&object->data.f_union_type))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'union_type' in 'UserDefinedType'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::MojomUnion_Data>*>(&object->data.f_union_type))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UserDefinedType_Tag::INTERFACE_TYPE: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::MojomInterface_Data>*>(&object->data.f_interface_type))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'interface_type' in 'UserDefinedType'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::MojomInterface_Data>*>(&object->data.f_interface_type))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void UserDefinedType_Data::set_null() {
  size = 0U;
  tag = static_cast<UserDefinedType_Tag>(0);
  data.unknown = 0U;
}

UserDefinedType_Data::UserDefinedType_Data() {
}

void UserDefinedType_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case UserDefinedType_Tag::ENUM_TYPE: {
      mojo::internal::Encode(&data.f_enum_type, handles);
      return;
    }
    case UserDefinedType_Tag::STRUCT_TYPE: {
      mojo::internal::Encode(&data.f_struct_type, handles);
      return;
    }
    case UserDefinedType_Tag::UNION_TYPE: {
      mojo::internal::Encode(&data.f_union_type, handles);
      return;
    }
    case UserDefinedType_Tag::INTERFACE_TYPE: {
      mojo::internal::Encode(&data.f_interface_type, handles);
      return;
    }
    case UserDefinedType_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void UserDefinedType_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case UserDefinedType_Tag::ENUM_TYPE: {
      mojo::internal::Decode(&data.f_enum_type, handles);
      return;
    }
    case UserDefinedType_Tag::STRUCT_TYPE: {
      mojo::internal::Decode(&data.f_struct_type, handles);
      return;
    }
    case UserDefinedType_Tag::UNION_TYPE: {
      mojo::internal::Decode(&data.f_union_type, handles);
      return;
    }
    case UserDefinedType_Tag::INTERFACE_TYPE: {
      mojo::internal::Decode(&data.f_interface_type, handles);
      return;
    }
    default:
      return;
  }
}
// static
DefaultFieldValue_Data* DefaultFieldValue_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(DefaultFieldValue_Data))) DefaultFieldValue_Data();
}


// static
mojo::internal::ValidationError DefaultFieldValue_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(DefaultFieldValue_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const DefaultFieldValue_Data* object = static_cast<const DefaultFieldValue_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case DefaultFieldValue_Tag::VALUE: {

        if (!(reinterpret_cast<const mojo::internal::UnionPointer<internal::Value_Data>*>(&object->data.f_value))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'value' in 'DefaultFieldValue'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::UnionPointer<internal::Value_Data>*>(&object->data.f_value))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case DefaultFieldValue_Tag::DEFAULT_KEYWORD: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::DefaultKeyword_Data>*>(&object->data.f_default_keyword))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'default_keyword' in 'DefaultFieldValue'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::DefaultKeyword_Data>*>(&object->data.f_default_keyword))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void DefaultFieldValue_Data::set_null() {
  size = 0U;
  tag = static_cast<DefaultFieldValue_Tag>(0);
  data.unknown = 0U;
}

DefaultFieldValue_Data::DefaultFieldValue_Data() {
}

void DefaultFieldValue_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case DefaultFieldValue_Tag::VALUE: {
      mojo::internal::Encode(&data.f_value, handles);
      return;
    }
    case DefaultFieldValue_Tag::DEFAULT_KEYWORD: {
      mojo::internal::Encode(&data.f_default_keyword, handles);
      return;
    }
    case DefaultFieldValue_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void DefaultFieldValue_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case DefaultFieldValue_Tag::VALUE: {
      mojo::internal::Decode(&data.f_value, handles);
      return;
    }
    case DefaultFieldValue_Tag::DEFAULT_KEYWORD: {
      mojo::internal::Decode(&data.f_default_keyword, handles);
      return;
    }
    default:
      return;
  }
}
// static
Value_Data* Value_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Value_Data))) Value_Data();
}


// static
mojo::internal::ValidationError Value_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(Value_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const Value_Data* object = static_cast<const Value_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case Value_Tag::LITERAL_VALUE: {

        if (!(reinterpret_cast<const mojo::internal::UnionPointer<internal::LiteralValue_Data>*>(&object->data.f_literal_value))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'literal_value' in 'Value'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::UnionPointer<internal::LiteralValue_Data>*>(&object->data.f_literal_value))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case Value_Tag::CONSTANT_REFERENCE: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::ConstantReference_Data>*>(&object->data.f_constant_reference))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'constant_reference' in 'Value'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::ConstantReference_Data>*>(&object->data.f_constant_reference))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case Value_Tag::ENUM_VALUE_REFERENCE: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::EnumValueReference_Data>*>(&object->data.f_enum_value_reference))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'enum_value_reference' in 'Value'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::EnumValueReference_Data>*>(&object->data.f_enum_value_reference))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case Value_Tag::BUILTIN_VALUE: {

        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void Value_Data::set_null() {
  size = 0U;
  tag = static_cast<Value_Tag>(0);
  data.unknown = 0U;
}

Value_Data::Value_Data() {
}

void Value_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case Value_Tag::LITERAL_VALUE: {
      mojo::internal::Encode(&data.f_literal_value, handles);
      return;
    }
    case Value_Tag::CONSTANT_REFERENCE: {
      mojo::internal::Encode(&data.f_constant_reference, handles);
      return;
    }
    case Value_Tag::ENUM_VALUE_REFERENCE: {
      mojo::internal::Encode(&data.f_enum_value_reference, handles);
      return;
    }
    case Value_Tag::BUILTIN_VALUE: {
      return;
    }
    case Value_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void Value_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case Value_Tag::LITERAL_VALUE: {
      mojo::internal::Decode(&data.f_literal_value, handles);
      return;
    }
    case Value_Tag::CONSTANT_REFERENCE: {
      mojo::internal::Decode(&data.f_constant_reference, handles);
      return;
    }
    case Value_Tag::ENUM_VALUE_REFERENCE: {
      mojo::internal::Decode(&data.f_enum_value_reference, handles);
      return;
    }
    case Value_Tag::BUILTIN_VALUE: {
      return;
    }
    default:
      return;
  }
}
// static
LiteralValue_Data* LiteralValue_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(LiteralValue_Data))) LiteralValue_Data();
}


// static
mojo::internal::ValidationError LiteralValue_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(LiteralValue_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const LiteralValue_Data* object = static_cast<const LiteralValue_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case LiteralValue_Tag::BOOL_VALUE: {

        return mojo::internal::ValidationError::NONE;
    }
    case LiteralValue_Tag::DOUBLE_VALUE: {

        return mojo::internal::ValidationError::NONE;
    }
    case LiteralValue_Tag::FLOAT_VALUE: {

        return mojo::internal::ValidationError::NONE;
    }
    case LiteralValue_Tag::INT8_VALUE: {

        return mojo::internal::ValidationError::NONE;
    }
    case LiteralValue_Tag::INT16_VALUE: {

        return mojo::internal::ValidationError::NONE;
    }
    case LiteralValue_Tag::INT32_VALUE: {

        return mojo::internal::ValidationError::NONE;
    }
    case LiteralValue_Tag::INT64_VALUE: {

        return mojo::internal::ValidationError::NONE;
    }
    case LiteralValue_Tag::STRING_VALUE: {

        if (!(reinterpret_cast<const mojo::internal::StringPointer*>(&object->data.f_string_value))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'string_value' in 'LiteralValue'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StringPointer*>(&object->data.f_string_value))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }const mojo::internal::ArrayValidateParams string_value_validate_params(
            0, false, nullptr);
        auto validate_retval = mojo::String::Data_::Validate(
                mojo::internal::DecodePointerRaw(&(reinterpret_cast<const mojo::internal::StringPointer*>(&object->data.f_string_value))->offset),
                bounds_checker, &string_value_validate_params,
                err);
        if (validate_retval != mojo::internal::ValidationError::NONE) {
          return validate_retval;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case LiteralValue_Tag::UINT8_VALUE: {

        return mojo::internal::ValidationError::NONE;
    }
    case LiteralValue_Tag::UINT16_VALUE: {

        return mojo::internal::ValidationError::NONE;
    }
    case LiteralValue_Tag::UINT32_VALUE: {

        return mojo::internal::ValidationError::NONE;
    }
    case LiteralValue_Tag::UINT64_VALUE: {

        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void LiteralValue_Data::set_null() {
  size = 0U;
  tag = static_cast<LiteralValue_Tag>(0);
  data.unknown = 0U;
}

LiteralValue_Data::LiteralValue_Data() {
}

void LiteralValue_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case LiteralValue_Tag::BOOL_VALUE: {
      return;
    }
    case LiteralValue_Tag::DOUBLE_VALUE: {
      return;
    }
    case LiteralValue_Tag::FLOAT_VALUE: {
      return;
    }
    case LiteralValue_Tag::INT8_VALUE: {
      return;
    }
    case LiteralValue_Tag::INT16_VALUE: {
      return;
    }
    case LiteralValue_Tag::INT32_VALUE: {
      return;
    }
    case LiteralValue_Tag::INT64_VALUE: {
      return;
    }
    case LiteralValue_Tag::STRING_VALUE: {
      mojo::internal::Encode(&data.f_string_value, handles);
      return;
    }
    case LiteralValue_Tag::UINT8_VALUE: {
      return;
    }
    case LiteralValue_Tag::UINT16_VALUE: {
      return;
    }
    case LiteralValue_Tag::UINT32_VALUE: {
      return;
    }
    case LiteralValue_Tag::UINT64_VALUE: {
      return;
    }
    case LiteralValue_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void LiteralValue_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case LiteralValue_Tag::BOOL_VALUE: {
      return;
    }
    case LiteralValue_Tag::DOUBLE_VALUE: {
      return;
    }
    case LiteralValue_Tag::FLOAT_VALUE: {
      return;
    }
    case LiteralValue_Tag::INT8_VALUE: {
      return;
    }
    case LiteralValue_Tag::INT16_VALUE: {
      return;
    }
    case LiteralValue_Tag::INT32_VALUE: {
      return;
    }
    case LiteralValue_Tag::INT64_VALUE: {
      return;
    }
    case LiteralValue_Tag::STRING_VALUE: {
      mojo::internal::Decode(&data.f_string_value, handles);
      return;
    }
    case LiteralValue_Tag::UINT8_VALUE: {
      return;
    }
    case LiteralValue_Tag::UINT16_VALUE: {
      return;
    }
    case LiteralValue_Tag::UINT32_VALUE: {
      return;
    }
    case LiteralValue_Tag::UINT64_VALUE: {
      return;
    }
    default:
      return;
  }
}


// --- Definitions of the data structs for interface methods ---

}  // namespace internal

// --- Request and response validator definitions for interfaces --- 

// --- Enums ---
bool SimpleType_IsValidValue(SimpleType value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const SimpleType& val) {
  return (stream << static_cast<int32_t>(val));
}
bool BuiltinConstantValue_IsValidValue(BuiltinConstantValue value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const BuiltinConstantValue& val) {
  return (stream << static_cast<int32_t>(val));
}

// Base interface definitions (Name_, Version_, Constants, Enums)

// Struct Constants

// --- Struct builder definitions ---

// static
StringTypePtr StringType::New() {
  StringTypePtr rv;
  mojo::internal::StructHelper<StringType>::Initialize(&rv);
  return rv;
}

StringType::StringType()
    : nullable() {
}

StringType::~StringType() {
}


StringTypePtr StringType::Clone() const {
  StringTypePtr rv(New());
  rv->nullable = nullable;
  return rv;
}


bool StringType::Equals(const StringType& other) const {
  if (!mojo::internal::ValueTraits<bool>::Equals(this->nullable, other.nullable))
    return false;
  return true;
}

// static
bool HandleType::Kind_IsValidValue(Kind value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream,
                         const HandleType::Kind& val) {
  return (stream << static_cast<int32_t>(val));
}

// static
HandleTypePtr HandleType::New() {
  HandleTypePtr rv;
  mojo::internal::StructHelper<HandleType>::Initialize(&rv);
  return rv;
}

HandleType::HandleType()
    : nullable(),
      kind(HandleType::Kind::UNSPECIFIED) {
}

HandleType::~HandleType() {
}


HandleTypePtr HandleType::Clone() const {
  HandleTypePtr rv(New());
  rv->nullable = nullable;
  rv->kind = kind;
  return rv;
}


bool HandleType::Equals(const HandleType& other) const {
  if (!mojo::internal::ValueTraits<bool>::Equals(this->nullable, other.nullable))
    return false;
  if (!mojo::internal::ValueTraits<HandleType::Kind>::Equals(this->kind, other.kind))
    return false;
  return true;
}


// static
ArrayTypePtr ArrayType::New() {
  ArrayTypePtr rv;
  mojo::internal::StructHelper<ArrayType>::Initialize(&rv);
  return rv;
}

ArrayType::ArrayType()
    : nullable(),
      fixed_length(-1),
      element_type() {
}

ArrayType::~ArrayType() {
}


ArrayTypePtr ArrayType::Clone() const {
  ArrayTypePtr rv(New());
  rv->nullable = nullable;
  rv->fixed_length = fixed_length;
  rv->element_type = element_type.Clone();
  return rv;
}


bool ArrayType::Equals(const ArrayType& other) const {
  if (!mojo::internal::ValueTraits<bool>::Equals(this->nullable, other.nullable))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->fixed_length, other.fixed_length))
    return false;
  if (!mojo::internal::ValueTraits<TypePtr>::Equals(this->element_type, other.element_type))
    return false;
  return true;
}


// static
MapTypePtr MapType::New() {
  MapTypePtr rv;
  mojo::internal::StructHelper<MapType>::Initialize(&rv);
  return rv;
}

MapType::MapType()
    : nullable(),
      key_type(),
      value_type() {
}

MapType::~MapType() {
}


MapTypePtr MapType::Clone() const {
  MapTypePtr rv(New());
  rv->nullable = nullable;
  rv->key_type = key_type.Clone();
  rv->value_type = value_type.Clone();
  return rv;
}


bool MapType::Equals(const MapType& other) const {
  if (!mojo::internal::ValueTraits<bool>::Equals(this->nullable, other.nullable))
    return false;
  if (!mojo::internal::ValueTraits<TypePtr>::Equals(this->key_type, other.key_type))
    return false;
  if (!mojo::internal::ValueTraits<TypePtr>::Equals(this->value_type, other.value_type))
    return false;
  return true;
}


// static
TypeReferencePtr TypeReference::New() {
  TypeReferencePtr rv;
  mojo::internal::StructHelper<TypeReference>::Initialize(&rv);
  return rv;
}

TypeReference::TypeReference()
    : nullable(),
      is_interface_request(),
      identifier(),
      type_key() {
}

TypeReference::~TypeReference() {
}


TypeReferencePtr TypeReference::Clone() const {
  TypeReferencePtr rv(New());
  rv->nullable = nullable;
  rv->is_interface_request = is_interface_request;
  rv->identifier = identifier;
  rv->type_key = type_key;
  return rv;
}


bool TypeReference::Equals(const TypeReference& other) const {
  if (!mojo::internal::ValueTraits<bool>::Equals(this->nullable, other.nullable))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->is_interface_request, other.is_interface_request))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->identifier, other.identifier))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->type_key, other.type_key))
    return false;
  return true;
}


// static
StructFieldPtr StructField::New() {
  StructFieldPtr rv;
  mojo::internal::StructHelper<StructField>::Initialize(&rv);
  return rv;
}

StructField::StructField()
    : decl_data(),
      type(),
      default_value(),
      offset(),
      bit(),
      min_version() {
}

StructField::~StructField() {
}


StructFieldPtr StructField::Clone() const {
  StructFieldPtr rv(New());
  rv->decl_data = decl_data.Clone();
  rv->type = type.Clone();
  rv->default_value = default_value.Clone();
  rv->offset = offset;
  rv->bit = bit;
  rv->min_version = min_version;
  return rv;
}


bool StructField::Equals(const StructField& other) const {
  if (!mojo::internal::ValueTraits<DeclarationDataPtr>::Equals(this->decl_data, other.decl_data))
    return false;
  if (!mojo::internal::ValueTraits<TypePtr>::Equals(this->type, other.type))
    return false;
  if (!mojo::internal::ValueTraits<DefaultFieldValuePtr>::Equals(this->default_value, other.default_value))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->offset, other.offset))
    return false;
  if (!mojo::internal::ValueTraits<int8_t>::Equals(this->bit, other.bit))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->min_version, other.min_version))
    return false;
  return true;
}


// static
DefaultKeywordPtr DefaultKeyword::New() {
  DefaultKeywordPtr rv;
  mojo::internal::StructHelper<DefaultKeyword>::Initialize(&rv);
  return rv;
}

DefaultKeyword::DefaultKeyword() {
}

DefaultKeyword::~DefaultKeyword() {
}


DefaultKeywordPtr DefaultKeyword::Clone() const {
  DefaultKeywordPtr rv(New());
  return rv;
}


bool DefaultKeyword::Equals(const DefaultKeyword& other) const {
  return true;
}


// static
StructVersionPtr StructVersion::New() {
  StructVersionPtr rv;
  mojo::internal::StructHelper<StructVersion>::Initialize(&rv);
  return rv;
}

StructVersion::StructVersion()
    : version_number(),
      num_fields(),
      num_bytes() {
}

StructVersion::~StructVersion() {
}


StructVersionPtr StructVersion::Clone() const {
  StructVersionPtr rv(New());
  rv->version_number = version_number;
  rv->num_fields = num_fields;
  rv->num_bytes = num_bytes;
  return rv;
}


bool StructVersion::Equals(const StructVersion& other) const {
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->version_number, other.version_number))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->num_fields, other.num_fields))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->num_bytes, other.num_bytes))
    return false;
  return true;
}


// static
MojomStructPtr MojomStruct::New() {
  MojomStructPtr rv;
  mojo::internal::StructHelper<MojomStruct>::Initialize(&rv);
  return rv;
}

MojomStruct::MojomStruct()
    : decl_data(),
      fields(),
      version_info() {
}

MojomStruct::~MojomStruct() {
}


MojomStructPtr MojomStruct::Clone() const {
  MojomStructPtr rv(New());
  rv->decl_data = decl_data.Clone();
  rv->fields = fields.Clone();
  rv->version_info = version_info.Clone();
  return rv;
}


bool MojomStruct::Equals(const MojomStruct& other) const {
  if (!mojo::internal::ValueTraits<DeclarationDataPtr>::Equals(this->decl_data, other.decl_data))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<StructFieldPtr>>::Equals(this->fields, other.fields))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<StructVersionPtr>>::Equals(this->version_info, other.version_info))
    return false;
  return true;
}


// static
UnionFieldPtr UnionField::New() {
  UnionFieldPtr rv;
  mojo::internal::StructHelper<UnionField>::Initialize(&rv);
  return rv;
}

UnionField::UnionField()
    : decl_data(),
      type(),
      tag() {
}

UnionField::~UnionField() {
}


UnionFieldPtr UnionField::Clone() const {
  UnionFieldPtr rv(New());
  rv->decl_data = decl_data.Clone();
  rv->type = type.Clone();
  rv->tag = tag;
  return rv;
}


bool UnionField::Equals(const UnionField& other) const {
  if (!mojo::internal::ValueTraits<DeclarationDataPtr>::Equals(this->decl_data, other.decl_data))
    return false;
  if (!mojo::internal::ValueTraits<TypePtr>::Equals(this->type, other.type))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->tag, other.tag))
    return false;
  return true;
}


// static
MojomUnionPtr MojomUnion::New() {
  MojomUnionPtr rv;
  mojo::internal::StructHelper<MojomUnion>::Initialize(&rv);
  return rv;
}

MojomUnion::MojomUnion()
    : decl_data(),
      fields() {
}

MojomUnion::~MojomUnion() {
}


MojomUnionPtr MojomUnion::Clone() const {
  MojomUnionPtr rv(New());
  rv->decl_data = decl_data.Clone();
  rv->fields = fields.Clone();
  return rv;
}


bool MojomUnion::Equals(const MojomUnion& other) const {
  if (!mojo::internal::ValueTraits<DeclarationDataPtr>::Equals(this->decl_data, other.decl_data))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<UnionFieldPtr>>::Equals(this->fields, other.fields))
    return false;
  return true;
}


// static
EnumValuePtr EnumValue::New() {
  EnumValuePtr rv;
  mojo::internal::StructHelper<EnumValue>::Initialize(&rv);
  return rv;
}

EnumValue::EnumValue()
    : decl_data(),
      initializer_value(),
      int_value() {
}

EnumValue::~EnumValue() {
}


EnumValuePtr EnumValue::Clone() const {
  EnumValuePtr rv(New());
  rv->decl_data = decl_data.Clone();
  rv->initializer_value = initializer_value.Clone();
  rv->int_value = int_value;
  return rv;
}


bool EnumValue::Equals(const EnumValue& other) const {
  if (!mojo::internal::ValueTraits<DeclarationDataPtr>::Equals(this->decl_data, other.decl_data))
    return false;
  if (!mojo::internal::ValueTraits<ValuePtr>::Equals(this->initializer_value, other.initializer_value))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->int_value, other.int_value))
    return false;
  return true;
}


// static
MojomEnumPtr MojomEnum::New() {
  MojomEnumPtr rv;
  mojo::internal::StructHelper<MojomEnum>::Initialize(&rv);
  return rv;
}

MojomEnum::MojomEnum()
    : decl_data(),
      values() {
}

MojomEnum::~MojomEnum() {
}


MojomEnumPtr MojomEnum::Clone() const {
  MojomEnumPtr rv(New());
  rv->decl_data = decl_data.Clone();
  rv->values = values.Clone();
  return rv;
}


bool MojomEnum::Equals(const MojomEnum& other) const {
  if (!mojo::internal::ValueTraits<DeclarationDataPtr>::Equals(this->decl_data, other.decl_data))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<EnumValuePtr>>::Equals(this->values, other.values))
    return false;
  return true;
}


// static
MojomMethodPtr MojomMethod::New() {
  MojomMethodPtr rv;
  mojo::internal::StructHelper<MojomMethod>::Initialize(&rv);
  return rv;
}

MojomMethod::MojomMethod()
    : decl_data(),
      parameters(),
      response_params(),
      ordinal(),
      min_version() {
}

MojomMethod::~MojomMethod() {
}


MojomMethodPtr MojomMethod::Clone() const {
  MojomMethodPtr rv(New());
  rv->decl_data = decl_data.Clone();
  rv->parameters = parameters.Clone();
  rv->response_params = response_params.Clone();
  rv->ordinal = ordinal;
  rv->min_version = min_version;
  return rv;
}


bool MojomMethod::Equals(const MojomMethod& other) const {
  if (!mojo::internal::ValueTraits<DeclarationDataPtr>::Equals(this->decl_data, other.decl_data))
    return false;
  if (!mojo::internal::ValueTraits<MojomStructPtr>::Equals(this->parameters, other.parameters))
    return false;
  if (!mojo::internal::ValueTraits<MojomStructPtr>::Equals(this->response_params, other.response_params))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->ordinal, other.ordinal))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->min_version, other.min_version))
    return false;
  return true;
}


// static
MojomInterfacePtr MojomInterface::New() {
  MojomInterfacePtr rv;
  mojo::internal::StructHelper<MojomInterface>::Initialize(&rv);
  return rv;
}

MojomInterface::MojomInterface()
    : decl_data(),
      service_name(),
      methods(),
      current_version() {
}

MojomInterface::~MojomInterface() {
}


MojomInterfacePtr MojomInterface::Clone() const {
  MojomInterfacePtr rv(New());
  rv->decl_data = decl_data.Clone();
  rv->service_name = service_name;
  rv->methods = methods.Clone();
  rv->current_version = current_version;
  return rv;
}


bool MojomInterface::Equals(const MojomInterface& other) const {
  if (!mojo::internal::ValueTraits<DeclarationDataPtr>::Equals(this->decl_data, other.decl_data))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->service_name, other.service_name))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<uint32_t, MojomMethodPtr>>::Equals(this->methods, other.methods))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->current_version, other.current_version))
    return false;
  return true;
}


// static
ConstantReferencePtr ConstantReference::New() {
  ConstantReferencePtr rv;
  mojo::internal::StructHelper<ConstantReference>::Initialize(&rv);
  return rv;
}

ConstantReference::ConstantReference()
    : identifier(),
      constant_key() {
}

ConstantReference::~ConstantReference() {
}


ConstantReferencePtr ConstantReference::Clone() const {
  ConstantReferencePtr rv(New());
  rv->identifier = identifier;
  rv->constant_key = constant_key;
  return rv;
}


bool ConstantReference::Equals(const ConstantReference& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->identifier, other.identifier))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->constant_key, other.constant_key))
    return false;
  return true;
}


// static
EnumValueReferencePtr EnumValueReference::New() {
  EnumValueReferencePtr rv;
  mojo::internal::StructHelper<EnumValueReference>::Initialize(&rv);
  return rv;
}

EnumValueReference::EnumValueReference()
    : identifier(),
      enum_type_key(),
      enum_value_index() {
}

EnumValueReference::~EnumValueReference() {
}


EnumValueReferencePtr EnumValueReference::Clone() const {
  EnumValueReferencePtr rv(New());
  rv->identifier = identifier;
  rv->enum_type_key = enum_type_key;
  rv->enum_value_index = enum_value_index;
  return rv;
}


bool EnumValueReference::Equals(const EnumValueReference& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->identifier, other.identifier))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->enum_type_key, other.enum_type_key))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->enum_value_index, other.enum_value_index))
    return false;
  return true;
}


// static
DeclaredConstantPtr DeclaredConstant::New() {
  DeclaredConstantPtr rv;
  mojo::internal::StructHelper<DeclaredConstant>::Initialize(&rv);
  return rv;
}

DeclaredConstant::DeclaredConstant()
    : decl_data(),
      type(),
      value(),
      resolved_concrete_value() {
}

DeclaredConstant::~DeclaredConstant() {
}


DeclaredConstantPtr DeclaredConstant::Clone() const {
  DeclaredConstantPtr rv(New());
  rv->decl_data = decl_data.Clone();
  rv->type = type.Clone();
  rv->value = value.Clone();
  rv->resolved_concrete_value = resolved_concrete_value.Clone();
  return rv;
}


bool DeclaredConstant::Equals(const DeclaredConstant& other) const {
  if (!mojo::internal::ValueTraits<DeclarationDataPtr>::Equals(this->decl_data, other.decl_data))
    return false;
  if (!mojo::internal::ValueTraits<TypePtr>::Equals(this->type, other.type))
    return false;
  if (!mojo::internal::ValueTraits<ValuePtr>::Equals(this->value, other.value))
    return false;
  if (!mojo::internal::ValueTraits<ValuePtr>::Equals(this->resolved_concrete_value, other.resolved_concrete_value))
    return false;
  return true;
}


// static
AttributePtr Attribute::New() {
  AttributePtr rv;
  mojo::internal::StructHelper<Attribute>::Initialize(&rv);
  return rv;
}

Attribute::Attribute()
    : key(),
      value() {
}

Attribute::~Attribute() {
}


AttributePtr Attribute::Clone() const {
  AttributePtr rv(New());
  rv->key = key;
  rv->value = value.Clone();
  return rv;
}


bool Attribute::Equals(const Attribute& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->key, other.key))
    return false;
  if (!mojo::internal::ValueTraits<LiteralValuePtr>::Equals(this->value, other.value))
    return false;
  return true;
}


// static
DeclarationDataPtr DeclarationData::New() {
  DeclarationDataPtr rv;
  mojo::internal::StructHelper<DeclarationData>::Initialize(&rv);
  return rv;
}

DeclarationData::DeclarationData()
    : attributes(),
      short_name(),
      full_identifier(),
      declared_ordinal(-1),
      declaration_order(-1),
      source_file_info(),
      contained_declarations(),
      container_type_key() {
}

DeclarationData::~DeclarationData() {
}


DeclarationDataPtr DeclarationData::Clone() const {
  DeclarationDataPtr rv(New());
  rv->attributes = attributes.Clone();
  rv->short_name = short_name;
  rv->full_identifier = full_identifier;
  rv->declared_ordinal = declared_ordinal;
  rv->declaration_order = declaration_order;
  rv->source_file_info = source_file_info.Clone();
  rv->contained_declarations = contained_declarations.Clone();
  rv->container_type_key = container_type_key;
  return rv;
}


bool DeclarationData::Equals(const DeclarationData& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<AttributePtr>>::Equals(this->attributes, other.attributes))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->short_name, other.short_name))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->full_identifier, other.full_identifier))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->declared_ordinal, other.declared_ordinal))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->declaration_order, other.declaration_order))
    return false;
  if (!mojo::internal::ValueTraits<SourceFileInfoPtr>::Equals(this->source_file_info, other.source_file_info))
    return false;
  if (!mojo::internal::ValueTraits<ContainedDeclarationsPtr>::Equals(this->contained_declarations, other.contained_declarations))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->container_type_key, other.container_type_key))
    return false;
  return true;
}


// static
SourceFileInfoPtr SourceFileInfo::New() {
  SourceFileInfoPtr rv;
  mojo::internal::StructHelper<SourceFileInfo>::Initialize(&rv);
  return rv;
}

SourceFileInfo::SourceFileInfo()
    : file_name(),
      line_number(),
      column_number() {
}

SourceFileInfo::~SourceFileInfo() {
}


SourceFileInfoPtr SourceFileInfo::Clone() const {
  SourceFileInfoPtr rv(New());
  rv->file_name = file_name;
  rv->line_number = line_number;
  rv->column_number = column_number;
  return rv;
}


bool SourceFileInfo::Equals(const SourceFileInfo& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->file_name, other.file_name))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->line_number, other.line_number))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->column_number, other.column_number))
    return false;
  return true;
}


// static
ContainedDeclarationsPtr ContainedDeclarations::New() {
  ContainedDeclarationsPtr rv;
  mojo::internal::StructHelper<ContainedDeclarations>::Initialize(&rv);
  return rv;
}

ContainedDeclarations::ContainedDeclarations()
    : enums(),
      constants() {
}

ContainedDeclarations::~ContainedDeclarations() {
}


ContainedDeclarationsPtr ContainedDeclarations::Clone() const {
  ContainedDeclarationsPtr rv(New());
  rv->enums = enums.Clone();
  rv->constants = constants.Clone();
  return rv;
}


bool ContainedDeclarations::Equals(const ContainedDeclarations& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->enums, other.enums))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::String>>::Equals(this->constants, other.constants))
    return false;
  return true;
}


// static
RuntimeTypeInfoPtr RuntimeTypeInfo::New() {
  RuntimeTypeInfoPtr rv;
  mojo::internal::StructHelper<RuntimeTypeInfo>::Initialize(&rv);
  return rv;
}

RuntimeTypeInfo::RuntimeTypeInfo()
    : services(),
      type_map() {
}

RuntimeTypeInfo::~RuntimeTypeInfo() {
}


RuntimeTypeInfoPtr RuntimeTypeInfo::Clone() const {
  RuntimeTypeInfoPtr rv(New());
  rv->services = services.Clone();
  rv->type_map = type_map.Clone();
  return rv;
}


bool RuntimeTypeInfo::Equals(const RuntimeTypeInfo& other) const {
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::String>>::Equals(this->services, other.services))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, UserDefinedTypePtr>>::Equals(this->type_map, other.type_map))
    return false;
  return true;
}


// --- Union builder definitions ---// static
TypePtr Type::New() {
  TypePtr rv;
  mojo::internal::StructHelper<Type>::Initialize(&rv);
  return rv;
}

Type::Type() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

Type::~Type() {
  DestroyActive();
}


TypePtr Type::Clone() const {
  TypePtr rv(New());
  switch (tag_) {

    case Tag::SIMPLE_TYPE:

      rv->set_simple_type(data_.simple_type);
      break;
    case Tag::STRING_TYPE:

      rv->set_string_type(data_.string_type->Clone());
      break;
    case Tag::ARRAY_TYPE:

      rv->set_array_type(data_.array_type->Clone());
      break;
    case Tag::MAP_TYPE:

      rv->set_map_type(data_.map_type->Clone());
      break;
    case Tag::HANDLE_TYPE:

      rv->set_handle_type(data_.handle_type->Clone());
      break;
    case Tag::TYPE_REFERENCE:

      rv->set_type_reference(data_.type_reference->Clone());
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool Type::Equals(const Type& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::SIMPLE_TYPE:

      return mojo::internal::ValueTraits<SimpleType>::Equals(data_.simple_type, other.data_.simple_type);
    case Tag::STRING_TYPE:

      return mojo::internal::ValueTraits<StringTypePtr>::Equals(*(data_.string_type), *(other.data_.string_type));
    case Tag::ARRAY_TYPE:

      return mojo::internal::ValueTraits<ArrayTypePtr>::Equals(*(data_.array_type), *(other.data_.array_type));
    case Tag::MAP_TYPE:

      return mojo::internal::ValueTraits<MapTypePtr>::Equals(*(data_.map_type), *(other.data_.map_type));
    case Tag::HANDLE_TYPE:

      return mojo::internal::ValueTraits<HandleTypePtr>::Equals(*(data_.handle_type), *(other.data_.handle_type));
    case Tag::TYPE_REFERENCE:

      return mojo::internal::ValueTraits<TypeReferencePtr>::Equals(*(data_.type_reference), *(other.data_.type_reference));
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool Type::is_simple_type() const {
  return tag_ == Tag::SIMPLE_TYPE;
}

SimpleType Type::get_simple_type() const {
  MOJO_DCHECK(tag_ == Tag::SIMPLE_TYPE);

  return data_.simple_type;
}

void Type::set_simple_type(SimpleType simple_type) {
  SwitchActive(Tag::SIMPLE_TYPE);

  data_.simple_type = simple_type;
}
bool Type::is_string_type() const {
  return tag_ == Tag::STRING_TYPE;
}

StringTypePtr& Type::get_string_type() const {
  MOJO_DCHECK(tag_ == Tag::STRING_TYPE);

  return *(data_.string_type);
}

void Type::set_string_type(StringTypePtr string_type) {
  SwitchActive(Tag::STRING_TYPE);

  *(data_.string_type) = string_type.Pass();

}
bool Type::is_array_type() const {
  return tag_ == Tag::ARRAY_TYPE;
}

ArrayTypePtr& Type::get_array_type() const {
  MOJO_DCHECK(tag_ == Tag::ARRAY_TYPE);

  return *(data_.array_type);
}

void Type::set_array_type(ArrayTypePtr array_type) {
  SwitchActive(Tag::ARRAY_TYPE);

  *(data_.array_type) = array_type.Pass();

}
bool Type::is_map_type() const {
  return tag_ == Tag::MAP_TYPE;
}

MapTypePtr& Type::get_map_type() const {
  MOJO_DCHECK(tag_ == Tag::MAP_TYPE);

  return *(data_.map_type);
}

void Type::set_map_type(MapTypePtr map_type) {
  SwitchActive(Tag::MAP_TYPE);

  *(data_.map_type) = map_type.Pass();

}
bool Type::is_handle_type() const {
  return tag_ == Tag::HANDLE_TYPE;
}

HandleTypePtr& Type::get_handle_type() const {
  MOJO_DCHECK(tag_ == Tag::HANDLE_TYPE);

  return *(data_.handle_type);
}

void Type::set_handle_type(HandleTypePtr handle_type) {
  SwitchActive(Tag::HANDLE_TYPE);

  *(data_.handle_type) = handle_type.Pass();

}
bool Type::is_type_reference() const {
  return tag_ == Tag::TYPE_REFERENCE;
}

TypeReferencePtr& Type::get_type_reference() const {
  MOJO_DCHECK(tag_ == Tag::TYPE_REFERENCE);

  return *(data_.type_reference);
}

void Type::set_type_reference(TypeReferencePtr type_reference) {
  SwitchActive(Tag::TYPE_REFERENCE);

  *(data_.type_reference) = type_reference.Pass();

}

bool Type::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void Type::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void Type::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::SIMPLE_TYPE:

      break;
    case Tag::STRING_TYPE:

      data_.string_type = new StringTypePtr();
      break;
    case Tag::ARRAY_TYPE:

      data_.array_type = new ArrayTypePtr();
      break;
    case Tag::MAP_TYPE:

      data_.map_type = new MapTypePtr();
      break;
    case Tag::HANDLE_TYPE:

      data_.handle_type = new HandleTypePtr();
      break;
    case Tag::TYPE_REFERENCE:

      data_.type_reference = new TypeReferencePtr();
      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void Type::DestroyActive() {
  switch (tag_) {

    case Tag::SIMPLE_TYPE:

      break;
    case Tag::STRING_TYPE:

      delete data_.string_type;
      break;
    case Tag::ARRAY_TYPE:

      delete data_.array_type;
      break;
    case Tag::MAP_TYPE:

      delete data_.map_type;
      break;
    case Tag::HANDLE_TYPE:

      delete data_.handle_type;
      break;
    case Tag::TYPE_REFERENCE:

      delete data_.type_reference;
      break;
    default:
      break;
  }
}
// static
UserDefinedTypePtr UserDefinedType::New() {
  UserDefinedTypePtr rv;
  mojo::internal::StructHelper<UserDefinedType>::Initialize(&rv);
  return rv;
}

UserDefinedType::UserDefinedType() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

UserDefinedType::~UserDefinedType() {
  DestroyActive();
}


UserDefinedTypePtr UserDefinedType::Clone() const {
  UserDefinedTypePtr rv(New());
  switch (tag_) {

    case Tag::ENUM_TYPE:

      rv->set_enum_type(data_.enum_type->Clone());
      break;
    case Tag::STRUCT_TYPE:

      rv->set_struct_type(data_.struct_type->Clone());
      break;
    case Tag::UNION_TYPE:

      rv->set_union_type(data_.union_type->Clone());
      break;
    case Tag::INTERFACE_TYPE:

      rv->set_interface_type(data_.interface_type->Clone());
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool UserDefinedType::Equals(const UserDefinedType& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::ENUM_TYPE:

      return mojo::internal::ValueTraits<MojomEnumPtr>::Equals(*(data_.enum_type), *(other.data_.enum_type));
    case Tag::STRUCT_TYPE:

      return mojo::internal::ValueTraits<MojomStructPtr>::Equals(*(data_.struct_type), *(other.data_.struct_type));
    case Tag::UNION_TYPE:

      return mojo::internal::ValueTraits<MojomUnionPtr>::Equals(*(data_.union_type), *(other.data_.union_type));
    case Tag::INTERFACE_TYPE:

      return mojo::internal::ValueTraits<MojomInterfacePtr>::Equals(*(data_.interface_type), *(other.data_.interface_type));
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool UserDefinedType::is_enum_type() const {
  return tag_ == Tag::ENUM_TYPE;
}

MojomEnumPtr& UserDefinedType::get_enum_type() const {
  MOJO_DCHECK(tag_ == Tag::ENUM_TYPE);

  return *(data_.enum_type);
}

void UserDefinedType::set_enum_type(MojomEnumPtr enum_type) {
  SwitchActive(Tag::ENUM_TYPE);

  *(data_.enum_type) = enum_type.Pass();

}
bool UserDefinedType::is_struct_type() const {
  return tag_ == Tag::STRUCT_TYPE;
}

MojomStructPtr& UserDefinedType::get_struct_type() const {
  MOJO_DCHECK(tag_ == Tag::STRUCT_TYPE);

  return *(data_.struct_type);
}

void UserDefinedType::set_struct_type(MojomStructPtr struct_type) {
  SwitchActive(Tag::STRUCT_TYPE);

  *(data_.struct_type) = struct_type.Pass();

}
bool UserDefinedType::is_union_type() const {
  return tag_ == Tag::UNION_TYPE;
}

MojomUnionPtr& UserDefinedType::get_union_type() const {
  MOJO_DCHECK(tag_ == Tag::UNION_TYPE);

  return *(data_.union_type);
}

void UserDefinedType::set_union_type(MojomUnionPtr union_type) {
  SwitchActive(Tag::UNION_TYPE);

  *(data_.union_type) = union_type.Pass();

}
bool UserDefinedType::is_interface_type() const {
  return tag_ == Tag::INTERFACE_TYPE;
}

MojomInterfacePtr& UserDefinedType::get_interface_type() const {
  MOJO_DCHECK(tag_ == Tag::INTERFACE_TYPE);

  return *(data_.interface_type);
}

void UserDefinedType::set_interface_type(MojomInterfacePtr interface_type) {
  SwitchActive(Tag::INTERFACE_TYPE);

  *(data_.interface_type) = interface_type.Pass();

}

bool UserDefinedType::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void UserDefinedType::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void UserDefinedType::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::ENUM_TYPE:

      data_.enum_type = new MojomEnumPtr();
      break;
    case Tag::STRUCT_TYPE:

      data_.struct_type = new MojomStructPtr();
      break;
    case Tag::UNION_TYPE:

      data_.union_type = new MojomUnionPtr();
      break;
    case Tag::INTERFACE_TYPE:

      data_.interface_type = new MojomInterfacePtr();
      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void UserDefinedType::DestroyActive() {
  switch (tag_) {

    case Tag::ENUM_TYPE:

      delete data_.enum_type;
      break;
    case Tag::STRUCT_TYPE:

      delete data_.struct_type;
      break;
    case Tag::UNION_TYPE:

      delete data_.union_type;
      break;
    case Tag::INTERFACE_TYPE:

      delete data_.interface_type;
      break;
    default:
      break;
  }
}
// static
DefaultFieldValuePtr DefaultFieldValue::New() {
  DefaultFieldValuePtr rv;
  mojo::internal::StructHelper<DefaultFieldValue>::Initialize(&rv);
  return rv;
}

DefaultFieldValue::DefaultFieldValue() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

DefaultFieldValue::~DefaultFieldValue() {
  DestroyActive();
}


DefaultFieldValuePtr DefaultFieldValue::Clone() const {
  DefaultFieldValuePtr rv(New());
  switch (tag_) {

    case Tag::VALUE:

      rv->set_value(data_.value->Clone());
      break;
    case Tag::DEFAULT_KEYWORD:

      rv->set_default_keyword(data_.default_keyword->Clone());
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool DefaultFieldValue::Equals(const DefaultFieldValue& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::VALUE:

      return mojo::internal::ValueTraits<ValuePtr>::Equals(*(data_.value), *(other.data_.value));
    case Tag::DEFAULT_KEYWORD:

      return mojo::internal::ValueTraits<DefaultKeywordPtr>::Equals(*(data_.default_keyword), *(other.data_.default_keyword));
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool DefaultFieldValue::is_value() const {
  return tag_ == Tag::VALUE;
}

ValuePtr& DefaultFieldValue::get_value() const {
  MOJO_DCHECK(tag_ == Tag::VALUE);

  return *(data_.value);
}

void DefaultFieldValue::set_value(ValuePtr value) {
  SwitchActive(Tag::VALUE);

  *(data_.value) = value.Pass();

}
bool DefaultFieldValue::is_default_keyword() const {
  return tag_ == Tag::DEFAULT_KEYWORD;
}

DefaultKeywordPtr& DefaultFieldValue::get_default_keyword() const {
  MOJO_DCHECK(tag_ == Tag::DEFAULT_KEYWORD);

  return *(data_.default_keyword);
}

void DefaultFieldValue::set_default_keyword(DefaultKeywordPtr default_keyword) {
  SwitchActive(Tag::DEFAULT_KEYWORD);

  *(data_.default_keyword) = default_keyword.Pass();

}

bool DefaultFieldValue::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void DefaultFieldValue::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void DefaultFieldValue::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::VALUE:

      data_.value = new ValuePtr();
      break;
    case Tag::DEFAULT_KEYWORD:

      data_.default_keyword = new DefaultKeywordPtr();
      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void DefaultFieldValue::DestroyActive() {
  switch (tag_) {

    case Tag::VALUE:

      delete data_.value;
      break;
    case Tag::DEFAULT_KEYWORD:

      delete data_.default_keyword;
      break;
    default:
      break;
  }
}
// static
ValuePtr Value::New() {
  ValuePtr rv;
  mojo::internal::StructHelper<Value>::Initialize(&rv);
  return rv;
}

Value::Value() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

Value::~Value() {
  DestroyActive();
}


ValuePtr Value::Clone() const {
  ValuePtr rv(New());
  switch (tag_) {

    case Tag::LITERAL_VALUE:

      rv->set_literal_value(data_.literal_value->Clone());
      break;
    case Tag::CONSTANT_REFERENCE:

      rv->set_constant_reference(data_.constant_reference->Clone());
      break;
    case Tag::ENUM_VALUE_REFERENCE:

      rv->set_enum_value_reference(data_.enum_value_reference->Clone());
      break;
    case Tag::BUILTIN_VALUE:

      rv->set_builtin_value(data_.builtin_value);
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool Value::Equals(const Value& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::LITERAL_VALUE:

      return mojo::internal::ValueTraits<LiteralValuePtr>::Equals(*(data_.literal_value), *(other.data_.literal_value));
    case Tag::CONSTANT_REFERENCE:

      return mojo::internal::ValueTraits<ConstantReferencePtr>::Equals(*(data_.constant_reference), *(other.data_.constant_reference));
    case Tag::ENUM_VALUE_REFERENCE:

      return mojo::internal::ValueTraits<EnumValueReferencePtr>::Equals(*(data_.enum_value_reference), *(other.data_.enum_value_reference));
    case Tag::BUILTIN_VALUE:

      return mojo::internal::ValueTraits<BuiltinConstantValue>::Equals(data_.builtin_value, other.data_.builtin_value);
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool Value::is_literal_value() const {
  return tag_ == Tag::LITERAL_VALUE;
}

LiteralValuePtr& Value::get_literal_value() const {
  MOJO_DCHECK(tag_ == Tag::LITERAL_VALUE);

  return *(data_.literal_value);
}

void Value::set_literal_value(LiteralValuePtr literal_value) {
  SwitchActive(Tag::LITERAL_VALUE);

  *(data_.literal_value) = literal_value.Pass();

}
bool Value::is_constant_reference() const {
  return tag_ == Tag::CONSTANT_REFERENCE;
}

ConstantReferencePtr& Value::get_constant_reference() const {
  MOJO_DCHECK(tag_ == Tag::CONSTANT_REFERENCE);

  return *(data_.constant_reference);
}

void Value::set_constant_reference(ConstantReferencePtr constant_reference) {
  SwitchActive(Tag::CONSTANT_REFERENCE);

  *(data_.constant_reference) = constant_reference.Pass();

}
bool Value::is_enum_value_reference() const {
  return tag_ == Tag::ENUM_VALUE_REFERENCE;
}

EnumValueReferencePtr& Value::get_enum_value_reference() const {
  MOJO_DCHECK(tag_ == Tag::ENUM_VALUE_REFERENCE);

  return *(data_.enum_value_reference);
}

void Value::set_enum_value_reference(EnumValueReferencePtr enum_value_reference) {
  SwitchActive(Tag::ENUM_VALUE_REFERENCE);

  *(data_.enum_value_reference) = enum_value_reference.Pass();

}
bool Value::is_builtin_value() const {
  return tag_ == Tag::BUILTIN_VALUE;
}

BuiltinConstantValue Value::get_builtin_value() const {
  MOJO_DCHECK(tag_ == Tag::BUILTIN_VALUE);

  return data_.builtin_value;
}

void Value::set_builtin_value(BuiltinConstantValue builtin_value) {
  SwitchActive(Tag::BUILTIN_VALUE);

  data_.builtin_value = builtin_value;
}

bool Value::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void Value::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void Value::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::LITERAL_VALUE:

      data_.literal_value = new LiteralValuePtr();
      break;
    case Tag::CONSTANT_REFERENCE:

      data_.constant_reference = new ConstantReferencePtr();
      break;
    case Tag::ENUM_VALUE_REFERENCE:

      data_.enum_value_reference = new EnumValueReferencePtr();
      break;
    case Tag::BUILTIN_VALUE:

      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void Value::DestroyActive() {
  switch (tag_) {

    case Tag::LITERAL_VALUE:

      delete data_.literal_value;
      break;
    case Tag::CONSTANT_REFERENCE:

      delete data_.constant_reference;
      break;
    case Tag::ENUM_VALUE_REFERENCE:

      delete data_.enum_value_reference;
      break;
    case Tag::BUILTIN_VALUE:

      break;
    default:
      break;
  }
}
// static
LiteralValuePtr LiteralValue::New() {
  LiteralValuePtr rv;
  mojo::internal::StructHelper<LiteralValue>::Initialize(&rv);
  return rv;
}

LiteralValue::LiteralValue() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

LiteralValue::~LiteralValue() {
  DestroyActive();
}


LiteralValuePtr LiteralValue::Clone() const {
  LiteralValuePtr rv(New());
  switch (tag_) {

    case Tag::BOOL_VALUE:

      rv->set_bool_value(data_.bool_value);
      break;
    case Tag::DOUBLE_VALUE:

      rv->set_double_value(data_.double_value);
      break;
    case Tag::FLOAT_VALUE:

      rv->set_float_value(data_.float_value);
      break;
    case Tag::INT8_VALUE:

      rv->set_int8_value(data_.int8_value);
      break;
    case Tag::INT16_VALUE:

      rv->set_int16_value(data_.int16_value);
      break;
    case Tag::INT32_VALUE:

      rv->set_int32_value(data_.int32_value);
      break;
    case Tag::INT64_VALUE:

      rv->set_int64_value(data_.int64_value);
      break;
    case Tag::STRING_VALUE:

      rv->set_string_value(*(data_.string_value));

      break;
    case Tag::UINT8_VALUE:

      rv->set_uint8_value(data_.uint8_value);
      break;
    case Tag::UINT16_VALUE:

      rv->set_uint16_value(data_.uint16_value);
      break;
    case Tag::UINT32_VALUE:

      rv->set_uint32_value(data_.uint32_value);
      break;
    case Tag::UINT64_VALUE:

      rv->set_uint64_value(data_.uint64_value);
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool LiteralValue::Equals(const LiteralValue& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::BOOL_VALUE:

      return mojo::internal::ValueTraits<bool>::Equals(data_.bool_value, other.data_.bool_value);
    case Tag::DOUBLE_VALUE:

      return mojo::internal::ValueTraits<double>::Equals(data_.double_value, other.data_.double_value);
    case Tag::FLOAT_VALUE:

      return mojo::internal::ValueTraits<float>::Equals(data_.float_value, other.data_.float_value);
    case Tag::INT8_VALUE:

      return mojo::internal::ValueTraits<int8_t>::Equals(data_.int8_value, other.data_.int8_value);
    case Tag::INT16_VALUE:

      return mojo::internal::ValueTraits<int16_t>::Equals(data_.int16_value, other.data_.int16_value);
    case Tag::INT32_VALUE:

      return mojo::internal::ValueTraits<int32_t>::Equals(data_.int32_value, other.data_.int32_value);
    case Tag::INT64_VALUE:

      return mojo::internal::ValueTraits<int64_t>::Equals(data_.int64_value, other.data_.int64_value);
    case Tag::STRING_VALUE:

      return mojo::internal::ValueTraits<mojo::String>::Equals(*(data_.string_value), *(other.data_.string_value));
    case Tag::UINT8_VALUE:

      return mojo::internal::ValueTraits<uint8_t>::Equals(data_.uint8_value, other.data_.uint8_value);
    case Tag::UINT16_VALUE:

      return mojo::internal::ValueTraits<uint16_t>::Equals(data_.uint16_value, other.data_.uint16_value);
    case Tag::UINT32_VALUE:

      return mojo::internal::ValueTraits<uint32_t>::Equals(data_.uint32_value, other.data_.uint32_value);
    case Tag::UINT64_VALUE:

      return mojo::internal::ValueTraits<uint64_t>::Equals(data_.uint64_value, other.data_.uint64_value);
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool LiteralValue::is_bool_value() const {
  return tag_ == Tag::BOOL_VALUE;
}

bool LiteralValue::get_bool_value() const {
  MOJO_DCHECK(tag_ == Tag::BOOL_VALUE);

  return data_.bool_value;
}

void LiteralValue::set_bool_value(bool bool_value) {
  SwitchActive(Tag::BOOL_VALUE);

  data_.bool_value = bool_value;
}
bool LiteralValue::is_double_value() const {
  return tag_ == Tag::DOUBLE_VALUE;
}

double LiteralValue::get_double_value() const {
  MOJO_DCHECK(tag_ == Tag::DOUBLE_VALUE);

  return data_.double_value;
}

void LiteralValue::set_double_value(double double_value) {
  SwitchActive(Tag::DOUBLE_VALUE);

  data_.double_value = double_value;
}
bool LiteralValue::is_float_value() const {
  return tag_ == Tag::FLOAT_VALUE;
}

float LiteralValue::get_float_value() const {
  MOJO_DCHECK(tag_ == Tag::FLOAT_VALUE);

  return data_.float_value;
}

void LiteralValue::set_float_value(float float_value) {
  SwitchActive(Tag::FLOAT_VALUE);

  data_.float_value = float_value;
}
bool LiteralValue::is_int8_value() const {
  return tag_ == Tag::INT8_VALUE;
}

int8_t LiteralValue::get_int8_value() const {
  MOJO_DCHECK(tag_ == Tag::INT8_VALUE);

  return data_.int8_value;
}

void LiteralValue::set_int8_value(int8_t int8_value) {
  SwitchActive(Tag::INT8_VALUE);

  data_.int8_value = int8_value;
}
bool LiteralValue::is_int16_value() const {
  return tag_ == Tag::INT16_VALUE;
}

int16_t LiteralValue::get_int16_value() const {
  MOJO_DCHECK(tag_ == Tag::INT16_VALUE);

  return data_.int16_value;
}

void LiteralValue::set_int16_value(int16_t int16_value) {
  SwitchActive(Tag::INT16_VALUE);

  data_.int16_value = int16_value;
}
bool LiteralValue::is_int32_value() const {
  return tag_ == Tag::INT32_VALUE;
}

int32_t LiteralValue::get_int32_value() const {
  MOJO_DCHECK(tag_ == Tag::INT32_VALUE);

  return data_.int32_value;
}

void LiteralValue::set_int32_value(int32_t int32_value) {
  SwitchActive(Tag::INT32_VALUE);

  data_.int32_value = int32_value;
}
bool LiteralValue::is_int64_value() const {
  return tag_ == Tag::INT64_VALUE;
}

int64_t LiteralValue::get_int64_value() const {
  MOJO_DCHECK(tag_ == Tag::INT64_VALUE);

  return data_.int64_value;
}

void LiteralValue::set_int64_value(int64_t int64_value) {
  SwitchActive(Tag::INT64_VALUE);

  data_.int64_value = int64_value;
}
bool LiteralValue::is_string_value() const {
  return tag_ == Tag::STRING_VALUE;
}

mojo::String LiteralValue::get_string_value() const {
  MOJO_DCHECK(tag_ == Tag::STRING_VALUE);

  return *(data_.string_value);
}

void LiteralValue::set_string_value(const mojo::String& string_value) {
  SwitchActive(Tag::STRING_VALUE);

  *(data_.string_value) = string_value;

}
bool LiteralValue::is_uint8_value() const {
  return tag_ == Tag::UINT8_VALUE;
}

uint8_t LiteralValue::get_uint8_value() const {
  MOJO_DCHECK(tag_ == Tag::UINT8_VALUE);

  return data_.uint8_value;
}

void LiteralValue::set_uint8_value(uint8_t uint8_value) {
  SwitchActive(Tag::UINT8_VALUE);

  data_.uint8_value = uint8_value;
}
bool LiteralValue::is_uint16_value() const {
  return tag_ == Tag::UINT16_VALUE;
}

uint16_t LiteralValue::get_uint16_value() const {
  MOJO_DCHECK(tag_ == Tag::UINT16_VALUE);

  return data_.uint16_value;
}

void LiteralValue::set_uint16_value(uint16_t uint16_value) {
  SwitchActive(Tag::UINT16_VALUE);

  data_.uint16_value = uint16_value;
}
bool LiteralValue::is_uint32_value() const {
  return tag_ == Tag::UINT32_VALUE;
}

uint32_t LiteralValue::get_uint32_value() const {
  MOJO_DCHECK(tag_ == Tag::UINT32_VALUE);

  return data_.uint32_value;
}

void LiteralValue::set_uint32_value(uint32_t uint32_value) {
  SwitchActive(Tag::UINT32_VALUE);

  data_.uint32_value = uint32_value;
}
bool LiteralValue::is_uint64_value() const {
  return tag_ == Tag::UINT64_VALUE;
}

uint64_t LiteralValue::get_uint64_value() const {
  MOJO_DCHECK(tag_ == Tag::UINT64_VALUE);

  return data_.uint64_value;
}

void LiteralValue::set_uint64_value(uint64_t uint64_value) {
  SwitchActive(Tag::UINT64_VALUE);

  data_.uint64_value = uint64_value;
}

bool LiteralValue::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void LiteralValue::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void LiteralValue::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::BOOL_VALUE:

      break;
    case Tag::DOUBLE_VALUE:

      break;
    case Tag::FLOAT_VALUE:

      break;
    case Tag::INT8_VALUE:

      break;
    case Tag::INT16_VALUE:

      break;
    case Tag::INT32_VALUE:

      break;
    case Tag::INT64_VALUE:

      break;
    case Tag::STRING_VALUE:

      data_.string_value = new mojo::String();
      break;
    case Tag::UINT8_VALUE:

      break;
    case Tag::UINT16_VALUE:

      break;
    case Tag::UINT32_VALUE:

      break;
    case Tag::UINT64_VALUE:

      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void LiteralValue::DestroyActive() {
  switch (tag_) {

    case Tag::BOOL_VALUE:

      break;
    case Tag::DOUBLE_VALUE:

      break;
    case Tag::FLOAT_VALUE:

      break;
    case Tag::INT8_VALUE:

      break;
    case Tag::INT16_VALUE:

      break;
    case Tag::INT32_VALUE:

      break;
    case Tag::INT64_VALUE:

      break;
    case Tag::STRING_VALUE:

      delete data_.string_value;
      break;
    case Tag::UINT8_VALUE:

      break;
    case Tag::UINT16_VALUE:

      break;
    case Tag::UINT32_VALUE:

      break;
    case Tag::UINT64_VALUE:

      break;
    default:
      break;
  }
}


// --- Struct Serialization Helpers ---

size_t StringType::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StringType::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StringType_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StringType::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StringType_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StringType::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StringType_Data* input =
      static_cast<internal::StringType_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StringType& input) {
  size_t size = sizeof(internal::StringType_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StringType* input,
    mojo::internal::Buffer* buf,
    internal::StringType_Data** output) {
  if (input) {
    internal::StringType_Data* result =
        internal::StringType_Data::New(buf);
    result->nullable = input->nullable;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StringType_Data* input,
                  StringType* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->nullable = input->nullable;
    } while (false);
  }
}


size_t HandleType::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool HandleType::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::HandleType_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool HandleType::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::HandleType_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void HandleType::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::HandleType_Data* input =
      static_cast<internal::HandleType_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const HandleType& input) {
  size_t size = sizeof(internal::HandleType_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    HandleType* input,
    mojo::internal::Buffer* buf,
    internal::HandleType_Data** output) {
  if (input) {
    internal::HandleType_Data* result =
        internal::HandleType_Data::New(buf);
    result->nullable = input->nullable;
    result->kind =
      static_cast<int32_t>(input->kind);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::HandleType_Data* input,
                  HandleType* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->nullable = input->nullable;
      result->kind = static_cast<HandleType::Kind>(input->kind);
    } while (false);
  }
}


size_t ArrayType::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ArrayType::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ArrayType_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ArrayType::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ArrayType_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ArrayType::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ArrayType_Data* input =
      static_cast<internal::ArrayType_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ArrayType& input) {
  size_t size = sizeof(internal::ArrayType_Data);
  size += GetSerializedSize_(input.element_type);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ArrayType* input,
    mojo::internal::Buffer* buf,
    internal::ArrayType_Data** output) {
  if (input) {
    internal::ArrayType_Data* result =
        internal::ArrayType_Data::New(buf);
    result->nullable = input->nullable;
    result->fixed_length = input->fixed_length;
    internal::Type_Data* element_type_ptr = &result->element_type;
    {
      auto retval =
        SerializeUnion_(input->element_type.get(),
                        buf,
                        &element_type_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->element_type.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null element_type in ArrayType struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ArrayType_Data* input,
                  ArrayType* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->nullable = input->nullable;
      result->fixed_length = input->fixed_length;
      if (!input->element_type.is_null()) {
        result->element_type = Type::New();
        Deserialize_(&input->element_type, result->element_type.get());
      }
    } while (false);
  }
}


size_t MapType::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MapType::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MapType_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MapType::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MapType_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MapType::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MapType_Data* input =
      static_cast<internal::MapType_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MapType& input) {
  size_t size = sizeof(internal::MapType_Data);
  size += GetSerializedSize_(input.key_type);
  size += GetSerializedSize_(input.value_type);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MapType* input,
    mojo::internal::Buffer* buf,
    internal::MapType_Data** output) {
  if (input) {
    internal::MapType_Data* result =
        internal::MapType_Data::New(buf);
    result->nullable = input->nullable;
    internal::Type_Data* key_type_ptr = &result->key_type;
    {
      auto retval =
        SerializeUnion_(input->key_type.get(),
                        buf,
                        &key_type_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->key_type.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null key_type in MapType struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    internal::Type_Data* value_type_ptr = &result->value_type;
    {
      auto retval =
        SerializeUnion_(input->value_type.get(),
                        buf,
                        &value_type_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->value_type.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null value_type in MapType struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MapType_Data* input,
                  MapType* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->nullable = input->nullable;
      if (!input->key_type.is_null()) {
        result->key_type = Type::New();
        Deserialize_(&input->key_type, result->key_type.get());
      }
      if (!input->value_type.is_null()) {
        result->value_type = Type::New();
        Deserialize_(&input->value_type, result->value_type.get());
      }
    } while (false);
  }
}


size_t TypeReference::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool TypeReference::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::TypeReference_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool TypeReference::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::TypeReference_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void TypeReference::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::TypeReference_Data* input =
      static_cast<internal::TypeReference_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const TypeReference& input) {
  size_t size = sizeof(internal::TypeReference_Data);
  size += GetSerializedSize_(input.identifier);
  size += GetSerializedSize_(input.type_key);
  return size;
}

mojo::internal::ValidationError Serialize_(
    TypeReference* input,
    mojo::internal::Buffer* buf,
    internal::TypeReference_Data** output) {
  if (input) {
    internal::TypeReference_Data* result =
        internal::TypeReference_Data::New(buf);
    result->nullable = input->nullable;
    result->is_interface_request = input->is_interface_request;
    SerializeString_(input->identifier, buf, &result->identifier.ptr);
    SerializeString_(input->type_key, buf, &result->type_key.ptr);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::TypeReference_Data* input,
                  TypeReference* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->nullable = input->nullable;
      result->is_interface_request = input->is_interface_request;
      Deserialize_(input->identifier.ptr, &result->identifier);
      Deserialize_(input->type_key.ptr, &result->type_key);
    } while (false);
  }
}


size_t StructField::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructField::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructField_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructField::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructField_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructField::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructField_Data* input =
      static_cast<internal::StructField_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructField& input) {
  size_t size = sizeof(internal::StructField_Data);
  size += input.decl_data.is_null()
              ? 0
              : GetSerializedSize_(*input.decl_data);
  size += GetSerializedSize_(input.type);
  size += GetSerializedSize_(input.default_value);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructField* input,
    mojo::internal::Buffer* buf,
    internal::StructField_Data** output) {
  if (input) {
    internal::StructField_Data* result =
        internal::StructField_Data::New(buf);
    {auto retval =Serialize_(input->decl_data.get(),
                 buf,
                 &result->decl_data.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    internal::Type_Data* type_ptr = &result->type;
    {
      auto retval =
        SerializeUnion_(input->type.get(),
                        buf,
                        &type_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->type.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null type in StructField struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    internal::DefaultFieldValue_Data* default_value_ptr = &result->default_value;
    {
      auto retval =
        SerializeUnion_(input->default_value.get(),
                        buf,
                        &default_value_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    result->offset = input->offset;
    result->bit = input->bit;
    result->min_version = input->min_version;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructField_Data* input,
                  StructField* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->decl_data.ptr) {
        result->decl_data = DeclarationData::New();
        Deserialize_(input->decl_data.ptr, result->decl_data.get());
      }
      if (!input->type.is_null()) {
        result->type = Type::New();
        Deserialize_(&input->type, result->type.get());
      }
      if (!input->default_value.is_null()) {
        result->default_value = DefaultFieldValue::New();
        Deserialize_(&input->default_value, result->default_value.get());
      }
      result->offset = input->offset;
      result->bit = input->bit;
      result->min_version = input->min_version;
    } while (false);
  }
}


size_t DefaultKeyword::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool DefaultKeyword::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::DefaultKeyword_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool DefaultKeyword::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::DefaultKeyword_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void DefaultKeyword::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::DefaultKeyword_Data* input =
      static_cast<internal::DefaultKeyword_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const DefaultKeyword& input) {
  size_t size = sizeof(internal::DefaultKeyword_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    DefaultKeyword* input,
    mojo::internal::Buffer* buf,
    internal::DefaultKeyword_Data** output) {
  if (input) {
    internal::DefaultKeyword_Data* result =
        internal::DefaultKeyword_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::DefaultKeyword_Data* input,
                  DefaultKeyword* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


size_t StructVersion::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructVersion::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructVersion_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructVersion::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructVersion_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructVersion::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructVersion_Data* input =
      static_cast<internal::StructVersion_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructVersion& input) {
  size_t size = sizeof(internal::StructVersion_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructVersion* input,
    mojo::internal::Buffer* buf,
    internal::StructVersion_Data** output) {
  if (input) {
    internal::StructVersion_Data* result =
        internal::StructVersion_Data::New(buf);
    result->version_number = input->version_number;
    result->num_fields = input->num_fields;
    result->num_bytes = input->num_bytes;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructVersion_Data* input,
                  StructVersion* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->version_number = input->version_number;
      result->num_fields = input->num_fields;
      result->num_bytes = input->num_bytes;
    } while (false);
  }
}


size_t MojomStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MojomStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MojomStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MojomStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MojomStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MojomStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MojomStruct_Data* input =
      static_cast<internal::MojomStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MojomStruct& input) {
  size_t size = sizeof(internal::MojomStruct_Data);
  size += input.decl_data.is_null()
              ? 0
              : GetSerializedSize_(*input.decl_data);
  size += GetSerializedSize_(input.fields);
  size += GetSerializedSize_(input.version_info);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MojomStruct* input,
    mojo::internal::Buffer* buf,
    internal::MojomStruct_Data** output) {
  if (input) {
    internal::MojomStruct_Data* result =
        internal::MojomStruct_Data::New(buf);
    {auto retval =Serialize_(input->decl_data.get(),
                 buf,
                 &result->decl_data.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams fields_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->fields, buf, &result->fields.ptr,
                            &fields_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->fields.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null fields in MojomStruct struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams version_info_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->version_info, buf, &result->version_info.ptr,
                            &version_info_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MojomStruct_Data* input,
                  MojomStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->decl_data.ptr) {
        result->decl_data = DeclarationData::New();
        Deserialize_(input->decl_data.ptr, result->decl_data.get());
      }
      Deserialize_(input->fields.ptr, &result->fields);
      Deserialize_(input->version_info.ptr, &result->version_info);
    } while (false);
  }
}


size_t UnionField::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool UnionField::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::UnionField_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool UnionField::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::UnionField_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void UnionField::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::UnionField_Data* input =
      static_cast<internal::UnionField_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const UnionField& input) {
  size_t size = sizeof(internal::UnionField_Data);
  size += input.decl_data.is_null()
              ? 0
              : GetSerializedSize_(*input.decl_data);
  size += GetSerializedSize_(input.type);
  return size;
}

mojo::internal::ValidationError Serialize_(
    UnionField* input,
    mojo::internal::Buffer* buf,
    internal::UnionField_Data** output) {
  if (input) {
    internal::UnionField_Data* result =
        internal::UnionField_Data::New(buf);
    {auto retval =Serialize_(input->decl_data.get(),
                 buf,
                 &result->decl_data.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    internal::Type_Data* type_ptr = &result->type;
    {
      auto retval =
        SerializeUnion_(input->type.get(),
                        buf,
                        &type_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->type.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null type in UnionField struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->tag = input->tag;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::UnionField_Data* input,
                  UnionField* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->decl_data.ptr) {
        result->decl_data = DeclarationData::New();
        Deserialize_(input->decl_data.ptr, result->decl_data.get());
      }
      if (!input->type.is_null()) {
        result->type = Type::New();
        Deserialize_(&input->type, result->type.get());
      }
      result->tag = input->tag;
    } while (false);
  }
}


size_t MojomUnion::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MojomUnion::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MojomUnion_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MojomUnion::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MojomUnion_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MojomUnion::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MojomUnion_Data* input =
      static_cast<internal::MojomUnion_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MojomUnion& input) {
  size_t size = sizeof(internal::MojomUnion_Data);
  size += input.decl_data.is_null()
              ? 0
              : GetSerializedSize_(*input.decl_data);
  size += GetSerializedSize_(input.fields);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MojomUnion* input,
    mojo::internal::Buffer* buf,
    internal::MojomUnion_Data** output) {
  if (input) {
    internal::MojomUnion_Data* result =
        internal::MojomUnion_Data::New(buf);
    {auto retval =Serialize_(input->decl_data.get(),
                 buf,
                 &result->decl_data.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams fields_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->fields, buf, &result->fields.ptr,
                            &fields_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->fields.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null fields in MojomUnion struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MojomUnion_Data* input,
                  MojomUnion* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->decl_data.ptr) {
        result->decl_data = DeclarationData::New();
        Deserialize_(input->decl_data.ptr, result->decl_data.get());
      }
      Deserialize_(input->fields.ptr, &result->fields);
    } while (false);
  }
}


size_t EnumValue::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool EnumValue::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::EnumValue_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool EnumValue::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::EnumValue_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void EnumValue::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::EnumValue_Data* input =
      static_cast<internal::EnumValue_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const EnumValue& input) {
  size_t size = sizeof(internal::EnumValue_Data);
  size += input.decl_data.is_null()
              ? 0
              : GetSerializedSize_(*input.decl_data);
  size += GetSerializedSize_(input.initializer_value);
  return size;
}

mojo::internal::ValidationError Serialize_(
    EnumValue* input,
    mojo::internal::Buffer* buf,
    internal::EnumValue_Data** output) {
  if (input) {
    internal::EnumValue_Data* result =
        internal::EnumValue_Data::New(buf);
    {auto retval =Serialize_(input->decl_data.get(),
                 buf,
                 &result->decl_data.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    internal::Value_Data* initializer_value_ptr = &result->initializer_value;
    {
      auto retval =
        SerializeUnion_(input->initializer_value.get(),
                        buf,
                        &initializer_value_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    result->int_value = input->int_value;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::EnumValue_Data* input,
                  EnumValue* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->decl_data.ptr) {
        result->decl_data = DeclarationData::New();
        Deserialize_(input->decl_data.ptr, result->decl_data.get());
      }
      if (!input->initializer_value.is_null()) {
        result->initializer_value = Value::New();
        Deserialize_(&input->initializer_value, result->initializer_value.get());
      }
      result->int_value = input->int_value;
    } while (false);
  }
}


size_t MojomEnum::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MojomEnum::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MojomEnum_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MojomEnum::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MojomEnum_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MojomEnum::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MojomEnum_Data* input =
      static_cast<internal::MojomEnum_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MojomEnum& input) {
  size_t size = sizeof(internal::MojomEnum_Data);
  size += input.decl_data.is_null()
              ? 0
              : GetSerializedSize_(*input.decl_data);
  size += GetSerializedSize_(input.values);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MojomEnum* input,
    mojo::internal::Buffer* buf,
    internal::MojomEnum_Data** output) {
  if (input) {
    internal::MojomEnum_Data* result =
        internal::MojomEnum_Data::New(buf);
    {auto retval =Serialize_(input->decl_data.get(),
                 buf,
                 &result->decl_data.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams values_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->values, buf, &result->values.ptr,
                            &values_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->values.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null values in MojomEnum struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MojomEnum_Data* input,
                  MojomEnum* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->decl_data.ptr) {
        result->decl_data = DeclarationData::New();
        Deserialize_(input->decl_data.ptr, result->decl_data.get());
      }
      Deserialize_(input->values.ptr, &result->values);
    } while (false);
  }
}


size_t MojomMethod::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MojomMethod::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MojomMethod_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MojomMethod::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MojomMethod_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MojomMethod::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MojomMethod_Data* input =
      static_cast<internal::MojomMethod_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MojomMethod& input) {
  size_t size = sizeof(internal::MojomMethod_Data);
  size += input.decl_data.is_null()
              ? 0
              : GetSerializedSize_(*input.decl_data);
  size += input.parameters.is_null()
              ? 0
              : GetSerializedSize_(*input.parameters);
  size += input.response_params.is_null()
              ? 0
              : GetSerializedSize_(*input.response_params);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MojomMethod* input,
    mojo::internal::Buffer* buf,
    internal::MojomMethod_Data** output) {
  if (input) {
    internal::MojomMethod_Data* result =
        internal::MojomMethod_Data::New(buf);
    {auto retval =Serialize_(input->decl_data.get(),
                 buf,
                 &result->decl_data.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->parameters.get(),
                 buf,
                 &result->parameters.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->parameters.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null parameters in MojomMethod struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->response_params.get(),
                 buf,
                 &result->response_params.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    result->ordinal = input->ordinal;
    result->min_version = input->min_version;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MojomMethod_Data* input,
                  MojomMethod* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->decl_data.ptr) {
        result->decl_data = DeclarationData::New();
        Deserialize_(input->decl_data.ptr, result->decl_data.get());
      }
      if (input->parameters.ptr) {
        result->parameters = MojomStruct::New();
        Deserialize_(input->parameters.ptr, result->parameters.get());
      }
      if (input->response_params.ptr) {
        result->response_params = MojomStruct::New();
        Deserialize_(input->response_params.ptr, result->response_params.get());
      }
      result->ordinal = input->ordinal;
      result->min_version = input->min_version;
    } while (false);
  }
}


size_t MojomInterface::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool MojomInterface::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::MojomInterface_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool MojomInterface::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::MojomInterface_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void MojomInterface::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::MojomInterface_Data* input =
      static_cast<internal::MojomInterface_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const MojomInterface& input) {
  size_t size = sizeof(internal::MojomInterface_Data);
  size += input.decl_data.is_null()
              ? 0
              : GetSerializedSize_(*input.decl_data);
  size += GetSerializedSize_(input.service_name);
  size += GetSerializedSize_(input.methods);
  return size;
}

mojo::internal::ValidationError Serialize_(
    MojomInterface* input,
    mojo::internal::Buffer* buf,
    internal::MojomInterface_Data** output) {
  if (input) {
    internal::MojomInterface_Data* result =
        internal::MojomInterface_Data::New(buf);
    {auto retval =Serialize_(input->decl_data.get(),
                 buf,
                 &result->decl_data.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    SerializeString_(input->service_name, buf, &result->service_name.ptr);
    {
      const mojo::internal::ArrayValidateParams methods_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->methods, buf, &result->methods.ptr,
          &methods_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->methods.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null methods in MojomInterface struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->current_version = input->current_version;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::MojomInterface_Data* input,
                  MojomInterface* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->decl_data.ptr) {
        result->decl_data = DeclarationData::New();
        Deserialize_(input->decl_data.ptr, result->decl_data.get());
      }
      Deserialize_(input->service_name.ptr, &result->service_name);
      Deserialize_(input->methods.ptr, &result->methods);
      result->current_version = input->current_version;
    } while (false);
  }
}


size_t ConstantReference::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConstantReference::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConstantReference_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConstantReference::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConstantReference_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConstantReference::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConstantReference_Data* input =
      static_cast<internal::ConstantReference_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConstantReference& input) {
  size_t size = sizeof(internal::ConstantReference_Data);
  size += GetSerializedSize_(input.identifier);
  size += GetSerializedSize_(input.constant_key);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConstantReference* input,
    mojo::internal::Buffer* buf,
    internal::ConstantReference_Data** output) {
  if (input) {
    internal::ConstantReference_Data* result =
        internal::ConstantReference_Data::New(buf);
    SerializeString_(input->identifier, buf, &result->identifier.ptr);
    if (!result->identifier.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null identifier in ConstantReference struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    SerializeString_(input->constant_key, buf, &result->constant_key.ptr);
    if (!result->constant_key.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null constant_key in ConstantReference struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConstantReference_Data* input,
                  ConstantReference* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->identifier.ptr, &result->identifier);
      Deserialize_(input->constant_key.ptr, &result->constant_key);
    } while (false);
  }
}


size_t EnumValueReference::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool EnumValueReference::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::EnumValueReference_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool EnumValueReference::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::EnumValueReference_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void EnumValueReference::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::EnumValueReference_Data* input =
      static_cast<internal::EnumValueReference_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const EnumValueReference& input) {
  size_t size = sizeof(internal::EnumValueReference_Data);
  size += GetSerializedSize_(input.identifier);
  size += GetSerializedSize_(input.enum_type_key);
  return size;
}

mojo::internal::ValidationError Serialize_(
    EnumValueReference* input,
    mojo::internal::Buffer* buf,
    internal::EnumValueReference_Data** output) {
  if (input) {
    internal::EnumValueReference_Data* result =
        internal::EnumValueReference_Data::New(buf);
    SerializeString_(input->identifier, buf, &result->identifier.ptr);
    if (!result->identifier.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null identifier in EnumValueReference struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    SerializeString_(input->enum_type_key, buf, &result->enum_type_key.ptr);
    if (!result->enum_type_key.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null enum_type_key in EnumValueReference struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->enum_value_index = input->enum_value_index;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::EnumValueReference_Data* input,
                  EnumValueReference* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->identifier.ptr, &result->identifier);
      Deserialize_(input->enum_type_key.ptr, &result->enum_type_key);
      result->enum_value_index = input->enum_value_index;
    } while (false);
  }
}


size_t DeclaredConstant::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool DeclaredConstant::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::DeclaredConstant_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool DeclaredConstant::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::DeclaredConstant_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void DeclaredConstant::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::DeclaredConstant_Data* input =
      static_cast<internal::DeclaredConstant_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const DeclaredConstant& input) {
  size_t size = sizeof(internal::DeclaredConstant_Data);
  size += input.decl_data.is_null()
              ? 0
              : GetSerializedSize_(*input.decl_data);
  size += GetSerializedSize_(input.type);
  size += GetSerializedSize_(input.value);
  size += GetSerializedSize_(input.resolved_concrete_value);
  return size;
}

mojo::internal::ValidationError Serialize_(
    DeclaredConstant* input,
    mojo::internal::Buffer* buf,
    internal::DeclaredConstant_Data** output) {
  if (input) {
    internal::DeclaredConstant_Data* result =
        internal::DeclaredConstant_Data::New(buf);
    {auto retval =Serialize_(input->decl_data.get(),
                 buf,
                 &result->decl_data.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->decl_data.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null decl_data in DeclaredConstant struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    internal::Type_Data* type_ptr = &result->type;
    {
      auto retval =
        SerializeUnion_(input->type.get(),
                        buf,
                        &type_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->type.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null type in DeclaredConstant struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    internal::Value_Data* value_ptr = &result->value;
    {
      auto retval =
        SerializeUnion_(input->value.get(),
                        buf,
                        &value_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->value.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null value in DeclaredConstant struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    internal::Value_Data* resolved_concrete_value_ptr = &result->resolved_concrete_value;
    {
      auto retval =
        SerializeUnion_(input->resolved_concrete_value.get(),
                        buf,
                        &resolved_concrete_value_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::DeclaredConstant_Data* input,
                  DeclaredConstant* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->decl_data.ptr) {
        result->decl_data = DeclarationData::New();
        Deserialize_(input->decl_data.ptr, result->decl_data.get());
      }
      if (!input->type.is_null()) {
        result->type = Type::New();
        Deserialize_(&input->type, result->type.get());
      }
      if (!input->value.is_null()) {
        result->value = Value::New();
        Deserialize_(&input->value, result->value.get());
      }
      if (!input->resolved_concrete_value.is_null()) {
        result->resolved_concrete_value = Value::New();
        Deserialize_(&input->resolved_concrete_value, result->resolved_concrete_value.get());
      }
    } while (false);
  }
}


size_t Attribute::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Attribute::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Attribute_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Attribute::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Attribute_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Attribute::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Attribute_Data* input =
      static_cast<internal::Attribute_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Attribute& input) {
  size_t size = sizeof(internal::Attribute_Data);
  size += GetSerializedSize_(input.key);
  size += GetSerializedSize_(input.value);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Attribute* input,
    mojo::internal::Buffer* buf,
    internal::Attribute_Data** output) {
  if (input) {
    internal::Attribute_Data* result =
        internal::Attribute_Data::New(buf);
    SerializeString_(input->key, buf, &result->key.ptr);
    if (!result->key.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null key in Attribute struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    internal::LiteralValue_Data* value_ptr = &result->value;
    {
      auto retval =
        SerializeUnion_(input->value.get(),
                        buf,
                        &value_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->value.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null value in Attribute struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Attribute_Data* input,
                  Attribute* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->key.ptr, &result->key);
      if (!input->value.is_null()) {
        result->value = LiteralValue::New();
        Deserialize_(&input->value, result->value.get());
      }
    } while (false);
  }
}


size_t DeclarationData::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool DeclarationData::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::DeclarationData_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool DeclarationData::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::DeclarationData_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void DeclarationData::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::DeclarationData_Data* input =
      static_cast<internal::DeclarationData_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const DeclarationData& input) {
  size_t size = sizeof(internal::DeclarationData_Data);
  size += GetSerializedSize_(input.attributes);
  size += GetSerializedSize_(input.short_name);
  size += GetSerializedSize_(input.full_identifier);
  size += input.source_file_info.is_null()
              ? 0
              : GetSerializedSize_(*input.source_file_info);
  size += input.contained_declarations.is_null()
              ? 0
              : GetSerializedSize_(*input.contained_declarations);
  size += GetSerializedSize_(input.container_type_key);
  return size;
}

mojo::internal::ValidationError Serialize_(
    DeclarationData* input,
    mojo::internal::Buffer* buf,
    internal::DeclarationData_Data** output) {
  if (input) {
    internal::DeclarationData_Data* result =
        internal::DeclarationData_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams attributes_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->attributes, buf, &result->attributes.ptr,
                            &attributes_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    SerializeString_(input->short_name, buf, &result->short_name.ptr);
    SerializeString_(input->full_identifier, buf, &result->full_identifier.ptr);
    result->declared_ordinal = input->declared_ordinal;
    result->declaration_order = input->declaration_order;
    {auto retval =Serialize_(input->source_file_info.get(),
                 buf,
                 &result->source_file_info.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {auto retval =Serialize_(input->contained_declarations.get(),
                 buf,
                 &result->contained_declarations.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    SerializeString_(input->container_type_key, buf, &result->container_type_key.ptr);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::DeclarationData_Data* input,
                  DeclarationData* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->attributes.ptr, &result->attributes);
      Deserialize_(input->short_name.ptr, &result->short_name);
      Deserialize_(input->full_identifier.ptr, &result->full_identifier);
      result->declared_ordinal = input->declared_ordinal;
      result->declaration_order = input->declaration_order;
      if (input->source_file_info.ptr) {
        result->source_file_info = SourceFileInfo::New();
        Deserialize_(input->source_file_info.ptr, result->source_file_info.get());
      }
      if (input->contained_declarations.ptr) {
        result->contained_declarations = ContainedDeclarations::New();
        Deserialize_(input->contained_declarations.ptr, result->contained_declarations.get());
      }
      Deserialize_(input->container_type_key.ptr, &result->container_type_key);
    } while (false);
  }
}


size_t SourceFileInfo::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool SourceFileInfo::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::SourceFileInfo_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool SourceFileInfo::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::SourceFileInfo_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void SourceFileInfo::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::SourceFileInfo_Data* input =
      static_cast<internal::SourceFileInfo_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const SourceFileInfo& input) {
  size_t size = sizeof(internal::SourceFileInfo_Data);
  size += GetSerializedSize_(input.file_name);
  return size;
}

mojo::internal::ValidationError Serialize_(
    SourceFileInfo* input,
    mojo::internal::Buffer* buf,
    internal::SourceFileInfo_Data** output) {
  if (input) {
    internal::SourceFileInfo_Data* result =
        internal::SourceFileInfo_Data::New(buf);
    SerializeString_(input->file_name, buf, &result->file_name.ptr);
    if (!result->file_name.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null file_name in SourceFileInfo struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->line_number = input->line_number;
    result->column_number = input->column_number;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::SourceFileInfo_Data* input,
                  SourceFileInfo* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->file_name.ptr, &result->file_name);
      result->line_number = input->line_number;
      result->column_number = input->column_number;
    } while (false);
  }
}


size_t ContainedDeclarations::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ContainedDeclarations::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ContainedDeclarations_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ContainedDeclarations::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ContainedDeclarations_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ContainedDeclarations::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ContainedDeclarations_Data* input =
      static_cast<internal::ContainedDeclarations_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ContainedDeclarations& input) {
  size_t size = sizeof(internal::ContainedDeclarations_Data);
  size += GetSerializedSize_(input.enums);
  size += GetSerializedSize_(input.constants);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ContainedDeclarations* input,
    mojo::internal::Buffer* buf,
    internal::ContainedDeclarations_Data** output) {
  if (input) {
    internal::ContainedDeclarations_Data* result =
        internal::ContainedDeclarations_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams enums_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->enums, buf, &result->enums.ptr,
                            &enums_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams constants_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->constants, buf, &result->constants.ptr,
                            &constants_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ContainedDeclarations_Data* input,
                  ContainedDeclarations* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->enums.ptr, &result->enums);
      Deserialize_(input->constants.ptr, &result->constants);
    } while (false);
  }
}


size_t RuntimeTypeInfo::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool RuntimeTypeInfo::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::RuntimeTypeInfo_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool RuntimeTypeInfo::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::RuntimeTypeInfo_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void RuntimeTypeInfo::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::RuntimeTypeInfo_Data* input =
      static_cast<internal::RuntimeTypeInfo_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const RuntimeTypeInfo& input) {
  size_t size = sizeof(internal::RuntimeTypeInfo_Data);
  size += GetSerializedSize_(input.services);
  size += GetSerializedSize_(input.type_map);
  return size;
}

mojo::internal::ValidationError Serialize_(
    RuntimeTypeInfo* input,
    mojo::internal::Buffer* buf,
    internal::RuntimeTypeInfo_Data** output) {
  if (input) {
    internal::RuntimeTypeInfo_Data* result =
        internal::RuntimeTypeInfo_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams services_validate_params(
          0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeMap_(
          &input->services, buf, &result->services.ptr,
          &services_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->services.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null services in RuntimeTypeInfo struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams type_map_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->type_map, buf, &result->type_map.ptr,
          &type_map_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->type_map.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null type_map in RuntimeTypeInfo struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::RuntimeTypeInfo_Data* input,
                  RuntimeTypeInfo* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->services.ptr, &result->services);
      Deserialize_(input->type_map.ptr, &result->type_map);
    } while (false);
  }
}


// --- Union Serialization Helpers ---

size_t GetSerializedSize_(const TypePtr& input) {
   size_t size = sizeof(internal::Type_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<Type> input_acc(input.get());
  switch (input->which()) {



    case Type::Tag::STRING_TYPE:

      size += GetSerializedSize_(*(input_acc.data()->string_type->get()));

      break;

    case Type::Tag::ARRAY_TYPE:

      size += GetSerializedSize_(*(input_acc.data()->array_type->get()));

      break;

    case Type::Tag::MAP_TYPE:

      size += GetSerializedSize_(*(input_acc.data()->map_type->get()));

      break;

    case Type::Tag::HANDLE_TYPE:

      size += GetSerializedSize_(*(input_acc.data()->handle_type->get()));

      break;

    case Type::Tag::TYPE_REFERENCE:

      size += GetSerializedSize_(*(input_acc.data()->type_reference->get()));

      break;
    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    Type* input,
    mojo::internal::Buffer* buf,
    internal::Type_Data** output) {
  internal::Type_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<Type> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case Type::Tag::SIMPLE_TYPE: {

        result->data.f_simple_type = 
          static_cast<int32_t>(input_acc.data()->simple_type);

        break;
      }
      case Type::Tag::STRING_TYPE: {


          {auto retval =Serialize_(input_acc.data()->string_type->get(),
                     buf,
                     &result->data.f_string_type.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case Type::Tag::ARRAY_TYPE: {


          {auto retval =Serialize_(input_acc.data()->array_type->get(),
                     buf,
                     &result->data.f_array_type.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case Type::Tag::MAP_TYPE: {


          {auto retval =Serialize_(input_acc.data()->map_type->get(),
                     buf,
                     &result->data.f_map_type.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case Type::Tag::HANDLE_TYPE: {


          {auto retval =Serialize_(input_acc.data()->handle_type->get(),
                     buf,
                     &result->data.f_handle_type.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case Type::Tag::TYPE_REFERENCE: {


          {auto retval =Serialize_(input_acc.data()->type_reference->get(),
                     buf,
                     &result->data.f_type_reference.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Type_Data* input,
                  Type* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<Type> result_acc(output);
    switch (input->tag) {

      case Type::Tag::SIMPLE_TYPE: {

        output->set_simple_type(static_cast<SimpleType>(input->data.f_simple_type));

        break;
      }
      case Type::Tag::STRING_TYPE: {

        result_acc.SwitchActive(Type::Tag::STRING_TYPE);

        *result_acc.data()->string_type =
            StringType::New();
        Deserialize_(input->data.f_string_type.ptr,
            result_acc.data()->string_type->get());


        break;
      }
      case Type::Tag::ARRAY_TYPE: {

        result_acc.SwitchActive(Type::Tag::ARRAY_TYPE);

        *result_acc.data()->array_type =
            ArrayType::New();
        Deserialize_(input->data.f_array_type.ptr,
            result_acc.data()->array_type->get());


        break;
      }
      case Type::Tag::MAP_TYPE: {

        result_acc.SwitchActive(Type::Tag::MAP_TYPE);

        *result_acc.data()->map_type =
            MapType::New();
        Deserialize_(input->data.f_map_type.ptr,
            result_acc.data()->map_type->get());


        break;
      }
      case Type::Tag::HANDLE_TYPE: {

        result_acc.SwitchActive(Type::Tag::HANDLE_TYPE);

        *result_acc.data()->handle_type =
            HandleType::New();
        Deserialize_(input->data.f_handle_type.ptr,
            result_acc.data()->handle_type->get());


        break;
      }
      case Type::Tag::TYPE_REFERENCE: {

        result_acc.SwitchActive(Type::Tag::TYPE_REFERENCE);

        *result_acc.data()->type_reference =
            TypeReference::New();
        Deserialize_(input->data.f_type_reference.ptr,
            result_acc.data()->type_reference->get());


        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing Type with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


size_t GetSerializedSize_(const UserDefinedTypePtr& input) {
   size_t size = sizeof(internal::UserDefinedType_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<UserDefinedType> input_acc(input.get());
  switch (input->which()) {


    case UserDefinedType::Tag::ENUM_TYPE:

      size += GetSerializedSize_(*(input_acc.data()->enum_type->get()));

      break;

    case UserDefinedType::Tag::STRUCT_TYPE:

      size += GetSerializedSize_(*(input_acc.data()->struct_type->get()));

      break;

    case UserDefinedType::Tag::UNION_TYPE:

      size += GetSerializedSize_(*(input_acc.data()->union_type->get()));

      break;

    case UserDefinedType::Tag::INTERFACE_TYPE:

      size += GetSerializedSize_(*(input_acc.data()->interface_type->get()));

      break;
    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    UserDefinedType* input,
    mojo::internal::Buffer* buf,
    internal::UserDefinedType_Data** output) {
  internal::UserDefinedType_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<UserDefinedType> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case UserDefinedType::Tag::ENUM_TYPE: {


          {auto retval =Serialize_(input_acc.data()->enum_type->get(),
                     buf,
                     &result->data.f_enum_type.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case UserDefinedType::Tag::STRUCT_TYPE: {


          {auto retval =Serialize_(input_acc.data()->struct_type->get(),
                     buf,
                     &result->data.f_struct_type.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case UserDefinedType::Tag::UNION_TYPE: {


          {auto retval =Serialize_(input_acc.data()->union_type->get(),
                     buf,
                     &result->data.f_union_type.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case UserDefinedType::Tag::INTERFACE_TYPE: {


          {auto retval =Serialize_(input_acc.data()->interface_type->get(),
                     buf,
                     &result->data.f_interface_type.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::UserDefinedType_Data* input,
                  UserDefinedType* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<UserDefinedType> result_acc(output);
    switch (input->tag) {

      case UserDefinedType::Tag::ENUM_TYPE: {

        result_acc.SwitchActive(UserDefinedType::Tag::ENUM_TYPE);

        *result_acc.data()->enum_type =
            MojomEnum::New();
        Deserialize_(input->data.f_enum_type.ptr,
            result_acc.data()->enum_type->get());


        break;
      }
      case UserDefinedType::Tag::STRUCT_TYPE: {

        result_acc.SwitchActive(UserDefinedType::Tag::STRUCT_TYPE);

        *result_acc.data()->struct_type =
            MojomStruct::New();
        Deserialize_(input->data.f_struct_type.ptr,
            result_acc.data()->struct_type->get());


        break;
      }
      case UserDefinedType::Tag::UNION_TYPE: {

        result_acc.SwitchActive(UserDefinedType::Tag::UNION_TYPE);

        *result_acc.data()->union_type =
            MojomUnion::New();
        Deserialize_(input->data.f_union_type.ptr,
            result_acc.data()->union_type->get());


        break;
      }
      case UserDefinedType::Tag::INTERFACE_TYPE: {

        result_acc.SwitchActive(UserDefinedType::Tag::INTERFACE_TYPE);

        *result_acc.data()->interface_type =
            MojomInterface::New();
        Deserialize_(input->data.f_interface_type.ptr,
            result_acc.data()->interface_type->get());


        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing UserDefinedType with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


size_t GetSerializedSize_(const DefaultFieldValuePtr& input) {
   size_t size = sizeof(internal::DefaultFieldValue_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<DefaultFieldValue> input_acc(input.get());
  switch (input->which()) {


    case DefaultFieldValue::Tag::VALUE:

      if ((input_acc.data()->value)) {
        //size += sizeof(mojo::internal::UnionPointer<Value::Data_>);
        size += GetSerializedSize_(*(input_acc.data()->value));
      }

      break;

    case DefaultFieldValue::Tag::DEFAULT_KEYWORD:

      size += GetSerializedSize_(*(input_acc.data()->default_keyword->get()));

      break;
    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    DefaultFieldValue* input,
    mojo::internal::Buffer* buf,
    internal::DefaultFieldValue_Data** output) {
  internal::DefaultFieldValue_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<DefaultFieldValue> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case DefaultFieldValue::Tag::VALUE: {


          // Point *output to newly allocated memory
          // SerializeUnion_ into newly allocated memory.
          if (!input_acc.data()->value->get()) {
            result->data.f_value.ptr = nullptr;
          } else {
            result->data.f_value.ptr =
              Value::Data_::New(buf);
            {
            auto retval =
              SerializeUnion_(input_acc.data()->value->get(),
                              buf,
                              &result->data.f_value.ptr);
            if (retval != mojo::internal::ValidationError::NONE)
              return retval;
          }
          }


        break;
      }
      case DefaultFieldValue::Tag::DEFAULT_KEYWORD: {


          {auto retval =Serialize_(input_acc.data()->default_keyword->get(),
                     buf,
                     &result->data.f_default_keyword.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::DefaultFieldValue_Data* input,
                  DefaultFieldValue* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<DefaultFieldValue> result_acc(output);
    switch (input->tag) {

      case DefaultFieldValue::Tag::VALUE: {

        result_acc.SwitchActive(DefaultFieldValue::Tag::VALUE);

        *result_acc.data()->value =
            Value::New();
        Deserialize_(input->data.f_value.ptr,
            result_acc.data()->value->get());


        break;
      }
      case DefaultFieldValue::Tag::DEFAULT_KEYWORD: {

        result_acc.SwitchActive(DefaultFieldValue::Tag::DEFAULT_KEYWORD);

        *result_acc.data()->default_keyword =
            DefaultKeyword::New();
        Deserialize_(input->data.f_default_keyword.ptr,
            result_acc.data()->default_keyword->get());


        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing DefaultFieldValue with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


size_t GetSerializedSize_(const ValuePtr& input) {
   size_t size = sizeof(internal::Value_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<Value> input_acc(input.get());
  switch (input->which()) {


    case Value::Tag::LITERAL_VALUE:

      if ((input_acc.data()->literal_value)) {
        //size += sizeof(mojo::internal::UnionPointer<LiteralValue::Data_>);
        size += GetSerializedSize_(*(input_acc.data()->literal_value));
      }

      break;

    case Value::Tag::CONSTANT_REFERENCE:

      size += GetSerializedSize_(*(input_acc.data()->constant_reference->get()));

      break;

    case Value::Tag::ENUM_VALUE_REFERENCE:

      size += GetSerializedSize_(*(input_acc.data()->enum_value_reference->get()));

      break;

    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    Value* input,
    mojo::internal::Buffer* buf,
    internal::Value_Data** output) {
  internal::Value_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<Value> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case Value::Tag::LITERAL_VALUE: {


          // Point *output to newly allocated memory
          // SerializeUnion_ into newly allocated memory.
          if (!input_acc.data()->literal_value->get()) {
            result->data.f_literal_value.ptr = nullptr;
          } else {
            result->data.f_literal_value.ptr =
              LiteralValue::Data_::New(buf);
            {
            auto retval =
              SerializeUnion_(input_acc.data()->literal_value->get(),
                              buf,
                              &result->data.f_literal_value.ptr);
            if (retval != mojo::internal::ValidationError::NONE)
              return retval;
          }
          }


        break;
      }
      case Value::Tag::CONSTANT_REFERENCE: {


          {auto retval =Serialize_(input_acc.data()->constant_reference->get(),
                     buf,
                     &result->data.f_constant_reference.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case Value::Tag::ENUM_VALUE_REFERENCE: {


          {auto retval =Serialize_(input_acc.data()->enum_value_reference->get(),
                     buf,
                     &result->data.f_enum_value_reference.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case Value::Tag::BUILTIN_VALUE: {

        result->data.f_builtin_value = 
          static_cast<int32_t>(input_acc.data()->builtin_value);

        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Value_Data* input,
                  Value* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<Value> result_acc(output);
    switch (input->tag) {

      case Value::Tag::LITERAL_VALUE: {

        result_acc.SwitchActive(Value::Tag::LITERAL_VALUE);

        *result_acc.data()->literal_value =
            LiteralValue::New();
        Deserialize_(input->data.f_literal_value.ptr,
            result_acc.data()->literal_value->get());


        break;
      }
      case Value::Tag::CONSTANT_REFERENCE: {

        result_acc.SwitchActive(Value::Tag::CONSTANT_REFERENCE);

        *result_acc.data()->constant_reference =
            ConstantReference::New();
        Deserialize_(input->data.f_constant_reference.ptr,
            result_acc.data()->constant_reference->get());


        break;
      }
      case Value::Tag::ENUM_VALUE_REFERENCE: {

        result_acc.SwitchActive(Value::Tag::ENUM_VALUE_REFERENCE);

        *result_acc.data()->enum_value_reference =
            EnumValueReference::New();
        Deserialize_(input->data.f_enum_value_reference.ptr,
            result_acc.data()->enum_value_reference->get());


        break;
      }
      case Value::Tag::BUILTIN_VALUE: {

        output->set_builtin_value(static_cast<BuiltinConstantValue>(input->data.f_builtin_value));

        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing Value with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


size_t GetSerializedSize_(const LiteralValuePtr& input) {
   size_t size = sizeof(internal::LiteralValue_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<LiteralValue> input_acc(input.get());
  switch (input->which()) {









    case LiteralValue::Tag::STRING_VALUE:

      size += GetSerializedSize_(*(input_acc.data()->string_value));

      break;




    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    LiteralValue* input,
    mojo::internal::Buffer* buf,
    internal::LiteralValue_Data** output) {
  internal::LiteralValue_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<LiteralValue> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case LiteralValue::Tag::BOOL_VALUE: {

        result->data.f_bool_value = input_acc.data()->bool_value;
        break;
      }
      case LiteralValue::Tag::DOUBLE_VALUE: {

        result->data.f_double_value = input_acc.data()->double_value;
        break;
      }
      case LiteralValue::Tag::FLOAT_VALUE: {

        result->data.f_float_value = input_acc.data()->float_value;
        break;
      }
      case LiteralValue::Tag::INT8_VALUE: {

        result->data.f_int8_value = input_acc.data()->int8_value;
        break;
      }
      case LiteralValue::Tag::INT16_VALUE: {

        result->data.f_int16_value = input_acc.data()->int16_value;
        break;
      }
      case LiteralValue::Tag::INT32_VALUE: {

        result->data.f_int32_value = input_acc.data()->int32_value;
        break;
      }
      case LiteralValue::Tag::INT64_VALUE: {

        result->data.f_int64_value = input_acc.data()->int64_value;
        break;
      }
      case LiteralValue::Tag::STRING_VALUE: {


        SerializeString_(
            *input_acc.data()->string_value,
            buf, &result->data.f_string_value.ptr);


        break;
      }
      case LiteralValue::Tag::UINT8_VALUE: {

        result->data.f_uint8_value = input_acc.data()->uint8_value;
        break;
      }
      case LiteralValue::Tag::UINT16_VALUE: {

        result->data.f_uint16_value = input_acc.data()->uint16_value;
        break;
      }
      case LiteralValue::Tag::UINT32_VALUE: {

        result->data.f_uint32_value = input_acc.data()->uint32_value;
        break;
      }
      case LiteralValue::Tag::UINT64_VALUE: {

        result->data.f_uint64_value = input_acc.data()->uint64_value;
        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::LiteralValue_Data* input,
                  LiteralValue* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<LiteralValue> result_acc(output);
    switch (input->tag) {

      case LiteralValue::Tag::BOOL_VALUE: {

        output->set_bool_value(input->data.f_bool_value);
        break;
      }
      case LiteralValue::Tag::DOUBLE_VALUE: {

        output->set_double_value(input->data.f_double_value);
        break;
      }
      case LiteralValue::Tag::FLOAT_VALUE: {

        output->set_float_value(input->data.f_float_value);
        break;
      }
      case LiteralValue::Tag::INT8_VALUE: {

        output->set_int8_value(input->data.f_int8_value);
        break;
      }
      case LiteralValue::Tag::INT16_VALUE: {

        output->set_int16_value(input->data.f_int16_value);
        break;
      }
      case LiteralValue::Tag::INT32_VALUE: {

        output->set_int32_value(input->data.f_int32_value);
        break;
      }
      case LiteralValue::Tag::INT64_VALUE: {

        output->set_int64_value(input->data.f_int64_value);
        break;
      }
      case LiteralValue::Tag::STRING_VALUE: {

        result_acc.SwitchActive(LiteralValue::Tag::STRING_VALUE);

        Deserialize_(input->data.f_string_value.ptr, result_acc.data()->string_value);


        break;
      }
      case LiteralValue::Tag::UINT8_VALUE: {

        output->set_uint8_value(input->data.f_uint8_value);
        break;
      }
      case LiteralValue::Tag::UINT16_VALUE: {

        output->set_uint16_value(input->data.f_uint16_value);
        break;
      }
      case LiteralValue::Tag::UINT32_VALUE: {

        output->set_uint32_value(input->data.f_uint32_value);
        break;
      }
      case LiteralValue::Tag::UINT64_VALUE: {

        output->set_uint64_value(input->data.f_uint64_value);
        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing LiteralValue with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


// --- Structs for interface method parameters ---
}  // namespace types
}  // namespace bindings
}  // namespace mojo
