// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/services/flog/interfaces/flog.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace mojo {
namespace flog {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// static
FlogDescription_Data* FlogDescription_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogDescription_Data))) FlogDescription_Data();
}

// static
mojo::internal::ValidationError FlogDescription_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogDescription_Data* object = static_cast<const FlogDescription_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->label.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null label field in FlogDescription struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->label.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams label_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->label.offset),
          bounds_checker, &label_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogDescription_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->label, handles);
}

void FlogDescription_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->label, handles);
}

FlogDescription_Data::FlogDescription_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
FlogEntry_Data* FlogEntry_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogEntry_Data))) FlogEntry_Data();
}

// static
mojo::internal::ValidationError FlogEntry_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogEntry_Data* object = static_cast<const FlogEntry_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 40 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  auto validate_retval = FlogEntryDetails::Data_::Validate(
          &object->details, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogEntry_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  details.EncodePointersAndHandles(handles);
}

void FlogEntry_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  details.DecodePointersAndHandles(handles);
}

FlogEntry_Data::FlogEntry_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
FlogChannelCreationEntryDetails_Data* FlogChannelCreationEntryDetails_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogChannelCreationEntryDetails_Data))) FlogChannelCreationEntryDetails_Data();
}

// static
mojo::internal::ValidationError FlogChannelCreationEntryDetails_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogChannelCreationEntryDetails_Data* object = static_cast<const FlogChannelCreationEntryDetails_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->type_name.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null type_name field in FlogChannelCreationEntryDetails struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->type_name.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams type_name_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->type_name.offset),
          bounds_checker, &type_name_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogChannelCreationEntryDetails_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->type_name, handles);
}

void FlogChannelCreationEntryDetails_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->type_name, handles);
}

FlogChannelCreationEntryDetails_Data::FlogChannelCreationEntryDetails_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
FlogChannelMessageEntryDetails_Data* FlogChannelMessageEntryDetails_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogChannelMessageEntryDetails_Data))) FlogChannelMessageEntryDetails_Data();
}

// static
mojo::internal::ValidationError FlogChannelMessageEntryDetails_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogChannelMessageEntryDetails_Data* object = static_cast<const FlogChannelMessageEntryDetails_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->data.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null data field in FlogChannelMessageEntryDetails struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams data_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<uint8_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->data.offset),
          bounds_checker, &data_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogChannelMessageEntryDetails_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->data, handles);
}

void FlogChannelMessageEntryDetails_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->data, handles);
}

FlogChannelMessageEntryDetails_Data::FlogChannelMessageEntryDetails_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
FlogChannelDeletionEntryDetails_Data* FlogChannelDeletionEntryDetails_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogChannelDeletionEntryDetails_Data))) FlogChannelDeletionEntryDetails_Data();
}

// static
mojo::internal::ValidationError FlogChannelDeletionEntryDetails_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogChannelDeletionEntryDetails_Data* object = static_cast<const FlogChannelDeletionEntryDetails_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogChannelDeletionEntryDetails_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void FlogChannelDeletionEntryDetails_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

FlogChannelDeletionEntryDetails_Data::FlogChannelDeletionEntryDetails_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// --- Union definitions ---
// static
FlogEntryDetails_Data* FlogEntryDetails_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogEntryDetails_Data))) FlogEntryDetails_Data();
}


// static
mojo::internal::ValidationError FlogEntryDetails_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(FlogEntryDetails_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const FlogEntryDetails_Data* object = static_cast<const FlogEntryDetails_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case FlogEntryDetails_Tag::CHANNEL_CREATION: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::FlogChannelCreationEntryDetails_Data>*>(&object->data.f_channel_creation))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'channel_creation' in 'FlogEntryDetails'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::FlogChannelCreationEntryDetails_Data>*>(&object->data.f_channel_creation))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case FlogEntryDetails_Tag::CHANNEL_MESSAGE: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::FlogChannelMessageEntryDetails_Data>*>(&object->data.f_channel_message))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'channel_message' in 'FlogEntryDetails'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::FlogChannelMessageEntryDetails_Data>*>(&object->data.f_channel_message))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case FlogEntryDetails_Tag::CHANNEL_DELETION: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::FlogChannelDeletionEntryDetails_Data>*>(&object->data.f_channel_deletion))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'channel_deletion' in 'FlogEntryDetails'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::FlogChannelDeletionEntryDetails_Data>*>(&object->data.f_channel_deletion))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void FlogEntryDetails_Data::set_null() {
  size = 0U;
  tag = static_cast<FlogEntryDetails_Tag>(0);
  data.unknown = 0U;
}

FlogEntryDetails_Data::FlogEntryDetails_Data() {
}

void FlogEntryDetails_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case FlogEntryDetails_Tag::CHANNEL_CREATION: {
      mojo::internal::Encode(&data.f_channel_creation, handles);
      return;
    }
    case FlogEntryDetails_Tag::CHANNEL_MESSAGE: {
      mojo::internal::Encode(&data.f_channel_message, handles);
      return;
    }
    case FlogEntryDetails_Tag::CHANNEL_DELETION: {
      mojo::internal::Encode(&data.f_channel_deletion, handles);
      return;
    }
    case FlogEntryDetails_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void FlogEntryDetails_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case FlogEntryDetails_Tag::CHANNEL_CREATION: {
      mojo::internal::Decode(&data.f_channel_creation, handles);
      return;
    }
    case FlogEntryDetails_Tag::CHANNEL_MESSAGE: {
      mojo::internal::Decode(&data.f_channel_message, handles);
      return;
    }
    case FlogEntryDetails_Tag::CHANNEL_DELETION: {
      mojo::internal::Decode(&data.f_channel_deletion, handles);
      return;
    }
    default:
      return;
  }
}


// --- Definitions of the data structs for interface methods ---


// static
FlogService_CreateLogger_Params_Data* FlogService_CreateLogger_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogService_CreateLogger_Params_Data))) FlogService_CreateLogger_Params_Data();
}

// static
mojo::internal::ValidationError FlogService_CreateLogger_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogService_CreateLogger_Params_Data* object = static_cast<const FlogService_CreateLogger_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle logger_handle = object->logger;
  if (logger_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid logger field in FlogService_CreateLogger_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(logger_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  if (!object->label.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null label field in FlogService_CreateLogger_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->label.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams label_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->label.offset),
          bounds_checker, &label_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogService_CreateLogger_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->logger, handles);
  mojo::internal::Encode(&this->label, handles);
}

void FlogService_CreateLogger_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->logger, handles);
  mojo::internal::Decode(&this->label, handles);
}

FlogService_CreateLogger_Params_Data::FlogService_CreateLogger_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
FlogService_GetLogDescriptions_Params_Data* FlogService_GetLogDescriptions_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogService_GetLogDescriptions_Params_Data))) FlogService_GetLogDescriptions_Params_Data();
}

// static
mojo::internal::ValidationError FlogService_GetLogDescriptions_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogService_GetLogDescriptions_Params_Data* object = static_cast<const FlogService_GetLogDescriptions_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogService_GetLogDescriptions_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void FlogService_GetLogDescriptions_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

FlogService_GetLogDescriptions_Params_Data::FlogService_GetLogDescriptions_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
FlogService_GetLogDescriptions_ResponseParams_Data* FlogService_GetLogDescriptions_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogService_GetLogDescriptions_ResponseParams_Data))) FlogService_GetLogDescriptions_ResponseParams_Data();
}

// static
mojo::internal::ValidationError FlogService_GetLogDescriptions_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogService_GetLogDescriptions_ResponseParams_Data* object = static_cast<const FlogService_GetLogDescriptions_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->descriptions.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null descriptions field in FlogService_GetLogDescriptions_ResponseParams struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->descriptions.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams descriptions_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<FlogDescriptionPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->descriptions.offset),
          bounds_checker, &descriptions_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogService_GetLogDescriptions_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->descriptions, handles);
}

void FlogService_GetLogDescriptions_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->descriptions, handles);
}

FlogService_GetLogDescriptions_ResponseParams_Data::FlogService_GetLogDescriptions_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
FlogService_CreateReader_Params_Data* FlogService_CreateReader_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogService_CreateReader_Params_Data))) FlogService_CreateReader_Params_Data();
}

// static
mojo::internal::ValidationError FlogService_CreateReader_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogService_CreateReader_Params_Data* object = static_cast<const FlogService_CreateReader_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle reader_handle = object->reader;
  if (reader_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid reader field in FlogService_CreateReader_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(reader_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogService_CreateReader_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->reader, handles);
}

void FlogService_CreateReader_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->reader, handles);
}

FlogService_CreateReader_Params_Data::FlogService_CreateReader_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
FlogLogger_LogChannelCreation_Params_Data* FlogLogger_LogChannelCreation_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogLogger_LogChannelCreation_Params_Data))) FlogLogger_LogChannelCreation_Params_Data();
}

// static
mojo::internal::ValidationError FlogLogger_LogChannelCreation_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogLogger_LogChannelCreation_Params_Data* object = static_cast<const FlogLogger_LogChannelCreation_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->type_name.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null type_name field in FlogLogger_LogChannelCreation_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->type_name.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams type_name_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->type_name.offset),
          bounds_checker, &type_name_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogLogger_LogChannelCreation_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->type_name, handles);
}

void FlogLogger_LogChannelCreation_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->type_name, handles);
}

FlogLogger_LogChannelCreation_Params_Data::FlogLogger_LogChannelCreation_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
FlogLogger_LogChannelMessage_Params_Data* FlogLogger_LogChannelMessage_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogLogger_LogChannelMessage_Params_Data))) FlogLogger_LogChannelMessage_Params_Data();
}

// static
mojo::internal::ValidationError FlogLogger_LogChannelMessage_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogLogger_LogChannelMessage_Params_Data* object = static_cast<const FlogLogger_LogChannelMessage_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->data.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null data field in FlogLogger_LogChannelMessage_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams data_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<uint8_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->data.offset),
          bounds_checker, &data_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogLogger_LogChannelMessage_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->data, handles);
}

void FlogLogger_LogChannelMessage_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->data, handles);
}

FlogLogger_LogChannelMessage_Params_Data::FlogLogger_LogChannelMessage_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
FlogLogger_LogChannelDeletion_Params_Data* FlogLogger_LogChannelDeletion_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogLogger_LogChannelDeletion_Params_Data))) FlogLogger_LogChannelDeletion_Params_Data();
}

// static
mojo::internal::ValidationError FlogLogger_LogChannelDeletion_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogLogger_LogChannelDeletion_Params_Data* object = static_cast<const FlogLogger_LogChannelDeletion_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogLogger_LogChannelDeletion_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void FlogLogger_LogChannelDeletion_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

FlogLogger_LogChannelDeletion_Params_Data::FlogLogger_LogChannelDeletion_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
FlogReader_GetEntries_Params_Data* FlogReader_GetEntries_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogReader_GetEntries_Params_Data))) FlogReader_GetEntries_Params_Data();
}

// static
mojo::internal::ValidationError FlogReader_GetEntries_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogReader_GetEntries_Params_Data* object = static_cast<const FlogReader_GetEntries_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogReader_GetEntries_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void FlogReader_GetEntries_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

FlogReader_GetEntries_Params_Data::FlogReader_GetEntries_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
FlogReader_GetEntries_ResponseParams_Data* FlogReader_GetEntries_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(FlogReader_GetEntries_ResponseParams_Data))) FlogReader_GetEntries_ResponseParams_Data();
}

// static
mojo::internal::ValidationError FlogReader_GetEntries_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const FlogReader_GetEntries_ResponseParams_Data* object = static_cast<const FlogReader_GetEntries_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->entries.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null entries field in FlogReader_GetEntries_ResponseParams struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->entries.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams entries_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<FlogEntryPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->entries.offset),
          bounds_checker, &entries_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void FlogReader_GetEntries_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->entries, handles);
}

void FlogReader_GetEntries_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->entries, handles);
}

FlogReader_GetEntries_ResponseParams_Data::FlogReader_GetEntries_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


}  // namespace internal

// --- Request and response validator definitions for interfaces ---
mojo::internal::ValidationError FlogServiceRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'FlogService', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::FlogService_Base::MessageOrdinals method_ordinal =
      static_cast<internal::FlogService_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::FlogService_Base::MessageOrdinals::CreateLogger: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'FlogService', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::FlogService_CreateLogger_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'FlogService', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::FlogService_Base::MessageOrdinals::GetLogDescriptions: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'FlogService', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::FlogService_GetLogDescriptions_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'FlogService', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::FlogService_Base::MessageOrdinals::CreateReader: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'FlogService', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::FlogService_CreateReader_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'FlogService', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'FlogService'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError FlogServiceResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'FlogService', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'FlogService', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::FlogService_Base::MessageOrdinals method_ordinal =
      static_cast<internal::FlogService_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::FlogService_Base::MessageOrdinals::GetLogDescriptions: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::FlogService_GetLogDescriptions_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'FlogService',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'FlogService'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError FlogLoggerRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'FlogLogger', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::FlogLogger_Base::MessageOrdinals method_ordinal =
      static_cast<internal::FlogLogger_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::FlogLogger_Base::MessageOrdinals::LogChannelCreation: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'FlogLogger', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::FlogLogger_LogChannelCreation_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'FlogLogger', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::FlogLogger_Base::MessageOrdinals::LogChannelMessage: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'FlogLogger', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::FlogLogger_LogChannelMessage_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'FlogLogger', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::FlogLogger_Base::MessageOrdinals::LogChannelDeletion: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'FlogLogger', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::FlogLogger_LogChannelDeletion_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'FlogLogger', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'FlogLogger'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError FlogReaderRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'FlogReader', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::FlogReader_Base::MessageOrdinals method_ordinal =
      static_cast<internal::FlogReader_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::FlogReader_Base::MessageOrdinals::GetEntries: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'FlogReader', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::FlogReader_GetEntries_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'FlogReader', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'FlogReader'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError FlogReaderResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'FlogReader', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'FlogReader', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::FlogReader_Base::MessageOrdinals method_ordinal =
      static_cast<internal::FlogReader_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::FlogReader_Base::MessageOrdinals::GetEntries: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::FlogReader_GetEntries_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'FlogReader',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'FlogReader'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
} 

// --- Enums ---

// Base interface definitions (Name_, Version_, Constants, Enums)
const char internal::FlogService_Base::Name_[] = "mojo::flog::FlogService";
const uint32_t internal::FlogService_Base::Version_;

// Constants

// Enums
const uint32_t internal::FlogLogger_Base::Version_;

// Constants

// Enums
const uint32_t internal::FlogReader_Base::Version_;

// Constants

// Enums

// Struct Constants

// --- Struct builder definitions ---

// static
FlogDescriptionPtr FlogDescription::New() {
  FlogDescriptionPtr rv;
  mojo::internal::StructHelper<FlogDescription>::Initialize(&rv);
  return rv;
}

FlogDescription::FlogDescription()
    : log_id(),
      label(),
      open() {
}

FlogDescription::~FlogDescription() {
}


FlogDescriptionPtr FlogDescription::Clone() const {
  FlogDescriptionPtr rv(New());
  rv->log_id = log_id;
  rv->label = label;
  rv->open = open;
  return rv;
}


bool FlogDescription::Equals(const FlogDescription& other) const {
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->log_id, other.log_id))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->label, other.label))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->open, other.open))
    return false;
  return true;
}


// static
FlogEntryPtr FlogEntry::New() {
  FlogEntryPtr rv;
  mojo::internal::StructHelper<FlogEntry>::Initialize(&rv);
  return rv;
}

FlogEntry::FlogEntry()
    : time_us(),
      log_id(),
      channel_id(),
      details() {
}

FlogEntry::~FlogEntry() {
}


FlogEntryPtr FlogEntry::Clone() const {
  FlogEntryPtr rv(New());
  rv->time_us = time_us;
  rv->log_id = log_id;
  rv->channel_id = channel_id;
  rv->details = details.Clone();
  return rv;
}


bool FlogEntry::Equals(const FlogEntry& other) const {
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->time_us, other.time_us))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->log_id, other.log_id))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->channel_id, other.channel_id))
    return false;
  if (!mojo::internal::ValueTraits<FlogEntryDetailsPtr>::Equals(this->details, other.details))
    return false;
  return true;
}


// static
FlogChannelCreationEntryDetailsPtr FlogChannelCreationEntryDetails::New() {
  FlogChannelCreationEntryDetailsPtr rv;
  mojo::internal::StructHelper<FlogChannelCreationEntryDetails>::Initialize(&rv);
  return rv;
}

FlogChannelCreationEntryDetails::FlogChannelCreationEntryDetails()
    : type_name() {
}

FlogChannelCreationEntryDetails::~FlogChannelCreationEntryDetails() {
}


FlogChannelCreationEntryDetailsPtr FlogChannelCreationEntryDetails::Clone() const {
  FlogChannelCreationEntryDetailsPtr rv(New());
  rv->type_name = type_name;
  return rv;
}


bool FlogChannelCreationEntryDetails::Equals(const FlogChannelCreationEntryDetails& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->type_name, other.type_name))
    return false;
  return true;
}


// static
FlogChannelMessageEntryDetailsPtr FlogChannelMessageEntryDetails::New() {
  FlogChannelMessageEntryDetailsPtr rv;
  mojo::internal::StructHelper<FlogChannelMessageEntryDetails>::Initialize(&rv);
  return rv;
}

FlogChannelMessageEntryDetails::FlogChannelMessageEntryDetails()
    : data() {
}

FlogChannelMessageEntryDetails::~FlogChannelMessageEntryDetails() {
}


FlogChannelMessageEntryDetailsPtr FlogChannelMessageEntryDetails::Clone() const {
  FlogChannelMessageEntryDetailsPtr rv(New());
  rv->data = data.Clone();
  return rv;
}


bool FlogChannelMessageEntryDetails::Equals(const FlogChannelMessageEntryDetails& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<uint8_t>>::Equals(this->data, other.data))
    return false;
  return true;
}


// static
FlogChannelDeletionEntryDetailsPtr FlogChannelDeletionEntryDetails::New() {
  FlogChannelDeletionEntryDetailsPtr rv;
  mojo::internal::StructHelper<FlogChannelDeletionEntryDetails>::Initialize(&rv);
  return rv;
}

FlogChannelDeletionEntryDetails::FlogChannelDeletionEntryDetails() {
}

FlogChannelDeletionEntryDetails::~FlogChannelDeletionEntryDetails() {
}


FlogChannelDeletionEntryDetailsPtr FlogChannelDeletionEntryDetails::Clone() const {
  FlogChannelDeletionEntryDetailsPtr rv(New());
  return rv;
}


bool FlogChannelDeletionEntryDetails::Equals(const FlogChannelDeletionEntryDetails& other) const {
  return true;
}


// --- Union builder definitions ---// static
FlogEntryDetailsPtr FlogEntryDetails::New() {
  FlogEntryDetailsPtr rv;
  mojo::internal::StructHelper<FlogEntryDetails>::Initialize(&rv);
  return rv;
}

FlogEntryDetails::FlogEntryDetails() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

FlogEntryDetails::~FlogEntryDetails() {
  DestroyActive();
}


FlogEntryDetailsPtr FlogEntryDetails::Clone() const {
  FlogEntryDetailsPtr rv(New());
  switch (tag_) {

    case Tag::CHANNEL_CREATION:

      rv->set_channel_creation(data_.channel_creation->Clone());
      break;
    case Tag::CHANNEL_MESSAGE:

      rv->set_channel_message(data_.channel_message->Clone());
      break;
    case Tag::CHANNEL_DELETION:

      rv->set_channel_deletion(data_.channel_deletion->Clone());
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool FlogEntryDetails::Equals(const FlogEntryDetails& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::CHANNEL_CREATION:

      return mojo::internal::ValueTraits<FlogChannelCreationEntryDetailsPtr>::Equals(*(data_.channel_creation), *(other.data_.channel_creation));
    case Tag::CHANNEL_MESSAGE:

      return mojo::internal::ValueTraits<FlogChannelMessageEntryDetailsPtr>::Equals(*(data_.channel_message), *(other.data_.channel_message));
    case Tag::CHANNEL_DELETION:

      return mojo::internal::ValueTraits<FlogChannelDeletionEntryDetailsPtr>::Equals(*(data_.channel_deletion), *(other.data_.channel_deletion));
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool FlogEntryDetails::is_channel_creation() const {
  return tag_ == Tag::CHANNEL_CREATION;
}

FlogChannelCreationEntryDetailsPtr& FlogEntryDetails::get_channel_creation() const {
  MOJO_DCHECK(tag_ == Tag::CHANNEL_CREATION);

  return *(data_.channel_creation);
}

void FlogEntryDetails::set_channel_creation(FlogChannelCreationEntryDetailsPtr channel_creation) {
  SwitchActive(Tag::CHANNEL_CREATION);

  *(data_.channel_creation) = channel_creation.Pass();

}
bool FlogEntryDetails::is_channel_message() const {
  return tag_ == Tag::CHANNEL_MESSAGE;
}

FlogChannelMessageEntryDetailsPtr& FlogEntryDetails::get_channel_message() const {
  MOJO_DCHECK(tag_ == Tag::CHANNEL_MESSAGE);

  return *(data_.channel_message);
}

void FlogEntryDetails::set_channel_message(FlogChannelMessageEntryDetailsPtr channel_message) {
  SwitchActive(Tag::CHANNEL_MESSAGE);

  *(data_.channel_message) = channel_message.Pass();

}
bool FlogEntryDetails::is_channel_deletion() const {
  return tag_ == Tag::CHANNEL_DELETION;
}

FlogChannelDeletionEntryDetailsPtr& FlogEntryDetails::get_channel_deletion() const {
  MOJO_DCHECK(tag_ == Tag::CHANNEL_DELETION);

  return *(data_.channel_deletion);
}

void FlogEntryDetails::set_channel_deletion(FlogChannelDeletionEntryDetailsPtr channel_deletion) {
  SwitchActive(Tag::CHANNEL_DELETION);

  *(data_.channel_deletion) = channel_deletion.Pass();

}

bool FlogEntryDetails::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void FlogEntryDetails::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void FlogEntryDetails::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::CHANNEL_CREATION:

      data_.channel_creation = new FlogChannelCreationEntryDetailsPtr();
      break;
    case Tag::CHANNEL_MESSAGE:

      data_.channel_message = new FlogChannelMessageEntryDetailsPtr();
      break;
    case Tag::CHANNEL_DELETION:

      data_.channel_deletion = new FlogChannelDeletionEntryDetailsPtr();
      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void FlogEntryDetails::DestroyActive() {
  switch (tag_) {

    case Tag::CHANNEL_CREATION:

      delete data_.channel_creation;
      break;
    case Tag::CHANNEL_MESSAGE:

      delete data_.channel_message;
      break;
    case Tag::CHANNEL_DELETION:

      delete data_.channel_deletion;
      break;
    default:
      break;
  }
}


// --- Struct Serialization Helpers ---

size_t FlogDescription::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogDescription::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogDescription_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogDescription::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogDescription_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogDescription::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogDescription_Data* input =
      static_cast<internal::FlogDescription_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogDescription& input) {
  size_t size = sizeof(internal::FlogDescription_Data);
  size += GetSerializedSize_(input.label);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogDescription* input,
    mojo::internal::Buffer* buf,
    internal::FlogDescription_Data** output) {
  if (input) {
    internal::FlogDescription_Data* result =
        internal::FlogDescription_Data::New(buf);
    result->log_id = input->log_id;
    SerializeString_(input->label, buf, &result->label.ptr);
    if (!result->label.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null label in FlogDescription struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->open = input->open;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogDescription_Data* input,
                  FlogDescription* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->log_id = input->log_id;
      Deserialize_(input->label.ptr, &result->label);
      result->open = input->open;
    } while (false);
  }
}


size_t FlogEntry::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogEntry::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogEntry_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogEntry::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogEntry_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogEntry::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogEntry_Data* input =
      static_cast<internal::FlogEntry_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogEntry& input) {
  size_t size = sizeof(internal::FlogEntry_Data);
  size += GetSerializedSize_(input.details);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogEntry* input,
    mojo::internal::Buffer* buf,
    internal::FlogEntry_Data** output) {
  if (input) {
    internal::FlogEntry_Data* result =
        internal::FlogEntry_Data::New(buf);
    result->time_us = input->time_us;
    result->log_id = input->log_id;
    result->channel_id = input->channel_id;
    internal::FlogEntryDetails_Data* details_ptr = &result->details;
    {
      auto retval =
        SerializeUnion_(input->details.get(),
                        buf,
                        &details_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogEntry_Data* input,
                  FlogEntry* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->time_us = input->time_us;
      result->log_id = input->log_id;
      result->channel_id = input->channel_id;
      if (!input->details.is_null()) {
        result->details = FlogEntryDetails::New();
        Deserialize_(&input->details, result->details.get());
      }
    } while (false);
  }
}


size_t FlogChannelCreationEntryDetails::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogChannelCreationEntryDetails::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogChannelCreationEntryDetails_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogChannelCreationEntryDetails::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogChannelCreationEntryDetails_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogChannelCreationEntryDetails::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogChannelCreationEntryDetails_Data* input =
      static_cast<internal::FlogChannelCreationEntryDetails_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogChannelCreationEntryDetails& input) {
  size_t size = sizeof(internal::FlogChannelCreationEntryDetails_Data);
  size += GetSerializedSize_(input.type_name);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogChannelCreationEntryDetails* input,
    mojo::internal::Buffer* buf,
    internal::FlogChannelCreationEntryDetails_Data** output) {
  if (input) {
    internal::FlogChannelCreationEntryDetails_Data* result =
        internal::FlogChannelCreationEntryDetails_Data::New(buf);
    SerializeString_(input->type_name, buf, &result->type_name.ptr);
    if (!result->type_name.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null type_name in FlogChannelCreationEntryDetails struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogChannelCreationEntryDetails_Data* input,
                  FlogChannelCreationEntryDetails* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->type_name.ptr, &result->type_name);
    } while (false);
  }
}


size_t FlogChannelMessageEntryDetails::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogChannelMessageEntryDetails::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogChannelMessageEntryDetails_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogChannelMessageEntryDetails::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogChannelMessageEntryDetails_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogChannelMessageEntryDetails::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogChannelMessageEntryDetails_Data* input =
      static_cast<internal::FlogChannelMessageEntryDetails_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogChannelMessageEntryDetails& input) {
  size_t size = sizeof(internal::FlogChannelMessageEntryDetails_Data);
  size += GetSerializedSize_(input.data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogChannelMessageEntryDetails* input,
    mojo::internal::Buffer* buf,
    internal::FlogChannelMessageEntryDetails_Data** output) {
  if (input) {
    internal::FlogChannelMessageEntryDetails_Data* result =
        internal::FlogChannelMessageEntryDetails_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams data_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->data, buf, &result->data.ptr,
                            &data_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->data.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null data in FlogChannelMessageEntryDetails struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogChannelMessageEntryDetails_Data* input,
                  FlogChannelMessageEntryDetails* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->data.ptr, &result->data);
    } while (false);
  }
}


size_t FlogChannelDeletionEntryDetails::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogChannelDeletionEntryDetails::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogChannelDeletionEntryDetails_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogChannelDeletionEntryDetails::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogChannelDeletionEntryDetails_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogChannelDeletionEntryDetails::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogChannelDeletionEntryDetails_Data* input =
      static_cast<internal::FlogChannelDeletionEntryDetails_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogChannelDeletionEntryDetails& input) {
  size_t size = sizeof(internal::FlogChannelDeletionEntryDetails_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogChannelDeletionEntryDetails* input,
    mojo::internal::Buffer* buf,
    internal::FlogChannelDeletionEntryDetails_Data** output) {
  if (input) {
    internal::FlogChannelDeletionEntryDetails_Data* result =
        internal::FlogChannelDeletionEntryDetails_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogChannelDeletionEntryDetails_Data* input,
                  FlogChannelDeletionEntryDetails* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


// --- Union Serialization Helpers ---

size_t GetSerializedSize_(const FlogEntryDetailsPtr& input) {
   size_t size = sizeof(internal::FlogEntryDetails_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<FlogEntryDetails> input_acc(input.get());
  switch (input->which()) {


    case FlogEntryDetails::Tag::CHANNEL_CREATION:

      size += GetSerializedSize_(*(input_acc.data()->channel_creation->get()));

      break;

    case FlogEntryDetails::Tag::CHANNEL_MESSAGE:

      size += GetSerializedSize_(*(input_acc.data()->channel_message->get()));

      break;

    case FlogEntryDetails::Tag::CHANNEL_DELETION:

      size += GetSerializedSize_(*(input_acc.data()->channel_deletion->get()));

      break;
    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    FlogEntryDetails* input,
    mojo::internal::Buffer* buf,
    internal::FlogEntryDetails_Data** output) {
  internal::FlogEntryDetails_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<FlogEntryDetails> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case FlogEntryDetails::Tag::CHANNEL_CREATION: {


          {auto retval =Serialize_(input_acc.data()->channel_creation->get(),
                     buf,
                     &result->data.f_channel_creation.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case FlogEntryDetails::Tag::CHANNEL_MESSAGE: {


          {auto retval =Serialize_(input_acc.data()->channel_message->get(),
                     buf,
                     &result->data.f_channel_message.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case FlogEntryDetails::Tag::CHANNEL_DELETION: {


          {auto retval =Serialize_(input_acc.data()->channel_deletion->get(),
                     buf,
                     &result->data.f_channel_deletion.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogEntryDetails_Data* input,
                  FlogEntryDetails* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<FlogEntryDetails> result_acc(output);
    switch (input->tag) {

      case FlogEntryDetails::Tag::CHANNEL_CREATION: {

        result_acc.SwitchActive(FlogEntryDetails::Tag::CHANNEL_CREATION);

        *result_acc.data()->channel_creation =
            FlogChannelCreationEntryDetails::New();
        Deserialize_(input->data.f_channel_creation.ptr,
            result_acc.data()->channel_creation->get());


        break;
      }
      case FlogEntryDetails::Tag::CHANNEL_MESSAGE: {

        result_acc.SwitchActive(FlogEntryDetails::Tag::CHANNEL_MESSAGE);

        *result_acc.data()->channel_message =
            FlogChannelMessageEntryDetails::New();
        Deserialize_(input->data.f_channel_message.ptr,
            result_acc.data()->channel_message->get());


        break;
      }
      case FlogEntryDetails::Tag::CHANNEL_DELETION: {

        result_acc.SwitchActive(FlogEntryDetails::Tag::CHANNEL_DELETION);

        *result_acc.data()->channel_deletion =
            FlogChannelDeletionEntryDetails::New();
        Deserialize_(input->data.f_channel_deletion.ptr,
            result_acc.data()->channel_deletion->get());


        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing FlogEntryDetails with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


// --- Structs for interface method parameters ---


// static
FlogService_CreateLogger_ParamsPtr FlogService_CreateLogger_Params::New() {
  FlogService_CreateLogger_ParamsPtr rv;
  mojo::internal::StructHelper<FlogService_CreateLogger_Params>::Initialize(&rv);
  return rv;
}

FlogService_CreateLogger_Params::FlogService_CreateLogger_Params()
    : logger(),
      label() {
}

FlogService_CreateLogger_Params::~FlogService_CreateLogger_Params() {
}



bool FlogService_CreateLogger_Params::Equals(const FlogService_CreateLogger_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::InterfaceRequest<FlogLogger>>::Equals(this->logger, other.logger))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->label, other.label))
    return false;
  return true;
}


size_t FlogService_CreateLogger_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogService_CreateLogger_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogService_CreateLogger_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogService_CreateLogger_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogService_CreateLogger_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogService_CreateLogger_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogService_CreateLogger_Params_Data* input =
      static_cast<internal::FlogService_CreateLogger_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogService_CreateLogger_Params& input) {
  size_t size = sizeof(internal::FlogService_CreateLogger_Params_Data);
  size += GetSerializedSize_(input.label);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogService_CreateLogger_Params* input,
    mojo::internal::Buffer* buf,
    internal::FlogService_CreateLogger_Params_Data** output) {
  if (input) {
    internal::FlogService_CreateLogger_Params_Data* result =
        internal::FlogService_CreateLogger_Params_Data::New(buf);
    result->logger = input->logger.PassMessagePipe().release();
    if (!result->logger.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid logger in FlogService_CreateLogger_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    SerializeString_(input->label, buf, &result->label.ptr);
    if (!result->label.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null label in FlogService_CreateLogger_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogService_CreateLogger_Params_Data* input,
                  FlogService_CreateLogger_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->logger.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&input->logger)));
      Deserialize_(input->label.ptr, &result->label);
    } while (false);
  }
}



// static
FlogService_GetLogDescriptions_ParamsPtr FlogService_GetLogDescriptions_Params::New() {
  FlogService_GetLogDescriptions_ParamsPtr rv;
  mojo::internal::StructHelper<FlogService_GetLogDescriptions_Params>::Initialize(&rv);
  return rv;
}

FlogService_GetLogDescriptions_Params::FlogService_GetLogDescriptions_Params() {
}

FlogService_GetLogDescriptions_Params::~FlogService_GetLogDescriptions_Params() {
}


FlogService_GetLogDescriptions_ParamsPtr FlogService_GetLogDescriptions_Params::Clone() const {
  FlogService_GetLogDescriptions_ParamsPtr rv(New());
  return rv;
}


bool FlogService_GetLogDescriptions_Params::Equals(const FlogService_GetLogDescriptions_Params& other) const {
  return true;
}


size_t FlogService_GetLogDescriptions_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogService_GetLogDescriptions_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogService_GetLogDescriptions_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogService_GetLogDescriptions_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogService_GetLogDescriptions_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogService_GetLogDescriptions_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogService_GetLogDescriptions_Params_Data* input =
      static_cast<internal::FlogService_GetLogDescriptions_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogService_GetLogDescriptions_Params& input) {
  size_t size = sizeof(internal::FlogService_GetLogDescriptions_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogService_GetLogDescriptions_Params* input,
    mojo::internal::Buffer* buf,
    internal::FlogService_GetLogDescriptions_Params_Data** output) {
  if (input) {
    internal::FlogService_GetLogDescriptions_Params_Data* result =
        internal::FlogService_GetLogDescriptions_Params_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogService_GetLogDescriptions_Params_Data* input,
                  FlogService_GetLogDescriptions_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


// static
FlogService_GetLogDescriptions_ResponseParamsPtr FlogService_GetLogDescriptions_ResponseParams::New() {
  FlogService_GetLogDescriptions_ResponseParamsPtr rv;
  mojo::internal::StructHelper<FlogService_GetLogDescriptions_ResponseParams>::Initialize(&rv);
  return rv;
}

FlogService_GetLogDescriptions_ResponseParams::FlogService_GetLogDescriptions_ResponseParams()
    : descriptions() {
}

FlogService_GetLogDescriptions_ResponseParams::~FlogService_GetLogDescriptions_ResponseParams() {
}


FlogService_GetLogDescriptions_ResponseParamsPtr FlogService_GetLogDescriptions_ResponseParams::Clone() const {
  FlogService_GetLogDescriptions_ResponseParamsPtr rv(New());
  rv->descriptions = descriptions.Clone();
  return rv;
}


bool FlogService_GetLogDescriptions_ResponseParams::Equals(const FlogService_GetLogDescriptions_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<FlogDescriptionPtr>>::Equals(this->descriptions, other.descriptions))
    return false;
  return true;
}


size_t FlogService_GetLogDescriptions_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogService_GetLogDescriptions_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogService_GetLogDescriptions_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogService_GetLogDescriptions_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogService_GetLogDescriptions_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogService_GetLogDescriptions_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogService_GetLogDescriptions_ResponseParams_Data* input =
      static_cast<internal::FlogService_GetLogDescriptions_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogService_GetLogDescriptions_ResponseParams& input) {
  size_t size = sizeof(internal::FlogService_GetLogDescriptions_ResponseParams_Data);
  size += GetSerializedSize_(input.descriptions);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogService_GetLogDescriptions_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::FlogService_GetLogDescriptions_ResponseParams_Data** output) {
  if (input) {
    internal::FlogService_GetLogDescriptions_ResponseParams_Data* result =
        internal::FlogService_GetLogDescriptions_ResponseParams_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams descriptions_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->descriptions, buf, &result->descriptions.ptr,
                            &descriptions_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->descriptions.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null descriptions in FlogService_GetLogDescriptions_ResponseParams struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogService_GetLogDescriptions_ResponseParams_Data* input,
                  FlogService_GetLogDescriptions_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->descriptions.ptr, &result->descriptions);
    } while (false);
  }
}



// static
FlogService_CreateReader_ParamsPtr FlogService_CreateReader_Params::New() {
  FlogService_CreateReader_ParamsPtr rv;
  mojo::internal::StructHelper<FlogService_CreateReader_Params>::Initialize(&rv);
  return rv;
}

FlogService_CreateReader_Params::FlogService_CreateReader_Params()
    : reader(),
      log_id() {
}

FlogService_CreateReader_Params::~FlogService_CreateReader_Params() {
}



bool FlogService_CreateReader_Params::Equals(const FlogService_CreateReader_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::InterfaceRequest<FlogReader>>::Equals(this->reader, other.reader))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->log_id, other.log_id))
    return false;
  return true;
}


size_t FlogService_CreateReader_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogService_CreateReader_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogService_CreateReader_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogService_CreateReader_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogService_CreateReader_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogService_CreateReader_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogService_CreateReader_Params_Data* input =
      static_cast<internal::FlogService_CreateReader_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogService_CreateReader_Params& input) {
  size_t size = sizeof(internal::FlogService_CreateReader_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogService_CreateReader_Params* input,
    mojo::internal::Buffer* buf,
    internal::FlogService_CreateReader_Params_Data** output) {
  if (input) {
    internal::FlogService_CreateReader_Params_Data* result =
        internal::FlogService_CreateReader_Params_Data::New(buf);
    result->reader = input->reader.PassMessagePipe().release();
    if (!result->reader.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid reader in FlogService_CreateReader_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    result->log_id = input->log_id;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogService_CreateReader_Params_Data* input,
                  FlogService_CreateReader_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->reader.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&input->reader)));
      result->log_id = input->log_id;
    } while (false);
  }
}



// static
FlogLogger_LogChannelCreation_ParamsPtr FlogLogger_LogChannelCreation_Params::New() {
  FlogLogger_LogChannelCreation_ParamsPtr rv;
  mojo::internal::StructHelper<FlogLogger_LogChannelCreation_Params>::Initialize(&rv);
  return rv;
}

FlogLogger_LogChannelCreation_Params::FlogLogger_LogChannelCreation_Params()
    : time_us(),
      channel_id(),
      type_name() {
}

FlogLogger_LogChannelCreation_Params::~FlogLogger_LogChannelCreation_Params() {
}


FlogLogger_LogChannelCreation_ParamsPtr FlogLogger_LogChannelCreation_Params::Clone() const {
  FlogLogger_LogChannelCreation_ParamsPtr rv(New());
  rv->time_us = time_us;
  rv->channel_id = channel_id;
  rv->type_name = type_name;
  return rv;
}


bool FlogLogger_LogChannelCreation_Params::Equals(const FlogLogger_LogChannelCreation_Params& other) const {
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->time_us, other.time_us))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->channel_id, other.channel_id))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->type_name, other.type_name))
    return false;
  return true;
}


size_t FlogLogger_LogChannelCreation_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogLogger_LogChannelCreation_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogLogger_LogChannelCreation_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogLogger_LogChannelCreation_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogLogger_LogChannelCreation_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogLogger_LogChannelCreation_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogLogger_LogChannelCreation_Params_Data* input =
      static_cast<internal::FlogLogger_LogChannelCreation_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogLogger_LogChannelCreation_Params& input) {
  size_t size = sizeof(internal::FlogLogger_LogChannelCreation_Params_Data);
  size += GetSerializedSize_(input.type_name);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogLogger_LogChannelCreation_Params* input,
    mojo::internal::Buffer* buf,
    internal::FlogLogger_LogChannelCreation_Params_Data** output) {
  if (input) {
    internal::FlogLogger_LogChannelCreation_Params_Data* result =
        internal::FlogLogger_LogChannelCreation_Params_Data::New(buf);
    result->time_us = input->time_us;
    result->channel_id = input->channel_id;
    SerializeString_(input->type_name, buf, &result->type_name.ptr);
    if (!result->type_name.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null type_name in FlogLogger_LogChannelCreation_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogLogger_LogChannelCreation_Params_Data* input,
                  FlogLogger_LogChannelCreation_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->time_us = input->time_us;
      result->channel_id = input->channel_id;
      Deserialize_(input->type_name.ptr, &result->type_name);
    } while (false);
  }
}



// static
FlogLogger_LogChannelMessage_ParamsPtr FlogLogger_LogChannelMessage_Params::New() {
  FlogLogger_LogChannelMessage_ParamsPtr rv;
  mojo::internal::StructHelper<FlogLogger_LogChannelMessage_Params>::Initialize(&rv);
  return rv;
}

FlogLogger_LogChannelMessage_Params::FlogLogger_LogChannelMessage_Params()
    : time_us(),
      channel_id(),
      data() {
}

FlogLogger_LogChannelMessage_Params::~FlogLogger_LogChannelMessage_Params() {
}


FlogLogger_LogChannelMessage_ParamsPtr FlogLogger_LogChannelMessage_Params::Clone() const {
  FlogLogger_LogChannelMessage_ParamsPtr rv(New());
  rv->time_us = time_us;
  rv->channel_id = channel_id;
  rv->data = data.Clone();
  return rv;
}


bool FlogLogger_LogChannelMessage_Params::Equals(const FlogLogger_LogChannelMessage_Params& other) const {
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->time_us, other.time_us))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->channel_id, other.channel_id))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<uint8_t>>::Equals(this->data, other.data))
    return false;
  return true;
}


size_t FlogLogger_LogChannelMessage_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogLogger_LogChannelMessage_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogLogger_LogChannelMessage_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogLogger_LogChannelMessage_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogLogger_LogChannelMessage_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogLogger_LogChannelMessage_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogLogger_LogChannelMessage_Params_Data* input =
      static_cast<internal::FlogLogger_LogChannelMessage_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogLogger_LogChannelMessage_Params& input) {
  size_t size = sizeof(internal::FlogLogger_LogChannelMessage_Params_Data);
  size += GetSerializedSize_(input.data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogLogger_LogChannelMessage_Params* input,
    mojo::internal::Buffer* buf,
    internal::FlogLogger_LogChannelMessage_Params_Data** output) {
  if (input) {
    internal::FlogLogger_LogChannelMessage_Params_Data* result =
        internal::FlogLogger_LogChannelMessage_Params_Data::New(buf);
    result->time_us = input->time_us;
    result->channel_id = input->channel_id;
    {
      const mojo::internal::ArrayValidateParams data_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->data, buf, &result->data.ptr,
                            &data_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->data.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null data in FlogLogger_LogChannelMessage_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogLogger_LogChannelMessage_Params_Data* input,
                  FlogLogger_LogChannelMessage_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->time_us = input->time_us;
      result->channel_id = input->channel_id;
      Deserialize_(input->data.ptr, &result->data);
    } while (false);
  }
}



// static
FlogLogger_LogChannelDeletion_ParamsPtr FlogLogger_LogChannelDeletion_Params::New() {
  FlogLogger_LogChannelDeletion_ParamsPtr rv;
  mojo::internal::StructHelper<FlogLogger_LogChannelDeletion_Params>::Initialize(&rv);
  return rv;
}

FlogLogger_LogChannelDeletion_Params::FlogLogger_LogChannelDeletion_Params()
    : time_us(),
      channel_id() {
}

FlogLogger_LogChannelDeletion_Params::~FlogLogger_LogChannelDeletion_Params() {
}


FlogLogger_LogChannelDeletion_ParamsPtr FlogLogger_LogChannelDeletion_Params::Clone() const {
  FlogLogger_LogChannelDeletion_ParamsPtr rv(New());
  rv->time_us = time_us;
  rv->channel_id = channel_id;
  return rv;
}


bool FlogLogger_LogChannelDeletion_Params::Equals(const FlogLogger_LogChannelDeletion_Params& other) const {
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->time_us, other.time_us))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->channel_id, other.channel_id))
    return false;
  return true;
}


size_t FlogLogger_LogChannelDeletion_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogLogger_LogChannelDeletion_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogLogger_LogChannelDeletion_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogLogger_LogChannelDeletion_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogLogger_LogChannelDeletion_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogLogger_LogChannelDeletion_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogLogger_LogChannelDeletion_Params_Data* input =
      static_cast<internal::FlogLogger_LogChannelDeletion_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogLogger_LogChannelDeletion_Params& input) {
  size_t size = sizeof(internal::FlogLogger_LogChannelDeletion_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogLogger_LogChannelDeletion_Params* input,
    mojo::internal::Buffer* buf,
    internal::FlogLogger_LogChannelDeletion_Params_Data** output) {
  if (input) {
    internal::FlogLogger_LogChannelDeletion_Params_Data* result =
        internal::FlogLogger_LogChannelDeletion_Params_Data::New(buf);
    result->time_us = input->time_us;
    result->channel_id = input->channel_id;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogLogger_LogChannelDeletion_Params_Data* input,
                  FlogLogger_LogChannelDeletion_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->time_us = input->time_us;
      result->channel_id = input->channel_id;
    } while (false);
  }
}



// static
FlogReader_GetEntries_ParamsPtr FlogReader_GetEntries_Params::New() {
  FlogReader_GetEntries_ParamsPtr rv;
  mojo::internal::StructHelper<FlogReader_GetEntries_Params>::Initialize(&rv);
  return rv;
}

FlogReader_GetEntries_Params::FlogReader_GetEntries_Params()
    : start_index(),
      max_count() {
}

FlogReader_GetEntries_Params::~FlogReader_GetEntries_Params() {
}


FlogReader_GetEntries_ParamsPtr FlogReader_GetEntries_Params::Clone() const {
  FlogReader_GetEntries_ParamsPtr rv(New());
  rv->start_index = start_index;
  rv->max_count = max_count;
  return rv;
}


bool FlogReader_GetEntries_Params::Equals(const FlogReader_GetEntries_Params& other) const {
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->start_index, other.start_index))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->max_count, other.max_count))
    return false;
  return true;
}


size_t FlogReader_GetEntries_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogReader_GetEntries_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogReader_GetEntries_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogReader_GetEntries_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogReader_GetEntries_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogReader_GetEntries_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogReader_GetEntries_Params_Data* input =
      static_cast<internal::FlogReader_GetEntries_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogReader_GetEntries_Params& input) {
  size_t size = sizeof(internal::FlogReader_GetEntries_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogReader_GetEntries_Params* input,
    mojo::internal::Buffer* buf,
    internal::FlogReader_GetEntries_Params_Data** output) {
  if (input) {
    internal::FlogReader_GetEntries_Params_Data* result =
        internal::FlogReader_GetEntries_Params_Data::New(buf);
    result->start_index = input->start_index;
    result->max_count = input->max_count;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogReader_GetEntries_Params_Data* input,
                  FlogReader_GetEntries_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->start_index = input->start_index;
      result->max_count = input->max_count;
    } while (false);
  }
}


// static
FlogReader_GetEntries_ResponseParamsPtr FlogReader_GetEntries_ResponseParams::New() {
  FlogReader_GetEntries_ResponseParamsPtr rv;
  mojo::internal::StructHelper<FlogReader_GetEntries_ResponseParams>::Initialize(&rv);
  return rv;
}

FlogReader_GetEntries_ResponseParams::FlogReader_GetEntries_ResponseParams()
    : entries() {
}

FlogReader_GetEntries_ResponseParams::~FlogReader_GetEntries_ResponseParams() {
}


FlogReader_GetEntries_ResponseParamsPtr FlogReader_GetEntries_ResponseParams::Clone() const {
  FlogReader_GetEntries_ResponseParamsPtr rv(New());
  rv->entries = entries.Clone();
  return rv;
}


bool FlogReader_GetEntries_ResponseParams::Equals(const FlogReader_GetEntries_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<FlogEntryPtr>>::Equals(this->entries, other.entries))
    return false;
  return true;
}


size_t FlogReader_GetEntries_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool FlogReader_GetEntries_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::FlogReader_GetEntries_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool FlogReader_GetEntries_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::FlogReader_GetEntries_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void FlogReader_GetEntries_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::FlogReader_GetEntries_ResponseParams_Data* input =
      static_cast<internal::FlogReader_GetEntries_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const FlogReader_GetEntries_ResponseParams& input) {
  size_t size = sizeof(internal::FlogReader_GetEntries_ResponseParams_Data);
  size += GetSerializedSize_(input.entries);
  return size;
}

mojo::internal::ValidationError Serialize_(
    FlogReader_GetEntries_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::FlogReader_GetEntries_ResponseParams_Data** output) {
  if (input) {
    internal::FlogReader_GetEntries_ResponseParams_Data* result =
        internal::FlogReader_GetEntries_ResponseParams_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams entries_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->entries, buf, &result->entries.ptr,
                            &entries_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->entries.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null entries in FlogReader_GetEntries_ResponseParams struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::FlogReader_GetEntries_ResponseParams_Data* input,
                  FlogReader_GetEntries_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->entries.ptr, &result->entries);
    } while (false);
  }
}

}  // namespace flog
}  // namespace mojo
