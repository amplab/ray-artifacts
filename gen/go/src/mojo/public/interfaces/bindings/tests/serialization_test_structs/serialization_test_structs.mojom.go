// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/public/interfaces/bindings/tests/serialization_test_structs.mojom
//

package serialization_test_structs

import (
	sort "sort"
	ioutil "io/ioutil"
	base64 "encoding/base64"
	fmt "fmt"
	bytes "bytes"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
	gzip "compress/gzip"
)

// This global variable contains a mojom_types.RuntimeTypeInfo struct
// describing the types defined in this file and all of its imports as
// well as the top-level interfaces defined in this file.
var runtimeTypeInfo__ = mojom_types.RuntimeTypeInfo{}

func getRuntimeTypeInfo() mojom_types.RuntimeTypeInfo {
  if runtimeTypeInfo__.TypeMap == nil {
    initRuntimeTypeInfo()
  }
  return runtimeTypeInfo__
}

func initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this file.
  // The string contains the base64 encoding of the gzip-compressed bytes.
  serializedRuntimeTypeInfo := "H4sIAAAJbogC/+yYzW7TQBDHbbdV3NKqQQIp5UMyLYceIEvzpYhTL5UqIQESHOgpOI5LtnLiyOtIpScegyNHHoEjj9Ejj9Eb7NazYr14I5PgrBGMNJqONUnH//l5d52akVgV4hOI8nUebSnKdUMziYfUK9S7cP0NxHOIHyF+gXgJ8QriLvU71F+fvDzqPTs6eToKz8J67JO4/iqOpl58kLOukbOumbOulbOunbOuk9Q9ov5wVt2L0+fTIHD7gU+4jhXQnUk+FObA8q9WOt9fS+eXlXT+eSOdn2+l82/bSe5Ic7dh3vvWz7mLxnniHHwHOzaybRvuiw95h/59k7pi/L/wZ8Pnz6j3qaNhOPLRxBuFEY4vUOS+f+yFkY9I5CH2nWgy7QfYQ3gc+9Gp6/kE9fF4gMfvCGL/jiDiR9gN8IUb43DcY9d65LoFUmdfMErrxJ+LQ+m+eX8VI5+pdDQEHa91V3x+HfrBCp3WoVfdOtWEnk2hPxVn3UI4ayg5ayj02ywxZ6tczCVwdoP6Clt/BkGmTlvAmg6dRFuUuw+FcNdUctecsQ+Xlbu1JXJXhV6SVnsHsk5M0w0NOjkZfYpzlPe3vOecRfn9VAi/LSW/LQW/t0rMr7VEfjdhnR64sZul023QVSe/7B74c20b/yLfbSXfbQXftf98p/ieuDjK0mkH1gKdfFvCvlV2vos593aUfHcUfN8rMd+mhnMvbTVTp/t/+bnXAR2vVmfrdSxx91ahF+cs88cManvU72ZwKFfKOjuaeHRg/ryfrmIfKut72QNN5+OqwN487xH2HDqZC7xH7IKWuvYp8w/vQ7+7blbn0NtaYN3cKwmXs9bNFWE+PwIAAP//FCzSZEAXAAA="

  // Deserialize RuntimeTypeInfo
  compressedBytes, err := base64.StdEncoding.DecodeString(serializedRuntimeTypeInfo)
  if err != nil {
    panic(fmt.Sprintf("Error while base64Decoding runtimeTypeInfo: %s", err.Error()))
  }
  reader, err := gzip.NewReader(bytes.NewBuffer(compressedBytes))
  if err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  uncompressedBytes, err := ioutil.ReadAll(reader)
  if err != nil {
     panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  if err = reader.Close(); err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  decoder := bindings.NewDecoder(uncompressedBytes, nil)
  runtimeTypeInfo__.Decode(decoder)

}
func GetAllMojomTypeDefinitions() map[string]mojom_types.UserDefinedType {
  return getRuntimeTypeInfo().TypeMap
}

type Struct1 struct {
	I uint8
}
// Struct1MojomType returns the UserDefinedType that describes the Mojom
// type of Struct1. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func Struct1MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.Struct1"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Struct1) MojomType() mojom_types.UserDefinedType {
	return Struct1MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Struct1) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *Struct1) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteUint8(s.I); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var struct1_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *Struct1) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(struct1_Versions), func(i int) bool {
		return struct1_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(struct1_Versions) {
		if struct1_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := struct1_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint8()
		if err != nil {
			return err
		}
		s.I = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type Struct2 struct {
	Hdl system.Handle
}
// Struct2MojomType returns the UserDefinedType that describes the Mojom
// type of Struct2. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func Struct2MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.Struct2"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Struct2) MojomType() mojom_types.UserDefinedType {
	return Struct2MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Struct2) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *Struct2) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteHandle(s.Hdl); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var struct2_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *Struct2) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(struct2_Versions), func(i int) bool {
		return struct2_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(struct2_Versions) {
		if struct2_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := struct2_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.Hdl = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type Struct3 struct {
	Struct1 Struct1
}
// Struct3MojomType returns the UserDefinedType that describes the Mojom
// type of Struct3. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func Struct3MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.Struct3"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Struct3) MojomType() mojom_types.UserDefinedType {
	return Struct3MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Struct3) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *Struct3) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.Struct1.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var struct3_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *Struct3) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(struct3_Versions), func(i int) bool {
		return struct3_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(struct3_Versions) {
		if struct3_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := struct3_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.Struct1.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type Struct4 struct {
	Data []Struct1
}
// Struct4MojomType returns the UserDefinedType that describes the Mojom
// type of Struct4. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func Struct4MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.Struct4"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Struct4) MojomType() mojom_types.UserDefinedType {
	return Struct4MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Struct4) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *Struct4) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.Data)), 64)
	for _, elem0 := range s.Data {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var struct4_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *Struct4) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(struct4_Versions), func(i int) bool {
		return struct4_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(struct4_Versions) {
		if struct4_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := struct4_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.Data = make([]Struct1, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := s.Data[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type Struct5 struct {
	Pair [2]Struct1
}
// Struct5MojomType returns the UserDefinedType that describes the Mojom
// type of Struct5. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func Struct5MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.Struct5"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Struct5) MojomType() mojom_types.UserDefinedType {
	return Struct5MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Struct5) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *Struct5) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.Pair)), 64)
	for _, elem0 := range s.Pair {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var struct5_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *Struct5) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(struct5_Versions), func(i int) bool {
		return struct5_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(struct5_Versions) {
		if struct5_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := struct5_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			if len0 != 2 {
				return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
					fmt.Sprintf("invalid array length: expected %d, got %d", 2, len0),
				}
			}
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := s.Pair[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type Struct6 struct {
	Str string
}
// Struct6MojomType returns the UserDefinedType that describes the Mojom
// type of Struct6. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func Struct6MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.Struct6"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Struct6) MojomType() mojom_types.UserDefinedType {
	return Struct6MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Struct6) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *Struct6) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.Str); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var struct6_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *Struct6) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(struct6_Versions), func(i int) bool {
		return struct6_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(struct6_Versions) {
		if struct6_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := struct6_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.Str = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructOfNullables struct {
	Hdl *system.Handle
	Struct1 *Struct1
	Str *string
}
// StructOfNullablesMojomType returns the UserDefinedType that describes the Mojom
// type of StructOfNullables. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructOfNullablesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructOfNullables"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructOfNullables) MojomType() mojom_types.UserDefinedType {
	return StructOfNullablesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructOfNullables) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructOfNullables) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if s.Hdl == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.Hdl)); err != nil {
			return err
		}
	}
	if s.Struct1 == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.Struct1).Encode(encoder); err != nil {
			return err
		}
	}
	if s.Str == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.Str)); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structOfNullables_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *StructOfNullables) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structOfNullables_Versions), func(i int) bool {
		return structOfNullables_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structOfNullables_Versions) {
		if structOfNullables_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structOfNullables_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.Hdl = &handle0
		} else {
			s.Hdl = nil
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Struct1 = nil
		} else {
			s.Struct1 = new(Struct1)
			if err := (*s.Struct1).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Str = nil
		} else {
			s.Str = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.Str) = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

