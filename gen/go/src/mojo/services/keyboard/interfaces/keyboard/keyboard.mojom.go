// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/services/keyboard/interfaces/keyboard.mojom
//

package keyboard

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	fmt "fmt"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
	native_viewport_event_dispatcher "mojo/services/native_viewport/interfaces/native_viewport_event_dispatcher"
)


type SubmitAction int32

const (
	SubmitAction_Done SubmitAction = 0
)


type KeyboardType int32

const (
	KeyboardType_Text KeyboardType = 0
	KeyboardType_Number = KeyboardType_Text + 1;
	KeyboardType_Phone = KeyboardType_Number + 1;
	KeyboardType_Datetime = KeyboardType_Phone + 1;
)


type KeyboardClient interface {
	CommitCompletion(inCompletion CompletionData) (err error)
	CommitCorrection(inCorrection CorrectionData) (err error)
	CommitText(inText string, inNewCursorPosition int32) (err error)
	DeleteSurroundingText(inBeforeLength int32, inAfterLength int32) (err error)
	SetComposingRegion(inStart int32, inEnd int32) (err error)
	SetComposingText(inText string, inNewCursorPosition int32) (err error)
	SetSelection(inStart int32, inEnd int32) (err error)
	Submit(inAction SubmitAction) (err error)
}




type KeyboardClient_Request bindings.InterfaceRequest



type KeyboardClient_Pointer bindings.InterfacePointer


type KeyboardClient_ServiceFactory struct{
	Delegate KeyboardClient_Factory
}

type KeyboardClient_Factory interface {
	Create(request KeyboardClient_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *KeyboardClient_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &KeyboardClient_ServiceDescription{}
}

func (f *KeyboardClient_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := KeyboardClient_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForKeyboardClient creates a message pipe for use with the
// KeyboardClient interface with a KeyboardClient_Request on one end and a KeyboardClient_Pointer on the other.
func CreateMessagePipeForKeyboardClient() (KeyboardClient_Request, KeyboardClient_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return KeyboardClient_Request(r), KeyboardClient_Pointer(p)
}

const keyboardClient_CommitCompletion_Name uint32 = 0
const keyboardClient_CommitCorrection_Name uint32 = 1
const keyboardClient_CommitText_Name uint32 = 2
const keyboardClient_DeleteSurroundingText_Name uint32 = 3
const keyboardClient_SetComposingRegion_Name uint32 = 4
const keyboardClient_SetComposingText_Name uint32 = 5
const keyboardClient_SetSelection_Name uint32 = 6
const keyboardClient_Submit_Name uint32 = 7

type KeyboardClient_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewKeyboardClientProxy(p KeyboardClient_Pointer, waiter bindings.AsyncWaiter) *KeyboardClient_Proxy {
	return &KeyboardClient_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *KeyboardClient_Proxy) Close_Proxy() {
	p.router.Close()
}

type keyboardClient_CommitCompletion_Params struct {
	inCompletion CompletionData
}


func (s *keyboardClient_CommitCompletion_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inCompletion.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardClient_CommitCompletion_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *keyboardClient_CommitCompletion_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardClient_CommitCompletion_Params_Versions), func(i int) bool {
		return keyboardClient_CommitCompletion_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardClient_CommitCompletion_Params_Versions) {
		if keyboardClient_CommitCompletion_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardClient_CommitCompletion_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inCompletion.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardClient_Proxy) CommitCompletion(inCompletion CompletionData) (err error) {
	payload := &keyboardClient_CommitCompletion_Params{
		inCompletion,
	}
	header := bindings.MessageHeader{
		Type: keyboardClient_CommitCompletion_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardClient_CommitCorrection_Params struct {
	inCorrection CorrectionData
}


func (s *keyboardClient_CommitCorrection_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inCorrection.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardClient_CommitCorrection_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *keyboardClient_CommitCorrection_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardClient_CommitCorrection_Params_Versions), func(i int) bool {
		return keyboardClient_CommitCorrection_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardClient_CommitCorrection_Params_Versions) {
		if keyboardClient_CommitCorrection_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardClient_CommitCorrection_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inCorrection.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardClient_Proxy) CommitCorrection(inCorrection CorrectionData) (err error) {
	payload := &keyboardClient_CommitCorrection_Params{
		inCorrection,
	}
	header := bindings.MessageHeader{
		Type: keyboardClient_CommitCorrection_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardClient_CommitText_Params struct {
	inText string
	inNewCursorPosition int32
}


func (s *keyboardClient_CommitText_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inText); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.inNewCursorPosition); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardClient_CommitText_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *keyboardClient_CommitText_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardClient_CommitText_Params_Versions), func(i int) bool {
		return keyboardClient_CommitText_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardClient_CommitText_Params_Versions) {
		if keyboardClient_CommitText_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardClient_CommitText_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inText = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inNewCursorPosition = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardClient_Proxy) CommitText(inText string, inNewCursorPosition int32) (err error) {
	payload := &keyboardClient_CommitText_Params{
		inText,
		inNewCursorPosition,
	}
	header := bindings.MessageHeader{
		Type: keyboardClient_CommitText_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardClient_DeleteSurroundingText_Params struct {
	inBeforeLength int32
	inAfterLength int32
}


func (s *keyboardClient_DeleteSurroundingText_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.inBeforeLength); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.inAfterLength); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardClient_DeleteSurroundingText_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *keyboardClient_DeleteSurroundingText_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardClient_DeleteSurroundingText_Params_Versions), func(i int) bool {
		return keyboardClient_DeleteSurroundingText_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardClient_DeleteSurroundingText_Params_Versions) {
		if keyboardClient_DeleteSurroundingText_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardClient_DeleteSurroundingText_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inBeforeLength = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inAfterLength = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardClient_Proxy) DeleteSurroundingText(inBeforeLength int32, inAfterLength int32) (err error) {
	payload := &keyboardClient_DeleteSurroundingText_Params{
		inBeforeLength,
		inAfterLength,
	}
	header := bindings.MessageHeader{
		Type: keyboardClient_DeleteSurroundingText_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardClient_SetComposingRegion_Params struct {
	inStart int32
	inEnd int32
}


func (s *keyboardClient_SetComposingRegion_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.inStart); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.inEnd); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardClient_SetComposingRegion_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *keyboardClient_SetComposingRegion_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardClient_SetComposingRegion_Params_Versions), func(i int) bool {
		return keyboardClient_SetComposingRegion_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardClient_SetComposingRegion_Params_Versions) {
		if keyboardClient_SetComposingRegion_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardClient_SetComposingRegion_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inStart = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inEnd = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardClient_Proxy) SetComposingRegion(inStart int32, inEnd int32) (err error) {
	payload := &keyboardClient_SetComposingRegion_Params{
		inStart,
		inEnd,
	}
	header := bindings.MessageHeader{
		Type: keyboardClient_SetComposingRegion_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardClient_SetComposingText_Params struct {
	inText string
	inNewCursorPosition int32
}


func (s *keyboardClient_SetComposingText_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inText); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.inNewCursorPosition); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardClient_SetComposingText_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *keyboardClient_SetComposingText_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardClient_SetComposingText_Params_Versions), func(i int) bool {
		return keyboardClient_SetComposingText_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardClient_SetComposingText_Params_Versions) {
		if keyboardClient_SetComposingText_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardClient_SetComposingText_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inText = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inNewCursorPosition = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardClient_Proxy) SetComposingText(inText string, inNewCursorPosition int32) (err error) {
	payload := &keyboardClient_SetComposingText_Params{
		inText,
		inNewCursorPosition,
	}
	header := bindings.MessageHeader{
		Type: keyboardClient_SetComposingText_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardClient_SetSelection_Params struct {
	inStart int32
	inEnd int32
}


func (s *keyboardClient_SetSelection_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.inStart); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.inEnd); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardClient_SetSelection_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *keyboardClient_SetSelection_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardClient_SetSelection_Params_Versions), func(i int) bool {
		return keyboardClient_SetSelection_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardClient_SetSelection_Params_Versions) {
		if keyboardClient_SetSelection_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardClient_SetSelection_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inStart = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inEnd = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardClient_Proxy) SetSelection(inStart int32, inEnd int32) (err error) {
	payload := &keyboardClient_SetSelection_Params{
		inStart,
		inEnd,
	}
	header := bindings.MessageHeader{
		Type: keyboardClient_SetSelection_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardClient_Submit_Params struct {
	inAction SubmitAction
}


func (s *keyboardClient_Submit_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.inAction)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardClient_Submit_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *keyboardClient_Submit_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardClient_Submit_Params_Versions), func(i int) bool {
		return keyboardClient_Submit_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardClient_Submit_Params_Versions) {
		if keyboardClient_Submit_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardClient_Submit_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inAction = SubmitAction(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardClient_Proxy) Submit(inAction SubmitAction) (err error) {
	payload := &keyboardClient_Submit_Params{
		inAction,
	}
	header := bindings.MessageHeader{
		Type: keyboardClient_Submit_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardClient_Stub struct {
	connector *bindings.Connector
	impl KeyboardClient
}

func NewKeyboardClientStub(r KeyboardClient_Request, impl KeyboardClient, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &keyboardClient_Stub{connector, impl})
}


func (f *KeyboardClient_Request) ServiceDescription() service_describer.ServiceDescription {
	return &KeyboardClient_ServiceDescription{}
}


type KeyboardClient_ServiceDescription struct{}

func (sd *KeyboardClient_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *KeyboardClient_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *KeyboardClient_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*KeyboardClient_ServiceDescription)(nil)


func (s *keyboardClient_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case keyboardClient_CommitCompletion_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardClient_CommitCompletion_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.CommitCompletion(request.inCompletion)
		if err != nil {
			return
		}
	case keyboardClient_CommitCorrection_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardClient_CommitCorrection_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.CommitCorrection(request.inCorrection)
		if err != nil {
			return
		}
	case keyboardClient_CommitText_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardClient_CommitText_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.CommitText(request.inText, request.inNewCursorPosition)
		if err != nil {
			return
		}
	case keyboardClient_DeleteSurroundingText_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardClient_DeleteSurroundingText_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.DeleteSurroundingText(request.inBeforeLength, request.inAfterLength)
		if err != nil {
			return
		}
	case keyboardClient_SetComposingRegion_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardClient_SetComposingRegion_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SetComposingRegion(request.inStart, request.inEnd)
		if err != nil {
			return
		}
	case keyboardClient_SetComposingText_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardClient_SetComposingText_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SetComposingText(request.inText, request.inNewCursorPosition)
		if err != nil {
			return
		}
	case keyboardClient_SetSelection_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardClient_SetSelection_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SetSelection(request.inStart, request.inEnd)
		if err != nil {
			return
		}
	case keyboardClient_Submit_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardClient_Submit_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Submit(request.inAction)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type KeyboardService interface {
	Show(inClient KeyboardClient_Pointer, inType KeyboardType) (err error)
	ShowByRequest() (err error)
	Hide() (err error)
	SetText(inText string) (err error)
	SetSelection(inStart int32, inEnd int32) (err error)
}



var keyboardService_Name = "keyboard::KeyboardService"

type KeyboardService_Request bindings.InterfaceRequest

func (r *KeyboardService_Request) Name() string {
	return keyboardService_Name
}


type KeyboardService_Pointer bindings.InterfacePointer

func (p *KeyboardService_Pointer) Name() string {
	return keyboardService_Name
}

type KeyboardService_ServiceFactory struct{
	Delegate KeyboardService_Factory
}

type KeyboardService_Factory interface {
	Create(request KeyboardService_Request)
}

func (f *KeyboardService_ServiceFactory) Name() string {
	return keyboardService_Name
}

// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *KeyboardService_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &KeyboardService_ServiceDescription{}
}

func (f *KeyboardService_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := KeyboardService_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForKeyboardService creates a message pipe for use with the
// KeyboardService interface with a KeyboardService_Request on one end and a KeyboardService_Pointer on the other.
func CreateMessagePipeForKeyboardService() (KeyboardService_Request, KeyboardService_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return KeyboardService_Request(r), KeyboardService_Pointer(p)
}

const keyboardService_Show_Name uint32 = 0
const keyboardService_ShowByRequest_Name uint32 = 1
const keyboardService_Hide_Name uint32 = 2
const keyboardService_SetText_Name uint32 = 3
const keyboardService_SetSelection_Name uint32 = 4

type KeyboardService_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewKeyboardServiceProxy(p KeyboardService_Pointer, waiter bindings.AsyncWaiter) *KeyboardService_Proxy {
	return &KeyboardService_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *KeyboardService_Proxy) Close_Proxy() {
	p.router.Close()
}

type keyboardService_Show_Params struct {
	inClient KeyboardClient_Pointer
	inType KeyboardType
}


func (s *keyboardService_Show_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInterface(s.inClient.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.inType)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardService_Show_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *keyboardService_Show_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardService_Show_Params_Versions), func(i int) bool {
		return keyboardService_Show_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardService_Show_Params_Versions) {
		if keyboardService_Show_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardService_Show_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadInterface()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inClient = KeyboardClient_Pointer{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inType = KeyboardType(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardService_Proxy) Show(inClient KeyboardClient_Pointer, inType KeyboardType) (err error) {
	payload := &keyboardService_Show_Params{
		inClient,
		inType,
	}
	header := bindings.MessageHeader{
		Type: keyboardService_Show_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardService_ShowByRequest_Params struct {
}


func (s *keyboardService_ShowByRequest_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardService_ShowByRequest_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *keyboardService_ShowByRequest_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardService_ShowByRequest_Params_Versions), func(i int) bool {
		return keyboardService_ShowByRequest_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardService_ShowByRequest_Params_Versions) {
		if keyboardService_ShowByRequest_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardService_ShowByRequest_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardService_Proxy) ShowByRequest() (err error) {
	payload := &keyboardService_ShowByRequest_Params{
	}
	header := bindings.MessageHeader{
		Type: keyboardService_ShowByRequest_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardService_Hide_Params struct {
}


func (s *keyboardService_Hide_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardService_Hide_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *keyboardService_Hide_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardService_Hide_Params_Versions), func(i int) bool {
		return keyboardService_Hide_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardService_Hide_Params_Versions) {
		if keyboardService_Hide_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardService_Hide_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardService_Proxy) Hide() (err error) {
	payload := &keyboardService_Hide_Params{
	}
	header := bindings.MessageHeader{
		Type: keyboardService_Hide_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardService_SetText_Params struct {
	inText string
}


func (s *keyboardService_SetText_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inText); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardService_SetText_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *keyboardService_SetText_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardService_SetText_Params_Versions), func(i int) bool {
		return keyboardService_SetText_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardService_SetText_Params_Versions) {
		if keyboardService_SetText_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardService_SetText_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inText = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardService_Proxy) SetText(inText string) (err error) {
	payload := &keyboardService_SetText_Params{
		inText,
	}
	header := bindings.MessageHeader{
		Type: keyboardService_SetText_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardService_SetSelection_Params struct {
	inStart int32
	inEnd int32
}


func (s *keyboardService_SetSelection_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.inStart); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.inEnd); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardService_SetSelection_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *keyboardService_SetSelection_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardService_SetSelection_Params_Versions), func(i int) bool {
		return keyboardService_SetSelection_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardService_SetSelection_Params_Versions) {
		if keyboardService_SetSelection_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardService_SetSelection_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inStart = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inEnd = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardService_Proxy) SetSelection(inStart int32, inEnd int32) (err error) {
	payload := &keyboardService_SetSelection_Params{
		inStart,
		inEnd,
	}
	header := bindings.MessageHeader{
		Type: keyboardService_SetSelection_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardService_Stub struct {
	connector *bindings.Connector
	impl KeyboardService
}

func NewKeyboardServiceStub(r KeyboardService_Request, impl KeyboardService, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &keyboardService_Stub{connector, impl})
}


func (f *KeyboardService_Request) ServiceDescription() service_describer.ServiceDescription {
	return &KeyboardService_ServiceDescription{}
}


type KeyboardService_ServiceDescription struct{}

func (sd *KeyboardService_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *KeyboardService_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *KeyboardService_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*KeyboardService_ServiceDescription)(nil)


func (s *keyboardService_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case keyboardService_Show_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardService_Show_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Show(request.inClient, request.inType)
		if err != nil {
			return
		}
	case keyboardService_ShowByRequest_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardService_ShowByRequest_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.ShowByRequest()
		if err != nil {
			return
		}
	case keyboardService_Hide_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardService_Hide_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Hide()
		if err != nil {
			return
		}
	case keyboardService_SetText_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardService_SetText_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SetText(request.inText)
		if err != nil {
			return
		}
	case keyboardService_SetSelection_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardService_SetSelection_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SetSelection(request.inStart, request.inEnd)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type KeyboardServiceFactory interface {
	CreateKeyboardService(inKeyEventDispatcher native_viewport_event_dispatcher.NativeViewportEventDispatcher_Request, inServiceRequest KeyboardService_Request) (err error)
}



var keyboardServiceFactory_Name = "keyboard::KeyboardServiceFactory"

type KeyboardServiceFactory_Request bindings.InterfaceRequest

func (r *KeyboardServiceFactory_Request) Name() string {
	return keyboardServiceFactory_Name
}


type KeyboardServiceFactory_Pointer bindings.InterfacePointer

func (p *KeyboardServiceFactory_Pointer) Name() string {
	return keyboardServiceFactory_Name
}

type KeyboardServiceFactory_ServiceFactory struct{
	Delegate KeyboardServiceFactory_Factory
}

type KeyboardServiceFactory_Factory interface {
	Create(request KeyboardServiceFactory_Request)
}

func (f *KeyboardServiceFactory_ServiceFactory) Name() string {
	return keyboardServiceFactory_Name
}

// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *KeyboardServiceFactory_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &KeyboardServiceFactory_ServiceDescription{}
}

func (f *KeyboardServiceFactory_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := KeyboardServiceFactory_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForKeyboardServiceFactory creates a message pipe for use with the
// KeyboardServiceFactory interface with a KeyboardServiceFactory_Request on one end and a KeyboardServiceFactory_Pointer on the other.
func CreateMessagePipeForKeyboardServiceFactory() (KeyboardServiceFactory_Request, KeyboardServiceFactory_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return KeyboardServiceFactory_Request(r), KeyboardServiceFactory_Pointer(p)
}

const keyboardServiceFactory_CreateKeyboardService_Name uint32 = 0

type KeyboardServiceFactory_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewKeyboardServiceFactoryProxy(p KeyboardServiceFactory_Pointer, waiter bindings.AsyncWaiter) *KeyboardServiceFactory_Proxy {
	return &KeyboardServiceFactory_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *KeyboardServiceFactory_Proxy) Close_Proxy() {
	p.router.Close()
}

type keyboardServiceFactory_CreateKeyboardService_Params struct {
	inKeyEventDispatcher native_viewport_event_dispatcher.NativeViewportEventDispatcher_Request
	inServiceRequest KeyboardService_Request
}


func (s *keyboardServiceFactory_CreateKeyboardService_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteHandle(s.inKeyEventDispatcher.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.WriteHandle(s.inServiceRequest.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var keyboardServiceFactory_CreateKeyboardService_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *keyboardServiceFactory_CreateKeyboardService_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(keyboardServiceFactory_CreateKeyboardService_Params_Versions), func(i int) bool {
		return keyboardServiceFactory_CreateKeyboardService_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(keyboardServiceFactory_CreateKeyboardService_Params_Versions) {
		if keyboardServiceFactory_CreateKeyboardService_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := keyboardServiceFactory_CreateKeyboardService_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inKeyEventDispatcher = native_viewport_event_dispatcher.NativeViewportEventDispatcher_Request{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inServiceRequest = KeyboardService_Request{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *KeyboardServiceFactory_Proxy) CreateKeyboardService(inKeyEventDispatcher native_viewport_event_dispatcher.NativeViewportEventDispatcher_Request, inServiceRequest KeyboardService_Request) (err error) {
	payload := &keyboardServiceFactory_CreateKeyboardService_Params{
		inKeyEventDispatcher,
		inServiceRequest,
	}
	header := bindings.MessageHeader{
		Type: keyboardServiceFactory_CreateKeyboardService_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type keyboardServiceFactory_Stub struct {
	connector *bindings.Connector
	impl KeyboardServiceFactory
}

func NewKeyboardServiceFactoryStub(r KeyboardServiceFactory_Request, impl KeyboardServiceFactory, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &keyboardServiceFactory_Stub{connector, impl})
}


func (f *KeyboardServiceFactory_Request) ServiceDescription() service_describer.ServiceDescription {
	return &KeyboardServiceFactory_ServiceDescription{}
}


type KeyboardServiceFactory_ServiceDescription struct{}

func (sd *KeyboardServiceFactory_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *KeyboardServiceFactory_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *KeyboardServiceFactory_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*KeyboardServiceFactory_ServiceDescription)(nil)


func (s *keyboardServiceFactory_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case keyboardServiceFactory_CreateKeyboardService_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request keyboardServiceFactory_CreateKeyboardService_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.CreateKeyboardService(request.inKeyEventDispatcher, request.inServiceRequest)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type CompletionData struct {
	Id int64
	Position int32
	Text string
	Label string
}


func (s *CompletionData) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WriteInt64(s.Id); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.Position); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.Text); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.Label); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var completionData_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *CompletionData) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(completionData_Versions), func(i int) bool {
		return completionData_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(completionData_Versions) {
		if completionData_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := completionData_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.Id = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Position = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.Text = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.Label = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type CorrectionData struct {
	Offset int32
	OldText string
	NewText string
}


func (s *CorrectionData) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if err := encoder.WriteInt32(s.Offset); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.OldText); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.NewText); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var correctionData_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *CorrectionData) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(correctionData_Versions), func(i int) bool {
		return correctionData_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(correctionData_Versions) {
		if correctionData_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := correctionData_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Offset = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.OldText = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.NewText = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

