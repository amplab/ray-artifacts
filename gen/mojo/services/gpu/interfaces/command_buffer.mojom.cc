// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/services/gpu/interfaces/command_buffer.mojom.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
namespace mojo {

// --- Interface definitions ---

CommandBufferSyncClientProxy::CommandBufferSyncClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : ControlMessageProxy(receiver) {
}
void CommandBufferSyncClientProxy::DidInitialize(
    bool in_success, mojo::GpuCapabilitiesPtr in_capabilities) {
  size_t size = sizeof(internal::CommandBufferSyncClient_DidInitialize_Params_Data);
  size += in_capabilities.is_null()
              ? 0
              : GetSerializedSize_(*in_capabilities);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::CommandBufferSyncClient_Base::MessageOrdinals::DidInitialize), size);

  internal::CommandBufferSyncClient_DidInitialize_Params_Data* params =
      internal::CommandBufferSyncClient_DidInitialize_Params_Data::New(builder.buffer());
  params->success = in_success;
  {Serialize_(in_capabilities.get(),
               builder.buffer(),
               &params->capabilities.ptr);
  }
  if (!params->capabilities.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null capabilities in CommandBufferSyncClient.DidInitialize request");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
void CommandBufferSyncClientProxy::DidMakeProgress(
    CommandBufferStatePtr in_state) {
  size_t size = sizeof(internal::CommandBufferSyncClient_DidMakeProgress_Params_Data);
  size += in_state.is_null()
              ? 0
              : GetSerializedSize_(*in_state);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::CommandBufferSyncClient_Base::MessageOrdinals::DidMakeProgress), size);

  internal::CommandBufferSyncClient_DidMakeProgress_Params_Data* params =
      internal::CommandBufferSyncClient_DidMakeProgress_Params_Data::New(builder.buffer());
  {Serialize_(in_state.get(),
               builder.buffer(),
               &params->state.ptr);
  }
  if (!params->state.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null state in CommandBufferSyncClient.DidMakeProgress request");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}

CommandBufferSyncClientStub::CommandBufferSyncClientStub()
    : sink_(nullptr),
      control_message_handler_(CommandBufferSyncClient::Version_) {
}

CommandBufferSyncClientStub::~CommandBufferSyncClientStub() {}

bool CommandBufferSyncClientStub::Accept(mojo::Message* message) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.Accept(message);
  internal::CommandBufferSyncClient_Base::MessageOrdinals method_ordinal =
      static_cast<internal::CommandBufferSyncClient_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::CommandBufferSyncClient_Base::MessageOrdinals::DidInitialize: {
      internal::CommandBufferSyncClient_DidInitialize_Params_Data* params =
          reinterpret_cast<internal::CommandBufferSyncClient_DidInitialize_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      bool p_success {};
      mojo::GpuCapabilitiesPtr p_capabilities {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_success = params->success;
        if (params->capabilities.ptr) {
          p_capabilities = mojo::GpuCapabilities::New();
          Deserialize_(params->capabilities.ptr, p_capabilities.get());
        }
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->DidInitialize(p_success, p_capabilities.Pass());
      return true;
    }
    case internal::CommandBufferSyncClient_Base::MessageOrdinals::DidMakeProgress: {
      internal::CommandBufferSyncClient_DidMakeProgress_Params_Data* params =
          reinterpret_cast<internal::CommandBufferSyncClient_DidMakeProgress_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      CommandBufferStatePtr p_state {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        if (params->state.ptr) {
          p_state = CommandBufferState::New();
          Deserialize_(params->state.ptr, p_state.get());
        }
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->DidMakeProgress(p_state.Pass());
      return true;
    }
  }
  return false;
}

bool CommandBufferSyncClientStub::AcceptWithResponder(
    mojo::Message* message, mojo::MessageReceiverWithStatus* responder) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.AcceptWithResponder(message, responder);
  internal::CommandBufferSyncClient_Base::MessageOrdinals method_ordinal =
      static_cast<internal::CommandBufferSyncClient_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::CommandBufferSyncClient_Base::MessageOrdinals::DidInitialize: {
      break;
    }
    case internal::CommandBufferSyncClient_Base::MessageOrdinals::DidMakeProgress: {
      break;
    }
  }
  return false;
}


CommandBufferSyncPointClientProxy::CommandBufferSyncPointClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : ControlMessageProxy(receiver) {
}
void CommandBufferSyncPointClientProxy::DidInsertSyncPoint(
    uint32_t in_sync_point) {
  size_t size = sizeof(internal::CommandBufferSyncPointClient_DidInsertSyncPoint_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::CommandBufferSyncPointClient_Base::MessageOrdinals::DidInsertSyncPoint), size);

  internal::CommandBufferSyncPointClient_DidInsertSyncPoint_Params_Data* params =
      internal::CommandBufferSyncPointClient_DidInsertSyncPoint_Params_Data::New(builder.buffer());
  params->sync_point = in_sync_point;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}

CommandBufferSyncPointClientStub::CommandBufferSyncPointClientStub()
    : sink_(nullptr),
      control_message_handler_(CommandBufferSyncPointClient::Version_) {
}

CommandBufferSyncPointClientStub::~CommandBufferSyncPointClientStub() {}

bool CommandBufferSyncPointClientStub::Accept(mojo::Message* message) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.Accept(message);
  internal::CommandBufferSyncPointClient_Base::MessageOrdinals method_ordinal =
      static_cast<internal::CommandBufferSyncPointClient_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::CommandBufferSyncPointClient_Base::MessageOrdinals::DidInsertSyncPoint: {
      internal::CommandBufferSyncPointClient_DidInsertSyncPoint_Params_Data* params =
          reinterpret_cast<internal::CommandBufferSyncPointClient_DidInsertSyncPoint_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      uint32_t p_sync_point {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_sync_point = params->sync_point;
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->DidInsertSyncPoint(p_sync_point);
      return true;
    }
  }
  return false;
}

bool CommandBufferSyncPointClientStub::AcceptWithResponder(
    mojo::Message* message, mojo::MessageReceiverWithStatus* responder) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.AcceptWithResponder(message, responder);
  internal::CommandBufferSyncPointClient_Base::MessageOrdinals method_ordinal =
      static_cast<internal::CommandBufferSyncPointClient_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::CommandBufferSyncPointClient_Base::MessageOrdinals::DidInsertSyncPoint: {
      break;
    }
  }
  return false;
}


CommandBufferLostContextObserverProxy::CommandBufferLostContextObserverProxy(mojo::MessageReceiverWithResponder* receiver)
    : ControlMessageProxy(receiver) {
}
void CommandBufferLostContextObserverProxy::DidLoseContext(
    int32_t in_context_lost_reason) {
  size_t size = sizeof(internal::CommandBufferLostContextObserver_DidLoseContext_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::CommandBufferLostContextObserver_Base::MessageOrdinals::DidLoseContext), size);

  internal::CommandBufferLostContextObserver_DidLoseContext_Params_Data* params =
      internal::CommandBufferLostContextObserver_DidLoseContext_Params_Data::New(builder.buffer());
  params->context_lost_reason = in_context_lost_reason;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}

CommandBufferLostContextObserverStub::CommandBufferLostContextObserverStub()
    : sink_(nullptr),
      control_message_handler_(CommandBufferLostContextObserver::Version_) {
}

CommandBufferLostContextObserverStub::~CommandBufferLostContextObserverStub() {}

bool CommandBufferLostContextObserverStub::Accept(mojo::Message* message) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.Accept(message);
  internal::CommandBufferLostContextObserver_Base::MessageOrdinals method_ordinal =
      static_cast<internal::CommandBufferLostContextObserver_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::CommandBufferLostContextObserver_Base::MessageOrdinals::DidLoseContext: {
      internal::CommandBufferLostContextObserver_DidLoseContext_Params_Data* params =
          reinterpret_cast<internal::CommandBufferLostContextObserver_DidLoseContext_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      int32_t p_context_lost_reason {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_context_lost_reason = params->context_lost_reason;
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->DidLoseContext(p_context_lost_reason);
      return true;
    }
  }
  return false;
}

bool CommandBufferLostContextObserverStub::AcceptWithResponder(
    mojo::Message* message, mojo::MessageReceiverWithStatus* responder) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.AcceptWithResponder(message, responder);
  internal::CommandBufferLostContextObserver_Base::MessageOrdinals method_ordinal =
      static_cast<internal::CommandBufferLostContextObserver_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::CommandBufferLostContextObserver_Base::MessageOrdinals::DidLoseContext: {
      break;
    }
  }
  return false;
}

class CommandBuffer_Echo_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CommandBuffer_Echo_ForwardToCallback(
      const CommandBuffer::EchoCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  CommandBuffer::EchoCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(CommandBuffer_Echo_ForwardToCallback);
};
bool CommandBuffer_Echo_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::CommandBuffer_Echo_ResponseParams_Data* params =
      reinterpret_cast<internal::CommandBuffer_Echo_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
  } while (false);
  callback_.Run();
  return true;
}

CommandBufferProxy::CommandBufferProxy(mojo::MessageReceiverWithResponder* receiver)
    : ControlMessageProxy(receiver) {
}
void CommandBufferProxy::Initialize(
    mojo::InterfaceHandle<CommandBufferSyncClient> in_sync_client, mojo::InterfaceHandle<CommandBufferSyncPointClient> in_sync_point_client, mojo::InterfaceHandle<CommandBufferLostContextObserver> in_lost_observer, mojo::ScopedSharedBufferHandle in_shared_state) {
  size_t size = sizeof(internal::CommandBuffer_Initialize_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::CommandBuffer_Base::MessageOrdinals::Initialize), size);

  internal::CommandBuffer_Initialize_Params_Data* params =
      internal::CommandBuffer_Initialize_Params_Data::New(builder.buffer());
  mojo::internal::InterfaceHandleToData(in_sync_client.Pass(),
                                        &params->sync_client);
  if (!params->sync_client.handle.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid sync_client in CommandBuffer.Initialize request");
  }
  mojo::internal::InterfaceHandleToData(in_sync_point_client.Pass(),
                                        &params->sync_point_client);
  if (!params->sync_point_client.handle.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid sync_point_client in CommandBuffer.Initialize request");
  }
  mojo::internal::InterfaceHandleToData(in_lost_observer.Pass(),
                                        &params->lost_observer);
  if (!params->lost_observer.handle.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid lost_observer in CommandBuffer.Initialize request");
  }
  params->shared_state = in_shared_state.release();
  if (!params->shared_state.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid shared_state in CommandBuffer.Initialize request");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
void CommandBufferProxy::SetGetBuffer(
    int32_t in_buffer) {
  size_t size = sizeof(internal::CommandBuffer_SetGetBuffer_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::CommandBuffer_Base::MessageOrdinals::SetGetBuffer), size);

  internal::CommandBuffer_SetGetBuffer_Params_Data* params =
      internal::CommandBuffer_SetGetBuffer_Params_Data::New(builder.buffer());
  params->buffer = in_buffer;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
void CommandBufferProxy::Flush(
    int32_t in_put_offset) {
  size_t size = sizeof(internal::CommandBuffer_Flush_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::CommandBuffer_Base::MessageOrdinals::Flush), size);

  internal::CommandBuffer_Flush_Params_Data* params =
      internal::CommandBuffer_Flush_Params_Data::New(builder.buffer());
  params->put_offset = in_put_offset;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
void CommandBufferProxy::MakeProgress(
    int32_t in_last_get_offset) {
  size_t size = sizeof(internal::CommandBuffer_MakeProgress_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::CommandBuffer_Base::MessageOrdinals::MakeProgress), size);

  internal::CommandBuffer_MakeProgress_Params_Data* params =
      internal::CommandBuffer_MakeProgress_Params_Data::New(builder.buffer());
  params->last_get_offset = in_last_get_offset;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
void CommandBufferProxy::RegisterTransferBuffer(
    int32_t in_id, mojo::ScopedSharedBufferHandle in_transfer_buffer, uint32_t in_size) {
  size_t size = sizeof(internal::CommandBuffer_RegisterTransferBuffer_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::CommandBuffer_Base::MessageOrdinals::RegisterTransferBuffer), size);

  internal::CommandBuffer_RegisterTransferBuffer_Params_Data* params =
      internal::CommandBuffer_RegisterTransferBuffer_Params_Data::New(builder.buffer());
  params->id = in_id;
  params->transfer_buffer = in_transfer_buffer.release();
  if (!params->transfer_buffer.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid transfer_buffer in CommandBuffer.RegisterTransferBuffer request");
  }
  params->size = in_size;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
void CommandBufferProxy::DestroyTransferBuffer(
    int32_t in_id) {
  size_t size = sizeof(internal::CommandBuffer_DestroyTransferBuffer_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::CommandBuffer_Base::MessageOrdinals::DestroyTransferBuffer), size);

  internal::CommandBuffer_DestroyTransferBuffer_Params_Data* params =
      internal::CommandBuffer_DestroyTransferBuffer_Params_Data::New(builder.buffer());
  params->id = in_id;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
void CommandBufferProxy::InsertSyncPoint(
    bool in_retire) {
  size_t size = sizeof(internal::CommandBuffer_InsertSyncPoint_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::CommandBuffer_Base::MessageOrdinals::InsertSyncPoint), size);

  internal::CommandBuffer_InsertSyncPoint_Params_Data* params =
      internal::CommandBuffer_InsertSyncPoint_Params_Data::New(builder.buffer());
  params->retire = in_retire;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
void CommandBufferProxy::RetireSyncPoint(
    uint32_t in_sync_point) {
  size_t size = sizeof(internal::CommandBuffer_RetireSyncPoint_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::CommandBuffer_Base::MessageOrdinals::RetireSyncPoint), size);

  internal::CommandBuffer_RetireSyncPoint_Params_Data* params =
      internal::CommandBuffer_RetireSyncPoint_Params_Data::New(builder.buffer());
  params->sync_point = in_sync_point;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
void CommandBufferProxy::Echo(
    const EchoCallback& callback) {
  size_t size = sizeof(internal::CommandBuffer_Echo_Params_Data);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::CommandBuffer_Base::MessageOrdinals::Echo), size);

  internal::CommandBuffer_Echo_Params_Data* params =
      internal::CommandBuffer_Echo_Params_Data::New(builder.buffer());
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new CommandBuffer_Echo_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class CommandBuffer_Echo_ProxyToResponder
    : public CommandBuffer::EchoCallback::Runnable {
 public:
  ~CommandBuffer_Echo_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "CommandBuffer::Echo(callback) "
        "was never run.";
  }

  CommandBuffer_Echo_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run() const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(CommandBuffer_Echo_ProxyToResponder);
};

void CommandBuffer_Echo_ProxyToResponder::Run(
    ) const {
  size_t size = sizeof(internal::CommandBuffer_Echo_ResponseParams_Data);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::CommandBuffer_Base::MessageOrdinals::Echo), size, request_id_);
  internal::CommandBuffer_Echo_ResponseParams_Data* params =
      internal::CommandBuffer_Echo_ResponseParams_Data::New(builder.buffer());
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}

CommandBufferStub::CommandBufferStub()
    : sink_(nullptr),
      control_message_handler_(CommandBuffer::Version_) {
}

CommandBufferStub::~CommandBufferStub() {}

bool CommandBufferStub::Accept(mojo::Message* message) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.Accept(message);
  internal::CommandBuffer_Base::MessageOrdinals method_ordinal =
      static_cast<internal::CommandBuffer_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::CommandBuffer_Base::MessageOrdinals::Initialize: {
      internal::CommandBuffer_Initialize_Params_Data* params =
          reinterpret_cast<internal::CommandBuffer_Initialize_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      mojo::InterfaceHandle<CommandBufferSyncClient> p_sync_client {};
      mojo::InterfaceHandle<CommandBufferSyncPointClient> p_sync_point_client {};
      mojo::InterfaceHandle<CommandBufferLostContextObserver> p_lost_observer {};
      mojo::ScopedSharedBufferHandle p_shared_state {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        mojo::internal::InterfaceDataToHandle(&params->sync_client, &p_sync_client);
        mojo::internal::InterfaceDataToHandle(&params->sync_point_client, &p_sync_point_client);
        mojo::internal::InterfaceDataToHandle(&params->lost_observer, &p_lost_observer);
        p_shared_state.reset(mojo::internal::FetchAndReset(&params->shared_state));
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->Initialize(p_sync_client.Pass(), p_sync_point_client.Pass(), p_lost_observer.Pass(), p_shared_state.Pass());
      return true;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::SetGetBuffer: {
      internal::CommandBuffer_SetGetBuffer_Params_Data* params =
          reinterpret_cast<internal::CommandBuffer_SetGetBuffer_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      int32_t p_buffer {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_buffer = params->buffer;
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->SetGetBuffer(p_buffer);
      return true;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::Flush: {
      internal::CommandBuffer_Flush_Params_Data* params =
          reinterpret_cast<internal::CommandBuffer_Flush_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      int32_t p_put_offset {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_put_offset = params->put_offset;
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->Flush(p_put_offset);
      return true;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::MakeProgress: {
      internal::CommandBuffer_MakeProgress_Params_Data* params =
          reinterpret_cast<internal::CommandBuffer_MakeProgress_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      int32_t p_last_get_offset {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_last_get_offset = params->last_get_offset;
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->MakeProgress(p_last_get_offset);
      return true;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::RegisterTransferBuffer: {
      internal::CommandBuffer_RegisterTransferBuffer_Params_Data* params =
          reinterpret_cast<internal::CommandBuffer_RegisterTransferBuffer_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      int32_t p_id {};
      mojo::ScopedSharedBufferHandle p_transfer_buffer {};
      uint32_t p_size {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_id = params->id;
        p_transfer_buffer.reset(mojo::internal::FetchAndReset(&params->transfer_buffer));
        p_size = params->size;
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->RegisterTransferBuffer(p_id, p_transfer_buffer.Pass(), p_size);
      return true;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::DestroyTransferBuffer: {
      internal::CommandBuffer_DestroyTransferBuffer_Params_Data* params =
          reinterpret_cast<internal::CommandBuffer_DestroyTransferBuffer_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      int32_t p_id {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_id = params->id;
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->DestroyTransferBuffer(p_id);
      return true;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::InsertSyncPoint: {
      internal::CommandBuffer_InsertSyncPoint_Params_Data* params =
          reinterpret_cast<internal::CommandBuffer_InsertSyncPoint_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      bool p_retire {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_retire = params->retire;
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->InsertSyncPoint(p_retire);
      return true;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::RetireSyncPoint: {
      internal::CommandBuffer_RetireSyncPoint_Params_Data* params =
          reinterpret_cast<internal::CommandBuffer_RetireSyncPoint_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      uint32_t p_sync_point {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_sync_point = params->sync_point;
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->RetireSyncPoint(p_sync_point);
      return true;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::Echo: {
      break;
    }
  }
  return false;
}

bool CommandBufferStub::AcceptWithResponder(
    mojo::Message* message, mojo::MessageReceiverWithStatus* responder) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.AcceptWithResponder(message, responder);
  internal::CommandBuffer_Base::MessageOrdinals method_ordinal =
      static_cast<internal::CommandBuffer_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::CommandBuffer_Base::MessageOrdinals::Initialize: {
      break;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::SetGetBuffer: {
      break;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::Flush: {
      break;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::MakeProgress: {
      break;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::RegisterTransferBuffer: {
      break;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::DestroyTransferBuffer: {
      break;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::InsertSyncPoint: {
      break;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::RetireSyncPoint: {
      break;
    }
    case internal::CommandBuffer_Base::MessageOrdinals::Echo: {
      internal::CommandBuffer_Echo_Params_Data* params =
          reinterpret_cast<internal::CommandBuffer_Echo_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      CommandBuffer::EchoCallback::Runnable* runnable =
          new CommandBuffer_Echo_ProxyToResponder(
              message->request_id(), responder);
      CommandBuffer::EchoCallback callback(runnable);
      
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->Echo(callback);
      return true;
    }
  }
  return false;
}

}  // namespace mojo
