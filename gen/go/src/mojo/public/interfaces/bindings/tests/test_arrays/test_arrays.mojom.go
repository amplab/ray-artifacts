// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/public/interfaces/bindings/tests/test_arrays.mojom
//

package test_arrays

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	ioutil "io/ioutil"
	base64 "encoding/base64"
	fmt "fmt"
	bytes "bytes"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
	gzip "compress/gzip"
)

// This global variable contains a mojom_types.RuntimeTypeInfo struct
// describing the types defined in this file and all of its imports as
// well as the top-level interfaces defined in this file.
var runtimeTypeInfo__ = mojom_types.RuntimeTypeInfo{}

func getRuntimeTypeInfo() mojom_types.RuntimeTypeInfo {
  if runtimeTypeInfo__.TypeMap == nil {
    initRuntimeTypeInfo()
  }
  return runtimeTypeInfo__
}

func initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this file.
  // The string contains the base64 encoding of the gzip-compressed bytes.
  serializedRuntimeTypeInfo := "H4sIAAAJbogC/+xbT5PbNBS343QTKH+yLbThT7eBttvQNnHbBWYpHMqfMsswzGRoZ9gOh9abeBszSZzazgxw4tiP0CPHPXLkI3DkuMf9CBx7o1L8lMqKVDne2JZnohlFK8cvtn7vPf2e9LR1LSw1aK9Dy14nbZVp5+RLYdtB9RVUd+D6r9AeQPsvtM+gbephuwvtE2j/hvZTVNuo3rvfufPg+zv3bw3dX9x2YPtB+27gTbrBT07Q/8YKrI4ztr92R/5kaHv+gnIdz+1NulO5a0jmokxuxxr1BravwTM2Zfd/Nwpsb9/q2pq2he69Gvv+Lz3P+i0+DjO5H+3HE/QVesMbSOYjmdwPtu9bj2wMhQ96uYnqFZnc3b7l2b2vJvv7U+ym+kS1wZe7hz5mb/gU7ATbD1b1E8qecL9eifYPXo/2m29F+4dnov2jjWj/r81o/3rrRd/A9rYV9huMfTfADh+uhe1tLVqI33Sg/R/KWOOXC6i+h+pLjRcV/HqXUI1p7nP++DaqGMKf8bNQNfvu0DbH3aHrOcHvJjKrVtf1bNP3uiZ+hjme7A2crukQBfnmnjPqOaNHvokfH34+sLBB+m0sMZzpu0zhRvz4KcwHh0YUt23qPUvUPCArItw1CnfedY3CA5tQP3TdcCAc3M6A/6eNW4N59xrgWGXeRwOcRPhpOn+81QT46dTvs2UDsCH4jSaDgbU3sAmQLI5nwX6zwlFPCcdaAhxLMXCc4ccYJItjPWMcZfaoS3CsCnCsJ8DR4NxHymVUz/NwZAyTxfMd4GtV7JLgSXipysGrDPNsvvxEBUkx+YmWYPXw/oqfEvHTOQX5ySggP20oyE9GAfnpvIL8ZBSYnxoK8pNxDH6qAd4dCT/tMPz0UIAr5u/1CD9Ri3GKvyTL9jncb6z4KBEf3YS/VeIjrYB8tAV2rRIfaQXko48zxjEOH2kF5qNPUD2lGB9pS+CjP0rL4SPMNacjfERt9kJsdE7AR/SdLO6vZsRHLI48Oz2B6n9L5p2mQP410J8zDjweT5/MgW/Y+Izmx8im9gL73y+zX53zPPJ9Hez3sLKY/fYFeDfgt0XJB5wD+FBmvy/SFHP6eiOnuIrkj3YhnnpWViuu8qcoiuOqN2HeyIPHTlB2KfKDZsz5b9H8mCpxG9GPLG6rgUwe/FgkPaUeFzIOxeppPWM9yfxJz1lPucWdAsdi9XUK5FTxq6z0ddw8wJ+VtPIAnMMFkjwAT4LV83ZO8cEB4LUN8cE/isQH63AuwrMfz2IDXlz1GVxTZT4rpRQn5x0PvAtzEdYHGwvw9HIL9ihVmbdU0cuy+Z/oZaYTxmFYvXyesV5k/mJkrJes+J7wRkQvHMdh9fMF6FQVvzFyWPdnmUch8bPoECAZj+y4IKvHK6s8SqI8ytUc1yei/X+9gHmUazmuG5aJY955lFbGOMbJo+gFzqO0Yawq5VH0Y+RRyD707tpy9qExpmcjfBQ9XI7PsH8g4CPOMfQ5/C+seCkRL11UbB4gdlk0XrqkmP8nxTFvXtrMGMc4vFQuMC9dhnlVJV4qL8BLTUH+g7VfEb63GX7qSOZLdt1HeEuw3JvDew1y+2njzfs/ApJf1xl/pnFm8TxKKc9/EtbY37ou930r4D9Z2WWdGe/RAuPERcSzp2GsaJwtL9wG546XlLTHW41xfoa+73kAAAD//zUoldooOgAA"

  // Deserialize RuntimeTypeInfo
  compressedBytes, err := base64.StdEncoding.DecodeString(serializedRuntimeTypeInfo)
  if err != nil {
    panic(fmt.Sprintf("Error while base64Decoding runtimeTypeInfo: %s", err.Error()))
  }
  reader, err := gzip.NewReader(bytes.NewBuffer(compressedBytes))
  if err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  uncompressedBytes, err := ioutil.ReadAll(reader)
  if err != nil {
     panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  if err = reader.Close(); err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  decoder := bindings.NewDecoder(uncompressedBytes, nil)
  runtimeTypeInfo__.Decode(decoder)

}
func GetAllMojomTypeDefinitions() map[string]mojom_types.UserDefinedType {
  return getRuntimeTypeInfo().TypeMap
}

type TestInterface interface {
	Foo() (err error)
}


// TestInterfaceMojomType returns the UserDefinedType that describes the Mojom
// type of TestInterface. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func TestInterfaceMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.TestInterface"]
}




type TestInterface_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*TestInterface_Request) MojomType() mojom_types.UserDefinedType {
	return TestInterfaceMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*TestInterface_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type TestInterface_Pointer bindings.InterfacePointer


type TestInterface_ServiceFactory struct{
	Delegate TestInterface_Factory
}

type TestInterface_Factory interface {
	Create(request TestInterface_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *TestInterface_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &TestInterface_ServiceDescription{}
}

func (f *TestInterface_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := TestInterface_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForTestInterface creates a message pipe for use with the
// TestInterface interface with a TestInterface_Request on one end and a TestInterface_Pointer on the other.
func CreateMessagePipeForTestInterface() (TestInterface_Request, TestInterface_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return TestInterface_Request(r), TestInterface_Pointer(p)
}

const testInterface_Foo_Name uint32 = 0

type TestInterface_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewTestInterfaceProxy(p TestInterface_Pointer, waiter bindings.AsyncWaiter) *TestInterface_Proxy {
	return &TestInterface_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *TestInterface_Proxy) Close_Proxy() {
	p.router.Close()
}

type testInterface_Foo_Params struct {
}


func (s *testInterface_Foo_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var testInterface_Foo_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *testInterface_Foo_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(testInterface_Foo_Params_Versions), func(i int) bool {
		return testInterface_Foo_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(testInterface_Foo_Params_Versions) {
		if testInterface_Foo_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := testInterface_Foo_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *TestInterface_Proxy) Foo() (err error) {
	payload := &testInterface_Foo_Params{
	}
	header := bindings.MessageHeader{
		Type: testInterface_Foo_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type testInterface_Stub struct {
	connector *bindings.Connector
	impl TestInterface
}

func NewTestInterfaceStub(r TestInterface_Request, impl TestInterface, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &testInterface_Stub{connector, impl})
}


func (f *TestInterface_Request) ServiceDescription() service_describer.ServiceDescription {
	return &TestInterface_ServiceDescription{}
}


type TestInterface_ServiceDescription struct{}

func (sd *TestInterface_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *TestInterface_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *TestInterface_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*TestInterface_ServiceDescription)(nil)


func (s *testInterface_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case testInterface_Foo_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request testInterface_Foo_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Foo()
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type StructWithInterface struct {
	Iptr TestInterface_Pointer
}
// StructWithInterfaceMojomType returns the UserDefinedType that describes the Mojom
// type of StructWithInterface. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithInterfaceMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructWithInterface"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithInterface) MojomType() mojom_types.UserDefinedType {
	return StructWithInterfaceMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithInterface) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithInterface) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInterface(s.Iptr.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithInterface_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *StructWithInterface) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithInterface_Versions), func(i int) bool {
		return structWithInterface_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithInterface_Versions) {
		if structWithInterface_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithInterface_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadInterface()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.Iptr = TestInterface_Pointer{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructWithInterfaceArray struct {
	StructsArray []StructWithInterface
	StructsNullableArray *[]StructWithInterface
	NullableStructsArray []*StructWithInterface
	NullableStructsNullableArray *[]*StructWithInterface
}
// StructWithInterfaceArrayMojomType returns the UserDefinedType that describes the Mojom
// type of StructWithInterfaceArray. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithInterfaceArrayMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructWithInterfaceArray"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithInterfaceArray) MojomType() mojom_types.UserDefinedType {
	return StructWithInterfaceArrayMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithInterfaceArray) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithInterfaceArray) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.StructsArray)), 64)
	for _, elem0 := range s.StructsArray {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.StructsNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.StructsNullableArray))), 64)
		for _, elem0 := range (*s.StructsNullableArray) {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem0.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.NullableStructsArray)), 64)
	for _, elem0 := range s.NullableStructsArray {
		if elem0 == nil {
			encoder.WriteNullPointer()
		} else {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := (*elem0).Encode(encoder); err != nil {
				return err
			}
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.NullableStructsNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.NullableStructsNullableArray))), 64)
		for _, elem0 := range (*s.NullableStructsNullableArray) {
			if elem0 == nil {
				encoder.WriteNullPointer()
			} else {
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				if err := (*elem0).Encode(encoder); err != nil {
					return err
				}
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithInterfaceArray_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *StructWithInterfaceArray) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithInterfaceArray_Versions), func(i int) bool {
		return structWithInterfaceArray_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithInterfaceArray_Versions) {
		if structWithInterfaceArray_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithInterfaceArray_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.StructsArray = make([]StructWithInterface, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := s.StructsArray[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.StructsNullableArray = nil
		} else {
			s.StructsNullableArray = new([]StructWithInterface)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.StructsNullableArray) = make([]StructWithInterface, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := (*s.StructsNullableArray)[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.NullableStructsArray = make([]*StructWithInterface, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					s.NullableStructsArray[i0] = nil
				} else {
					s.NullableStructsArray[i0] = new(StructWithInterface)
					if err := (*s.NullableStructsArray[i0]).Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.NullableStructsNullableArray = nil
		} else {
			s.NullableStructsNullableArray = new([]*StructWithInterface)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.NullableStructsNullableArray) = make([]*StructWithInterface, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					(*s.NullableStructsNullableArray)[i0] = nil
				} else {
					(*s.NullableStructsNullableArray)[i0] = new(StructWithInterface)
					if err := (*(*s.NullableStructsNullableArray)[i0]).Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructWithDataPipeConsumers struct {
	HandlesArray []system.ConsumerHandle
	HandlesNullableArray *[]system.ConsumerHandle
	NullableHandlesArray []*system.ConsumerHandle
	NullableHandlesNullableArray *[]*system.ConsumerHandle
}
// StructWithDataPipeConsumersMojomType returns the UserDefinedType that describes the Mojom
// type of StructWithDataPipeConsumers. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithDataPipeConsumersMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructWithDataPipeConsumers"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithDataPipeConsumers) MojomType() mojom_types.UserDefinedType {
	return StructWithDataPipeConsumersMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithDataPipeConsumers) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithDataPipeConsumers) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.HandlesArray)), 32)
	for _, elem0 := range s.HandlesArray {
		if err := encoder.WriteHandle(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.HandlesNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.HandlesNullableArray))), 32)
		for _, elem0 := range (*s.HandlesNullableArray) {
			if err := encoder.WriteHandle(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.NullableHandlesArray)), 32)
	for _, elem0 := range s.NullableHandlesArray {
		if elem0 == nil {
			encoder.WriteInvalidHandle()
		} else {
			if err := encoder.WriteHandle((*elem0)); err != nil {
				return err
			}
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.NullableHandlesNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.NullableHandlesNullableArray))), 32)
		for _, elem0 := range (*s.NullableHandlesNullableArray) {
			if elem0 == nil {
				encoder.WriteInvalidHandle()
			} else {
				if err := encoder.WriteHandle((*elem0)); err != nil {
					return err
				}
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithDataPipeConsumers_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *StructWithDataPipeConsumers) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithDataPipeConsumers_Versions), func(i int) bool {
		return structWithDataPipeConsumers_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithDataPipeConsumers_Versions) {
		if structWithDataPipeConsumers_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithDataPipeConsumers_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.HandlesArray = make([]system.ConsumerHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadConsumerHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					s.HandlesArray[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.HandlesNullableArray = nil
		} else {
			s.HandlesNullableArray = new([]system.ConsumerHandle)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.HandlesNullableArray) = make([]system.ConsumerHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadConsumerHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					(*s.HandlesNullableArray)[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.NullableHandlesArray = make([]*system.ConsumerHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadConsumerHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					s.NullableHandlesArray[i0] = &handle1
				} else {
					s.NullableHandlesArray[i0] = nil
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.NullableHandlesNullableArray = nil
		} else {
			s.NullableHandlesNullableArray = new([]*system.ConsumerHandle)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.NullableHandlesNullableArray) = make([]*system.ConsumerHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadConsumerHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					(*s.NullableHandlesNullableArray)[i0] = &handle1
				} else {
					(*s.NullableHandlesNullableArray)[i0] = nil
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructWithDataPipeProducers struct {
	HandlesArray []system.ProducerHandle
	HandlesNullableArray *[]system.ProducerHandle
	NullableHandlesArray []*system.ProducerHandle
	NullableHandlesNullableArray *[]*system.ProducerHandle
}
// StructWithDataPipeProducersMojomType returns the UserDefinedType that describes the Mojom
// type of StructWithDataPipeProducers. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithDataPipeProducersMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructWithDataPipeProducers"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithDataPipeProducers) MojomType() mojom_types.UserDefinedType {
	return StructWithDataPipeProducersMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithDataPipeProducers) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithDataPipeProducers) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.HandlesArray)), 32)
	for _, elem0 := range s.HandlesArray {
		if err := encoder.WriteHandle(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.HandlesNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.HandlesNullableArray))), 32)
		for _, elem0 := range (*s.HandlesNullableArray) {
			if err := encoder.WriteHandle(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.NullableHandlesArray)), 32)
	for _, elem0 := range s.NullableHandlesArray {
		if elem0 == nil {
			encoder.WriteInvalidHandle()
		} else {
			if err := encoder.WriteHandle((*elem0)); err != nil {
				return err
			}
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.NullableHandlesNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.NullableHandlesNullableArray))), 32)
		for _, elem0 := range (*s.NullableHandlesNullableArray) {
			if elem0 == nil {
				encoder.WriteInvalidHandle()
			} else {
				if err := encoder.WriteHandle((*elem0)); err != nil {
					return err
				}
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithDataPipeProducers_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *StructWithDataPipeProducers) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithDataPipeProducers_Versions), func(i int) bool {
		return structWithDataPipeProducers_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithDataPipeProducers_Versions) {
		if structWithDataPipeProducers_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithDataPipeProducers_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.HandlesArray = make([]system.ProducerHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadProducerHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					s.HandlesArray[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.HandlesNullableArray = nil
		} else {
			s.HandlesNullableArray = new([]system.ProducerHandle)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.HandlesNullableArray) = make([]system.ProducerHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadProducerHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					(*s.HandlesNullableArray)[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.NullableHandlesArray = make([]*system.ProducerHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadProducerHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					s.NullableHandlesArray[i0] = &handle1
				} else {
					s.NullableHandlesArray[i0] = nil
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.NullableHandlesNullableArray = nil
		} else {
			s.NullableHandlesNullableArray = new([]*system.ProducerHandle)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.NullableHandlesNullableArray) = make([]*system.ProducerHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadProducerHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					(*s.NullableHandlesNullableArray)[i0] = &handle1
				} else {
					(*s.NullableHandlesNullableArray)[i0] = nil
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructWithSharedBuffers struct {
	HandlesArray []system.SharedBufferHandle
	HandlesNullableArray *[]system.SharedBufferHandle
	NullableHandlesArray []*system.SharedBufferHandle
	NullableHandlesNullableArray *[]*system.SharedBufferHandle
}
// StructWithSharedBuffersMojomType returns the UserDefinedType that describes the Mojom
// type of StructWithSharedBuffers. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithSharedBuffersMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructWithSharedBuffers"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithSharedBuffers) MojomType() mojom_types.UserDefinedType {
	return StructWithSharedBuffersMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithSharedBuffers) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithSharedBuffers) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.HandlesArray)), 32)
	for _, elem0 := range s.HandlesArray {
		if err := encoder.WriteHandle(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.HandlesNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.HandlesNullableArray))), 32)
		for _, elem0 := range (*s.HandlesNullableArray) {
			if err := encoder.WriteHandle(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.NullableHandlesArray)), 32)
	for _, elem0 := range s.NullableHandlesArray {
		if elem0 == nil {
			encoder.WriteInvalidHandle()
		} else {
			if err := encoder.WriteHandle((*elem0)); err != nil {
				return err
			}
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.NullableHandlesNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.NullableHandlesNullableArray))), 32)
		for _, elem0 := range (*s.NullableHandlesNullableArray) {
			if elem0 == nil {
				encoder.WriteInvalidHandle()
			} else {
				if err := encoder.WriteHandle((*elem0)); err != nil {
					return err
				}
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithSharedBuffers_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *StructWithSharedBuffers) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithSharedBuffers_Versions), func(i int) bool {
		return structWithSharedBuffers_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithSharedBuffers_Versions) {
		if structWithSharedBuffers_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithSharedBuffers_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.HandlesArray = make([]system.SharedBufferHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadSharedBufferHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					s.HandlesArray[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.HandlesNullableArray = nil
		} else {
			s.HandlesNullableArray = new([]system.SharedBufferHandle)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.HandlesNullableArray) = make([]system.SharedBufferHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadSharedBufferHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					(*s.HandlesNullableArray)[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.NullableHandlesArray = make([]*system.SharedBufferHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadSharedBufferHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					s.NullableHandlesArray[i0] = &handle1
				} else {
					s.NullableHandlesArray[i0] = nil
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.NullableHandlesNullableArray = nil
		} else {
			s.NullableHandlesNullableArray = new([]*system.SharedBufferHandle)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.NullableHandlesNullableArray) = make([]*system.SharedBufferHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadSharedBufferHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					(*s.NullableHandlesNullableArray)[i0] = &handle1
				} else {
					(*s.NullableHandlesNullableArray)[i0] = nil
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructWithMessagePipes struct {
	HandlesArray []system.MessagePipeHandle
	HandlesNullableArray *[]system.MessagePipeHandle
	NullableHandlesArray []*system.MessagePipeHandle
	NullableHandlesNullableArray *[]*system.MessagePipeHandle
}
// StructWithMessagePipesMojomType returns the UserDefinedType that describes the Mojom
// type of StructWithMessagePipes. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithMessagePipesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructWithMessagePipes"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithMessagePipes) MojomType() mojom_types.UserDefinedType {
	return StructWithMessagePipesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithMessagePipes) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithMessagePipes) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.HandlesArray)), 32)
	for _, elem0 := range s.HandlesArray {
		if err := encoder.WriteHandle(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.HandlesNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.HandlesNullableArray))), 32)
		for _, elem0 := range (*s.HandlesNullableArray) {
			if err := encoder.WriteHandle(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.NullableHandlesArray)), 32)
	for _, elem0 := range s.NullableHandlesArray {
		if elem0 == nil {
			encoder.WriteInvalidHandle()
		} else {
			if err := encoder.WriteHandle((*elem0)); err != nil {
				return err
			}
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.NullableHandlesNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.NullableHandlesNullableArray))), 32)
		for _, elem0 := range (*s.NullableHandlesNullableArray) {
			if elem0 == nil {
				encoder.WriteInvalidHandle()
			} else {
				if err := encoder.WriteHandle((*elem0)); err != nil {
					return err
				}
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithMessagePipes_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *StructWithMessagePipes) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithMessagePipes_Versions), func(i int) bool {
		return structWithMessagePipes_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithMessagePipes_Versions) {
		if structWithMessagePipes_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithMessagePipes_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.HandlesArray = make([]system.MessagePipeHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadMessagePipeHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					s.HandlesArray[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.HandlesNullableArray = nil
		} else {
			s.HandlesNullableArray = new([]system.MessagePipeHandle)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.HandlesNullableArray) = make([]system.MessagePipeHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadMessagePipeHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					(*s.HandlesNullableArray)[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.NullableHandlesArray = make([]*system.MessagePipeHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadMessagePipeHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					s.NullableHandlesArray[i0] = &handle1
				} else {
					s.NullableHandlesArray[i0] = nil
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.NullableHandlesNullableArray = nil
		} else {
			s.NullableHandlesNullableArray = new([]*system.MessagePipeHandle)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.NullableHandlesNullableArray) = make([]*system.MessagePipeHandle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadMessagePipeHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					(*s.NullableHandlesNullableArray)[i0] = &handle1
				} else {
					(*s.NullableHandlesNullableArray)[i0] = nil
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructWithHandles struct {
	HandlesArray []system.Handle
	HandlesNullableArray *[]system.Handle
	NullableHandlesArray []*system.Handle
	NullableHandlesNullableArray *[]*system.Handle
}
// StructWithHandlesMojomType returns the UserDefinedType that describes the Mojom
// type of StructWithHandles. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithHandlesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructWithHandles"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithHandles) MojomType() mojom_types.UserDefinedType {
	return StructWithHandlesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithHandles) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithHandles) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.HandlesArray)), 32)
	for _, elem0 := range s.HandlesArray {
		if err := encoder.WriteHandle(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.HandlesNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.HandlesNullableArray))), 32)
		for _, elem0 := range (*s.HandlesNullableArray) {
			if err := encoder.WriteHandle(elem0); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.NullableHandlesArray)), 32)
	for _, elem0 := range s.NullableHandlesArray {
		if elem0 == nil {
			encoder.WriteInvalidHandle()
		} else {
			if err := encoder.WriteHandle((*elem0)); err != nil {
				return err
			}
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.NullableHandlesNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.NullableHandlesNullableArray))), 32)
		for _, elem0 := range (*s.NullableHandlesNullableArray) {
			if elem0 == nil {
				encoder.WriteInvalidHandle()
			} else {
				if err := encoder.WriteHandle((*elem0)); err != nil {
					return err
				}
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithHandles_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *StructWithHandles) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithHandles_Versions), func(i int) bool {
		return structWithHandles_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithHandles_Versions) {
		if structWithHandles_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithHandles_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.HandlesArray = make([]system.Handle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					s.HandlesArray[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.HandlesNullableArray = nil
		} else {
			s.HandlesNullableArray = new([]system.Handle)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.HandlesNullableArray) = make([]system.Handle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					(*s.HandlesNullableArray)[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.NullableHandlesArray = make([]*system.Handle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					s.NullableHandlesArray[i0] = &handle1
				} else {
					s.NullableHandlesArray[i0] = nil
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.NullableHandlesNullableArray = nil
		} else {
			s.NullableHandlesNullableArray = new([]*system.Handle)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.NullableHandlesNullableArray) = make([]*system.Handle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					(*s.NullableHandlesNullableArray)[i0] = &handle1
				} else {
					(*s.NullableHandlesNullableArray)[i0] = nil
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructWithInterfaceRequests struct {
	ReqArray []TestInterface_Request
	ReqNullableArray *[]TestInterface_Request
	NullableReqArray []*TestInterface_Request
	NullableReqNullableArray *[]*TestInterface_Request
}
// StructWithInterfaceRequestsMojomType returns the UserDefinedType that describes the Mojom
// type of StructWithInterfaceRequests. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithInterfaceRequestsMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructWithInterfaceRequests"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithInterfaceRequests) MojomType() mojom_types.UserDefinedType {
	return StructWithInterfaceRequestsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithInterfaceRequests) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithInterfaceRequests) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.ReqArray)), 32)
	for _, elem0 := range s.ReqArray {
		if err := encoder.WriteHandle(elem0.PassMessagePipe()); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.ReqNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.ReqNullableArray))), 32)
		for _, elem0 := range (*s.ReqNullableArray) {
			if err := encoder.WriteHandle(elem0.PassMessagePipe()); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.NullableReqArray)), 32)
	for _, elem0 := range s.NullableReqArray {
		if elem0 == nil {
			encoder.WriteInvalidHandle()
		} else {
			if err := encoder.WriteHandle((*elem0).PassMessagePipe()); err != nil {
				return err
			}
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if s.NullableReqNullableArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.NullableReqNullableArray))), 32)
		for _, elem0 := range (*s.NullableReqNullableArray) {
			if elem0 == nil {
				encoder.WriteInvalidHandle()
			} else {
				if err := encoder.WriteHandle((*elem0).PassMessagePipe()); err != nil {
					return err
				}
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithInterfaceRequests_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *StructWithInterfaceRequests) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithInterfaceRequests_Versions), func(i int) bool {
		return structWithInterfaceRequests_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithInterfaceRequests_Versions) {
		if structWithInterfaceRequests_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithInterfaceRequests_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.ReqArray = make([]TestInterface_Request, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadMessagePipeHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					handleOwner := bindings.NewMessagePipeHandleOwner(handle1)
					s.ReqArray[i0] = TestInterface_Request{handleOwner}
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.ReqNullableArray = nil
		} else {
			s.ReqNullableArray = new([]TestInterface_Request)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.ReqNullableArray) = make([]TestInterface_Request, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadMessagePipeHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					handleOwner := bindings.NewMessagePipeHandleOwner(handle1)
					(*s.ReqNullableArray)[i0] = TestInterface_Request{handleOwner}
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.NullableReqArray = make([]*TestInterface_Request, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadMessagePipeHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					handleOwner := bindings.NewMessagePipeHandleOwner(handle1)
					s.NullableReqArray[i0] = &TestInterface_Request{handleOwner}
				} else {
					s.NullableReqArray[i0] = nil
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.NullableReqNullableArray = nil
		} else {
			s.NullableReqNullableArray = new([]*TestInterface_Request)
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			(*s.NullableReqNullableArray) = make([]*TestInterface_Request, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadMessagePipeHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					handleOwner := bindings.NewMessagePipeHandleOwner(handle1)
					(*s.NullableReqNullableArray)[i0] = &TestInterface_Request{handleOwner}
				} else {
					(*s.NullableReqNullableArray)[i0] = nil
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

