// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/services/android/interfaces/activity.mojom
//

package activity

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	fmt "fmt"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
)


type SystemUiVisibility int32

const (
	SystemUiVisibility_Standard SystemUiVisibility = 0
	SystemUiVisibility_Fullscreen = SystemUiVisibility_Standard + 1;
	SystemUiVisibility_Immersive = SystemUiVisibility_Fullscreen + 1;
)


type ScreenOrientation int32

const (
	ScreenOrientation_Unspecified ScreenOrientation = 0
	ScreenOrientation_Landscape = ScreenOrientation_Unspecified + 1;
	ScreenOrientation_Portrait = ScreenOrientation_Landscape + 1;
	ScreenOrientation_Nosensor = ScreenOrientation_Portrait + 1;
)


type HapticFeedbackType int32

const (
	HapticFeedbackType_LongPress HapticFeedbackType = 0
	HapticFeedbackType_VirtualKey = HapticFeedbackType_LongPress + 1;
	HapticFeedbackType_KeyboardTap = HapticFeedbackType_VirtualKey + 1;
	HapticFeedbackType_ClockTick = HapticFeedbackType_KeyboardTap + 1;
)


type AuralFeedbackType int32

const (
	AuralFeedbackType_Click AuralFeedbackType = 0
	AuralFeedbackType_NavigationLeft = AuralFeedbackType_Click + 1;
	AuralFeedbackType_NavigationUp = AuralFeedbackType_NavigationLeft + 1;
	AuralFeedbackType_NavigationRight = AuralFeedbackType_NavigationUp + 1;
	AuralFeedbackType_NavigationDown = AuralFeedbackType_NavigationRight + 1;
)


type Activity interface {
	GetUserFeedback(inUserFeedback UserFeedback_Request) (err error)
	StartActivity(inIntent Intent) (err error)
	FinishCurrentActivity() (err error)
	SetTaskDescription(inDescription TaskDescription) (err error)
	SetSystemUiVisibility(inVisibility SystemUiVisibility) (err error)
	SetRequestedOrientation(inOrientation ScreenOrientation) (err error)
}



var activity_Name = "activity::Activity"

type Activity_Request bindings.InterfaceRequest

func (r *Activity_Request) Name() string {
	return activity_Name
}


type Activity_Pointer bindings.InterfacePointer

func (p *Activity_Pointer) Name() string {
	return activity_Name
}

type Activity_ServiceFactory struct{
	Delegate Activity_Factory
}

type Activity_Factory interface {
	Create(request Activity_Request)
}

func (f *Activity_ServiceFactory) Name() string {
	return activity_Name
}

// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *Activity_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &Activity_ServiceDescription{}
}

func (f *Activity_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := Activity_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForActivity creates a message pipe for use with the
// Activity interface with a Activity_Request on one end and a Activity_Pointer on the other.
func CreateMessagePipeForActivity() (Activity_Request, Activity_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return Activity_Request(r), Activity_Pointer(p)
}

const activity_GetUserFeedback_Name uint32 = 0
const activity_StartActivity_Name uint32 = 1
const activity_FinishCurrentActivity_Name uint32 = 2
const activity_SetTaskDescription_Name uint32 = 3
const activity_SetSystemUiVisibility_Name uint32 = 4
const activity_SetRequestedOrientation_Name uint32 = 5

type Activity_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewActivityProxy(p Activity_Pointer, waiter bindings.AsyncWaiter) *Activity_Proxy {
	return &Activity_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *Activity_Proxy) Close_Proxy() {
	p.router.Close()
}

type activity_GetUserFeedback_Params struct {
	inUserFeedback UserFeedback_Request
}


func (s *activity_GetUserFeedback_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteHandle(s.inUserFeedback.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var activity_GetUserFeedback_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *activity_GetUserFeedback_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(activity_GetUserFeedback_Params_Versions), func(i int) bool {
		return activity_GetUserFeedback_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(activity_GetUserFeedback_Params_Versions) {
		if activity_GetUserFeedback_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := activity_GetUserFeedback_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inUserFeedback = UserFeedback_Request{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Activity_Proxy) GetUserFeedback(inUserFeedback UserFeedback_Request) (err error) {
	payload := &activity_GetUserFeedback_Params{
		inUserFeedback,
	}
	header := bindings.MessageHeader{
		Type: activity_GetUserFeedback_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type activity_StartActivity_Params struct {
	inIntent Intent
}


func (s *activity_StartActivity_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inIntent.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var activity_StartActivity_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *activity_StartActivity_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(activity_StartActivity_Params_Versions), func(i int) bool {
		return activity_StartActivity_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(activity_StartActivity_Params_Versions) {
		if activity_StartActivity_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := activity_StartActivity_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inIntent.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Activity_Proxy) StartActivity(inIntent Intent) (err error) {
	payload := &activity_StartActivity_Params{
		inIntent,
	}
	header := bindings.MessageHeader{
		Type: activity_StartActivity_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type activity_FinishCurrentActivity_Params struct {
}


func (s *activity_FinishCurrentActivity_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var activity_FinishCurrentActivity_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *activity_FinishCurrentActivity_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(activity_FinishCurrentActivity_Params_Versions), func(i int) bool {
		return activity_FinishCurrentActivity_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(activity_FinishCurrentActivity_Params_Versions) {
		if activity_FinishCurrentActivity_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := activity_FinishCurrentActivity_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Activity_Proxy) FinishCurrentActivity() (err error) {
	payload := &activity_FinishCurrentActivity_Params{
	}
	header := bindings.MessageHeader{
		Type: activity_FinishCurrentActivity_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type activity_SetTaskDescription_Params struct {
	inDescription TaskDescription
}


func (s *activity_SetTaskDescription_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inDescription.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var activity_SetTaskDescription_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *activity_SetTaskDescription_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(activity_SetTaskDescription_Params_Versions), func(i int) bool {
		return activity_SetTaskDescription_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(activity_SetTaskDescription_Params_Versions) {
		if activity_SetTaskDescription_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := activity_SetTaskDescription_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inDescription.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Activity_Proxy) SetTaskDescription(inDescription TaskDescription) (err error) {
	payload := &activity_SetTaskDescription_Params{
		inDescription,
	}
	header := bindings.MessageHeader{
		Type: activity_SetTaskDescription_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type activity_SetSystemUIVisibility_Params struct {
	inVisibility SystemUiVisibility
}


func (s *activity_SetSystemUIVisibility_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.inVisibility)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var activity_SetSystemUIVisibility_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *activity_SetSystemUIVisibility_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(activity_SetSystemUIVisibility_Params_Versions), func(i int) bool {
		return activity_SetSystemUIVisibility_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(activity_SetSystemUIVisibility_Params_Versions) {
		if activity_SetSystemUIVisibility_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := activity_SetSystemUIVisibility_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inVisibility = SystemUiVisibility(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Activity_Proxy) SetSystemUiVisibility(inVisibility SystemUiVisibility) (err error) {
	payload := &activity_SetSystemUIVisibility_Params{
		inVisibility,
	}
	header := bindings.MessageHeader{
		Type: activity_SetSystemUiVisibility_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type activity_SetRequestedOrientation_Params struct {
	inOrientation ScreenOrientation
}


func (s *activity_SetRequestedOrientation_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.inOrientation)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var activity_SetRequestedOrientation_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *activity_SetRequestedOrientation_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(activity_SetRequestedOrientation_Params_Versions), func(i int) bool {
		return activity_SetRequestedOrientation_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(activity_SetRequestedOrientation_Params_Versions) {
		if activity_SetRequestedOrientation_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := activity_SetRequestedOrientation_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inOrientation = ScreenOrientation(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Activity_Proxy) SetRequestedOrientation(inOrientation ScreenOrientation) (err error) {
	payload := &activity_SetRequestedOrientation_Params{
		inOrientation,
	}
	header := bindings.MessageHeader{
		Type: activity_SetRequestedOrientation_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type activity_Stub struct {
	connector *bindings.Connector
	impl Activity
}

func NewActivityStub(r Activity_Request, impl Activity, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &activity_Stub{connector, impl})
}


func (f *Activity_Request) ServiceDescription() service_describer.ServiceDescription {
	return &Activity_ServiceDescription{}
}


type Activity_ServiceDescription struct{}

func (sd *Activity_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *Activity_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *Activity_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*Activity_ServiceDescription)(nil)


func (s *activity_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case activity_GetUserFeedback_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request activity_GetUserFeedback_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.GetUserFeedback(request.inUserFeedback)
		if err != nil {
			return
		}
	case activity_StartActivity_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request activity_StartActivity_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.StartActivity(request.inIntent)
		if err != nil {
			return
		}
	case activity_FinishCurrentActivity_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request activity_FinishCurrentActivity_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.FinishCurrentActivity()
		if err != nil {
			return
		}
	case activity_SetTaskDescription_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request activity_SetTaskDescription_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SetTaskDescription(request.inDescription)
		if err != nil {
			return
		}
	case activity_SetSystemUiVisibility_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request activity_SetSystemUIVisibility_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SetSystemUiVisibility(request.inVisibility)
		if err != nil {
			return
		}
	case activity_SetRequestedOrientation_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request activity_SetRequestedOrientation_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SetRequestedOrientation(request.inOrientation)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type PathService interface {
	GetAppDataDir() (outPath string, err error)
	GetFilesDir() (outPath string, err error)
	GetCacheDir() (outPath string, err error)
}



var pathService_Name = "activity::PathService"

type PathService_Request bindings.InterfaceRequest

func (r *PathService_Request) Name() string {
	return pathService_Name
}


type PathService_Pointer bindings.InterfacePointer

func (p *PathService_Pointer) Name() string {
	return pathService_Name
}

type PathService_ServiceFactory struct{
	Delegate PathService_Factory
}

type PathService_Factory interface {
	Create(request PathService_Request)
}

func (f *PathService_ServiceFactory) Name() string {
	return pathService_Name
}

// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *PathService_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &PathService_ServiceDescription{}
}

func (f *PathService_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := PathService_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForPathService creates a message pipe for use with the
// PathService interface with a PathService_Request on one end and a PathService_Pointer on the other.
func CreateMessagePipeForPathService() (PathService_Request, PathService_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return PathService_Request(r), PathService_Pointer(p)
}

const pathService_GetAppDataDir_Name uint32 = 0
const pathService_GetFilesDir_Name uint32 = 1
const pathService_GetCacheDir_Name uint32 = 2

type PathService_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewPathServiceProxy(p PathService_Pointer, waiter bindings.AsyncWaiter) *PathService_Proxy {
	return &PathService_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *PathService_Proxy) Close_Proxy() {
	p.router.Close()
}

type pathService_GetAppDataDir_Params struct {
}


func (s *pathService_GetAppDataDir_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var pathService_GetAppDataDir_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *pathService_GetAppDataDir_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(pathService_GetAppDataDir_Params_Versions), func(i int) bool {
		return pathService_GetAppDataDir_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(pathService_GetAppDataDir_Params_Versions) {
		if pathService_GetAppDataDir_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := pathService_GetAppDataDir_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type pathService_GetAppDataDir_ResponseParams struct {
	outPath string
}


func (s *pathService_GetAppDataDir_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.outPath); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var pathService_GetAppDataDir_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *pathService_GetAppDataDir_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(pathService_GetAppDataDir_ResponseParams_Versions), func(i int) bool {
		return pathService_GetAppDataDir_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(pathService_GetAppDataDir_ResponseParams_Versions) {
		if pathService_GetAppDataDir_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := pathService_GetAppDataDir_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.outPath = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *PathService_Proxy) GetAppDataDir() (outPath string, err error) {
	payload := &pathService_GetAppDataDir_Params{
	}
	header := bindings.MessageHeader{
		Type: pathService_GetAppDataDir_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, pathService_GetAppDataDir_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response pathService_GetAppDataDir_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outPath = response.outPath
	return
}

type pathService_GetFilesDir_Params struct {
}


func (s *pathService_GetFilesDir_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var pathService_GetFilesDir_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *pathService_GetFilesDir_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(pathService_GetFilesDir_Params_Versions), func(i int) bool {
		return pathService_GetFilesDir_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(pathService_GetFilesDir_Params_Versions) {
		if pathService_GetFilesDir_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := pathService_GetFilesDir_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type pathService_GetFilesDir_ResponseParams struct {
	outPath string
}


func (s *pathService_GetFilesDir_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.outPath); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var pathService_GetFilesDir_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *pathService_GetFilesDir_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(pathService_GetFilesDir_ResponseParams_Versions), func(i int) bool {
		return pathService_GetFilesDir_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(pathService_GetFilesDir_ResponseParams_Versions) {
		if pathService_GetFilesDir_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := pathService_GetFilesDir_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.outPath = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *PathService_Proxy) GetFilesDir() (outPath string, err error) {
	payload := &pathService_GetFilesDir_Params{
	}
	header := bindings.MessageHeader{
		Type: pathService_GetFilesDir_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, pathService_GetFilesDir_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response pathService_GetFilesDir_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outPath = response.outPath
	return
}

type pathService_GetCacheDir_Params struct {
}


func (s *pathService_GetCacheDir_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var pathService_GetCacheDir_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *pathService_GetCacheDir_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(pathService_GetCacheDir_Params_Versions), func(i int) bool {
		return pathService_GetCacheDir_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(pathService_GetCacheDir_Params_Versions) {
		if pathService_GetCacheDir_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := pathService_GetCacheDir_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type pathService_GetCacheDir_ResponseParams struct {
	outPath string
}


func (s *pathService_GetCacheDir_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.outPath); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var pathService_GetCacheDir_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *pathService_GetCacheDir_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(pathService_GetCacheDir_ResponseParams_Versions), func(i int) bool {
		return pathService_GetCacheDir_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(pathService_GetCacheDir_ResponseParams_Versions) {
		if pathService_GetCacheDir_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := pathService_GetCacheDir_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.outPath = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *PathService_Proxy) GetCacheDir() (outPath string, err error) {
	payload := &pathService_GetCacheDir_Params{
	}
	header := bindings.MessageHeader{
		Type: pathService_GetCacheDir_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, pathService_GetCacheDir_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response pathService_GetCacheDir_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outPath = response.outPath
	return
}

type pathService_Stub struct {
	connector *bindings.Connector
	impl PathService
}

func NewPathServiceStub(r PathService_Request, impl PathService, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &pathService_Stub{connector, impl})
}


func (f *PathService_Request) ServiceDescription() service_describer.ServiceDescription {
	return &PathService_ServiceDescription{}
}


type PathService_ServiceDescription struct{}

func (sd *PathService_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *PathService_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *PathService_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*PathService_ServiceDescription)(nil)


func (s *pathService_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case pathService_GetAppDataDir_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request pathService_GetAppDataDir_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response pathService_GetAppDataDir_ResponseParams
		response.outPath, err = s.impl.GetAppDataDir()
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: pathService_GetAppDataDir_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case pathService_GetFilesDir_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request pathService_GetFilesDir_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response pathService_GetFilesDir_ResponseParams
		response.outPath, err = s.impl.GetFilesDir()
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: pathService_GetFilesDir_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case pathService_GetCacheDir_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request pathService_GetCacheDir_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response pathService_GetCacheDir_ResponseParams
		response.outPath, err = s.impl.GetCacheDir()
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: pathService_GetCacheDir_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type UserFeedback interface {
	PerformHapticFeedback(inType HapticFeedbackType) (err error)
	PerformAuralFeedback(inType AuralFeedbackType) (err error)
}




type UserFeedback_Request bindings.InterfaceRequest



type UserFeedback_Pointer bindings.InterfacePointer


type UserFeedback_ServiceFactory struct{
	Delegate UserFeedback_Factory
}

type UserFeedback_Factory interface {
	Create(request UserFeedback_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *UserFeedback_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &UserFeedback_ServiceDescription{}
}

func (f *UserFeedback_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := UserFeedback_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForUserFeedback creates a message pipe for use with the
// UserFeedback interface with a UserFeedback_Request on one end and a UserFeedback_Pointer on the other.
func CreateMessagePipeForUserFeedback() (UserFeedback_Request, UserFeedback_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return UserFeedback_Request(r), UserFeedback_Pointer(p)
}

const userFeedback_PerformHapticFeedback_Name uint32 = 0
const userFeedback_PerformAuralFeedback_Name uint32 = 1

type UserFeedback_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewUserFeedbackProxy(p UserFeedback_Pointer, waiter bindings.AsyncWaiter) *UserFeedback_Proxy {
	return &UserFeedback_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *UserFeedback_Proxy) Close_Proxy() {
	p.router.Close()
}

type userFeedback_PerformHapticFeedback_Params struct {
	inType HapticFeedbackType
}


func (s *userFeedback_PerformHapticFeedback_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.inType)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var userFeedback_PerformHapticFeedback_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *userFeedback_PerformHapticFeedback_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(userFeedback_PerformHapticFeedback_Params_Versions), func(i int) bool {
		return userFeedback_PerformHapticFeedback_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(userFeedback_PerformHapticFeedback_Params_Versions) {
		if userFeedback_PerformHapticFeedback_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := userFeedback_PerformHapticFeedback_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inType = HapticFeedbackType(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *UserFeedback_Proxy) PerformHapticFeedback(inType HapticFeedbackType) (err error) {
	payload := &userFeedback_PerformHapticFeedback_Params{
		inType,
	}
	header := bindings.MessageHeader{
		Type: userFeedback_PerformHapticFeedback_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type userFeedback_PerformAuralFeedback_Params struct {
	inType AuralFeedbackType
}


func (s *userFeedback_PerformAuralFeedback_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.inType)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var userFeedback_PerformAuralFeedback_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *userFeedback_PerformAuralFeedback_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(userFeedback_PerformAuralFeedback_Params_Versions), func(i int) bool {
		return userFeedback_PerformAuralFeedback_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(userFeedback_PerformAuralFeedback_Params_Versions) {
		if userFeedback_PerformAuralFeedback_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := userFeedback_PerformAuralFeedback_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inType = AuralFeedbackType(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *UserFeedback_Proxy) PerformAuralFeedback(inType AuralFeedbackType) (err error) {
	payload := &userFeedback_PerformAuralFeedback_Params{
		inType,
	}
	header := bindings.MessageHeader{
		Type: userFeedback_PerformAuralFeedback_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type userFeedback_Stub struct {
	connector *bindings.Connector
	impl UserFeedback
}

func NewUserFeedbackStub(r UserFeedback_Request, impl UserFeedback, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &userFeedback_Stub{connector, impl})
}


func (f *UserFeedback_Request) ServiceDescription() service_describer.ServiceDescription {
	return &UserFeedback_ServiceDescription{}
}


type UserFeedback_ServiceDescription struct{}

func (sd *UserFeedback_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *UserFeedback_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *UserFeedback_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*UserFeedback_ServiceDescription)(nil)


func (s *userFeedback_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case userFeedback_PerformHapticFeedback_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request userFeedback_PerformHapticFeedback_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.PerformHapticFeedback(request.inType)
		if err != nil {
			return
		}
	case userFeedback_PerformAuralFeedback_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request userFeedback_PerformAuralFeedback_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.PerformAuralFeedback(request.inType)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type StringExtra struct {
	Name string
	Value string
}


func (s *StringExtra) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.Name); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.Value); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var stringExtra_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *StringExtra) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(stringExtra_Versions), func(i int) bool {
		return stringExtra_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(stringExtra_Versions) {
		if stringExtra_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := stringExtra_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.Name = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.Value = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type ComponentName struct {
	PackageName string
	ClassName string
}


func (s *ComponentName) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.PackageName); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.ClassName); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var componentName_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *ComponentName) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(componentName_Versions), func(i int) bool {
		return componentName_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(componentName_Versions) {
		if componentName_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := componentName_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.PackageName = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.ClassName = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type Intent struct {
	Action string
	Url string
	Flags uint32
	Component *ComponentName
	StringExtras *[]StringExtra
	Type *string
}


func (s *Intent) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(48, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.Action); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.Url); err != nil {
		return err
	}
	if err := encoder.WriteUint32(s.Flags); err != nil {
		return err
	}
	if s.Component == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.Component).Encode(encoder); err != nil {
			return err
		}
	}
	if s.StringExtras == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.StringExtras))), 64)
		for _, elem0 := range (*s.StringExtras) {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem0.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if s.Type == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.Type)); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var intent_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{56, 0},
}

func (s *Intent) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(intent_Versions), func(i int) bool {
		return intent_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(intent_Versions) {
		if intent_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := intent_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.Action = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.Url = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.Flags = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Component = nil
		} else {
			s.Component = new(ComponentName)
			if err := (*s.Component).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.StringExtras = nil
		} else {
			s.StringExtras = new([]StringExtra)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.StringExtras) = make([]StringExtra, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := (*s.StringExtras)[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Type = nil
		} else {
			s.Type = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.Type) = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type TaskDescription struct {
	Label *string
	PrimaryColor uint32
}


func (s *TaskDescription) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.Label == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.Label)); err != nil {
			return err
		}
	}
	if err := encoder.WriteUint32(s.PrimaryColor); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var taskDescription_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *TaskDescription) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(taskDescription_Versions), func(i int) bool {
		return taskDescription_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(taskDescription_Versions) {
		if taskDescription_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := taskDescription_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Label = nil
		} else {
			s.Label = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.Label) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint32()
		if err != nil {
			return err
		}
		s.PrimaryColor = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

