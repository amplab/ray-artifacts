// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/services/files/interfaces/types.mojom
//

package types

import (
	sort "sort"
	fmt "fmt"
	bindings "mojo/public/go/bindings"
)


type Error int32

const (
	Error_Ok Error = 0
	Error_Unknown = Error_Ok + 1;
	Error_InvalidArgument = Error_Unknown + 1;
	Error_PermissionDenied = Error_InvalidArgument + 1;
	Error_OutOfRange = Error_PermissionDenied + 1;
	Error_Unimplemented = Error_OutOfRange + 1;
	Error_Closed = Error_Unimplemented + 1;
	Error_Unavailable = Error_Closed + 1;
	Error_Internal = Error_Unavailable + 1;
)


type Whence int32

const (
	Whence_FromCurrent Whence = 0
	Whence_FromStart = Whence_FromCurrent + 1;
	Whence_FromEnd = Whence_FromStart + 1;
)


type FileType int32

const (
	FileType_Unknown FileType = 0
	FileType_RegularFile = FileType_Unknown + 1;
	FileType_Directory = FileType_RegularFile + 1;
)


type Timespec struct {
	Seconds int64
	Nanoseconds int32
}


func (s *Timespec) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInt64(s.Seconds); err != nil {
		return err
	}
	if err := encoder.WriteInt32(s.Nanoseconds); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var timespec_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *Timespec) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(timespec_Versions), func(i int) bool {
		return timespec_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(timespec_Versions) {
		if timespec_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := timespec_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.Seconds = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Nanoseconds = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type TimespecOrNow struct {
	Now bool
	Timespec *Timespec
}


func (s *TimespecOrNow) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteBool(s.Now); err != nil {
		return err
	}
	if s.Timespec == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.Timespec).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var timespecOrNow_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *TimespecOrNow) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(timespecOrNow_Versions), func(i int) bool {
		return timespecOrNow_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(timespecOrNow_Versions) {
		if timespecOrNow_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := timespecOrNow_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.Now = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Timespec = nil
		} else {
			s.Timespec = new(Timespec)
			if err := (*s.Timespec).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type FileInformation struct {
	Type FileType
	Size int64
	Atime *Timespec
	Mtime *Timespec
}


func (s *FileInformation) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WriteInt32(int32(s.Type)); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.Size); err != nil {
		return err
	}
	if s.Atime == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.Atime).Encode(encoder); err != nil {
			return err
		}
	}
	if s.Mtime == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.Mtime).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var fileInformation_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *FileInformation) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(fileInformation_Versions), func(i int) bool {
		return fileInformation_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(fileInformation_Versions) {
		if fileInformation_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := fileInformation_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Type = FileType(value0)
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.Size = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Atime = nil
		} else {
			s.Atime = new(Timespec)
			if err := (*s.Atime).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Mtime = nil
		} else {
			s.Mtime = new(Timespec)
			if err := (*s.Mtime).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type DirectoryEntry struct {
	Type FileType
	Name string
}


func (s *DirectoryEntry) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInt32(int32(s.Type)); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.Name); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var directoryEntry_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *DirectoryEntry) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(directoryEntry_Versions), func(i int) bool {
		return directoryEntry_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(directoryEntry_Versions) {
		if directoryEntry_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := directoryEntry_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Type = FileType(value0)
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.Name = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

