// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/public/interfaces/bindings/tests/validation_test_interfaces.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace mojo {
namespace test {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// static
StructA_Data* StructA_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructA_Data))) StructA_Data();
}

// static
mojo::internal::ValidationError StructA_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructA_Data* object = static_cast<const StructA_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void StructA_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void StructA_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

StructA_Data::StructA_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructB_Data* StructB_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructB_Data))) StructB_Data();
}

// static
mojo::internal::ValidationError StructB_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructB_Data* object = static_cast<const StructB_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->struct_a.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null struct_a field in StructB struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->struct_a.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = StructA::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->struct_a.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructB_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->struct_a, handles);
}

void StructB_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->struct_a, handles);
}

StructB_Data::StructB_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructC_Data* StructC_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructC_Data))) StructC_Data();
}

// static
mojo::internal::ValidationError StructC_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructC_Data* object = static_cast<const StructC_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->data.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null data field in StructC struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams data_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<uint8_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->data.offset),
          bounds_checker, &data_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructC_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->data, handles);
}

void StructC_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->data, handles);
}

StructC_Data::StructC_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructD_Data* StructD_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructD_Data))) StructD_Data();
}

// static
mojo::internal::ValidationError StructD_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructD_Data* object = static_cast<const StructD_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->message_pipes.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null message_pipes field in StructD struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->message_pipes.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams message_pipes_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<mojo::ScopedMessagePipeHandle>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->message_pipes.offset),
          bounds_checker, &message_pipes_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructD_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->message_pipes, handles);
}

void StructD_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->message_pipes, handles);
}

StructD_Data::StructD_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructE_Data* StructE_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructE_Data))) StructE_Data();
}

// static
mojo::internal::ValidationError StructE_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructE_Data* object = static_cast<const StructE_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->struct_d.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null struct_d field in StructE struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->struct_d.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = StructD::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->struct_d.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  const mojo::Handle data_pipe_consumer_handle = object->data_pipe_consumer;
  if (data_pipe_consumer_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid data_pipe_consumer field in StructE struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(data_pipe_consumer_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructE_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->struct_d, handles);
  mojo::internal::EncodeHandle(&this->data_pipe_consumer, handles);
}

void StructE_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->struct_d, handles);
  mojo::internal::DecodeHandle(&this->data_pipe_consumer, handles);
}

StructE_Data::StructE_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructF_Data* StructF_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructF_Data))) StructF_Data();
}

// static
mojo::internal::ValidationError StructF_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructF_Data* object = static_cast<const StructF_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->fixed_size_array.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null fixed_size_array field in StructF struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->fixed_size_array.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams fixed_size_array_validate_params(
      3, false, nullptr);
  auto validate_retval =
      mojo::Array<uint8_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->fixed_size_array.offset),
          bounds_checker, &fixed_size_array_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructF_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->fixed_size_array, handles);
}

void StructF_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->fixed_size_array, handles);
}

StructF_Data::StructF_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructG_Data* StructG_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructG_Data))) StructG_Data();
}

// static
mojo::internal::ValidationError StructG_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructG_Data* object = static_cast<const StructG_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }, { 1, 24 }, { 3, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  if (object->header_.version < 1)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->struct_a.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = StructA::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->struct_a.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  if (object->header_.version < 3)
    return mojo::internal::ValidationError::NONE;
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->str.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams str_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->str.offset),
          bounds_checker, &str_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructG_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 3);
  mojo::internal::Encode(&this->struct_a, handles);
  mojo::internal::Encode(&this->str, handles);
}

void StructG_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  if (header_.version < 1)
    return;
  mojo::internal::Decode(&this->struct_a, handles);
  if (header_.version < 3)
    return;
  mojo::internal::Decode(&this->str, handles);
}

StructG_Data::StructG_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 3;
}


// static
StructH_Data* StructH_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructH_Data))) StructH_Data();
}

// static
mojo::internal::ValidationError StructH_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructH_Data* object = static_cast<const StructH_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 48 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  auto validate_retval = UnionA::Data_::Validate(
          &object->c, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->d.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams d_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<UnionAPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->d.offset),
          bounds_checker, &d_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->e.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams e_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<uint8_t, UnionAPtr>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->e.offset),
              bounds_checker, &e_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructH_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  c.EncodePointersAndHandles(handles);
  mojo::internal::Encode(&this->d, handles);
  mojo::internal::Encode(&this->e, handles);
}

void StructH_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  c.DecodePointersAndHandles(handles);
  mojo::internal::Decode(&this->d, handles);
  mojo::internal::Decode(&this->e, handles);
}

StructH_Data::StructH_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
BasicStruct_Data* BasicStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(BasicStruct_Data))) BasicStruct_Data();
}

// static
mojo::internal::ValidationError BasicStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const BasicStruct_Data* object = static_cast<const BasicStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void BasicStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void BasicStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

BasicStruct_Data::BasicStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructWithEnum_Data* StructWithEnum_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructWithEnum_Data))) StructWithEnum_Data();
}

// static
mojo::internal::ValidationError StructWithEnum_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructWithEnum_Data* object = static_cast<const StructWithEnum_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void StructWithEnum_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void StructWithEnum_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

StructWithEnum_Data::StructWithEnum_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// --- Union definitions ---
// static
UnionA_Data* UnionA_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(UnionA_Data))) UnionA_Data();
}


// static
mojo::internal::ValidationError UnionA_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(UnionA_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const UnionA_Data* object = static_cast<const UnionA_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case UnionA_Tag::A: {

        return mojo::internal::ValidationError::NONE;
    }
    case UnionA_Tag::B: {

        return mojo::internal::ValidationError::NONE;
    }
    case UnionA_Tag::C: {

        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::StructA_Data>*>(&object->data.f_c))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionA_Tag::D: {

        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::ArrayPointer<uint8_t>*>(&object->data.f_d))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }const mojo::internal::ArrayValidateParams d_validate_params(
            0, false, nullptr);
        auto validate_retval = mojo::Array<uint8_t>::Data_::Validate(
                mojo::internal::DecodePointerRaw(&(reinterpret_cast<const mojo::internal::ArrayPointer<uint8_t>*>(&object->data.f_d))->offset),
                bounds_checker, &d_validate_params,
                err);
        if (validate_retval != mojo::internal::ValidationError::NONE) {
          return validate_retval;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionA_Tag::E: {

        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<mojo::internal::Map_Data<mojo::internal::String_Data*, uint8_t>>*>(&object->data.f_e))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionA_Tag::F: {

        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::UnionPointer<internal::UnionB_Data>*>(&object->data.f_f))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionA_Tag::G: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<internal::StructA_Data>*>(&object->data.f_g))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'g' in 'UnionA'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<internal::StructA_Data>*>(&object->data.f_g))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionA_Tag::H: {

        if (!(reinterpret_cast<const mojo::internal::ArrayPointer<uint8_t>*>(&object->data.f_h))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'h' in 'UnionA'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::ArrayPointer<uint8_t>*>(&object->data.f_h))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }const mojo::internal::ArrayValidateParams h_validate_params(
            0, false, nullptr);
        auto validate_retval = mojo::Array<uint8_t>::Data_::Validate(
                mojo::internal::DecodePointerRaw(&(reinterpret_cast<const mojo::internal::ArrayPointer<uint8_t>*>(&object->data.f_h))->offset),
                bounds_checker, &h_validate_params,
                err);
        if (validate_retval != mojo::internal::ValidationError::NONE) {
          return validate_retval;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionA_Tag::I: {

        if (!(reinterpret_cast<const mojo::internal::StructPointer<mojo::internal::Map_Data<mojo::internal::String_Data*, uint8_t>>*>(&object->data.f_i))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'i' in 'UnionA'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::StructPointer<mojo::internal::Map_Data<mojo::internal::String_Data*, uint8_t>>*>(&object->data.f_i))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    case UnionA_Tag::J: {

        if (!(reinterpret_cast<const mojo::internal::UnionPointer<internal::UnionB_Data>*>(&object->data.f_j))->offset) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "null field 'j' in 'UnionA'"; 
          return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
        }
        
        if (!mojo::internal::ValidateEncodedPointer(&(reinterpret_cast<const mojo::internal::UnionPointer<internal::UnionB_Data>*>(&object->data.f_j))->offset)) {
          MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
          return mojo::internal::ValidationError::ILLEGAL_POINTER;
        }
        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void UnionA_Data::set_null() {
  size = 0U;
  tag = static_cast<UnionA_Tag>(0);
  data.unknown = 0U;
}

UnionA_Data::UnionA_Data() {
}

void UnionA_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case UnionA_Tag::A: {
      return;
    }
    case UnionA_Tag::B: {
      return;
    }
    case UnionA_Tag::C: {
      mojo::internal::Encode(&data.f_c, handles);
      return;
    }
    case UnionA_Tag::D: {
      mojo::internal::Encode(&data.f_d, handles);
      return;
    }
    case UnionA_Tag::E: {
      mojo::internal::Encode(&data.f_e, handles);
      return;
    }
    case UnionA_Tag::F: {
      mojo::internal::Encode(&data.f_f, handles);
      return;
    }
    case UnionA_Tag::G: {
      mojo::internal::Encode(&data.f_g, handles);
      return;
    }
    case UnionA_Tag::H: {
      mojo::internal::Encode(&data.f_h, handles);
      return;
    }
    case UnionA_Tag::I: {
      mojo::internal::Encode(&data.f_i, handles);
      return;
    }
    case UnionA_Tag::J: {
      mojo::internal::Encode(&data.f_j, handles);
      return;
    }
    case UnionA_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void UnionA_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case UnionA_Tag::A: {
      return;
    }
    case UnionA_Tag::B: {
      return;
    }
    case UnionA_Tag::C: {
      mojo::internal::Decode(&data.f_c, handles);
      return;
    }
    case UnionA_Tag::D: {
      mojo::internal::Decode(&data.f_d, handles);
      return;
    }
    case UnionA_Tag::E: {
      mojo::internal::Decode(&data.f_e, handles);
      return;
    }
    case UnionA_Tag::F: {
      mojo::internal::Decode(&data.f_f, handles);
      return;
    }
    case UnionA_Tag::G: {
      mojo::internal::Decode(&data.f_g, handles);
      return;
    }
    case UnionA_Tag::H: {
      mojo::internal::Decode(&data.f_h, handles);
      return;
    }
    case UnionA_Tag::I: {
      mojo::internal::Decode(&data.f_i, handles);
      return;
    }
    case UnionA_Tag::J: {
      mojo::internal::Decode(&data.f_j, handles);
      return;
    }
    default:
      return;
  }
}
// static
UnionB_Data* UnionB_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(UnionB_Data))) UnionB_Data();
}


// static
mojo::internal::ValidationError UnionB_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    bool inlined,
    std::string* err) {
  if (!data)
    return mojo::internal::ValidationError::NONE;

  if (!mojo::internal::IsAligned(data)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::MISALIGNED_OBJECT;
  }

  // If the union is inlined in another structure its memory was already claimed.
  // This ONLY applies to the union itself, NOT anything which the union points
  // to.
  if (!inlined && !bounds_checker->ClaimMemory(data, sizeof(UnionB_Data))) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_MEMORY_RANGE;
  }

  const UnionB_Data* object = static_cast<const UnionB_Data*>(data);
  MOJO_ALLOW_UNUSED_LOCAL(object);

  if (object->is_null())
    return mojo::internal::ValidationError::NONE;

  switch (object->tag) {

    case UnionB_Tag::A: {

        return mojo::internal::ValidationError::NONE;
    }
    case UnionB_Tag::B: {

        return mojo::internal::ValidationError::NONE;
    }
    case UnionB_Tag::C: {

        return mojo::internal::ValidationError::NONE;
    }
    case UnionB_Tag::D: {

        return mojo::internal::ValidationError::NONE;
    }
    default:
      // Unknown tags should not cause validation to fail.
      break;
  }
  return mojo::internal::ValidationError::NONE;
}

void UnionB_Data::set_null() {
  size = 0U;
  tag = static_cast<UnionB_Tag>(0);
  data.unknown = 0U;
}

UnionB_Data::UnionB_Data() {
}

void UnionB_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case UnionB_Tag::A: {
      return;
    }
    case UnionB_Tag::B: {
      return;
    }
    case UnionB_Tag::C: {
      return;
    }
    case UnionB_Tag::D: {
      return;
    }
    case UnionB_Tag::__UNKNOWN__: {
      MOJO_DCHECK(false) << "No sane way to serialize a union with an unknown tag.";
      break;
    }
  }
}

void UnionB_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  switch (tag) {
    case UnionB_Tag::A: {
      return;
    }
    case UnionB_Tag::B: {
      return;
    }
    case UnionB_Tag::C: {
      return;
    }
    case UnionB_Tag::D: {
      return;
    }
    default:
      return;
  }
}


// --- Definitions of the data structs for interface methods ---


// static
BoundsCheckTestInterface_Method0_Params_Data* BoundsCheckTestInterface_Method0_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(BoundsCheckTestInterface_Method0_Params_Data))) BoundsCheckTestInterface_Method0_Params_Data();
}

// static
mojo::internal::ValidationError BoundsCheckTestInterface_Method0_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const BoundsCheckTestInterface_Method0_Params_Data* object = static_cast<const BoundsCheckTestInterface_Method0_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void BoundsCheckTestInterface_Method0_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void BoundsCheckTestInterface_Method0_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

BoundsCheckTestInterface_Method0_Params_Data::BoundsCheckTestInterface_Method0_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
BoundsCheckTestInterface_Method0_ResponseParams_Data* BoundsCheckTestInterface_Method0_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(BoundsCheckTestInterface_Method0_ResponseParams_Data))) BoundsCheckTestInterface_Method0_ResponseParams_Data();
}

// static
mojo::internal::ValidationError BoundsCheckTestInterface_Method0_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const BoundsCheckTestInterface_Method0_ResponseParams_Data* object = static_cast<const BoundsCheckTestInterface_Method0_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void BoundsCheckTestInterface_Method0_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void BoundsCheckTestInterface_Method0_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

BoundsCheckTestInterface_Method0_ResponseParams_Data::BoundsCheckTestInterface_Method0_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
BoundsCheckTestInterface_Method1_Params_Data* BoundsCheckTestInterface_Method1_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(BoundsCheckTestInterface_Method1_Params_Data))) BoundsCheckTestInterface_Method1_Params_Data();
}

// static
mojo::internal::ValidationError BoundsCheckTestInterface_Method1_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const BoundsCheckTestInterface_Method1_Params_Data* object = static_cast<const BoundsCheckTestInterface_Method1_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void BoundsCheckTestInterface_Method1_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void BoundsCheckTestInterface_Method1_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

BoundsCheckTestInterface_Method1_Params_Data::BoundsCheckTestInterface_Method1_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method0_Params_Data* ConformanceTestInterface_Method0_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method0_Params_Data))) ConformanceTestInterface_Method0_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method0_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method0_Params_Data* object = static_cast<const ConformanceTestInterface_Method0_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method0_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void ConformanceTestInterface_Method0_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

ConformanceTestInterface_Method0_Params_Data::ConformanceTestInterface_Method0_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method1_Params_Data* ConformanceTestInterface_Method1_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method1_Params_Data))) ConformanceTestInterface_Method1_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method1_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method1_Params_Data* object = static_cast<const ConformanceTestInterface_Method1_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->param0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in ConformanceTestInterface_Method1_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = StructA::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param0.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method1_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
}

void ConformanceTestInterface_Method1_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
}

ConformanceTestInterface_Method1_Params_Data::ConformanceTestInterface_Method1_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method2_Params_Data* ConformanceTestInterface_Method2_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method2_Params_Data))) ConformanceTestInterface_Method2_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method2_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method2_Params_Data* object = static_cast<const ConformanceTestInterface_Method2_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->param0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in ConformanceTestInterface_Method2_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = StructB::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param0.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->param1.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param1 field in ConformanceTestInterface_Method2_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param1.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = StructA::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param1.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method2_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
  mojo::internal::Encode(&this->param1, handles);
}

void ConformanceTestInterface_Method2_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
  mojo::internal::Decode(&this->param1, handles);
}

ConformanceTestInterface_Method2_Params_Data::ConformanceTestInterface_Method2_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method3_Params_Data* ConformanceTestInterface_Method3_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method3_Params_Data))) ConformanceTestInterface_Method3_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method3_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method3_Params_Data* object = static_cast<const ConformanceTestInterface_Method3_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->param0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in ConformanceTestInterface_Method3_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams param0_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<bool>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param0.offset),
          bounds_checker, &param0_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method3_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
}

void ConformanceTestInterface_Method3_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
}

ConformanceTestInterface_Method3_Params_Data::ConformanceTestInterface_Method3_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method4_Params_Data* ConformanceTestInterface_Method4_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method4_Params_Data))) ConformanceTestInterface_Method4_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method4_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method4_Params_Data* object = static_cast<const ConformanceTestInterface_Method4_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->param0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in ConformanceTestInterface_Method4_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = StructC::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param0.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->param1.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param1 field in ConformanceTestInterface_Method4_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param1.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams param1_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<uint8_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param1.offset),
          bounds_checker, &param1_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method4_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
  mojo::internal::Encode(&this->param1, handles);
}

void ConformanceTestInterface_Method4_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
  mojo::internal::Decode(&this->param1, handles);
}

ConformanceTestInterface_Method4_Params_Data::ConformanceTestInterface_Method4_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method5_Params_Data* ConformanceTestInterface_Method5_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method5_Params_Data))) ConformanceTestInterface_Method5_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method5_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method5_Params_Data* object = static_cast<const ConformanceTestInterface_Method5_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->param0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in ConformanceTestInterface_Method5_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = StructE::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param0.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  const mojo::Handle param1_handle = object->param1;
  if (param1_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid param1 field in ConformanceTestInterface_Method5_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(param1_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method5_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
  mojo::internal::EncodeHandle(&this->param1, handles);
}

void ConformanceTestInterface_Method5_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
  mojo::internal::DecodeHandle(&this->param1, handles);
}

ConformanceTestInterface_Method5_Params_Data::ConformanceTestInterface_Method5_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method6_Params_Data* ConformanceTestInterface_Method6_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method6_Params_Data))) ConformanceTestInterface_Method6_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method6_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method6_Params_Data* object = static_cast<const ConformanceTestInterface_Method6_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->param0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in ConformanceTestInterface_Method6_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams param0_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::Array<uint8_t> >::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param0.offset),
          bounds_checker, &param0_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method6_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
}

void ConformanceTestInterface_Method6_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
}

ConformanceTestInterface_Method6_Params_Data::ConformanceTestInterface_Method6_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method7_Params_Data* ConformanceTestInterface_Method7_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method7_Params_Data))) ConformanceTestInterface_Method7_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method7_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method7_Params_Data* object = static_cast<const ConformanceTestInterface_Method7_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->param0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in ConformanceTestInterface_Method7_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = StructF::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param0.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->param1.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param1 field in ConformanceTestInterface_Method7_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param1.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams param1_validate_params(
      2, true, new mojo::internal::ArrayValidateParams(3, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::Array<uint8_t> >::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param1.offset),
          bounds_checker, &param1_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method7_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
  mojo::internal::Encode(&this->param1, handles);
}

void ConformanceTestInterface_Method7_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
  mojo::internal::Decode(&this->param1, handles);
}

ConformanceTestInterface_Method7_Params_Data::ConformanceTestInterface_Method7_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method8_Params_Data* ConformanceTestInterface_Method8_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method8_Params_Data))) ConformanceTestInterface_Method8_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method8_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method8_Params_Data* object = static_cast<const ConformanceTestInterface_Method8_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->param0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in ConformanceTestInterface_Method8_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams param0_validate_params(
      0, true, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr)));
  auto validate_retval =
      mojo::Array<mojo::Array<mojo::String> >::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param0.offset),
          bounds_checker, &param0_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method8_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
}

void ConformanceTestInterface_Method8_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
}

ConformanceTestInterface_Method8_Params_Data::ConformanceTestInterface_Method8_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method9_Params_Data* ConformanceTestInterface_Method9_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method9_Params_Data))) ConformanceTestInterface_Method9_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method9_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method9_Params_Data* object = static_cast<const ConformanceTestInterface_Method9_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams param0_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, true, nullptr));
  auto validate_retval =
      mojo::Array<mojo::Array<mojo::ScopedHandle> >::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param0.offset),
          bounds_checker, &param0_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method9_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
}

void ConformanceTestInterface_Method9_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
}

ConformanceTestInterface_Method9_Params_Data::ConformanceTestInterface_Method9_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method10_Params_Data* ConformanceTestInterface_Method10_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method10_Params_Data))) ConformanceTestInterface_Method10_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method10_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method10_Params_Data* object = static_cast<const ConformanceTestInterface_Method10_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->param0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in ConformanceTestInterface_Method10_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams param0_validate_params(
      0, false, nullptr);
  auto validate_retval = mojo::Map<mojo::String, uint8_t>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->param0.offset),
              bounds_checker, &param0_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method10_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
}

void ConformanceTestInterface_Method10_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
}

ConformanceTestInterface_Method10_Params_Data::ConformanceTestInterface_Method10_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method11_Params_Data* ConformanceTestInterface_Method11_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method11_Params_Data))) ConformanceTestInterface_Method11_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method11_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method11_Params_Data* object = static_cast<const ConformanceTestInterface_Method11_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->param0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in ConformanceTestInterface_Method11_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = StructG::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param0.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method11_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
}

void ConformanceTestInterface_Method11_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
}

ConformanceTestInterface_Method11_Params_Data::ConformanceTestInterface_Method11_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method12_Params_Data* ConformanceTestInterface_Method12_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method12_Params_Data))) ConformanceTestInterface_Method12_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method12_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method12_Params_Data* object = static_cast<const ConformanceTestInterface_Method12_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method12_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void ConformanceTestInterface_Method12_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

ConformanceTestInterface_Method12_Params_Data::ConformanceTestInterface_Method12_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
ConformanceTestInterface_Method12_ResponseParams_Data* ConformanceTestInterface_Method12_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method12_ResponseParams_Data))) ConformanceTestInterface_Method12_ResponseParams_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method12_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method12_ResponseParams_Data* object = static_cast<const ConformanceTestInterface_Method12_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method12_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void ConformanceTestInterface_Method12_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

ConformanceTestInterface_Method12_ResponseParams_Data::ConformanceTestInterface_Method12_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method13_Params_Data* ConformanceTestInterface_Method13_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method13_Params_Data))) ConformanceTestInterface_Method13_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method13_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method13_Params_Data* object = static_cast<const ConformanceTestInterface_Method13_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle param0_handle = object->param0.handle;
  if (!bounds_checker->ClaimHandle(param0_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  const mojo::Handle param2_handle = object->param2.handle;
  if (!bounds_checker->ClaimHandle(param2_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method13_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->param0, handles);
  mojo::internal::EncodeHandle(&this->param2, handles);
}

void ConformanceTestInterface_Method13_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->param0, handles);
  mojo::internal::DecodeHandle(&this->param2, handles);
}

ConformanceTestInterface_Method13_Params_Data::ConformanceTestInterface_Method13_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method14_Params_Data* ConformanceTestInterface_Method14_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method14_Params_Data))) ConformanceTestInterface_Method14_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method14_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method14_Params_Data* object = static_cast<const ConformanceTestInterface_Method14_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (object->param0.is_null()) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in ConformanceTestInterface_Method14_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  auto validate_retval = UnionA::Data_::Validate(
          &object->param0, bounds_checker, true, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method14_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  param0.EncodePointersAndHandles(handles);
}

void ConformanceTestInterface_Method14_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  param0.DecodePointersAndHandles(handles);
}

ConformanceTestInterface_Method14_Params_Data::ConformanceTestInterface_Method14_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
ConformanceTestInterface_Method15_Params_Data* ConformanceTestInterface_Method15_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(ConformanceTestInterface_Method15_Params_Data))) ConformanceTestInterface_Method15_Params_Data();
}

// static
mojo::internal::ValidationError ConformanceTestInterface_Method15_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ConformanceTestInterface_Method15_Params_Data* object = static_cast<const ConformanceTestInterface_Method15_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->param0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in ConformanceTestInterface_Method15_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = StructH::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param0.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void ConformanceTestInterface_Method15_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
}

void ConformanceTestInterface_Method15_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
}

ConformanceTestInterface_Method15_Params_Data::ConformanceTestInterface_Method15_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
IntegrationTestInterface_Method0_Params_Data* IntegrationTestInterface_Method0_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(IntegrationTestInterface_Method0_Params_Data))) IntegrationTestInterface_Method0_Params_Data();
}

// static
mojo::internal::ValidationError IntegrationTestInterface_Method0_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const IntegrationTestInterface_Method0_Params_Data* object = static_cast<const IntegrationTestInterface_Method0_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->param0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in IntegrationTestInterface_Method0_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = BasicStruct::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param0.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void IntegrationTestInterface_Method0_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
}

void IntegrationTestInterface_Method0_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
}

IntegrationTestInterface_Method0_Params_Data::IntegrationTestInterface_Method0_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
IntegrationTestInterface_Method0_ResponseParams_Data* IntegrationTestInterface_Method0_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(IntegrationTestInterface_Method0_ResponseParams_Data))) IntegrationTestInterface_Method0_ResponseParams_Data();
}

// static
mojo::internal::ValidationError IntegrationTestInterface_Method0_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const IntegrationTestInterface_Method0_ResponseParams_Data* object = static_cast<const IntegrationTestInterface_Method0_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->param0.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null param0 field in IntegrationTestInterface_Method0_ResponseParams struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->param0.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams param0_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<uint8_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->param0.offset),
          bounds_checker, &param0_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void IntegrationTestInterface_Method0_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->param0, handles);
}

void IntegrationTestInterface_Method0_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->param0, handles);
}

IntegrationTestInterface_Method0_ResponseParams_Data::IntegrationTestInterface_Method0_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


}  // namespace internal

// --- Request and response validator definitions for interfaces ---
mojo::internal::ValidationError InterfaceARequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'InterfaceA', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::InterfaceA_Base::MessageOrdinals method_ordinal =
      static_cast<internal::InterfaceA_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'InterfaceA'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError BoundsCheckTestInterfaceRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'BoundsCheckTestInterface', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::BoundsCheckTestInterface_Base::MessageOrdinals method_ordinal =
      static_cast<internal::BoundsCheckTestInterface_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::BoundsCheckTestInterface_Base::MessageOrdinals::Method0: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'BoundsCheckTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::BoundsCheckTestInterface_Method0_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'BoundsCheckTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::BoundsCheckTestInterface_Base::MessageOrdinals::Method1: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'BoundsCheckTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::BoundsCheckTestInterface_Method1_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'BoundsCheckTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'BoundsCheckTestInterface'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError BoundsCheckTestInterfaceResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'BoundsCheckTestInterface', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'BoundsCheckTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::BoundsCheckTestInterface_Base::MessageOrdinals method_ordinal =
      static_cast<internal::BoundsCheckTestInterface_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::BoundsCheckTestInterface_Base::MessageOrdinals::Method0: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::BoundsCheckTestInterface_Method0_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'BoundsCheckTestInterface',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'BoundsCheckTestInterface'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError ConformanceTestInterfaceRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'ConformanceTestInterface', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::ConformanceTestInterface_Base::MessageOrdinals method_ordinal =
      static_cast<internal::ConformanceTestInterface_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method0: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method0_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method1: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method1_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method2: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method2_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method3: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method3_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method4: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method4_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method5: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method5_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method6: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method6_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method7: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method7_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method8: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method8_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method9: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method9_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method10: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method10_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method11: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method11_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method12: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method12_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method13: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method13_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method14: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method14_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method15: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'ConformanceTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::ConformanceTestInterface_Method15_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'ConformanceTestInterface'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError ConformanceTestInterfaceResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'ConformanceTestInterface', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'ConformanceTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::ConformanceTestInterface_Base::MessageOrdinals method_ordinal =
      static_cast<internal::ConformanceTestInterface_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::ConformanceTestInterface_Base::MessageOrdinals::Method12: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::ConformanceTestInterface_Method12_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'ConformanceTestInterface',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'ConformanceTestInterface'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError IntegrationTestInterfaceRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'IntegrationTestInterface', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::IntegrationTestInterface_Base::MessageOrdinals method_ordinal =
      static_cast<internal::IntegrationTestInterface_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::IntegrationTestInterface_Base::MessageOrdinals::Method0: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'IntegrationTestInterface', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::IntegrationTestInterface_Method0_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'IntegrationTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'IntegrationTestInterface'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError IntegrationTestInterfaceResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'IntegrationTestInterface', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'IntegrationTestInterface', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::IntegrationTestInterface_Base::MessageOrdinals method_ordinal =
      static_cast<internal::IntegrationTestInterface_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::IntegrationTestInterface_Base::MessageOrdinals::Method0: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::IntegrationTestInterface_Method0_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'IntegrationTestInterface',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'IntegrationTestInterface'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
} 

// --- Enums ---
bool BasicEnum_IsValidValue(BasicEnum value) {
  switch (static_cast<int32_t>(value)) {
    case -3:
    case 0:
    case 1:
    case 10:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const BasicEnum& val) {
  return (stream << static_cast<int32_t>(val));
}

// Base interface definitions (Name_, Version_, Constants, Enums)
const uint32_t internal::InterfaceA_Base::Version_;

// Constants

// Enums
const char internal::BoundsCheckTestInterface_Base::Name_[] = "this.is.the.service.name.for.BoundsCheckTestInterface";
const uint32_t internal::BoundsCheckTestInterface_Base::Version_;

// Constants

// Enums
const uint32_t internal::ConformanceTestInterface_Base::Version_;

// Constants

// Enums
const uint32_t internal::IntegrationTestInterface_Base::Version_;

// Constants

// Enums

// Struct Constants

// --- Struct builder definitions ---

// static
StructAPtr StructA::New() {
  StructAPtr rv;
  mojo::internal::StructHelper<StructA>::Initialize(&rv);
  return rv;
}

StructA::StructA()
    : i() {
}

StructA::~StructA() {
}


StructAPtr StructA::Clone() const {
  StructAPtr rv(New());
  rv->i = i;
  return rv;
}


bool StructA::Equals(const StructA& other) const {
  if (!mojo::internal::ValueTraits<uint64_t>::Equals(this->i, other.i))
    return false;
  return true;
}


// static
StructBPtr StructB::New() {
  StructBPtr rv;
  mojo::internal::StructHelper<StructB>::Initialize(&rv);
  return rv;
}

StructB::StructB()
    : struct_a() {
}

StructB::~StructB() {
}


StructBPtr StructB::Clone() const {
  StructBPtr rv(New());
  rv->struct_a = struct_a.Clone();
  return rv;
}


bool StructB::Equals(const StructB& other) const {
  if (!mojo::internal::ValueTraits<StructAPtr>::Equals(this->struct_a, other.struct_a))
    return false;
  return true;
}


// static
StructCPtr StructC::New() {
  StructCPtr rv;
  mojo::internal::StructHelper<StructC>::Initialize(&rv);
  return rv;
}

StructC::StructC()
    : data() {
}

StructC::~StructC() {
}


StructCPtr StructC::Clone() const {
  StructCPtr rv(New());
  rv->data = data.Clone();
  return rv;
}


bool StructC::Equals(const StructC& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<uint8_t>>::Equals(this->data, other.data))
    return false;
  return true;
}


// static
StructDPtr StructD::New() {
  StructDPtr rv;
  mojo::internal::StructHelper<StructD>::Initialize(&rv);
  return rv;
}

StructD::StructD()
    : message_pipes() {
}

StructD::~StructD() {
}



bool StructD::Equals(const StructD& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::ScopedMessagePipeHandle>>::Equals(this->message_pipes, other.message_pipes))
    return false;
  return true;
}


// static
StructEPtr StructE::New() {
  StructEPtr rv;
  mojo::internal::StructHelper<StructE>::Initialize(&rv);
  return rv;
}

StructE::StructE()
    : struct_d(),
      data_pipe_consumer() {
}

StructE::~StructE() {
}



bool StructE::Equals(const StructE& other) const {
  if (!mojo::internal::ValueTraits<StructDPtr>::Equals(this->struct_d, other.struct_d))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedDataPipeConsumerHandle>::Equals(this->data_pipe_consumer, other.data_pipe_consumer))
    return false;
  return true;
}


// static
StructFPtr StructF::New() {
  StructFPtr rv;
  mojo::internal::StructHelper<StructF>::Initialize(&rv);
  return rv;
}

StructF::StructF()
    : fixed_size_array() {
}

StructF::~StructF() {
}


StructFPtr StructF::Clone() const {
  StructFPtr rv(New());
  rv->fixed_size_array = fixed_size_array.Clone();
  return rv;
}


bool StructF::Equals(const StructF& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<uint8_t>>::Equals(this->fixed_size_array, other.fixed_size_array))
    return false;
  return true;
}


// static
StructGPtr StructG::New() {
  StructGPtr rv;
  mojo::internal::StructHelper<StructG>::Initialize(&rv);
  return rv;
}

StructG::StructG()
    : i(),
      struct_a(),
      str(),
      b() {
}

StructG::~StructG() {
}


StructGPtr StructG::Clone() const {
  StructGPtr rv(New());
  rv->i = i;
  rv->struct_a = struct_a.Clone();
  rv->str = str;
  rv->b = b;
  return rv;
}


bool StructG::Equals(const StructG& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->i, other.i))
    return false;
  if (!mojo::internal::ValueTraits<StructAPtr>::Equals(this->struct_a, other.struct_a))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->str, other.str))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->b, other.b))
    return false;
  return true;
}


// static
StructHPtr StructH::New() {
  StructHPtr rv;
  mojo::internal::StructHelper<StructH>::Initialize(&rv);
  return rv;
}

StructH::StructH()
    : a(),
      b(),
      c(),
      d(),
      e() {
}

StructH::~StructH() {
}


StructHPtr StructH::Clone() const {
  StructHPtr rv(New());
  rv->a = a;
  rv->b = b;
  rv->c = c.Clone();
  rv->d = d.Clone();
  rv->e = e.Clone();
  return rv;
}


bool StructH::Equals(const StructH& other) const {
  if (!mojo::internal::ValueTraits<bool>::Equals(this->a, other.a))
    return false;
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->b, other.b))
    return false;
  if (!mojo::internal::ValueTraits<UnionAPtr>::Equals(this->c, other.c))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<UnionAPtr>>::Equals(this->d, other.d))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Map<uint8_t, UnionAPtr>>::Equals(this->e, other.e))
    return false;
  return true;
}


// static
BasicStructPtr BasicStruct::New() {
  BasicStructPtr rv;
  mojo::internal::StructHelper<BasicStruct>::Initialize(&rv);
  return rv;
}

BasicStruct::BasicStruct()
    : a() {
}

BasicStruct::~BasicStruct() {
}


BasicStructPtr BasicStruct::Clone() const {
  BasicStructPtr rv(New());
  rv->a = a;
  return rv;
}


bool BasicStruct::Equals(const BasicStruct& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->a, other.a))
    return false;
  return true;
}

// static
bool StructWithEnum::EnumWithin_IsValidValue(EnumWithin value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream,
                         const StructWithEnum::EnumWithin& val) {
  return (stream << static_cast<int32_t>(val));
}

// static
StructWithEnumPtr StructWithEnum::New() {
  StructWithEnumPtr rv;
  mojo::internal::StructHelper<StructWithEnum>::Initialize(&rv);
  return rv;
}

StructWithEnum::StructWithEnum() {
}

StructWithEnum::~StructWithEnum() {
}


StructWithEnumPtr StructWithEnum::Clone() const {
  StructWithEnumPtr rv(New());
  return rv;
}


bool StructWithEnum::Equals(const StructWithEnum& other) const {
  return true;
}


// --- Union builder definitions ---// static
UnionAPtr UnionA::New() {
  UnionAPtr rv;
  mojo::internal::StructHelper<UnionA>::Initialize(&rv);
  return rv;
}

UnionA::UnionA() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

UnionA::~UnionA() {
  DestroyActive();
}


UnionAPtr UnionA::Clone() const {
  UnionAPtr rv(New());
  switch (tag_) {

    case Tag::A:

      rv->set_a(data_.a);
      break;
    case Tag::B:

      rv->set_b(data_.b);
      break;
    case Tag::C:

      rv->set_c(data_.c->Clone());
      break;
    case Tag::D:

      rv->set_d(data_.d->Clone());
      break;
    case Tag::E:

      rv->set_e(data_.e->Clone());
      break;
    case Tag::F:

      rv->set_f(data_.f->Clone());
      break;
    case Tag::G:

      rv->set_g(data_.g->Clone());
      break;
    case Tag::H:

      rv->set_h(data_.h->Clone());
      break;
    case Tag::I:

      rv->set_i(data_.i->Clone());
      break;
    case Tag::J:

      rv->set_j(data_.j->Clone());
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool UnionA::Equals(const UnionA& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::A:

      return mojo::internal::ValueTraits<uint16_t>::Equals(data_.a, other.data_.a);
    case Tag::B:

      return mojo::internal::ValueTraits<uint32_t>::Equals(data_.b, other.data_.b);
    case Tag::C:

      return mojo::internal::ValueTraits<StructAPtr>::Equals(*(data_.c), *(other.data_.c));
    case Tag::D:

      return mojo::internal::ValueTraits<mojo::Array<uint8_t>>::Equals(*(data_.d), *(other.data_.d));
    case Tag::E:

      return mojo::internal::ValueTraits<mojo::Map<mojo::String, uint8_t>>::Equals(*(data_.e), *(other.data_.e));
    case Tag::F:

      return mojo::internal::ValueTraits<UnionBPtr>::Equals(*(data_.f), *(other.data_.f));
    case Tag::G:

      return mojo::internal::ValueTraits<StructAPtr>::Equals(*(data_.g), *(other.data_.g));
    case Tag::H:

      return mojo::internal::ValueTraits<mojo::Array<uint8_t>>::Equals(*(data_.h), *(other.data_.h));
    case Tag::I:

      return mojo::internal::ValueTraits<mojo::Map<mojo::String, uint8_t>>::Equals(*(data_.i), *(other.data_.i));
    case Tag::J:

      return mojo::internal::ValueTraits<UnionBPtr>::Equals(*(data_.j), *(other.data_.j));
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool UnionA::is_a() const {
  return tag_ == Tag::A;
}

uint16_t UnionA::get_a() const {
  MOJO_DCHECK(tag_ == Tag::A);

  return data_.a;
}

void UnionA::set_a(uint16_t a) {
  SwitchActive(Tag::A);

  data_.a = a;
}
bool UnionA::is_b() const {
  return tag_ == Tag::B;
}

uint32_t UnionA::get_b() const {
  MOJO_DCHECK(tag_ == Tag::B);

  return data_.b;
}

void UnionA::set_b(uint32_t b) {
  SwitchActive(Tag::B);

  data_.b = b;
}
bool UnionA::is_c() const {
  return tag_ == Tag::C;
}

StructAPtr& UnionA::get_c() const {
  MOJO_DCHECK(tag_ == Tag::C);

  return *(data_.c);
}

void UnionA::set_c(StructAPtr c) {
  SwitchActive(Tag::C);

  *(data_.c) = c.Pass();

}
bool UnionA::is_d() const {
  return tag_ == Tag::D;
}

mojo::Array<uint8_t>& UnionA::get_d() const {
  MOJO_DCHECK(tag_ == Tag::D);

  return *(data_.d);
}

void UnionA::set_d(mojo::Array<uint8_t> d) {
  SwitchActive(Tag::D);

  *(data_.d) = d.Pass();

}
bool UnionA::is_e() const {
  return tag_ == Tag::E;
}

mojo::Map<mojo::String, uint8_t>& UnionA::get_e() const {
  MOJO_DCHECK(tag_ == Tag::E);

  return *(data_.e);
}

void UnionA::set_e(mojo::Map<mojo::String, uint8_t> e) {
  SwitchActive(Tag::E);

  *(data_.e) = e.Pass();

}
bool UnionA::is_f() const {
  return tag_ == Tag::F;
}

UnionBPtr& UnionA::get_f() const {
  MOJO_DCHECK(tag_ == Tag::F);

  return *(data_.f);
}

void UnionA::set_f(UnionBPtr f) {
  SwitchActive(Tag::F);

  *(data_.f) = f.Pass();

}
bool UnionA::is_g() const {
  return tag_ == Tag::G;
}

StructAPtr& UnionA::get_g() const {
  MOJO_DCHECK(tag_ == Tag::G);

  return *(data_.g);
}

void UnionA::set_g(StructAPtr g) {
  SwitchActive(Tag::G);

  *(data_.g) = g.Pass();

}
bool UnionA::is_h() const {
  return tag_ == Tag::H;
}

mojo::Array<uint8_t>& UnionA::get_h() const {
  MOJO_DCHECK(tag_ == Tag::H);

  return *(data_.h);
}

void UnionA::set_h(mojo::Array<uint8_t> h) {
  SwitchActive(Tag::H);

  *(data_.h) = h.Pass();

}
bool UnionA::is_i() const {
  return tag_ == Tag::I;
}

mojo::Map<mojo::String, uint8_t>& UnionA::get_i() const {
  MOJO_DCHECK(tag_ == Tag::I);

  return *(data_.i);
}

void UnionA::set_i(mojo::Map<mojo::String, uint8_t> i) {
  SwitchActive(Tag::I);

  *(data_.i) = i.Pass();

}
bool UnionA::is_j() const {
  return tag_ == Tag::J;
}

UnionBPtr& UnionA::get_j() const {
  MOJO_DCHECK(tag_ == Tag::J);

  return *(data_.j);
}

void UnionA::set_j(UnionBPtr j) {
  SwitchActive(Tag::J);

  *(data_.j) = j.Pass();

}

bool UnionA::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void UnionA::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void UnionA::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::A:

      break;
    case Tag::B:

      break;
    case Tag::C:

      data_.c = new StructAPtr();
      break;
    case Tag::D:

      data_.d = new mojo::Array<uint8_t>();
      break;
    case Tag::E:

      data_.e = new mojo::Map<mojo::String, uint8_t>();
      break;
    case Tag::F:

      data_.f = new UnionBPtr();
      break;
    case Tag::G:

      data_.g = new StructAPtr();
      break;
    case Tag::H:

      data_.h = new mojo::Array<uint8_t>();
      break;
    case Tag::I:

      data_.i = new mojo::Map<mojo::String, uint8_t>();
      break;
    case Tag::J:

      data_.j = new UnionBPtr();
      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void UnionA::DestroyActive() {
  switch (tag_) {

    case Tag::A:

      break;
    case Tag::B:

      break;
    case Tag::C:

      delete data_.c;
      break;
    case Tag::D:

      delete data_.d;
      break;
    case Tag::E:

      delete data_.e;
      break;
    case Tag::F:

      delete data_.f;
      break;
    case Tag::G:

      delete data_.g;
      break;
    case Tag::H:

      delete data_.h;
      break;
    case Tag::I:

      delete data_.i;
      break;
    case Tag::J:

      delete data_.j;
      break;
    default:
      break;
  }
}
// static
UnionBPtr UnionB::New() {
  UnionBPtr rv;
  mojo::internal::StructHelper<UnionB>::Initialize(&rv);
  return rv;
}

UnionB::UnionB() {
  // TODO(azani): Implement default values here when/if we support them.
  tag_ = Tag::__UNKNOWN__;
}

UnionB::~UnionB() {
  DestroyActive();
}


UnionBPtr UnionB::Clone() const {
  UnionBPtr rv(New());
  switch (tag_) {

    case Tag::A:

      rv->set_a(data_.a);
      break;
    case Tag::B:

      rv->set_b(data_.b);
      break;
    case Tag::C:

      rv->set_c(data_.c);
      break;
    case Tag::D:

      rv->set_d(data_.d);
      break;
    case Tag::__UNKNOWN__:
      break;
  };
  return rv;
}

bool UnionB::Equals(const UnionB& other) const {
  if (tag_ != other.which()) {
    return false;
  }

  switch (tag_) {

    case Tag::A:

      return mojo::internal::ValueTraits<uint16_t>::Equals(data_.a, other.data_.a);
    case Tag::B:

      return mojo::internal::ValueTraits<uint32_t>::Equals(data_.b, other.data_.b);
    case Tag::C:

      return mojo::internal::ValueTraits<uint64_t>::Equals(data_.c, other.data_.c);
    case Tag::D:

      return mojo::internal::ValueTraits<uint32_t>::Equals(data_.d, other.data_.d);
    case Tag::__UNKNOWN__:
      return false;
  };

  return false;
}


bool UnionB::is_a() const {
  return tag_ == Tag::A;
}

uint16_t UnionB::get_a() const {
  MOJO_DCHECK(tag_ == Tag::A);

  return data_.a;
}

void UnionB::set_a(uint16_t a) {
  SwitchActive(Tag::A);

  data_.a = a;
}
bool UnionB::is_b() const {
  return tag_ == Tag::B;
}

uint32_t UnionB::get_b() const {
  MOJO_DCHECK(tag_ == Tag::B);

  return data_.b;
}

void UnionB::set_b(uint32_t b) {
  SwitchActive(Tag::B);

  data_.b = b;
}
bool UnionB::is_c() const {
  return tag_ == Tag::C;
}

uint64_t UnionB::get_c() const {
  MOJO_DCHECK(tag_ == Tag::C);

  return data_.c;
}

void UnionB::set_c(uint64_t c) {
  SwitchActive(Tag::C);

  data_.c = c;
}
bool UnionB::is_d() const {
  return tag_ == Tag::D;
}

uint32_t UnionB::get_d() const {
  MOJO_DCHECK(tag_ == Tag::D);

  return data_.d;
}

void UnionB::set_d(uint32_t d) {
  SwitchActive(Tag::D);

  data_.d = d;
}

bool UnionB::has_unknown_tag() const {
  return tag_ == Tag::__UNKNOWN__;
}

void UnionB::SwitchActive(Tag new_active) {
  if (new_active == tag_) {
    return;
  }

  DestroyActive();
  SetActive(new_active);
}

void UnionB::SetActive(Tag new_active) {
  switch (new_active) {

    case Tag::A:

      break;
    case Tag::B:

      break;
    case Tag::C:

      break;
    case Tag::D:

      break;
    case Tag::__UNKNOWN__:
      MOJO_DCHECK(false) << "Do not set a union tag to unknown.";
      break;
  }

  tag_ = new_active;
}

void UnionB::DestroyActive() {
  switch (tag_) {

    case Tag::A:

      break;
    case Tag::B:

      break;
    case Tag::C:

      break;
    case Tag::D:

      break;
    default:
      break;
  }
}


// --- Struct Serialization Helpers ---

size_t StructA::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructA::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructA_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructA::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructA_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructA::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructA_Data* input =
      static_cast<internal::StructA_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructA& input) {
  size_t size = sizeof(internal::StructA_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructA* input,
    mojo::internal::Buffer* buf,
    internal::StructA_Data** output) {
  if (input) {
    internal::StructA_Data* result =
        internal::StructA_Data::New(buf);
    result->i = input->i;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructA_Data* input,
                  StructA* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->i = input->i;
    } while (false);
  }
}


size_t StructB::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructB::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructB_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructB::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructB_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructB::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructB_Data* input =
      static_cast<internal::StructB_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructB& input) {
  size_t size = sizeof(internal::StructB_Data);
  size += input.struct_a.is_null()
              ? 0
              : GetSerializedSize_(*input.struct_a);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructB* input,
    mojo::internal::Buffer* buf,
    internal::StructB_Data** output) {
  if (input) {
    internal::StructB_Data* result =
        internal::StructB_Data::New(buf);
    {auto retval =Serialize_(input->struct_a.get(),
                 buf,
                 &result->struct_a.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->struct_a.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null struct_a in StructB struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructB_Data* input,
                  StructB* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->struct_a.ptr) {
        result->struct_a = StructA::New();
        Deserialize_(input->struct_a.ptr, result->struct_a.get());
      }
    } while (false);
  }
}


size_t StructC::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructC::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructC_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructC::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructC_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructC::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructC_Data* input =
      static_cast<internal::StructC_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructC& input) {
  size_t size = sizeof(internal::StructC_Data);
  size += GetSerializedSize_(input.data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructC* input,
    mojo::internal::Buffer* buf,
    internal::StructC_Data** output) {
  if (input) {
    internal::StructC_Data* result =
        internal::StructC_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams data_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->data, buf, &result->data.ptr,
                            &data_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->data.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null data in StructC struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructC_Data* input,
                  StructC* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->data.ptr, &result->data);
    } while (false);
  }
}


size_t StructD::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructD::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructD_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructD::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructD_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructD::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructD_Data* input =
      static_cast<internal::StructD_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructD& input) {
  size_t size = sizeof(internal::StructD_Data);
  size += GetSerializedSize_(input.message_pipes);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructD* input,
    mojo::internal::Buffer* buf,
    internal::StructD_Data** output) {
  if (input) {
    internal::StructD_Data* result =
        internal::StructD_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams message_pipes_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->message_pipes, buf, &result->message_pipes.ptr,
                            &message_pipes_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->message_pipes.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null message_pipes in StructD struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructD_Data* input,
                  StructD* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->message_pipes.ptr, &result->message_pipes);
    } while (false);
  }
}


size_t StructE::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructE::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructE_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructE::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructE_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructE::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructE_Data* input =
      static_cast<internal::StructE_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructE& input) {
  size_t size = sizeof(internal::StructE_Data);
  size += input.struct_d.is_null()
              ? 0
              : GetSerializedSize_(*input.struct_d);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructE* input,
    mojo::internal::Buffer* buf,
    internal::StructE_Data** output) {
  if (input) {
    internal::StructE_Data* result =
        internal::StructE_Data::New(buf);
    {auto retval =Serialize_(input->struct_d.get(),
                 buf,
                 &result->struct_d.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->struct_d.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null struct_d in StructE struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->data_pipe_consumer = input->data_pipe_consumer.release();
    if (!result->data_pipe_consumer.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid data_pipe_consumer in StructE struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructE_Data* input,
                  StructE* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->struct_d.ptr) {
        result->struct_d = StructD::New();
        Deserialize_(input->struct_d.ptr, result->struct_d.get());
      }
      result->data_pipe_consumer.reset(mojo::internal::FetchAndReset(&input->data_pipe_consumer));
    } while (false);
  }
}


size_t StructF::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructF::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructF_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructF::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructF_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructF::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructF_Data* input =
      static_cast<internal::StructF_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructF& input) {
  size_t size = sizeof(internal::StructF_Data);
  size += GetSerializedSize_(input.fixed_size_array);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructF* input,
    mojo::internal::Buffer* buf,
    internal::StructF_Data** output) {
  if (input) {
    internal::StructF_Data* result =
        internal::StructF_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams fixed_size_array_validate_params(
        3, false, nullptr);auto retval =mojo::SerializeArray_(&input->fixed_size_array, buf, &result->fixed_size_array.ptr,
                            &fixed_size_array_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->fixed_size_array.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null fixed_size_array in StructF struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructF_Data* input,
                  StructF* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->fixed_size_array.ptr, &result->fixed_size_array);
    } while (false);
  }
}


size_t StructG::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructG::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructG_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructG::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructG_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructG::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructG_Data* input =
      static_cast<internal::StructG_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructG& input) {
  size_t size = sizeof(internal::StructG_Data);
  size += input.struct_a.is_null()
              ? 0
              : GetSerializedSize_(*input.struct_a);
  size += GetSerializedSize_(input.str);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructG* input,
    mojo::internal::Buffer* buf,
    internal::StructG_Data** output) {
  if (input) {
    internal::StructG_Data* result =
        internal::StructG_Data::New(buf);
    result->i = input->i;
    {auto retval =Serialize_(input->struct_a.get(),
                 buf,
                 &result->struct_a.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    SerializeString_(input->str, buf, &result->str.ptr);
    result->b = input->b;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructG_Data* input,
                  StructG* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->i = input->i;
      if (input->header_.version < 1)
        break;
      if (input->struct_a.ptr) {
        result->struct_a = StructA::New();
        Deserialize_(input->struct_a.ptr, result->struct_a.get());
      }
      if (input->header_.version < 3)
        break;
      Deserialize_(input->str.ptr, &result->str);
      result->b = input->b;
    } while (false);
  }
}


size_t StructH::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructH::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructH_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructH::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructH_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructH::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructH_Data* input =
      static_cast<internal::StructH_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructH& input) {
  size_t size = sizeof(internal::StructH_Data);
  size += GetSerializedSize_(input.c);
  size += GetSerializedSize_(input.d);
  size += GetSerializedSize_(input.e);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructH* input,
    mojo::internal::Buffer* buf,
    internal::StructH_Data** output) {
  if (input) {
    internal::StructH_Data* result =
        internal::StructH_Data::New(buf);
    result->a = input->a;
    result->b = input->b;
    internal::UnionA_Data* c_ptr = &result->c;
    {
      auto retval =
        SerializeUnion_(input->c.get(),
                        buf,
                        &c_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams d_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->d, buf, &result->d.ptr,
                            &d_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams e_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->e, buf, &result->e.ptr,
          &e_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructH_Data* input,
                  StructH* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->a = input->a;
      result->b = input->b;
      if (!input->c.is_null()) {
        result->c = UnionA::New();
        Deserialize_(&input->c, result->c.get());
      }
      Deserialize_(input->d.ptr, &result->d);
      Deserialize_(input->e.ptr, &result->e);
    } while (false);
  }
}


size_t BasicStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool BasicStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::BasicStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool BasicStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::BasicStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void BasicStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::BasicStruct_Data* input =
      static_cast<internal::BasicStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const BasicStruct& input) {
  size_t size = sizeof(internal::BasicStruct_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    BasicStruct* input,
    mojo::internal::Buffer* buf,
    internal::BasicStruct_Data** output) {
  if (input) {
    internal::BasicStruct_Data* result =
        internal::BasicStruct_Data::New(buf);
    result->a = input->a;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::BasicStruct_Data* input,
                  BasicStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->a = input->a;
    } while (false);
  }
}


size_t StructWithEnum::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructWithEnum::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructWithEnum_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructWithEnum::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructWithEnum_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructWithEnum::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructWithEnum_Data* input =
      static_cast<internal::StructWithEnum_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructWithEnum& input) {
  size_t size = sizeof(internal::StructWithEnum_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructWithEnum* input,
    mojo::internal::Buffer* buf,
    internal::StructWithEnum_Data** output) {
  if (input) {
    internal::StructWithEnum_Data* result =
        internal::StructWithEnum_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructWithEnum_Data* input,
                  StructWithEnum* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}


// --- Union Serialization Helpers ---

size_t GetSerializedSize_(const UnionAPtr& input) {
   size_t size = sizeof(internal::UnionA_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<UnionA> input_acc(input.get());
  switch (input->which()) {




    case UnionA::Tag::C:

      size += GetSerializedSize_(*(input_acc.data()->c->get()));

      break;

    case UnionA::Tag::D:

      size += GetSerializedSize_(*(input_acc.data()->d));

      break;

    case UnionA::Tag::E:

      size += GetSerializedSize_(*(input_acc.data()->e));

      break;

    case UnionA::Tag::F:

      if ((input_acc.data()->f)) {
        //size += sizeof(mojo::internal::UnionPointer<UnionB::Data_>);
        size += GetSerializedSize_(*(input_acc.data()->f));
      }

      break;

    case UnionA::Tag::G:

      size += GetSerializedSize_(*(input_acc.data()->g->get()));

      break;

    case UnionA::Tag::H:

      size += GetSerializedSize_(*(input_acc.data()->h));

      break;

    case UnionA::Tag::I:

      size += GetSerializedSize_(*(input_acc.data()->i));

      break;

    case UnionA::Tag::J:

      if ((input_acc.data()->j)) {
        //size += sizeof(mojo::internal::UnionPointer<UnionB::Data_>);
        size += GetSerializedSize_(*(input_acc.data()->j));
      }

      break;
    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    UnionA* input,
    mojo::internal::Buffer* buf,
    internal::UnionA_Data** output) {
  internal::UnionA_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<UnionA> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case UnionA::Tag::A: {

        result->data.f_a = input_acc.data()->a;
        break;
      }
      case UnionA::Tag::B: {

        result->data.f_b = input_acc.data()->b;
        break;
      }
      case UnionA::Tag::C: {


          {auto retval =Serialize_(input_acc.data()->c->get(),
                     buf,
                     &result->data.f_c.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case UnionA::Tag::D: {


          {
          const mojo::internal::ArrayValidateParams d_validate_params(
            0, false, nullptr);auto retval =mojo::SerializeArray_(input_acc.data()->d, buf, &result->data.f_d.ptr,
                                &d_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case UnionA::Tag::E: {


          {
          const mojo::internal::ArrayValidateParams e_validate_params(
              0, false, nullptr);auto retval =mojo::SerializeMap_(
              input_acc.data()->e, buf, &result->data.f_e.ptr,
              &e_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }

        break;
      }
      case UnionA::Tag::F: {


          // Point *output to newly allocated memory
          // SerializeUnion_ into newly allocated memory.
          if (!input_acc.data()->f->get()) {
            result->data.f_f.ptr = nullptr;
          } else {
            result->data.f_f.ptr =
              UnionB::Data_::New(buf);
            {
            auto retval =
              SerializeUnion_(input_acc.data()->f->get(),
                              buf,
                              &result->data.f_f.ptr);
            if (retval != mojo::internal::ValidationError::NONE)
              return retval;
          }
          }


        break;
      }
      case UnionA::Tag::G: {


          {auto retval =Serialize_(input_acc.data()->g->get(),
                     buf,
                     &result->data.f_g.ptr);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case UnionA::Tag::H: {


          {
          const mojo::internal::ArrayValidateParams h_validate_params(
            0, false, nullptr);auto retval =mojo::SerializeArray_(input_acc.data()->h, buf, &result->data.f_h.ptr,
                                &h_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }


        break;
      }
      case UnionA::Tag::I: {


          {
          const mojo::internal::ArrayValidateParams i_validate_params(
              0, false, nullptr);auto retval =mojo::SerializeMap_(
              input_acc.data()->i, buf, &result->data.f_i.ptr,
              &i_validate_params);
          if (retval != mojo::internal::ValidationError::NONE)
            return retval;
        }

        break;
      }
      case UnionA::Tag::J: {


          // Point *output to newly allocated memory
          // SerializeUnion_ into newly allocated memory.
          if (!input_acc.data()->j->get()) {
            result->data.f_j.ptr = nullptr;
          } else {
            result->data.f_j.ptr =
              UnionB::Data_::New(buf);
            {
            auto retval =
              SerializeUnion_(input_acc.data()->j->get(),
                              buf,
                              &result->data.f_j.ptr);
            if (retval != mojo::internal::ValidationError::NONE)
              return retval;
          }
          }


        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::UnionA_Data* input,
                  UnionA* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<UnionA> result_acc(output);
    switch (input->tag) {

      case UnionA::Tag::A: {

        output->set_a(input->data.f_a);
        break;
      }
      case UnionA::Tag::B: {

        output->set_b(input->data.f_b);
        break;
      }
      case UnionA::Tag::C: {

        result_acc.SwitchActive(UnionA::Tag::C);

        *result_acc.data()->c =
            StructA::New();
        Deserialize_(input->data.f_c.ptr,
            result_acc.data()->c->get());


        break;
      }
      case UnionA::Tag::D: {

        result_acc.SwitchActive(UnionA::Tag::D);

        Deserialize_(input->data.f_d.ptr, result_acc.data()->d);


        break;
      }
      case UnionA::Tag::E: {

        result_acc.SwitchActive(UnionA::Tag::E);

        Deserialize_(input->data.f_e.ptr, result_acc.data()->e);


        break;
      }
      case UnionA::Tag::F: {

        result_acc.SwitchActive(UnionA::Tag::F);

        *result_acc.data()->f =
            UnionB::New();
        Deserialize_(input->data.f_f.ptr,
            result_acc.data()->f->get());


        break;
      }
      case UnionA::Tag::G: {

        result_acc.SwitchActive(UnionA::Tag::G);

        *result_acc.data()->g =
            StructA::New();
        Deserialize_(input->data.f_g.ptr,
            result_acc.data()->g->get());


        break;
      }
      case UnionA::Tag::H: {

        result_acc.SwitchActive(UnionA::Tag::H);

        Deserialize_(input->data.f_h.ptr, result_acc.data()->h);


        break;
      }
      case UnionA::Tag::I: {

        result_acc.SwitchActive(UnionA::Tag::I);

        Deserialize_(input->data.f_i.ptr, result_acc.data()->i);


        break;
      }
      case UnionA::Tag::J: {

        result_acc.SwitchActive(UnionA::Tag::J);

        *result_acc.data()->j =
            UnionB::New();
        Deserialize_(input->data.f_j.ptr,
            result_acc.data()->j->get());


        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing UnionA with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


size_t GetSerializedSize_(const UnionBPtr& input) {
   size_t size = sizeof(internal::UnionB_Data);
   if (!input)
    return size;  
  
  mojo::internal::UnionAccessor<UnionB> input_acc(input.get());
  switch (input->which()) {





    default:
      break;
  }
  return size;
}


mojo::internal::ValidationError SerializeUnion_(
    UnionB* input,
    mojo::internal::Buffer* buf,
    internal::UnionB_Data** output) {
  internal::UnionB_Data* result = *output;
  if (input) {
    mojo::internal::UnionAccessor<UnionB> input_acc(input);
    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    result->size = 16;
    result->tag = input->which();
    switch (input->which()) {

      case UnionB::Tag::A: {

        result->data.f_a = input_acc.data()->a;
        break;
      }
      case UnionB::Tag::B: {

        result->data.f_b = input_acc.data()->b;
        break;
      }
      case UnionB::Tag::C: {

        result->data.f_c = input_acc.data()->c;
        break;
      }
      case UnionB::Tag::D: {

        result->data.f_d = input_acc.data()->d;
        break;
      }
      default:
        // TODO(vardhan): Should this return an error code instead?
        MOJO_CHECK(false) << "No sane way to serialize a union with an unknown tag.";
        break;
    }
  } else {
    result->set_null();
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::UnionB_Data* input,
                  UnionB* output) {
  if (input && !input->is_null()) {
    mojo::internal::UnionAccessor<UnionB> result_acc(output);
    switch (input->tag) {

      case UnionB::Tag::A: {

        output->set_a(input->data.f_a);
        break;
      }
      case UnionB::Tag::B: {

        output->set_b(input->data.f_b);
        break;
      }
      case UnionB::Tag::C: {

        output->set_c(input->data.f_c);
        break;
      }
      case UnionB::Tag::D: {

        output->set_d(input->data.f_d);
        break;
      }
      default:
        MOJO_LOG(WARNING) << "Deserializing UnionB with unknown tag!";
        // No way to deserialize the data when we encounter an unknown tag.
        break;
    }
  }
}


// --- Structs for interface method parameters ---


// static
BoundsCheckTestInterface_Method0_ParamsPtr BoundsCheckTestInterface_Method0_Params::New() {
  BoundsCheckTestInterface_Method0_ParamsPtr rv;
  mojo::internal::StructHelper<BoundsCheckTestInterface_Method0_Params>::Initialize(&rv);
  return rv;
}

BoundsCheckTestInterface_Method0_Params::BoundsCheckTestInterface_Method0_Params()
    : param0() {
}

BoundsCheckTestInterface_Method0_Params::~BoundsCheckTestInterface_Method0_Params() {
}


BoundsCheckTestInterface_Method0_ParamsPtr BoundsCheckTestInterface_Method0_Params::Clone() const {
  BoundsCheckTestInterface_Method0_ParamsPtr rv(New());
  rv->param0 = param0;
  return rv;
}


bool BoundsCheckTestInterface_Method0_Params::Equals(const BoundsCheckTestInterface_Method0_Params& other) const {
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t BoundsCheckTestInterface_Method0_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool BoundsCheckTestInterface_Method0_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::BoundsCheckTestInterface_Method0_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool BoundsCheckTestInterface_Method0_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::BoundsCheckTestInterface_Method0_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void BoundsCheckTestInterface_Method0_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::BoundsCheckTestInterface_Method0_Params_Data* input =
      static_cast<internal::BoundsCheckTestInterface_Method0_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const BoundsCheckTestInterface_Method0_Params& input) {
  size_t size = sizeof(internal::BoundsCheckTestInterface_Method0_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    BoundsCheckTestInterface_Method0_Params* input,
    mojo::internal::Buffer* buf,
    internal::BoundsCheckTestInterface_Method0_Params_Data** output) {
  if (input) {
    internal::BoundsCheckTestInterface_Method0_Params_Data* result =
        internal::BoundsCheckTestInterface_Method0_Params_Data::New(buf);
    result->param0 = input->param0;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::BoundsCheckTestInterface_Method0_Params_Data* input,
                  BoundsCheckTestInterface_Method0_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->param0 = input->param0;
    } while (false);
  }
}


// static
BoundsCheckTestInterface_Method0_ResponseParamsPtr BoundsCheckTestInterface_Method0_ResponseParams::New() {
  BoundsCheckTestInterface_Method0_ResponseParamsPtr rv;
  mojo::internal::StructHelper<BoundsCheckTestInterface_Method0_ResponseParams>::Initialize(&rv);
  return rv;
}

BoundsCheckTestInterface_Method0_ResponseParams::BoundsCheckTestInterface_Method0_ResponseParams()
    : param0() {
}

BoundsCheckTestInterface_Method0_ResponseParams::~BoundsCheckTestInterface_Method0_ResponseParams() {
}


BoundsCheckTestInterface_Method0_ResponseParamsPtr BoundsCheckTestInterface_Method0_ResponseParams::Clone() const {
  BoundsCheckTestInterface_Method0_ResponseParamsPtr rv(New());
  rv->param0 = param0;
  return rv;
}


bool BoundsCheckTestInterface_Method0_ResponseParams::Equals(const BoundsCheckTestInterface_Method0_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t BoundsCheckTestInterface_Method0_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool BoundsCheckTestInterface_Method0_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::BoundsCheckTestInterface_Method0_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool BoundsCheckTestInterface_Method0_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::BoundsCheckTestInterface_Method0_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void BoundsCheckTestInterface_Method0_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::BoundsCheckTestInterface_Method0_ResponseParams_Data* input =
      static_cast<internal::BoundsCheckTestInterface_Method0_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const BoundsCheckTestInterface_Method0_ResponseParams& input) {
  size_t size = sizeof(internal::BoundsCheckTestInterface_Method0_ResponseParams_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    BoundsCheckTestInterface_Method0_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::BoundsCheckTestInterface_Method0_ResponseParams_Data** output) {
  if (input) {
    internal::BoundsCheckTestInterface_Method0_ResponseParams_Data* result =
        internal::BoundsCheckTestInterface_Method0_ResponseParams_Data::New(buf);
    result->param0 = input->param0;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::BoundsCheckTestInterface_Method0_ResponseParams_Data* input,
                  BoundsCheckTestInterface_Method0_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->param0 = input->param0;
    } while (false);
  }
}



// static
BoundsCheckTestInterface_Method1_ParamsPtr BoundsCheckTestInterface_Method1_Params::New() {
  BoundsCheckTestInterface_Method1_ParamsPtr rv;
  mojo::internal::StructHelper<BoundsCheckTestInterface_Method1_Params>::Initialize(&rv);
  return rv;
}

BoundsCheckTestInterface_Method1_Params::BoundsCheckTestInterface_Method1_Params()
    : param0() {
}

BoundsCheckTestInterface_Method1_Params::~BoundsCheckTestInterface_Method1_Params() {
}


BoundsCheckTestInterface_Method1_ParamsPtr BoundsCheckTestInterface_Method1_Params::Clone() const {
  BoundsCheckTestInterface_Method1_ParamsPtr rv(New());
  rv->param0 = param0;
  return rv;
}


bool BoundsCheckTestInterface_Method1_Params::Equals(const BoundsCheckTestInterface_Method1_Params& other) const {
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t BoundsCheckTestInterface_Method1_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool BoundsCheckTestInterface_Method1_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::BoundsCheckTestInterface_Method1_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool BoundsCheckTestInterface_Method1_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::BoundsCheckTestInterface_Method1_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void BoundsCheckTestInterface_Method1_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::BoundsCheckTestInterface_Method1_Params_Data* input =
      static_cast<internal::BoundsCheckTestInterface_Method1_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const BoundsCheckTestInterface_Method1_Params& input) {
  size_t size = sizeof(internal::BoundsCheckTestInterface_Method1_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    BoundsCheckTestInterface_Method1_Params* input,
    mojo::internal::Buffer* buf,
    internal::BoundsCheckTestInterface_Method1_Params_Data** output) {
  if (input) {
    internal::BoundsCheckTestInterface_Method1_Params_Data* result =
        internal::BoundsCheckTestInterface_Method1_Params_Data::New(buf);
    result->param0 = input->param0;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::BoundsCheckTestInterface_Method1_Params_Data* input,
                  BoundsCheckTestInterface_Method1_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->param0 = input->param0;
    } while (false);
  }
}



// static
ConformanceTestInterface_Method0_ParamsPtr ConformanceTestInterface_Method0_Params::New() {
  ConformanceTestInterface_Method0_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method0_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method0_Params::ConformanceTestInterface_Method0_Params()
    : param0() {
}

ConformanceTestInterface_Method0_Params::~ConformanceTestInterface_Method0_Params() {
}


ConformanceTestInterface_Method0_ParamsPtr ConformanceTestInterface_Method0_Params::Clone() const {
  ConformanceTestInterface_Method0_ParamsPtr rv(New());
  rv->param0 = param0;
  return rv;
}


bool ConformanceTestInterface_Method0_Params::Equals(const ConformanceTestInterface_Method0_Params& other) const {
  if (!mojo::internal::ValueTraits<float>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method0_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method0_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method0_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method0_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method0_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method0_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method0_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method0_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method0_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method0_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method0_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method0_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method0_Params_Data* result =
        internal::ConformanceTestInterface_Method0_Params_Data::New(buf);
    result->param0 = input->param0;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method0_Params_Data* input,
                  ConformanceTestInterface_Method0_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->param0 = input->param0;
    } while (false);
  }
}



// static
ConformanceTestInterface_Method1_ParamsPtr ConformanceTestInterface_Method1_Params::New() {
  ConformanceTestInterface_Method1_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method1_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method1_Params::ConformanceTestInterface_Method1_Params()
    : param0() {
}

ConformanceTestInterface_Method1_Params::~ConformanceTestInterface_Method1_Params() {
}


ConformanceTestInterface_Method1_ParamsPtr ConformanceTestInterface_Method1_Params::Clone() const {
  ConformanceTestInterface_Method1_ParamsPtr rv(New());
  rv->param0 = param0.Clone();
  return rv;
}


bool ConformanceTestInterface_Method1_Params::Equals(const ConformanceTestInterface_Method1_Params& other) const {
  if (!mojo::internal::ValueTraits<StructAPtr>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method1_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method1_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method1_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method1_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method1_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method1_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method1_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method1_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method1_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method1_Params_Data);
  size += input.param0.is_null()
              ? 0
              : GetSerializedSize_(*input.param0);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method1_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method1_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method1_Params_Data* result =
        internal::ConformanceTestInterface_Method1_Params_Data::New(buf);
    {auto retval =Serialize_(input->param0.get(),
                 buf,
                 &result->param0.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in ConformanceTestInterface_Method1_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method1_Params_Data* input,
                  ConformanceTestInterface_Method1_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->param0.ptr) {
        result->param0 = StructA::New();
        Deserialize_(input->param0.ptr, result->param0.get());
      }
    } while (false);
  }
}



// static
ConformanceTestInterface_Method2_ParamsPtr ConformanceTestInterface_Method2_Params::New() {
  ConformanceTestInterface_Method2_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method2_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method2_Params::ConformanceTestInterface_Method2_Params()
    : param0(),
      param1() {
}

ConformanceTestInterface_Method2_Params::~ConformanceTestInterface_Method2_Params() {
}


ConformanceTestInterface_Method2_ParamsPtr ConformanceTestInterface_Method2_Params::Clone() const {
  ConformanceTestInterface_Method2_ParamsPtr rv(New());
  rv->param0 = param0.Clone();
  rv->param1 = param1.Clone();
  return rv;
}


bool ConformanceTestInterface_Method2_Params::Equals(const ConformanceTestInterface_Method2_Params& other) const {
  if (!mojo::internal::ValueTraits<StructBPtr>::Equals(this->param0, other.param0))
    return false;
  if (!mojo::internal::ValueTraits<StructAPtr>::Equals(this->param1, other.param1))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method2_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method2_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method2_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method2_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method2_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method2_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method2_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method2_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method2_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method2_Params_Data);
  size += input.param0.is_null()
              ? 0
              : GetSerializedSize_(*input.param0);
  size += input.param1.is_null()
              ? 0
              : GetSerializedSize_(*input.param1);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method2_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method2_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method2_Params_Data* result =
        internal::ConformanceTestInterface_Method2_Params_Data::New(buf);
    {auto retval =Serialize_(input->param0.get(),
                 buf,
                 &result->param0.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in ConformanceTestInterface_Method2_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->param1.get(),
                 buf,
                 &result->param1.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param1.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param1 in ConformanceTestInterface_Method2_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method2_Params_Data* input,
                  ConformanceTestInterface_Method2_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->param0.ptr) {
        result->param0 = StructB::New();
        Deserialize_(input->param0.ptr, result->param0.get());
      }
      if (input->param1.ptr) {
        result->param1 = StructA::New();
        Deserialize_(input->param1.ptr, result->param1.get());
      }
    } while (false);
  }
}



// static
ConformanceTestInterface_Method3_ParamsPtr ConformanceTestInterface_Method3_Params::New() {
  ConformanceTestInterface_Method3_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method3_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method3_Params::ConformanceTestInterface_Method3_Params()
    : param0() {
}

ConformanceTestInterface_Method3_Params::~ConformanceTestInterface_Method3_Params() {
}


ConformanceTestInterface_Method3_ParamsPtr ConformanceTestInterface_Method3_Params::Clone() const {
  ConformanceTestInterface_Method3_ParamsPtr rv(New());
  rv->param0 = param0.Clone();
  return rv;
}


bool ConformanceTestInterface_Method3_Params::Equals(const ConformanceTestInterface_Method3_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<bool>>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method3_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method3_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method3_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method3_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method3_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method3_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method3_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method3_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method3_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method3_Params_Data);
  size += GetSerializedSize_(input.param0);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method3_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method3_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method3_Params_Data* result =
        internal::ConformanceTestInterface_Method3_Params_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams param0_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->param0, buf, &result->param0.ptr,
                            &param0_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in ConformanceTestInterface_Method3_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method3_Params_Data* input,
                  ConformanceTestInterface_Method3_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->param0.ptr, &result->param0);
    } while (false);
  }
}



// static
ConformanceTestInterface_Method4_ParamsPtr ConformanceTestInterface_Method4_Params::New() {
  ConformanceTestInterface_Method4_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method4_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method4_Params::ConformanceTestInterface_Method4_Params()
    : param0(),
      param1() {
}

ConformanceTestInterface_Method4_Params::~ConformanceTestInterface_Method4_Params() {
}


ConformanceTestInterface_Method4_ParamsPtr ConformanceTestInterface_Method4_Params::Clone() const {
  ConformanceTestInterface_Method4_ParamsPtr rv(New());
  rv->param0 = param0.Clone();
  rv->param1 = param1.Clone();
  return rv;
}


bool ConformanceTestInterface_Method4_Params::Equals(const ConformanceTestInterface_Method4_Params& other) const {
  if (!mojo::internal::ValueTraits<StructCPtr>::Equals(this->param0, other.param0))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<uint8_t>>::Equals(this->param1, other.param1))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method4_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method4_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method4_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method4_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method4_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method4_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method4_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method4_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method4_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method4_Params_Data);
  size += input.param0.is_null()
              ? 0
              : GetSerializedSize_(*input.param0);
  size += GetSerializedSize_(input.param1);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method4_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method4_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method4_Params_Data* result =
        internal::ConformanceTestInterface_Method4_Params_Data::New(buf);
    {auto retval =Serialize_(input->param0.get(),
                 buf,
                 &result->param0.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in ConformanceTestInterface_Method4_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams param1_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->param1, buf, &result->param1.ptr,
                            &param1_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param1.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param1 in ConformanceTestInterface_Method4_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method4_Params_Data* input,
                  ConformanceTestInterface_Method4_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->param0.ptr) {
        result->param0 = StructC::New();
        Deserialize_(input->param0.ptr, result->param0.get());
      }
      Deserialize_(input->param1.ptr, &result->param1);
    } while (false);
  }
}



// static
ConformanceTestInterface_Method5_ParamsPtr ConformanceTestInterface_Method5_Params::New() {
  ConformanceTestInterface_Method5_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method5_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method5_Params::ConformanceTestInterface_Method5_Params()
    : param0(),
      param1() {
}

ConformanceTestInterface_Method5_Params::~ConformanceTestInterface_Method5_Params() {
}



bool ConformanceTestInterface_Method5_Params::Equals(const ConformanceTestInterface_Method5_Params& other) const {
  if (!mojo::internal::ValueTraits<StructEPtr>::Equals(this->param0, other.param0))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedDataPipeProducerHandle>::Equals(this->param1, other.param1))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method5_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method5_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method5_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method5_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method5_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method5_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method5_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method5_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method5_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method5_Params_Data);
  size += input.param0.is_null()
              ? 0
              : GetSerializedSize_(*input.param0);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method5_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method5_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method5_Params_Data* result =
        internal::ConformanceTestInterface_Method5_Params_Data::New(buf);
    {auto retval =Serialize_(input->param0.get(),
                 buf,
                 &result->param0.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in ConformanceTestInterface_Method5_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->param1 = input->param1.release();
    if (!result->param1.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid param1 in ConformanceTestInterface_Method5_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method5_Params_Data* input,
                  ConformanceTestInterface_Method5_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->param0.ptr) {
        result->param0 = StructE::New();
        Deserialize_(input->param0.ptr, result->param0.get());
      }
      result->param1.reset(mojo::internal::FetchAndReset(&input->param1));
    } while (false);
  }
}



// static
ConformanceTestInterface_Method6_ParamsPtr ConformanceTestInterface_Method6_Params::New() {
  ConformanceTestInterface_Method6_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method6_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method6_Params::ConformanceTestInterface_Method6_Params()
    : param0() {
}

ConformanceTestInterface_Method6_Params::~ConformanceTestInterface_Method6_Params() {
}


ConformanceTestInterface_Method6_ParamsPtr ConformanceTestInterface_Method6_Params::Clone() const {
  ConformanceTestInterface_Method6_ParamsPtr rv(New());
  rv->param0 = param0.Clone();
  return rv;
}


bool ConformanceTestInterface_Method6_Params::Equals(const ConformanceTestInterface_Method6_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::Array<uint8_t> >>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method6_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method6_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method6_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method6_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method6_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method6_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method6_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method6_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method6_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method6_Params_Data);
  size += GetSerializedSize_(input.param0);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method6_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method6_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method6_Params_Data* result =
        internal::ConformanceTestInterface_Method6_Params_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams param0_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->param0, buf, &result->param0.ptr,
                            &param0_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in ConformanceTestInterface_Method6_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method6_Params_Data* input,
                  ConformanceTestInterface_Method6_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->param0.ptr, &result->param0);
    } while (false);
  }
}



// static
ConformanceTestInterface_Method7_ParamsPtr ConformanceTestInterface_Method7_Params::New() {
  ConformanceTestInterface_Method7_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method7_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method7_Params::ConformanceTestInterface_Method7_Params()
    : param0(),
      param1() {
}

ConformanceTestInterface_Method7_Params::~ConformanceTestInterface_Method7_Params() {
}


ConformanceTestInterface_Method7_ParamsPtr ConformanceTestInterface_Method7_Params::Clone() const {
  ConformanceTestInterface_Method7_ParamsPtr rv(New());
  rv->param0 = param0.Clone();
  rv->param1 = param1.Clone();
  return rv;
}


bool ConformanceTestInterface_Method7_Params::Equals(const ConformanceTestInterface_Method7_Params& other) const {
  if (!mojo::internal::ValueTraits<StructFPtr>::Equals(this->param0, other.param0))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::Array<uint8_t> >>::Equals(this->param1, other.param1))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method7_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method7_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method7_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method7_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method7_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method7_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method7_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method7_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method7_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method7_Params_Data);
  size += input.param0.is_null()
              ? 0
              : GetSerializedSize_(*input.param0);
  size += GetSerializedSize_(input.param1);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method7_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method7_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method7_Params_Data* result =
        internal::ConformanceTestInterface_Method7_Params_Data::New(buf);
    {auto retval =Serialize_(input->param0.get(),
                 buf,
                 &result->param0.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in ConformanceTestInterface_Method7_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {
      const mojo::internal::ArrayValidateParams param1_validate_params(
        2, true, new mojo::internal::ArrayValidateParams(3, false, nullptr));auto retval =mojo::SerializeArray_(&input->param1, buf, &result->param1.ptr,
                            &param1_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param1.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param1 in ConformanceTestInterface_Method7_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method7_Params_Data* input,
                  ConformanceTestInterface_Method7_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->param0.ptr) {
        result->param0 = StructF::New();
        Deserialize_(input->param0.ptr, result->param0.get());
      }
      Deserialize_(input->param1.ptr, &result->param1);
    } while (false);
  }
}



// static
ConformanceTestInterface_Method8_ParamsPtr ConformanceTestInterface_Method8_Params::New() {
  ConformanceTestInterface_Method8_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method8_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method8_Params::ConformanceTestInterface_Method8_Params()
    : param0() {
}

ConformanceTestInterface_Method8_Params::~ConformanceTestInterface_Method8_Params() {
}


ConformanceTestInterface_Method8_ParamsPtr ConformanceTestInterface_Method8_Params::Clone() const {
  ConformanceTestInterface_Method8_ParamsPtr rv(New());
  rv->param0 = param0.Clone();
  return rv;
}


bool ConformanceTestInterface_Method8_Params::Equals(const ConformanceTestInterface_Method8_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::Array<mojo::String> >>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method8_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method8_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method8_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method8_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method8_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method8_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method8_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method8_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method8_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method8_Params_Data);
  size += GetSerializedSize_(input.param0);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method8_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method8_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method8_Params_Data* result =
        internal::ConformanceTestInterface_Method8_Params_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams param0_validate_params(
        0, true, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr)));auto retval =mojo::SerializeArray_(&input->param0, buf, &result->param0.ptr,
                            &param0_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in ConformanceTestInterface_Method8_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method8_Params_Data* input,
                  ConformanceTestInterface_Method8_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->param0.ptr, &result->param0);
    } while (false);
  }
}



// static
ConformanceTestInterface_Method9_ParamsPtr ConformanceTestInterface_Method9_Params::New() {
  ConformanceTestInterface_Method9_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method9_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method9_Params::ConformanceTestInterface_Method9_Params()
    : param0() {
}

ConformanceTestInterface_Method9_Params::~ConformanceTestInterface_Method9_Params() {
}



bool ConformanceTestInterface_Method9_Params::Equals(const ConformanceTestInterface_Method9_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::Array<mojo::ScopedHandle> >>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method9_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method9_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method9_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method9_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method9_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method9_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method9_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method9_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method9_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method9_Params_Data);
  size += GetSerializedSize_(input.param0);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method9_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method9_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method9_Params_Data* result =
        internal::ConformanceTestInterface_Method9_Params_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams param0_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, true, nullptr));auto retval =mojo::SerializeArray_(&input->param0, buf, &result->param0.ptr,
                            &param0_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method9_Params_Data* input,
                  ConformanceTestInterface_Method9_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->param0.ptr, &result->param0);
    } while (false);
  }
}



// static
ConformanceTestInterface_Method10_ParamsPtr ConformanceTestInterface_Method10_Params::New() {
  ConformanceTestInterface_Method10_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method10_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method10_Params::ConformanceTestInterface_Method10_Params()
    : param0() {
}

ConformanceTestInterface_Method10_Params::~ConformanceTestInterface_Method10_Params() {
}


ConformanceTestInterface_Method10_ParamsPtr ConformanceTestInterface_Method10_Params::Clone() const {
  ConformanceTestInterface_Method10_ParamsPtr rv(New());
  rv->param0 = param0.Clone();
  return rv;
}


bool ConformanceTestInterface_Method10_Params::Equals(const ConformanceTestInterface_Method10_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, uint8_t>>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method10_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method10_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method10_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method10_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method10_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method10_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method10_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method10_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method10_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method10_Params_Data);
  size += GetSerializedSize_(input.param0);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method10_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method10_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method10_Params_Data* result =
        internal::ConformanceTestInterface_Method10_Params_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams param0_validate_params(
          0, false, nullptr);auto retval =mojo::SerializeMap_(
          &input->param0, buf, &result->param0.ptr,
          &param0_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in ConformanceTestInterface_Method10_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method10_Params_Data* input,
                  ConformanceTestInterface_Method10_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->param0.ptr, &result->param0);
    } while (false);
  }
}



// static
ConformanceTestInterface_Method11_ParamsPtr ConformanceTestInterface_Method11_Params::New() {
  ConformanceTestInterface_Method11_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method11_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method11_Params::ConformanceTestInterface_Method11_Params()
    : param0() {
}

ConformanceTestInterface_Method11_Params::~ConformanceTestInterface_Method11_Params() {
}


ConformanceTestInterface_Method11_ParamsPtr ConformanceTestInterface_Method11_Params::Clone() const {
  ConformanceTestInterface_Method11_ParamsPtr rv(New());
  rv->param0 = param0.Clone();
  return rv;
}


bool ConformanceTestInterface_Method11_Params::Equals(const ConformanceTestInterface_Method11_Params& other) const {
  if (!mojo::internal::ValueTraits<StructGPtr>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method11_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method11_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method11_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method11_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method11_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method11_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method11_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method11_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method11_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method11_Params_Data);
  size += input.param0.is_null()
              ? 0
              : GetSerializedSize_(*input.param0);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method11_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method11_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method11_Params_Data* result =
        internal::ConformanceTestInterface_Method11_Params_Data::New(buf);
    {auto retval =Serialize_(input->param0.get(),
                 buf,
                 &result->param0.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in ConformanceTestInterface_Method11_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method11_Params_Data* input,
                  ConformanceTestInterface_Method11_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->param0.ptr) {
        result->param0 = StructG::New();
        Deserialize_(input->param0.ptr, result->param0.get());
      }
    } while (false);
  }
}



// static
ConformanceTestInterface_Method12_ParamsPtr ConformanceTestInterface_Method12_Params::New() {
  ConformanceTestInterface_Method12_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method12_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method12_Params::ConformanceTestInterface_Method12_Params()
    : param0() {
}

ConformanceTestInterface_Method12_Params::~ConformanceTestInterface_Method12_Params() {
}


ConformanceTestInterface_Method12_ParamsPtr ConformanceTestInterface_Method12_Params::Clone() const {
  ConformanceTestInterface_Method12_ParamsPtr rv(New());
  rv->param0 = param0;
  return rv;
}


bool ConformanceTestInterface_Method12_Params::Equals(const ConformanceTestInterface_Method12_Params& other) const {
  if (!mojo::internal::ValueTraits<float>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method12_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method12_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method12_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method12_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method12_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method12_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method12_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method12_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method12_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method12_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method12_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method12_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method12_Params_Data* result =
        internal::ConformanceTestInterface_Method12_Params_Data::New(buf);
    result->param0 = input->param0;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method12_Params_Data* input,
                  ConformanceTestInterface_Method12_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->param0 = input->param0;
    } while (false);
  }
}


// static
ConformanceTestInterface_Method12_ResponseParamsPtr ConformanceTestInterface_Method12_ResponseParams::New() {
  ConformanceTestInterface_Method12_ResponseParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method12_ResponseParams>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method12_ResponseParams::ConformanceTestInterface_Method12_ResponseParams()
    : param0() {
}

ConformanceTestInterface_Method12_ResponseParams::~ConformanceTestInterface_Method12_ResponseParams() {
}


ConformanceTestInterface_Method12_ResponseParamsPtr ConformanceTestInterface_Method12_ResponseParams::Clone() const {
  ConformanceTestInterface_Method12_ResponseParamsPtr rv(New());
  rv->param0 = param0;
  return rv;
}


bool ConformanceTestInterface_Method12_ResponseParams::Equals(const ConformanceTestInterface_Method12_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<float>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method12_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method12_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method12_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method12_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method12_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method12_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method12_ResponseParams_Data* input =
      static_cast<internal::ConformanceTestInterface_Method12_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method12_ResponseParams& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method12_ResponseParams_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method12_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method12_ResponseParams_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method12_ResponseParams_Data* result =
        internal::ConformanceTestInterface_Method12_ResponseParams_Data::New(buf);
    result->param0 = input->param0;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method12_ResponseParams_Data* input,
                  ConformanceTestInterface_Method12_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->param0 = input->param0;
    } while (false);
  }
}



// static
ConformanceTestInterface_Method13_ParamsPtr ConformanceTestInterface_Method13_Params::New() {
  ConformanceTestInterface_Method13_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method13_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method13_Params::ConformanceTestInterface_Method13_Params()
    : param0(),
      param1(),
      param2() {
}

ConformanceTestInterface_Method13_Params::~ConformanceTestInterface_Method13_Params() {
}



bool ConformanceTestInterface_Method13_Params::Equals(const ConformanceTestInterface_Method13_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::InterfaceHandle<InterfaceA>>::Equals(this->param0, other.param0))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->param1, other.param1))
    return false;
  if (!mojo::internal::ValueTraits<mojo::InterfaceHandle<InterfaceA>>::Equals(this->param2, other.param2))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method13_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method13_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method13_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method13_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method13_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method13_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method13_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method13_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method13_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method13_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method13_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method13_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method13_Params_Data* result =
        internal::ConformanceTestInterface_Method13_Params_Data::New(buf);
    mojo::internal::InterfaceHandleToData(input->param0.Pass(),
                                          &result->param0);
    result->param1 = input->param1;
    mojo::internal::InterfaceHandleToData(input->param2.Pass(),
                                          &result->param2);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method13_Params_Data* input,
                  ConformanceTestInterface_Method13_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      mojo::internal::InterfaceDataToHandle(&input->param0, &result->param0);
      result->param1 = input->param1;
      mojo::internal::InterfaceDataToHandle(&input->param2, &result->param2);
    } while (false);
  }
}



// static
ConformanceTestInterface_Method14_ParamsPtr ConformanceTestInterface_Method14_Params::New() {
  ConformanceTestInterface_Method14_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method14_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method14_Params::ConformanceTestInterface_Method14_Params()
    : param0() {
}

ConformanceTestInterface_Method14_Params::~ConformanceTestInterface_Method14_Params() {
}


ConformanceTestInterface_Method14_ParamsPtr ConformanceTestInterface_Method14_Params::Clone() const {
  ConformanceTestInterface_Method14_ParamsPtr rv(New());
  rv->param0 = param0.Clone();
  return rv;
}


bool ConformanceTestInterface_Method14_Params::Equals(const ConformanceTestInterface_Method14_Params& other) const {
  if (!mojo::internal::ValueTraits<UnionAPtr>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method14_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method14_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method14_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method14_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method14_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method14_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method14_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method14_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method14_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method14_Params_Data);
  size += GetSerializedSize_(input.param0);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method14_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method14_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method14_Params_Data* result =
        internal::ConformanceTestInterface_Method14_Params_Data::New(buf);
    internal::UnionA_Data* param0_ptr = &result->param0;
    {
      auto retval =
        SerializeUnion_(input->param0.get(),
                        buf,
                        &param0_ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (result->param0.is_null()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in ConformanceTestInterface_Method14_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method14_Params_Data* input,
                  ConformanceTestInterface_Method14_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (!input->param0.is_null()) {
        result->param0 = UnionA::New();
        Deserialize_(&input->param0, result->param0.get());
      }
    } while (false);
  }
}



// static
ConformanceTestInterface_Method15_ParamsPtr ConformanceTestInterface_Method15_Params::New() {
  ConformanceTestInterface_Method15_ParamsPtr rv;
  mojo::internal::StructHelper<ConformanceTestInterface_Method15_Params>::Initialize(&rv);
  return rv;
}

ConformanceTestInterface_Method15_Params::ConformanceTestInterface_Method15_Params()
    : param0() {
}

ConformanceTestInterface_Method15_Params::~ConformanceTestInterface_Method15_Params() {
}


ConformanceTestInterface_Method15_ParamsPtr ConformanceTestInterface_Method15_Params::Clone() const {
  ConformanceTestInterface_Method15_ParamsPtr rv(New());
  rv->param0 = param0.Clone();
  return rv;
}


bool ConformanceTestInterface_Method15_Params::Equals(const ConformanceTestInterface_Method15_Params& other) const {
  if (!mojo::internal::ValueTraits<StructHPtr>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t ConformanceTestInterface_Method15_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool ConformanceTestInterface_Method15_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::ConformanceTestInterface_Method15_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool ConformanceTestInterface_Method15_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::ConformanceTestInterface_Method15_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void ConformanceTestInterface_Method15_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::ConformanceTestInterface_Method15_Params_Data* input =
      static_cast<internal::ConformanceTestInterface_Method15_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const ConformanceTestInterface_Method15_Params& input) {
  size_t size = sizeof(internal::ConformanceTestInterface_Method15_Params_Data);
  size += input.param0.is_null()
              ? 0
              : GetSerializedSize_(*input.param0);
  return size;
}

mojo::internal::ValidationError Serialize_(
    ConformanceTestInterface_Method15_Params* input,
    mojo::internal::Buffer* buf,
    internal::ConformanceTestInterface_Method15_Params_Data** output) {
  if (input) {
    internal::ConformanceTestInterface_Method15_Params_Data* result =
        internal::ConformanceTestInterface_Method15_Params_Data::New(buf);
    {auto retval =Serialize_(input->param0.get(),
                 buf,
                 &result->param0.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in ConformanceTestInterface_Method15_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::ConformanceTestInterface_Method15_Params_Data* input,
                  ConformanceTestInterface_Method15_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->param0.ptr) {
        result->param0 = StructH::New();
        Deserialize_(input->param0.ptr, result->param0.get());
      }
    } while (false);
  }
}



// static
IntegrationTestInterface_Method0_ParamsPtr IntegrationTestInterface_Method0_Params::New() {
  IntegrationTestInterface_Method0_ParamsPtr rv;
  mojo::internal::StructHelper<IntegrationTestInterface_Method0_Params>::Initialize(&rv);
  return rv;
}

IntegrationTestInterface_Method0_Params::IntegrationTestInterface_Method0_Params()
    : param0() {
}

IntegrationTestInterface_Method0_Params::~IntegrationTestInterface_Method0_Params() {
}


IntegrationTestInterface_Method0_ParamsPtr IntegrationTestInterface_Method0_Params::Clone() const {
  IntegrationTestInterface_Method0_ParamsPtr rv(New());
  rv->param0 = param0.Clone();
  return rv;
}


bool IntegrationTestInterface_Method0_Params::Equals(const IntegrationTestInterface_Method0_Params& other) const {
  if (!mojo::internal::ValueTraits<BasicStructPtr>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t IntegrationTestInterface_Method0_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool IntegrationTestInterface_Method0_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::IntegrationTestInterface_Method0_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool IntegrationTestInterface_Method0_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::IntegrationTestInterface_Method0_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void IntegrationTestInterface_Method0_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::IntegrationTestInterface_Method0_Params_Data* input =
      static_cast<internal::IntegrationTestInterface_Method0_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const IntegrationTestInterface_Method0_Params& input) {
  size_t size = sizeof(internal::IntegrationTestInterface_Method0_Params_Data);
  size += input.param0.is_null()
              ? 0
              : GetSerializedSize_(*input.param0);
  return size;
}

mojo::internal::ValidationError Serialize_(
    IntegrationTestInterface_Method0_Params* input,
    mojo::internal::Buffer* buf,
    internal::IntegrationTestInterface_Method0_Params_Data** output) {
  if (input) {
    internal::IntegrationTestInterface_Method0_Params_Data* result =
        internal::IntegrationTestInterface_Method0_Params_Data::New(buf);
    {auto retval =Serialize_(input->param0.get(),
                 buf,
                 &result->param0.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in IntegrationTestInterface_Method0_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::IntegrationTestInterface_Method0_Params_Data* input,
                  IntegrationTestInterface_Method0_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->param0.ptr) {
        result->param0 = BasicStruct::New();
        Deserialize_(input->param0.ptr, result->param0.get());
      }
    } while (false);
  }
}


// static
IntegrationTestInterface_Method0_ResponseParamsPtr IntegrationTestInterface_Method0_ResponseParams::New() {
  IntegrationTestInterface_Method0_ResponseParamsPtr rv;
  mojo::internal::StructHelper<IntegrationTestInterface_Method0_ResponseParams>::Initialize(&rv);
  return rv;
}

IntegrationTestInterface_Method0_ResponseParams::IntegrationTestInterface_Method0_ResponseParams()
    : param0() {
}

IntegrationTestInterface_Method0_ResponseParams::~IntegrationTestInterface_Method0_ResponseParams() {
}


IntegrationTestInterface_Method0_ResponseParamsPtr IntegrationTestInterface_Method0_ResponseParams::Clone() const {
  IntegrationTestInterface_Method0_ResponseParamsPtr rv(New());
  rv->param0 = param0.Clone();
  return rv;
}


bool IntegrationTestInterface_Method0_ResponseParams::Equals(const IntegrationTestInterface_Method0_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<uint8_t>>::Equals(this->param0, other.param0))
    return false;
  return true;
}


size_t IntegrationTestInterface_Method0_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool IntegrationTestInterface_Method0_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::IntegrationTestInterface_Method0_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool IntegrationTestInterface_Method0_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::IntegrationTestInterface_Method0_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void IntegrationTestInterface_Method0_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::IntegrationTestInterface_Method0_ResponseParams_Data* input =
      static_cast<internal::IntegrationTestInterface_Method0_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const IntegrationTestInterface_Method0_ResponseParams& input) {
  size_t size = sizeof(internal::IntegrationTestInterface_Method0_ResponseParams_Data);
  size += GetSerializedSize_(input.param0);
  return size;
}

mojo::internal::ValidationError Serialize_(
    IntegrationTestInterface_Method0_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::IntegrationTestInterface_Method0_ResponseParams_Data** output) {
  if (input) {
    internal::IntegrationTestInterface_Method0_ResponseParams_Data* result =
        internal::IntegrationTestInterface_Method0_ResponseParams_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams param0_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->param0, buf, &result->param0.ptr,
                            &param0_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->param0.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null param0 in IntegrationTestInterface_Method0_ResponseParams struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::IntegrationTestInterface_Method0_ResponseParams_Data* input,
                  IntegrationTestInterface_Method0_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->param0.ptr, &result->param0);
    } while (false);
  }
}

}  // namespace test
}  // namespace mojo
