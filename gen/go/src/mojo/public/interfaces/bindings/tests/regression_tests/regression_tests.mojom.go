// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/public/interfaces/bindings/tests/regression_tests.mojom
//

package regression_tests

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	ioutil "io/ioutil"
	base64 "encoding/base64"
	fmt "fmt"
	bytes "bytes"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
	gzip "compress/gzip"
)

// This global variable contains a mojom_types.RuntimeTypeInfo struct
// describing the types defined in this file and all of its imports as
// well as the top-level interfaces defined in this file.
var runtimeTypeInfo__ = mojom_types.RuntimeTypeInfo{}

func getRuntimeTypeInfo() mojom_types.RuntimeTypeInfo {
  if runtimeTypeInfo__.TypeMap == nil {
    initRuntimeTypeInfo()
  }
  return runtimeTypeInfo__
}

func initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this file.
  // The string contains the base64 encoding of the gzip-compressed bytes.
  serializedRuntimeTypeInfo := "H4sIAAAJbogC/+xdT3fbxhEHKDmWbSWR2ziR41Rx7DZRY5sUbcthnDYRRVF/KonUI2lHfs17DE1BIiP+K0ilck8+6thjP0KPPvrYj5CPkKOPPurW7hKzJHaIBRY0CIBW8R7eGtQOsPvb2ZmdP7ueVYxrBsoFKPHvrJxCJa63c84oX5L7Q3K/gN9/gfI1lNdVo1yH8jmUL6D8FUolYhTzUP4I5QmUL6F8BeXshFEuQVmB8p9Q/gLl1CR8H8oWlDfJfY3chSc76eJm+slDXTvQtXa72mwUO1q7044mJestd+vdI/ct23qpUl2rpUptrUAe042jepcuRu4v7OkqWvmQ1k+VWm3lW1L3gXP9ba1Tae59X+1U0vVW51lOa7eajbamKPcJ7W1n+gxpbKpZq1XpH2g7F8l9x56u2eiUqo12UtdLz7L70MPPyT1nS5feO9CMd//Bvh7tSL6jH5U7pN7X5I7b1ycNoABsZArpXCa5lazVugga1y0YW2f6TcnxZfW3mn/X9HKJgg1t/KMUXeao/lTTWfvkv5fT9jVda5SN79Gx/b0tXaap10s1xoDO/Jfr/bC4GJcYp7ym/1wta5SDSL01cn9nX787pLQnwDnrpcZeTWunSrWatgcP3Xd8Jfkeg4anp7P0oST9RqOj6fulMnqF5Hyl07v3BmWeykDb+o81vaMdV1RDjlL5SkXirtqXt/SfryZ4+Xv8Tv+Z/un0A/555mP++eQm/77nt/nnSox/Po0jfXGPf1YS/HPiIf/8nz+j+kv88/wK377na/zzToZvz1SBf37xmH+ef8LTKz+g/hVBHyF9dqrw+mZJ4a8FvrvKf+FaV6yvC/C9JDzTYfgNuQXqRbHSy+dpeygPUH6rNOtarFWuN/Vq5x8xMkHulJu6Fmvr5Vi9+VMz1jp6WquWY1XGce3Y02pjr9o4aMe6H4oNfJmS1Xu48sPT6yf9+zmTHne6RLgpJty64+6A21PBeiMO7Rk1Low/VPT9WdTOZUVxtT7AeM+a+q6avuMXfy478eey9TjcP+P8WRLw52LI+DOpuFvnyvLngL2g2uO7jviyIsD3Krkvk9t6lawoX5L7hhWfCghwO8s+jQ99/yX4htne+XeEt0tOwQ65Dnp8/TzYJzAA/7oAevQi2D2XQG8iOeGW35ckx4PKBPrp5Wx2q1hY38is9fn8jtQ4RDlSPB57YPKNejyc8FI9wosuv6bJvZJ9tLyV7iP2FawZJfDiSDFeWkjwiniE129hnqxuZZMFE4NR2zYqhxdHivHaDwleEx7PR2LNJoacjxwpxusgJHhNeo9X/MHQePVJMV6VkOB1zuP5SDp97y7hkrj7+ciRYryqIcHrHe/xenC/WKjEGwdD4NUnxXj9FBK8znuM1yMqhQrFYfDiSDFehyHBa8rj9cSjrhTqkF67Xk9wpBivWkjwujACvAwpZDCYS7x6pBivekjwujgCvKgUWh+Ov3qkGK9GwHhNqcPZQ7sCvK6Q+11qn3LRmH58wyFsM4DPtzCWo8ZnVuAnmDbZPlb2P8b19A39KksC+hvgg8prHduADe7Hdz7xl8gfdxKR77+dP475NcT9v6NrfzsiDbLGgV1n1R+nKWL+WPSRPxT0fdbuT8n9EblFzP2mcUxZv51ITs5LyskdxM/HgnGhscdPmJwURqHt7DB7QjzOFwOWozMmn4gKv0dM9U4m7OUpy3fwSp6yeCPFrnnU2SnpRG+TriYbexyUuD+XApanp4o38nQBMHDqP5OqQcnTKYn5a7YnMG495a26w21HgBvLU5DArT+JA9RHbvETzb/EhJwf2IyjajP/aG7E7wBHIYgWuE0HPP+mPFrPsPwQ2/6bljRhXs+4uUYd/54GXP3GxW2c2is5HgXbyomP2IQaVznErlnJdZhsPJXF9a2z+fr5b5LpfwP4vj9m9iuzSxKTw83bhEPcupvBNwizZX5tEHKe9X9mwt38FOm5z6DvA/3mzdXA5iVeh+M8haDk/PvgU6+TJpcONEv+uOoDPsPgoLrEQbXBYQbmqi6wR2YgzzJIfRex0XdezyfmB7OaT+YF9//nk7v5dBnqnPX5dBnskrDOJ7b+eRnxZv1zDWKO1rsS+nnyktsYBvjq+xDlQUZs/PPDzrcFAT3NUX+P5kFSeIrN/aJGALKIb+xCjMlP/yttO/NDTwnW2Zj/WJ4IvyvC/T6KsOT3TkMOjbGrxpjzV6z4HCrgcftcOdv5vT8L1q1f+GTvXEe6Ads970EOi7FrRJHeXzIsf7I46pTqTRyV5YHwu7n6cQOHbV8D4xL1iV/d2vmjypN2iicx/7dsGAm3M6H4l8c+YcJpCfBpRez9JLLzPiGJJ1s35QvJzEoyt8LicbL4RRmhYNy/VsYzz7nlkFe5+mhrK5/KpdOwT+sbxdizKI0begHG7aEynvnOItwug47Z2N5O5/Ibj9Omft51gxt6AcbtG59wG7BDPdIPDCd+923fPnbYpjuAxw2f5JmT/3HGyuhzIb92HNYtmyj+LsYpummF002f+Ka3P3PEepL5Za13ZdvsJxIQ4HZe9YmvsN8loXqjH2XzBNl83KmVGiV9Nf4AfmfnCDjjF+VIMY4fK2/XPiCE1727Q+NlkGK8ro25fP8I/HH41ANmxzgdj4DbNRcy+c7spEmX8l2E17vQv8Pi3WLcFBd1wikKBBivT32W85M+y3n+NAwJOY8IcDs/CEjOV1R7PmN6YM5l3t6JQzzvsJgn6810tkisGupPWM4S26a4vZGCetTO+ZMUnlHbV2Gcr/jMl3M28zhimsdzns/j7eSuKU9NCkdCgvH6MKA4cmJIvhn2PJtR6SGR35ftl3dw9w60KxeQnJhXR+MvceLj1Y1cvgA5g5/Z4xVlda1wy4/J+k8WH+afzadT2cyKjf4x4cPqWuFTUN7OfTT8qVI2+2hQRYzPX8csD+lXhteEt/GLS6DX1rSOJR/9EJC+YP2dd5lfuuAQPyD95DKNwpxH6md8lu3rO9SeFVu6tl89Nk4us+KHoOKzZrxmLPzxw8SpGJ+9Vr3hM4ajwWf9DJyw5yuf8yleyvQcaepRrWPNX7eV8OQr+6XfmHziT0G08cuiihjH4pjpt1cM14i3co3h2ka44nb/GJCee4VKWfmTcMhfMvU3FPruTfctMXxmIt7g9AnIah6n8ZDXqo/rAjfz55pP+Hih95kf7NiBn3Yl/WBs/5LcqbRK7zzmIY+1HcB/NWR5hX7lX7E83goAg3FZg38HsV6dHMF6lflt1iPu/Leifdds36H9Kcg25+04EOLxWA4Rn06GiE9TEP8bF/m5gM6nlOXD5wJ8WBzP6TRtYZ6V3DHcA7hnzmjeqhM/ZgOQm4oFvzG/H386uvvz1MNm74n6JfRnoop4vP4ypvbeqNaredL9bdjbYzXvN98ye8/U37fC3mP2Tcuj/Q04/53lQwvS3gdw+1I52/sbROd23FL82Sd3HcXbsJ4Q7Q9w+//DyOqJ/wUAAP//scwfnBhpAAA="

  // Deserialize RuntimeTypeInfo
  compressedBytes, err := base64.StdEncoding.DecodeString(serializedRuntimeTypeInfo)
  if err != nil {
    panic(fmt.Sprintf("Error while base64Decoding runtimeTypeInfo: %s", err.Error()))
  }
  reader, err := gzip.NewReader(bytes.NewBuffer(compressedBytes))
  if err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  uncompressedBytes, err := ioutil.ReadAll(reader)
  if err != nil {
     panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  if err = reader.Close(); err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  decoder := bindings.NewDecoder(uncompressedBytes, nil)
  runtimeTypeInfo__.Decode(decoder)

}
func GetAllMojomTypeDefinitions() map[string]mojom_types.UserDefinedType {
  return getRuntimeTypeInfo().TypeMap
}

type EnumWithReference int32

const (
	EnumWithReference_KStereoAndKeyboardMic EnumWithReference = 30
	EnumWithReference_KMax = EnumWithReference_KStereoAndKeyboardMic
)
// EnumWithReferenceMojomType returns the UserDefinedType that describes the Mojom
// type of EnumWithReference. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func EnumWithReferenceMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.EnumWithReference"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*EnumWithReference) MojomType() mojom_types.UserDefinedType {
	return EnumWithReferenceMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*EnumWithReference) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type EnumWithLowercase int32

const (
	EnumWithLowercase_PlanarF16 EnumWithLowercase = 0
	EnumWithLowercase_PlanarF32 = EnumWithLowercase_PlanarF16 + 1;
)
// EnumWithLowercaseMojomType returns the UserDefinedType that describes the Mojom
// type of EnumWithLowercase. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func EnumWithLowercaseMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.EnumWithLowercase"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*EnumWithLowercase) MojomType() mojom_types.UserDefinedType {
	return EnumWithLowercaseMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*EnumWithLowercase) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type EnumWithNumbers int32

const (
	EnumWithNumbers_K21 EnumWithNumbers = 4
)
// EnumWithNumbersMojomType returns the UserDefinedType that describes the Mojom
// type of EnumWithNumbers. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func EnumWithNumbersMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.EnumWithNumbers"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*EnumWithNumbers) MojomType() mojom_types.UserDefinedType {
	return EnumWithNumbersMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*EnumWithNumbers) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type EnumWithK int32

const (
	EnumWithK_K EnumWithK = 0
)
// EnumWithKMojomType returns the UserDefinedType that describes the Mojom
// type of EnumWithK. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func EnumWithKMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.EnumWithK"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*EnumWithK) MojomType() mojom_types.UserDefinedType {
	return EnumWithKMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*EnumWithK) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type EnumWithInternalAllCaps int32

const (
	EnumWithInternalAllCaps_Standard EnumWithInternalAllCaps = 0
	EnumWithInternalAllCaps_Fullscreen = EnumWithInternalAllCaps_Standard + 1;
	EnumWithInternalAllCaps_Immersive = EnumWithInternalAllCaps_Fullscreen + 1;
)
// EnumWithInternalAllCapsMojomType returns the UserDefinedType that describes the Mojom
// type of EnumWithInternalAllCaps. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func EnumWithInternalAllCapsMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.EnumWithINTERNALAllCaps"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*EnumWithInternalAllCaps) MojomType() mojom_types.UserDefinedType {
	return EnumWithInternalAllCapsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*EnumWithInternalAllCaps) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type NormalEnum int32

const (
	NormalEnum_First NormalEnum = 0
	NormalEnum_Second = NormalEnum_First + 1;
)
// NormalEnumMojomType returns the UserDefinedType that describes the Mojom
// type of NormalEnum. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func NormalEnumMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.NormalEnum"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*NormalEnum) MojomType() mojom_types.UserDefinedType {
	return NormalEnumMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*NormalEnum) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type CamelCaseTestEnum int32

const (
	CamelCaseTestEnum_BoolThing CamelCaseTestEnum = 0
	CamelCaseTestEnum_DoubleThing = CamelCaseTestEnum_BoolThing + 1;
	CamelCaseTestEnum_FloatThing = CamelCaseTestEnum_DoubleThing + 1;
	CamelCaseTestEnum_Int8Thing = CamelCaseTestEnum_FloatThing + 1;
	CamelCaseTestEnum_Int16Thing = CamelCaseTestEnum_Int8Thing + 1;
	CamelCaseTestEnum_Int32Th1Ng = CamelCaseTestEnum_Int16Thing + 1;
	CamelCaseTestEnum_Int64Th1ng = CamelCaseTestEnum_Int32Th1Ng + 1;
	CamelCaseTestEnum_Uint8TH1ng = CamelCaseTestEnum_Int64Th1ng + 1;
	CamelCaseTestEnum_Uint16tH1Ng = CamelCaseTestEnum_Uint8TH1ng + 1;
	CamelCaseTestEnum_Uint32Th1ng = CamelCaseTestEnum_Uint16tH1Ng + 1;
	CamelCaseTestEnum_Uint64Th1Ng = CamelCaseTestEnum_Uint32Th1ng + 1;
)
// CamelCaseTestEnumMojomType returns the UserDefinedType that describes the Mojom
// type of CamelCaseTestEnum. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func CamelCaseTestEnumMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.CamelCaseTestEnum"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*CamelCaseTestEnum) MojomType() mojom_types.UserDefinedType {
	return CamelCaseTestEnumMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*CamelCaseTestEnum) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type CheckMethodWithEmptyResponse interface {
	WithoutParameterAndEmptyResponse() (err error)
	WithParameterAndEmptyResponse(inB bool) (err error)
}


// CheckMethodWithEmptyResponseMojomType returns the UserDefinedType that describes the Mojom
// type of CheckMethodWithEmptyResponse. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func CheckMethodWithEmptyResponseMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.CheckMethodWithEmptyResponse"]
}




type CheckMethodWithEmptyResponse_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*CheckMethodWithEmptyResponse_Request) MojomType() mojom_types.UserDefinedType {
	return CheckMethodWithEmptyResponseMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*CheckMethodWithEmptyResponse_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type CheckMethodWithEmptyResponse_Pointer bindings.InterfacePointer


type CheckMethodWithEmptyResponse_ServiceFactory struct{
	Delegate CheckMethodWithEmptyResponse_Factory
}

type CheckMethodWithEmptyResponse_Factory interface {
	Create(request CheckMethodWithEmptyResponse_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *CheckMethodWithEmptyResponse_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &CheckMethodWithEmptyResponse_ServiceDescription{}
}

func (f *CheckMethodWithEmptyResponse_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := CheckMethodWithEmptyResponse_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForCheckMethodWithEmptyResponse creates a message pipe for use with the
// CheckMethodWithEmptyResponse interface with a CheckMethodWithEmptyResponse_Request on one end and a CheckMethodWithEmptyResponse_Pointer on the other.
func CreateMessagePipeForCheckMethodWithEmptyResponse() (CheckMethodWithEmptyResponse_Request, CheckMethodWithEmptyResponse_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return CheckMethodWithEmptyResponse_Request(r), CheckMethodWithEmptyResponse_Pointer(p)
}

const checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Name uint32 = 0
const checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name uint32 = 1

type CheckMethodWithEmptyResponse_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewCheckMethodWithEmptyResponseProxy(p CheckMethodWithEmptyResponse_Pointer, waiter bindings.AsyncWaiter) *CheckMethodWithEmptyResponse_Proxy {
	return &CheckMethodWithEmptyResponse_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *CheckMethodWithEmptyResponse_Proxy) Close_Proxy() {
	p.router.Close()
}

type checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params struct {
}


func (s *checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Versions), func(i int) bool {
		return checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Versions) {
		if checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams struct {
}


func (s *checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Versions), func(i int) bool {
		return checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Versions) {
		if checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CheckMethodWithEmptyResponse_Proxy) WithoutParameterAndEmptyResponse() (err error) {
	payload := &checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params{
	}
	header := bindings.MessageHeader{
		Type: checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params struct {
	inB bool
}


func (s *checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteBool(s.inB); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Versions), func(i int) bool {
		return checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Versions) {
		if checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.inB = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams struct {
}


func (s *checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Versions), func(i int) bool {
		return checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Versions) {
		if checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CheckMethodWithEmptyResponse_Proxy) WithParameterAndEmptyResponse(inB bool) (err error) {
	payload := &checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params{
		inB,
	}
	header := bindings.MessageHeader{
		Type: checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type checkMethodWithEmptyResponse_Stub struct {
	connector *bindings.Connector
	impl CheckMethodWithEmptyResponse
}

func NewCheckMethodWithEmptyResponseStub(r CheckMethodWithEmptyResponse_Request, impl CheckMethodWithEmptyResponse, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &checkMethodWithEmptyResponse_Stub{connector, impl})
}


func (f *CheckMethodWithEmptyResponse_Request) ServiceDescription() service_describer.ServiceDescription {
	return &CheckMethodWithEmptyResponse_ServiceDescription{}
}


type CheckMethodWithEmptyResponse_ServiceDescription struct{}

func (sd *CheckMethodWithEmptyResponse_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *CheckMethodWithEmptyResponse_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *CheckMethodWithEmptyResponse_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*CheckMethodWithEmptyResponse_ServiceDescription)(nil)


func (s *checkMethodWithEmptyResponse_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams
		err = s.impl.WithoutParameterAndEmptyResponse()
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: checkMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams
		err = s.impl.WithParameterAndEmptyResponse(request.inB)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: checkMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type CheckNameCollision interface {
	WithNameCollision(inMessage bool, inResponse bool) (outMessage bool, outResponse bool, err error)
}


// CheckNameCollisionMojomType returns the UserDefinedType that describes the Mojom
// type of CheckNameCollision. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func CheckNameCollisionMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.CheckNameCollision"]
}




type CheckNameCollision_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*CheckNameCollision_Request) MojomType() mojom_types.UserDefinedType {
	return CheckNameCollisionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*CheckNameCollision_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type CheckNameCollision_Pointer bindings.InterfacePointer


type CheckNameCollision_ServiceFactory struct{
	Delegate CheckNameCollision_Factory
}

type CheckNameCollision_Factory interface {
	Create(request CheckNameCollision_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *CheckNameCollision_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &CheckNameCollision_ServiceDescription{}
}

func (f *CheckNameCollision_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := CheckNameCollision_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForCheckNameCollision creates a message pipe for use with the
// CheckNameCollision interface with a CheckNameCollision_Request on one end and a CheckNameCollision_Pointer on the other.
func CreateMessagePipeForCheckNameCollision() (CheckNameCollision_Request, CheckNameCollision_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return CheckNameCollision_Request(r), CheckNameCollision_Pointer(p)
}

const checkNameCollision_WithNameCollision_Name uint32 = 0

type CheckNameCollision_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewCheckNameCollisionProxy(p CheckNameCollision_Pointer, waiter bindings.AsyncWaiter) *CheckNameCollision_Proxy {
	return &CheckNameCollision_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *CheckNameCollision_Proxy) Close_Proxy() {
	p.router.Close()
}

type checkNameCollision_WithNameCollision_Params struct {
	inMessage bool
	inResponse bool
}


func (s *checkNameCollision_WithNameCollision_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteBool(s.inMessage); err != nil {
		return err
	}
	if err := encoder.WriteBool(s.inResponse); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var checkNameCollision_WithNameCollision_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *checkNameCollision_WithNameCollision_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(checkNameCollision_WithNameCollision_Params_Versions), func(i int) bool {
		return checkNameCollision_WithNameCollision_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(checkNameCollision_WithNameCollision_Params_Versions) {
		if checkNameCollision_WithNameCollision_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := checkNameCollision_WithNameCollision_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.inMessage = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.inResponse = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type checkNameCollision_WithNameCollision_ResponseParams struct {
	outMessage bool
	outResponse bool
}


func (s *checkNameCollision_WithNameCollision_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteBool(s.outMessage); err != nil {
		return err
	}
	if err := encoder.WriteBool(s.outResponse); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var checkNameCollision_WithNameCollision_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *checkNameCollision_WithNameCollision_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(checkNameCollision_WithNameCollision_ResponseParams_Versions), func(i int) bool {
		return checkNameCollision_WithNameCollision_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(checkNameCollision_WithNameCollision_ResponseParams_Versions) {
		if checkNameCollision_WithNameCollision_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := checkNameCollision_WithNameCollision_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.outMessage = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.outResponse = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CheckNameCollision_Proxy) WithNameCollision(inMessage bool, inResponse bool) (outMessage bool, outResponse bool, err error) {
	payload := &checkNameCollision_WithNameCollision_Params{
		inMessage,
		inResponse,
	}
	header := bindings.MessageHeader{
		Type: checkNameCollision_WithNameCollision_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, checkNameCollision_WithNameCollision_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response checkNameCollision_WithNameCollision_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outMessage = response.outMessage
	outResponse = response.outResponse
	return
}

type checkNameCollision_Stub struct {
	connector *bindings.Connector
	impl CheckNameCollision
}

func NewCheckNameCollisionStub(r CheckNameCollision_Request, impl CheckNameCollision, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &checkNameCollision_Stub{connector, impl})
}


func (f *CheckNameCollision_Request) ServiceDescription() service_describer.ServiceDescription {
	return &CheckNameCollision_ServiceDescription{}
}


type CheckNameCollision_ServiceDescription struct{}

func (sd *CheckNameCollision_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *CheckNameCollision_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *CheckNameCollision_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*CheckNameCollision_ServiceDescription)(nil)


func (s *checkNameCollision_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case checkNameCollision_WithNameCollision_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request checkNameCollision_WithNameCollision_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response checkNameCollision_WithNameCollision_ResponseParams
		response.outMessage, 		response.outResponse, err = s.impl.WithNameCollision(request.inMessage, request.inResponse)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: checkNameCollision_WithNameCollision_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type CheckEnumCaps interface {
	SetEnumWithInternalAllCaps(inE EnumWithInternalAllCaps) (err error)
}


// CheckEnumCapsMojomType returns the UserDefinedType that describes the Mojom
// type of CheckEnumCaps. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func CheckEnumCapsMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.CheckEnumCaps"]
}




type CheckEnumCaps_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*CheckEnumCaps_Request) MojomType() mojom_types.UserDefinedType {
	return CheckEnumCapsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*CheckEnumCaps_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type CheckEnumCaps_Pointer bindings.InterfacePointer


type CheckEnumCaps_ServiceFactory struct{
	Delegate CheckEnumCaps_Factory
}

type CheckEnumCaps_Factory interface {
	Create(request CheckEnumCaps_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *CheckEnumCaps_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &CheckEnumCaps_ServiceDescription{}
}

func (f *CheckEnumCaps_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := CheckEnumCaps_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForCheckEnumCaps creates a message pipe for use with the
// CheckEnumCaps interface with a CheckEnumCaps_Request on one end and a CheckEnumCaps_Pointer on the other.
func CreateMessagePipeForCheckEnumCaps() (CheckEnumCaps_Request, CheckEnumCaps_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return CheckEnumCaps_Request(r), CheckEnumCaps_Pointer(p)
}

const checkEnumCaps_SetEnumWithInternalAllCaps_Name uint32 = 0

type CheckEnumCaps_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewCheckEnumCapsProxy(p CheckEnumCaps_Pointer, waiter bindings.AsyncWaiter) *CheckEnumCaps_Proxy {
	return &CheckEnumCaps_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *CheckEnumCaps_Proxy) Close_Proxy() {
	p.router.Close()
}

type checkEnumCaps_SetEnumWithINTERNALAllCaps_Params struct {
	inE EnumWithInternalAllCaps
}


func (s *checkEnumCaps_SetEnumWithINTERNALAllCaps_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.inE)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var checkEnumCaps_SetEnumWithINTERNALAllCaps_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *checkEnumCaps_SetEnumWithINTERNALAllCaps_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(checkEnumCaps_SetEnumWithINTERNALAllCaps_Params_Versions), func(i int) bool {
		return checkEnumCaps_SetEnumWithINTERNALAllCaps_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(checkEnumCaps_SetEnumWithINTERNALAllCaps_Params_Versions) {
		if checkEnumCaps_SetEnumWithINTERNALAllCaps_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := checkEnumCaps_SetEnumWithINTERNALAllCaps_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inE = EnumWithInternalAllCaps(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *CheckEnumCaps_Proxy) SetEnumWithInternalAllCaps(inE EnumWithInternalAllCaps) (err error) {
	payload := &checkEnumCaps_SetEnumWithINTERNALAllCaps_Params{
		inE,
	}
	header := bindings.MessageHeader{
		Type: checkEnumCaps_SetEnumWithInternalAllCaps_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type checkEnumCaps_Stub struct {
	connector *bindings.Connector
	impl CheckEnumCaps
}

func NewCheckEnumCapsStub(r CheckEnumCaps_Request, impl CheckEnumCaps, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &checkEnumCaps_Stub{connector, impl})
}


func (f *CheckEnumCaps_Request) ServiceDescription() service_describer.ServiceDescription {
	return &CheckEnumCaps_ServiceDescription{}
}


type CheckEnumCaps_ServiceDescription struct{}

func (sd *CheckEnumCaps_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *CheckEnumCaps_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *CheckEnumCaps_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*CheckEnumCaps_ServiceDescription)(nil)


func (s *checkEnumCaps_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case checkEnumCaps_SetEnumWithInternalAllCaps_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request checkEnumCaps_SetEnumWithINTERNALAllCaps_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SetEnumWithInternalAllCaps(request.inE)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type TestInterface interface {
	SomeMessage() (err error)
}


// TestInterfaceMojomType returns the UserDefinedType that describes the Mojom
// type of TestInterface. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func TestInterfaceMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.TestInterface"]
}




type TestInterface_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*TestInterface_Request) MojomType() mojom_types.UserDefinedType {
	return TestInterfaceMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*TestInterface_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type TestInterface_Pointer bindings.InterfacePointer


type TestInterface_ServiceFactory struct{
	Delegate TestInterface_Factory
}

type TestInterface_Factory interface {
	Create(request TestInterface_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *TestInterface_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &TestInterface_ServiceDescription{}
}

func (f *TestInterface_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := TestInterface_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForTestInterface creates a message pipe for use with the
// TestInterface interface with a TestInterface_Request on one end and a TestInterface_Pointer on the other.
func CreateMessagePipeForTestInterface() (TestInterface_Request, TestInterface_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return TestInterface_Request(r), TestInterface_Pointer(p)
}

const testInterface_SomeMessage_Name uint32 = 0

type TestInterface_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewTestInterfaceProxy(p TestInterface_Pointer, waiter bindings.AsyncWaiter) *TestInterface_Proxy {
	return &TestInterface_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *TestInterface_Proxy) Close_Proxy() {
	p.router.Close()
}

type testInterface_SomeMessage_Params struct {
}


func (s *testInterface_SomeMessage_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var testInterface_SomeMessage_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *testInterface_SomeMessage_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(testInterface_SomeMessage_Params_Versions), func(i int) bool {
		return testInterface_SomeMessage_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(testInterface_SomeMessage_Params_Versions) {
		if testInterface_SomeMessage_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := testInterface_SomeMessage_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *TestInterface_Proxy) SomeMessage() (err error) {
	payload := &testInterface_SomeMessage_Params{
	}
	header := bindings.MessageHeader{
		Type: testInterface_SomeMessage_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type testInterface_Stub struct {
	connector *bindings.Connector
	impl TestInterface
}

func NewTestInterfaceStub(r TestInterface_Request, impl TestInterface, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &testInterface_Stub{connector, impl})
}


func (f *TestInterface_Request) ServiceDescription() service_describer.ServiceDescription {
	return &TestInterface_ServiceDescription{}
}


type TestInterface_ServiceDescription struct{}

func (sd *TestInterface_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *TestInterface_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *TestInterface_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*TestInterface_ServiceDescription)(nil)


func (s *testInterface_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case testInterface_SomeMessage_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request testInterface_SomeMessage_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SomeMessage()
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type Regression551 interface {
	Get(inKeyPrefixes []string) (outResult int32, err error)
}


// Regression551MojomType returns the UserDefinedType that describes the Mojom
// type of Regression551. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func Regression551MojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.Regression551"]
}




type Regression551_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Regression551_Request) MojomType() mojom_types.UserDefinedType {
	return Regression551MojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Regression551_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type Regression551_Pointer bindings.InterfacePointer


type Regression551_ServiceFactory struct{
	Delegate Regression551_Factory
}

type Regression551_Factory interface {
	Create(request Regression551_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *Regression551_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &Regression551_ServiceDescription{}
}

func (f *Regression551_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := Regression551_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForRegression551 creates a message pipe for use with the
// Regression551 interface with a Regression551_Request on one end and a Regression551_Pointer on the other.
func CreateMessagePipeForRegression551() (Regression551_Request, Regression551_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return Regression551_Request(r), Regression551_Pointer(p)
}

const regression551_Get_Name uint32 = 0

type Regression551_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewRegression551Proxy(p Regression551_Pointer, waiter bindings.AsyncWaiter) *Regression551_Proxy {
	return &Regression551_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *Regression551_Proxy) Close_Proxy() {
	p.router.Close()
}

type regression551_Get_Params struct {
	inKeyPrefixes []string
}


func (s *regression551_Get_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.inKeyPrefixes)), 64)
	for _, elem0 := range s.inKeyPrefixes {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var regression551_Get_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *regression551_Get_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(regression551_Get_Params_Versions), func(i int) bool {
		return regression551_Get_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(regression551_Get_Params_Versions) {
		if regression551_Get_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := regression551_Get_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.inKeyPrefixes = make([]string, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					value1, err := decoder.ReadString()
					if err != nil {
						return err
					}
					s.inKeyPrefixes[i0] = value1
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type regression551_Get_ResponseParams struct {
	outResult int32
}


func (s *regression551_Get_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.outResult); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var regression551_Get_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *regression551_Get_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(regression551_Get_ResponseParams_Versions), func(i int) bool {
		return regression551_Get_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(regression551_Get_ResponseParams_Versions) {
		if regression551_Get_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := regression551_Get_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outResult = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Regression551_Proxy) Get(inKeyPrefixes []string) (outResult int32, err error) {
	payload := &regression551_Get_Params{
		inKeyPrefixes,
	}
	header := bindings.MessageHeader{
		Type: regression551_Get_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, regression551_Get_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response regression551_Get_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outResult = response.outResult
	return
}

type regression551_Stub struct {
	connector *bindings.Connector
	impl Regression551
}

func NewRegression551Stub(r Regression551_Request, impl Regression551, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &regression551_Stub{connector, impl})
}


func (f *Regression551_Request) ServiceDescription() service_describer.ServiceDescription {
	return &Regression551_ServiceDescription{}
}


type Regression551_ServiceDescription struct{}

func (sd *Regression551_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *Regression551_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *Regression551_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*Regression551_ServiceDescription)(nil)


func (s *regression551_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case regression551_Get_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request regression551_Get_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response regression551_Get_ResponseParams
		response.outResult, err = s.impl.Get(request.inKeyPrefixes)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: regression551_Get_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type ServiceName interface {
	ServiceName() (outServiceName string, err error)
}


// ServiceNameMojomType returns the UserDefinedType that describes the Mojom
// type of ServiceName. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func ServiceNameMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.ServiceName"]
}




type ServiceName_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ServiceName_Request) MojomType() mojom_types.UserDefinedType {
	return ServiceNameMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ServiceName_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type ServiceName_Pointer bindings.InterfacePointer


type ServiceName_ServiceFactory struct{
	Delegate ServiceName_Factory
}

type ServiceName_Factory interface {
	Create(request ServiceName_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *ServiceName_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &ServiceName_ServiceDescription{}
}

func (f *ServiceName_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := ServiceName_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForServiceName creates a message pipe for use with the
// ServiceName interface with a ServiceName_Request on one end and a ServiceName_Pointer on the other.
func CreateMessagePipeForServiceName() (ServiceName_Request, ServiceName_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return ServiceName_Request(r), ServiceName_Pointer(p)
}

const serviceName_ServiceName_Name uint32 = 0

type ServiceName_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewServiceNameProxy(p ServiceName_Pointer, waiter bindings.AsyncWaiter) *ServiceName_Proxy {
	return &ServiceName_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *ServiceName_Proxy) Close_Proxy() {
	p.router.Close()
}

type serviceName_serviceName_Params struct {
}


func (s *serviceName_serviceName_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var serviceName_serviceName_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *serviceName_serviceName_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(serviceName_serviceName_Params_Versions), func(i int) bool {
		return serviceName_serviceName_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(serviceName_serviceName_Params_Versions) {
		if serviceName_serviceName_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := serviceName_serviceName_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type serviceName_serviceName_ResponseParams struct {
	outServiceName string
}


func (s *serviceName_serviceName_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.outServiceName); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var serviceName_serviceName_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *serviceName_serviceName_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(serviceName_serviceName_ResponseParams_Versions), func(i int) bool {
		return serviceName_serviceName_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(serviceName_serviceName_ResponseParams_Versions) {
		if serviceName_serviceName_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := serviceName_serviceName_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.outServiceName = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *ServiceName_Proxy) ServiceName() (outServiceName string, err error) {
	payload := &serviceName_serviceName_Params{
	}
	header := bindings.MessageHeader{
		Type: serviceName_ServiceName_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, serviceName_ServiceName_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response serviceName_serviceName_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outServiceName = response.outServiceName
	return
}

type serviceName_Stub struct {
	connector *bindings.Connector
	impl ServiceName
}

func NewServiceNameStub(r ServiceName_Request, impl ServiceName, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &serviceName_Stub{connector, impl})
}


func (f *ServiceName_Request) ServiceDescription() service_describer.ServiceDescription {
	return &ServiceName_ServiceDescription{}
}


type ServiceName_ServiceDescription struct{}

func (sd *ServiceName_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *ServiceName_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *ServiceName_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*ServiceName_ServiceDescription)(nil)


func (s *serviceName_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case serviceName_ServiceName_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request serviceName_serviceName_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response serviceName_serviceName_ResponseParams
		response.outServiceName, err = s.impl.ServiceName()
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: serviceName_ServiceName_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type Edge struct {
	V *Vertex
}
// EdgeMojomType returns the UserDefinedType that describes the Mojom
// type of Edge. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func EdgeMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.Edge"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Edge) MojomType() mojom_types.UserDefinedType {
	return EdgeMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Edge) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *Edge) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if s.V == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.V).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var edge_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *Edge) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(edge_Versions), func(i int) bool {
		return edge_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(edge_Versions) {
		if edge_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := edge_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.V = nil
		} else {
			s.V = new(Vertex)
			if err := (*s.V).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type Vertex struct {
	E *EmptyStruct
}
// VertexMojomType returns the UserDefinedType that describes the Mojom
// type of Vertex. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func VertexMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.Vertex"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Vertex) MojomType() mojom_types.UserDefinedType {
	return VertexMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Vertex) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *Vertex) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if s.E == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.E).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var vertex_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *Vertex) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(vertex_Versions), func(i int) bool {
		return vertex_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(vertex_Versions) {
		if vertex_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := vertex_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.E = nil
		} else {
			s.E = new(EmptyStruct)
			if err := (*s.E).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type EmptyStruct struct {
}
// EmptyStructMojomType returns the UserDefinedType that describes the Mojom
// type of EmptyStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func EmptyStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.EmptyStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*EmptyStruct) MojomType() mojom_types.UserDefinedType {
	return EmptyStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*EmptyStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *EmptyStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var emptyStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *EmptyStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(emptyStruct_Versions), func(i int) bool {
		return emptyStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(emptyStruct_Versions) {
		if emptyStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := emptyStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type A struct {
	B *B
}
// AMojomType returns the UserDefinedType that describes the Mojom
// type of A. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func AMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.A"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*A) MojomType() mojom_types.UserDefinedType {
	return AMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*A) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *A) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if s.B == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.B).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var a_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *A) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(a_Versions), func(i int) bool {
		return a_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(a_Versions) {
		if a_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := a_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.B = nil
		} else {
			s.B = new(B)
			if err := (*s.B).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type B struct {
	A *A
}
// BMojomType returns the UserDefinedType that describes the Mojom
// type of B. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func BMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.B"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*B) MojomType() mojom_types.UserDefinedType {
	return BMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*B) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *B) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if s.A == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.A).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var b_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *B) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(b_Versions), func(i int) bool {
		return b_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(b_Versions) {
		if b_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := b_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.A = nil
		} else {
			s.A = new(A)
			if err := (*s.A).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructWithHandleCalledHandles struct {
	Handles system.Handle
}
// StructWithHandleCalledHandlesMojomType returns the UserDefinedType that describes the Mojom
// type of StructWithHandleCalledHandles. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithHandleCalledHandlesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.StructWithHandleCalledHandles"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithHandleCalledHandles) MojomType() mojom_types.UserDefinedType {
	return StructWithHandleCalledHandlesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithHandleCalledHandles) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithHandleCalledHandles) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteHandle(s.Handles); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithHandleCalledHandles_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *StructWithHandleCalledHandles) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithHandleCalledHandles_Versions), func(i int) bool {
		return structWithHandleCalledHandles_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithHandleCalledHandles_Versions) {
		if structWithHandleCalledHandles_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithHandleCalledHandles_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.Handles = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructWithArrayOfHandlesCalledHandles struct {
	Handles []system.Handle
}
// StructWithArrayOfHandlesCalledHandlesMojomType returns the UserDefinedType that describes the Mojom
// type of StructWithArrayOfHandlesCalledHandles. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithArrayOfHandlesCalledHandlesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.StructWithArrayOfHandlesCalledHandles"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithArrayOfHandlesCalledHandles) MojomType() mojom_types.UserDefinedType {
	return StructWithArrayOfHandlesCalledHandlesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithArrayOfHandlesCalledHandles) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithArrayOfHandlesCalledHandles) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.Handles)), 32)
	for _, elem0 := range s.Handles {
		if err := encoder.WriteHandle(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithArrayOfHandlesCalledHandles_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *StructWithArrayOfHandlesCalledHandles) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithArrayOfHandlesCalledHandles_Versions), func(i int) bool {
		return structWithArrayOfHandlesCalledHandles_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithArrayOfHandlesCalledHandles_Versions) {
		if structWithArrayOfHandlesCalledHandles_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithArrayOfHandlesCalledHandles_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.Handles = make([]system.Handle, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				handle1, err := decoder.ReadHandle()
				if err != nil {
					return err
				}
				if handle1.IsValid() {
					s.Handles[i0] = handle1
				} else {
					return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructWithInterfaceCalledHandles struct {
	Handles TestInterface_Pointer
}
// StructWithInterfaceCalledHandlesMojomType returns the UserDefinedType that describes the Mojom
// type of StructWithInterfaceCalledHandles. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructWithInterfaceCalledHandlesMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.StructWithInterfaceCalledHandles"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructWithInterfaceCalledHandles) MojomType() mojom_types.UserDefinedType {
	return StructWithInterfaceCalledHandlesMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructWithInterfaceCalledHandles) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructWithInterfaceCalledHandles) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInterface(s.Handles.PassMessagePipe()); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structWithInterfaceCalledHandles_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *StructWithInterfaceCalledHandles) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structWithInterfaceCalledHandles_Versions), func(i int) bool {
		return structWithInterfaceCalledHandles_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structWithInterfaceCalledHandles_Versions) {
		if structWithInterfaceCalledHandles_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structWithInterfaceCalledHandles_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadInterface()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.Handles = TestInterface_Pointer{handleOwner}
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type ContainsArrayOfEnum struct {
	ArrayOfEnums []NormalEnum
}
// ContainsArrayOfEnumMojomType returns the UserDefinedType that describes the Mojom
// type of ContainsArrayOfEnum. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func ContainsArrayOfEnumMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:regression_tests.ContainsArrayOfEnum"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ContainsArrayOfEnum) MojomType() mojom_types.UserDefinedType {
	return ContainsArrayOfEnumMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ContainsArrayOfEnum) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *ContainsArrayOfEnum) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.ArrayOfEnums)), 32)
	for _, elem0 := range s.ArrayOfEnums {
		if err := encoder.WriteInt32(int32(elem0)); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var containsArrayOfEnum_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *ContainsArrayOfEnum) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(containsArrayOfEnum_Versions), func(i int) bool {
		return containsArrayOfEnum_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(containsArrayOfEnum_Versions) {
		if containsArrayOfEnum_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := containsArrayOfEnum_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(32)
			if err != nil {
				return err
			}
			s.ArrayOfEnums = make([]NormalEnum, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadInt32()
				if err != nil {
					return err
				}
				s.ArrayOfEnums[i0] = NormalEnum(value1)
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

