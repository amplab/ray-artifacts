// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library test_request_tracker_mojom;
import 'dart:async';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;



class ServiceStats extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  int numNewRequests = 0;
  double health = 0.0;

  ServiceStats() : super(kVersions.last.size);

  ServiceStats.init(
    int this.numNewRequests, 
    double this.health
  ) : super(kVersions.last.size);

  static ServiceStats deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ServiceStats decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ServiceStats result = new ServiceStats();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.numNewRequests = decoder0.decodeUint64(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.health = decoder0.decodeDouble(16);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ServiceStats";
    String fieldName;
    try {
      fieldName = "numNewRequests";
      encoder0.encodeUint64(numNewRequests, 8);
      fieldName = "health";
      encoder0.encodeDouble(health, 16);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ServiceStats("
           "numNewRequests: $numNewRequests" ", "
           "health: $health" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["numNewRequests"] = numNewRequests;
    map["health"] = health;
    return map;
  }
}


class ServiceReport extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  String serviceName_ = null;
  int totalRequests = 0;
  double meanHealth = 0.0;

  ServiceReport() : super(kVersions.last.size);

  ServiceReport.init(
    String this.serviceName_, 
    int this.totalRequests, 
    double this.meanHealth
  ) : super(kVersions.last.size);

  static ServiceReport deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ServiceReport decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ServiceReport result = new ServiceReport();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.serviceName_ = decoder0.decodeString(8, true);
    }
    if (mainDataHeader.version >= 0) {
      
      result.totalRequests = decoder0.decodeUint64(16);
    }
    if (mainDataHeader.version >= 0) {
      
      result.meanHealth = decoder0.decodeDouble(24);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ServiceReport";
    String fieldName;
    try {
      fieldName = "serviceName_";
      encoder0.encodeString(serviceName_, 8, true);
      fieldName = "totalRequests";
      encoder0.encodeUint64(totalRequests, 16);
      fieldName = "meanHealth";
      encoder0.encodeDouble(meanHealth, 24);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ServiceReport("
           "serviceName_: $serviceName_" ", "
           "totalRequests: $totalRequests" ", "
           "meanHealth: $meanHealth" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["serviceName_"] = serviceName_;
    map["totalRequests"] = totalRequests;
    map["meanHealth"] = meanHealth;
    return map;
  }
}


class _TestTrackedRequestServiceGetReportParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _TestTrackedRequestServiceGetReportParams() : super(kVersions.last.size);

  _TestTrackedRequestServiceGetReportParams.init(
  ) : super(kVersions.last.size);

  static _TestTrackedRequestServiceGetReportParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestTrackedRequestServiceGetReportParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestTrackedRequestServiceGetReportParams result = new _TestTrackedRequestServiceGetReportParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestTrackedRequestServiceGetReportParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestTrackedRequestServiceGetReportParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class TestTrackedRequestServiceGetReportResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<ServiceReport> report = null;

  TestTrackedRequestServiceGetReportResponseParams() : super(kVersions.last.size);

  TestTrackedRequestServiceGetReportResponseParams.init(
    List<ServiceReport> this.report
  ) : super(kVersions.last.size);

  static TestTrackedRequestServiceGetReportResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static TestTrackedRequestServiceGetReportResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    TestTrackedRequestServiceGetReportResponseParams result = new TestTrackedRequestServiceGetReportResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      if (decoder1 == null) {
        result.report = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.report = new List<ServiceReport>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, true);
          result.report[i1] = ServiceReport.decode(decoder2);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "TestTrackedRequestServiceGetReportResponseParams";
    String fieldName;
    try {
      fieldName = "report";
      if (report == null) {
        encoder0.encodeNullPointer(8, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(report.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < report.length; ++i0) {
          encoder1.encodeStruct(report[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, true);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "TestTrackedRequestServiceGetReportResponseParams("
           "report: $report" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["report"] = report;
    return map;
  }
}


class _TestRequestTrackerSetNameAndReturnIdParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String serviceName_ = null;

  _TestRequestTrackerSetNameAndReturnIdParams() : super(kVersions.last.size);

  _TestRequestTrackerSetNameAndReturnIdParams.init(
    String this.serviceName_
  ) : super(kVersions.last.size);

  static _TestRequestTrackerSetNameAndReturnIdParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestRequestTrackerSetNameAndReturnIdParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestRequestTrackerSetNameAndReturnIdParams result = new _TestRequestTrackerSetNameAndReturnIdParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.serviceName_ = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestRequestTrackerSetNameAndReturnIdParams";
    String fieldName;
    try {
      fieldName = "serviceName_";
      encoder0.encodeString(serviceName_, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestRequestTrackerSetNameAndReturnIdParams("
           "serviceName_: $serviceName_" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["serviceName_"] = serviceName_;
    return map;
  }
}


class TestRequestTrackerSetNameAndReturnIdResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int id = 0;

  TestRequestTrackerSetNameAndReturnIdResponseParams() : super(kVersions.last.size);

  TestRequestTrackerSetNameAndReturnIdResponseParams.init(
    int this.id
  ) : super(kVersions.last.size);

  static TestRequestTrackerSetNameAndReturnIdResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static TestRequestTrackerSetNameAndReturnIdResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    TestRequestTrackerSetNameAndReturnIdResponseParams result = new TestRequestTrackerSetNameAndReturnIdResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.id = decoder0.decodeUint64(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "TestRequestTrackerSetNameAndReturnIdResponseParams";
    String fieldName;
    try {
      fieldName = "id";
      encoder0.encodeUint64(id, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "TestRequestTrackerSetNameAndReturnIdResponseParams("
           "id: $id" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["id"] = id;
    return map;
  }
}


class _TestRequestTrackerRecordStatsParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  int clientId = 0;
  ServiceStats stats = null;

  _TestRequestTrackerRecordStatsParams() : super(kVersions.last.size);

  _TestRequestTrackerRecordStatsParams.init(
    int this.clientId, 
    ServiceStats this.stats
  ) : super(kVersions.last.size);

  static _TestRequestTrackerRecordStatsParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestRequestTrackerRecordStatsParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestRequestTrackerRecordStatsParams result = new _TestRequestTrackerRecordStatsParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.clientId = decoder0.decodeUint64(8);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.stats = ServiceStats.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestRequestTrackerRecordStatsParams";
    String fieldName;
    try {
      fieldName = "clientId";
      encoder0.encodeUint64(clientId, 8);
      fieldName = "stats";
      encoder0.encodeStruct(stats, 16, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestRequestTrackerRecordStatsParams("
           "clientId: $clientId" ", "
           "stats: $stats" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["clientId"] = clientId;
    map["stats"] = stats;
    return map;
  }
}

const int _testTrackedRequestServiceMethodGetReportName = 0;

class _TestTrackedRequestServiceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class TestTrackedRequestService {
  static const String serviceName = "mojo::test::TestTrackedRequestService";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _TestTrackedRequestServiceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static TestTrackedRequestServiceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    TestTrackedRequestServiceProxy p = new TestTrackedRequestServiceProxy.unbound();
    String name = serviceName ?? TestTrackedRequestService.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void getReport(void callback(List<ServiceReport> report));
}

abstract class TestTrackedRequestServiceInterface
    implements bindings.MojoInterface<TestTrackedRequestService>,
               TestTrackedRequestService {
  factory TestTrackedRequestServiceInterface([TestTrackedRequestService impl]) =>
      new TestTrackedRequestServiceStub.unbound(impl);

  factory TestTrackedRequestServiceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [TestTrackedRequestService impl]) =>
      new TestTrackedRequestServiceStub.fromEndpoint(endpoint, impl);

  factory TestTrackedRequestServiceInterface.fromMock(
      TestTrackedRequestService mock) =>
      new TestTrackedRequestServiceProxy.fromMock(mock);
}

abstract class TestTrackedRequestServiceInterfaceRequest
    implements bindings.MojoInterface<TestTrackedRequestService>,
               TestTrackedRequestService {
  factory TestTrackedRequestServiceInterfaceRequest() =>
      new TestTrackedRequestServiceProxy.unbound();
}

class _TestTrackedRequestServiceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<TestTrackedRequestService> {
  TestTrackedRequestService impl;

  _TestTrackedRequestServiceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _TestTrackedRequestServiceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _TestTrackedRequestServiceProxyControl.unbound() : super.unbound();

  String get serviceName => TestTrackedRequestService.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _testTrackedRequestServiceMethodGetReportName:
        var r = TestTrackedRequestServiceGetReportResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.report );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestTrackedRequestServiceProxyControl($superString)";
  }
}

class TestTrackedRequestServiceProxy
    extends bindings.Proxy<TestTrackedRequestService>
    implements TestTrackedRequestService,
               TestTrackedRequestServiceInterface,
               TestTrackedRequestServiceInterfaceRequest {
  TestTrackedRequestServiceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _TestTrackedRequestServiceProxyControl.fromEndpoint(endpoint));

  TestTrackedRequestServiceProxy.fromHandle(core.MojoHandle handle)
      : super(new _TestTrackedRequestServiceProxyControl.fromHandle(handle));

  TestTrackedRequestServiceProxy.unbound()
      : super(new _TestTrackedRequestServiceProxyControl.unbound());

  factory TestTrackedRequestServiceProxy.fromMock(TestTrackedRequestService mock) {
    TestTrackedRequestServiceProxy newMockedProxy =
        new TestTrackedRequestServiceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static TestTrackedRequestServiceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestTrackedRequestServiceProxy"));
    return new TestTrackedRequestServiceProxy.fromEndpoint(endpoint);
  }


  void getReport(void callback(List<ServiceReport> report)) {
    if (impl != null) {
      impl.getReport(callback);
      return;
    }
    var params = new _TestTrackedRequestServiceGetReportParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((List<ServiceReport> report) {
        z.bindCallback(() {
          callback(report);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _testTrackedRequestServiceMethodGetReportName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _TestTrackedRequestServiceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<TestTrackedRequestService> {
  TestTrackedRequestService _impl;

  _TestTrackedRequestServiceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestTrackedRequestService impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestTrackedRequestServiceStubControl.fromHandle(
      core.MojoHandle handle, [TestTrackedRequestService impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestTrackedRequestServiceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => TestTrackedRequestService.serviceName;


  Function _testTrackedRequestServiceGetReportResponseParamsResponder(
      int requestId) {
  return (List<ServiceReport> report) {
      var result = new TestTrackedRequestServiceGetReportResponseParams();
      result.report = report;
      sendResponse(buildResponseWithId(
          result,
          _testTrackedRequestServiceMethodGetReportName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _testTrackedRequestServiceMethodGetReportName:
        _impl.getReport(_testTrackedRequestServiceGetReportResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  TestTrackedRequestService get impl => _impl;
  set impl(TestTrackedRequestService d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestTrackedRequestServiceStubControl($superString)";
  }

  int get version => 0;
}

class TestTrackedRequestServiceStub
    extends bindings.Stub<TestTrackedRequestService>
    implements TestTrackedRequestService,
               TestTrackedRequestServiceInterface,
               TestTrackedRequestServiceInterfaceRequest {
  TestTrackedRequestServiceStub.unbound([TestTrackedRequestService impl])
      : super(new _TestTrackedRequestServiceStubControl.unbound(impl));

  TestTrackedRequestServiceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestTrackedRequestService impl])
      : super(new _TestTrackedRequestServiceStubControl.fromEndpoint(endpoint, impl));

  TestTrackedRequestServiceStub.fromHandle(
      core.MojoHandle handle, [TestTrackedRequestService impl])
      : super(new _TestTrackedRequestServiceStubControl.fromHandle(handle, impl));

  static TestTrackedRequestServiceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestTrackedRequestServiceStub"));
    return new TestTrackedRequestServiceStub.fromEndpoint(endpoint);
  }


  void getReport(void callback(List<ServiceReport> report)) {
    return impl.getReport(callback);
  }
}

const int _testRequestTrackerMethodSetNameAndReturnIdName = 0;
const int _testRequestTrackerMethodRecordStatsName = 1;

class _TestRequestTrackerServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class TestRequestTracker {
  static const String serviceName = "mojo::test::TestRequestTracker";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _TestRequestTrackerServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static TestRequestTrackerProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    TestRequestTrackerProxy p = new TestRequestTrackerProxy.unbound();
    String name = serviceName ?? TestRequestTracker.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void setNameAndReturnId(String serviceName_,void callback(int id));
  void recordStats(int clientId, ServiceStats stats);
}

abstract class TestRequestTrackerInterface
    implements bindings.MojoInterface<TestRequestTracker>,
               TestRequestTracker {
  factory TestRequestTrackerInterface([TestRequestTracker impl]) =>
      new TestRequestTrackerStub.unbound(impl);

  factory TestRequestTrackerInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [TestRequestTracker impl]) =>
      new TestRequestTrackerStub.fromEndpoint(endpoint, impl);

  factory TestRequestTrackerInterface.fromMock(
      TestRequestTracker mock) =>
      new TestRequestTrackerProxy.fromMock(mock);
}

abstract class TestRequestTrackerInterfaceRequest
    implements bindings.MojoInterface<TestRequestTracker>,
               TestRequestTracker {
  factory TestRequestTrackerInterfaceRequest() =>
      new TestRequestTrackerProxy.unbound();
}

class _TestRequestTrackerProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<TestRequestTracker> {
  TestRequestTracker impl;

  _TestRequestTrackerProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _TestRequestTrackerProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _TestRequestTrackerProxyControl.unbound() : super.unbound();

  String get serviceName => TestRequestTracker.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _testRequestTrackerMethodSetNameAndReturnIdName:
        var r = TestRequestTrackerSetNameAndReturnIdResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.id );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestRequestTrackerProxyControl($superString)";
  }
}

class TestRequestTrackerProxy
    extends bindings.Proxy<TestRequestTracker>
    implements TestRequestTracker,
               TestRequestTrackerInterface,
               TestRequestTrackerInterfaceRequest {
  TestRequestTrackerProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _TestRequestTrackerProxyControl.fromEndpoint(endpoint));

  TestRequestTrackerProxy.fromHandle(core.MojoHandle handle)
      : super(new _TestRequestTrackerProxyControl.fromHandle(handle));

  TestRequestTrackerProxy.unbound()
      : super(new _TestRequestTrackerProxyControl.unbound());

  factory TestRequestTrackerProxy.fromMock(TestRequestTracker mock) {
    TestRequestTrackerProxy newMockedProxy =
        new TestRequestTrackerProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static TestRequestTrackerProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestRequestTrackerProxy"));
    return new TestRequestTrackerProxy.fromEndpoint(endpoint);
  }


  void setNameAndReturnId(String serviceName_,void callback(int id)) {
    if (impl != null) {
      impl.setNameAndReturnId(serviceName_,callback);
      return;
    }
    var params = new _TestRequestTrackerSetNameAndReturnIdParams();
    params.serviceName_ = serviceName_;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((int id) {
        z.bindCallback(() {
          callback(id);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _testRequestTrackerMethodSetNameAndReturnIdName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void recordStats(int clientId, ServiceStats stats) {
    if (impl != null) {
      impl.recordStats(clientId, stats);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _TestRequestTrackerRecordStatsParams();
    params.clientId = clientId;
    params.stats = stats;
    ctrl.sendMessage(params,
        _testRequestTrackerMethodRecordStatsName);
  }
}

class _TestRequestTrackerStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<TestRequestTracker> {
  TestRequestTracker _impl;

  _TestRequestTrackerStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestRequestTracker impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestRequestTrackerStubControl.fromHandle(
      core.MojoHandle handle, [TestRequestTracker impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestRequestTrackerStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => TestRequestTracker.serviceName;


  Function _testRequestTrackerSetNameAndReturnIdResponseParamsResponder(
      int requestId) {
  return (int id) {
      var result = new TestRequestTrackerSetNameAndReturnIdResponseParams();
      result.id = id;
      sendResponse(buildResponseWithId(
          result,
          _testRequestTrackerMethodSetNameAndReturnIdName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _testRequestTrackerMethodSetNameAndReturnIdName:
        var params = _TestRequestTrackerSetNameAndReturnIdParams.deserialize(
            message.payload);
        _impl.setNameAndReturnId(params.serviceName_, _testRequestTrackerSetNameAndReturnIdResponseParamsResponder(message.header.requestId));
        break;
      case _testRequestTrackerMethodRecordStatsName:
        var params = _TestRequestTrackerRecordStatsParams.deserialize(
            message.payload);
        _impl.recordStats(params.clientId, params.stats);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  TestRequestTracker get impl => _impl;
  set impl(TestRequestTracker d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestRequestTrackerStubControl($superString)";
  }

  int get version => 0;
}

class TestRequestTrackerStub
    extends bindings.Stub<TestRequestTracker>
    implements TestRequestTracker,
               TestRequestTrackerInterface,
               TestRequestTrackerInterfaceRequest {
  TestRequestTrackerStub.unbound([TestRequestTracker impl])
      : super(new _TestRequestTrackerStubControl.unbound(impl));

  TestRequestTrackerStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestRequestTracker impl])
      : super(new _TestRequestTrackerStubControl.fromEndpoint(endpoint, impl));

  TestRequestTrackerStub.fromHandle(
      core.MojoHandle handle, [TestRequestTracker impl])
      : super(new _TestRequestTrackerStubControl.fromHandle(handle, impl));

  static TestRequestTrackerStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestRequestTrackerStub"));
    return new TestRequestTrackerStub.fromEndpoint(endpoint);
  }


  void setNameAndReturnId(String serviceName_,void callback(int id)) {
    return impl.setNameAndReturnId(serviceName_,callback);
  }
  void recordStats(int clientId, ServiceStats stats) {
    return impl.recordStats(clientId, stats);
  }
}



