// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/public/interfaces/bindings/tests/sample_interfaces.mojom.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
namespace sample {

// --- Interface definitions ---
class Provider_EchoString_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Provider_EchoString_ForwardToCallback(
      const Provider::EchoStringCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Provider::EchoStringCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Provider_EchoString_ForwardToCallback);
};
bool Provider_EchoString_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Provider_EchoString_ResponseParams_Data* params =
      reinterpret_cast<internal::Provider_EchoString_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::String p_a {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    Deserialize_(params->a.ptr, &p_a);
  } while (false);
  callback_.Run(p_a);
  return true;
}
class Provider_EchoStrings_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Provider_EchoStrings_ForwardToCallback(
      const Provider::EchoStringsCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Provider::EchoStringsCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Provider_EchoStrings_ForwardToCallback);
};
bool Provider_EchoStrings_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Provider_EchoStrings_ResponseParams_Data* params =
      reinterpret_cast<internal::Provider_EchoStrings_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::String p_a {};
  mojo::String p_b {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    Deserialize_(params->a.ptr, &p_a);
    Deserialize_(params->b.ptr, &p_b);
  } while (false);
  callback_.Run(p_a, p_b);
  return true;
}
class Provider_EchoMessagePipeHandle_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Provider_EchoMessagePipeHandle_ForwardToCallback(
      const Provider::EchoMessagePipeHandleCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Provider::EchoMessagePipeHandleCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Provider_EchoMessagePipeHandle_ForwardToCallback);
};
bool Provider_EchoMessagePipeHandle_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Provider_EchoMessagePipeHandle_ResponseParams_Data* params =
      reinterpret_cast<internal::Provider_EchoMessagePipeHandle_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::ScopedMessagePipeHandle p_a {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    p_a.reset(mojo::internal::FetchAndReset(&params->a));
  } while (false);
  callback_.Run(p_a.Pass());
  return true;
}
class Provider_EchoEnum_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Provider_EchoEnum_ForwardToCallback(
      const Provider::EchoEnumCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Provider::EchoEnumCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Provider_EchoEnum_ForwardToCallback);
};
bool Provider_EchoEnum_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Provider_EchoEnum_ResponseParams_Data* params =
      reinterpret_cast<internal::Provider_EchoEnum_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  Enum p_a {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    p_a = static_cast<Enum>(params->a);
  } while (false);
  callback_.Run(p_a);
  return true;
}
class Provider_EchoInt_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Provider_EchoInt_ForwardToCallback(
      const Provider::EchoIntCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Provider::EchoIntCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Provider_EchoInt_ForwardToCallback);
};
bool Provider_EchoInt_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Provider_EchoInt_ResponseParams_Data* params =
      reinterpret_cast<internal::Provider_EchoInt_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  int32_t p_a {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    p_a = params->a;
  } while (false);
  callback_.Run(p_a);
  return true;
}

ProviderProxy::ProviderProxy(mojo::MessageReceiverWithResponder* receiver)
    : ControlMessageProxy(receiver) {
}
void ProviderProxy::EchoString(
    const mojo::String& in_a, const EchoStringCallback& callback) {
  size_t size = sizeof(internal::Provider_EchoString_Params_Data);
  size += GetSerializedSize_(in_a);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoString), size);

  internal::Provider_EchoString_Params_Data* params =
      internal::Provider_EchoString_Params_Data::New(builder.buffer());
  SerializeString_(in_a, builder.buffer(), &params->a.ptr);
  if (!params->a.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a in Provider.EchoString request");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Provider_EchoString_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void ProviderProxy::EchoStrings(
    const mojo::String& in_a, const mojo::String& in_b, const EchoStringsCallback& callback) {
  size_t size = sizeof(internal::Provider_EchoStrings_Params_Data);
  size += GetSerializedSize_(in_a);
  size += GetSerializedSize_(in_b);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoStrings), size);

  internal::Provider_EchoStrings_Params_Data* params =
      internal::Provider_EchoStrings_Params_Data::New(builder.buffer());
  SerializeString_(in_a, builder.buffer(), &params->a.ptr);
  if (!params->a.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a in Provider.EchoStrings request");
  }
  SerializeString_(in_b, builder.buffer(), &params->b.ptr);
  if (!params->b.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null b in Provider.EchoStrings request");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Provider_EchoStrings_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void ProviderProxy::EchoMessagePipeHandle(
    mojo::ScopedMessagePipeHandle in_a, const EchoMessagePipeHandleCallback& callback) {
  size_t size = sizeof(internal::Provider_EchoMessagePipeHandle_Params_Data);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoMessagePipeHandle), size);

  internal::Provider_EchoMessagePipeHandle_Params_Data* params =
      internal::Provider_EchoMessagePipeHandle_Params_Data::New(builder.buffer());
  params->a = in_a.release();
  if (!params->a.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid a in Provider.EchoMessagePipeHandle request");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Provider_EchoMessagePipeHandle_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void ProviderProxy::EchoEnum(
    Enum in_a, const EchoEnumCallback& callback) {
  size_t size = sizeof(internal::Provider_EchoEnum_Params_Data);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoEnum), size);

  internal::Provider_EchoEnum_Params_Data* params =
      internal::Provider_EchoEnum_Params_Data::New(builder.buffer());
  params->a =
    static_cast<int32_t>(in_a);
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Provider_EchoEnum_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void ProviderProxy::EchoInt(
    int32_t in_a, const EchoIntCallback& callback) {
  size_t size = sizeof(internal::Provider_EchoInt_Params_Data);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoInt), size);

  internal::Provider_EchoInt_Params_Data* params =
      internal::Provider_EchoInt_Params_Data::New(builder.buffer());
  params->a = in_a;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Provider_EchoInt_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Provider_EchoString_ProxyToResponder
    : public Provider::EchoStringCallback::Runnable {
 public:
  ~Provider_EchoString_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Provider::EchoString(p_a, callback) "
        "was never run.";
  }

  Provider_EchoString_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(const mojo::String& in_a) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Provider_EchoString_ProxyToResponder);
};

void Provider_EchoString_ProxyToResponder::Run(
    const mojo::String& in_a) const {
  size_t size = sizeof(internal::Provider_EchoString_ResponseParams_Data);
  size += GetSerializedSize_(in_a);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoString), size, request_id_);
  internal::Provider_EchoString_ResponseParams_Data* params =
      internal::Provider_EchoString_ResponseParams_Data::New(builder.buffer());
  SerializeString_(in_a, builder.buffer(), &params->a.ptr);
  if (!params->a.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a in Provider.EchoString response");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Provider_EchoStrings_ProxyToResponder
    : public Provider::EchoStringsCallback::Runnable {
 public:
  ~Provider_EchoStrings_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Provider::EchoStrings(p_a, p_b, callback) "
        "was never run.";
  }

  Provider_EchoStrings_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(const mojo::String& in_a, const mojo::String& in_b) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Provider_EchoStrings_ProxyToResponder);
};

void Provider_EchoStrings_ProxyToResponder::Run(
    const mojo::String& in_a, const mojo::String& in_b) const {
  size_t size = sizeof(internal::Provider_EchoStrings_ResponseParams_Data);
  size += GetSerializedSize_(in_a);
  size += GetSerializedSize_(in_b);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoStrings), size, request_id_);
  internal::Provider_EchoStrings_ResponseParams_Data* params =
      internal::Provider_EchoStrings_ResponseParams_Data::New(builder.buffer());
  SerializeString_(in_a, builder.buffer(), &params->a.ptr);
  if (!params->a.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a in Provider.EchoStrings response");
  }
  SerializeString_(in_b, builder.buffer(), &params->b.ptr);
  if (!params->b.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null b in Provider.EchoStrings response");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Provider_EchoMessagePipeHandle_ProxyToResponder
    : public Provider::EchoMessagePipeHandleCallback::Runnable {
 public:
  ~Provider_EchoMessagePipeHandle_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Provider::EchoMessagePipeHandle(p_a.Pass(), callback) "
        "was never run.";
  }

  Provider_EchoMessagePipeHandle_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(mojo::ScopedMessagePipeHandle in_a) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Provider_EchoMessagePipeHandle_ProxyToResponder);
};

void Provider_EchoMessagePipeHandle_ProxyToResponder::Run(
    mojo::ScopedMessagePipeHandle in_a) const {
  size_t size = sizeof(internal::Provider_EchoMessagePipeHandle_ResponseParams_Data);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoMessagePipeHandle), size, request_id_);
  internal::Provider_EchoMessagePipeHandle_ResponseParams_Data* params =
      internal::Provider_EchoMessagePipeHandle_ResponseParams_Data::New(builder.buffer());
  params->a = in_a.release();
  if (!params->a.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid a in Provider.EchoMessagePipeHandle response");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Provider_EchoEnum_ProxyToResponder
    : public Provider::EchoEnumCallback::Runnable {
 public:
  ~Provider_EchoEnum_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Provider::EchoEnum(p_a, callback) "
        "was never run.";
  }

  Provider_EchoEnum_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(Enum in_a) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Provider_EchoEnum_ProxyToResponder);
};

void Provider_EchoEnum_ProxyToResponder::Run(
    Enum in_a) const {
  size_t size = sizeof(internal::Provider_EchoEnum_ResponseParams_Data);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoEnum), size, request_id_);
  internal::Provider_EchoEnum_ResponseParams_Data* params =
      internal::Provider_EchoEnum_ResponseParams_Data::New(builder.buffer());
  params->a =
    static_cast<int32_t>(in_a);
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Provider_EchoInt_ProxyToResponder
    : public Provider::EchoIntCallback::Runnable {
 public:
  ~Provider_EchoInt_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Provider::EchoInt(p_a, callback) "
        "was never run.";
  }

  Provider_EchoInt_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(int32_t in_a) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Provider_EchoInt_ProxyToResponder);
};

void Provider_EchoInt_ProxyToResponder::Run(
    int32_t in_a) const {
  size_t size = sizeof(internal::Provider_EchoInt_ResponseParams_Data);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Provider_Base::MessageOrdinals::EchoInt), size, request_id_);
  internal::Provider_EchoInt_ResponseParams_Data* params =
      internal::Provider_EchoInt_ResponseParams_Data::New(builder.buffer());
  params->a = in_a;
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}

ProviderStub::ProviderStub()
    : sink_(nullptr),
      control_message_handler_(Provider::Version_) {
}

ProviderStub::~ProviderStub() {}

bool ProviderStub::Accept(mojo::Message* message) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.Accept(message);
  internal::Provider_Base::MessageOrdinals method_ordinal =
      static_cast<internal::Provider_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::Provider_Base::MessageOrdinals::EchoString: {
      break;
    }
    case internal::Provider_Base::MessageOrdinals::EchoStrings: {
      break;
    }
    case internal::Provider_Base::MessageOrdinals::EchoMessagePipeHandle: {
      break;
    }
    case internal::Provider_Base::MessageOrdinals::EchoEnum: {
      break;
    }
    case internal::Provider_Base::MessageOrdinals::EchoInt: {
      break;
    }
  }
  return false;
}

bool ProviderStub::AcceptWithResponder(
    mojo::Message* message, mojo::MessageReceiverWithStatus* responder) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.AcceptWithResponder(message, responder);
  internal::Provider_Base::MessageOrdinals method_ordinal =
      static_cast<internal::Provider_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::Provider_Base::MessageOrdinals::EchoString: {
      internal::Provider_EchoString_Params_Data* params =
          reinterpret_cast<internal::Provider_EchoString_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Provider::EchoStringCallback::Runnable* runnable =
          new Provider_EchoString_ProxyToResponder(
              message->request_id(), responder);
      Provider::EchoStringCallback callback(runnable);
      
      mojo::String p_a {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        Deserialize_(params->a.ptr, &p_a);
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->EchoString(p_a, callback);
      return true;
    }
    case internal::Provider_Base::MessageOrdinals::EchoStrings: {
      internal::Provider_EchoStrings_Params_Data* params =
          reinterpret_cast<internal::Provider_EchoStrings_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Provider::EchoStringsCallback::Runnable* runnable =
          new Provider_EchoStrings_ProxyToResponder(
              message->request_id(), responder);
      Provider::EchoStringsCallback callback(runnable);
      
      mojo::String p_a {};
      mojo::String p_b {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        Deserialize_(params->a.ptr, &p_a);
        Deserialize_(params->b.ptr, &p_b);
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->EchoStrings(p_a, p_b, callback);
      return true;
    }
    case internal::Provider_Base::MessageOrdinals::EchoMessagePipeHandle: {
      internal::Provider_EchoMessagePipeHandle_Params_Data* params =
          reinterpret_cast<internal::Provider_EchoMessagePipeHandle_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Provider::EchoMessagePipeHandleCallback::Runnable* runnable =
          new Provider_EchoMessagePipeHandle_ProxyToResponder(
              message->request_id(), responder);
      Provider::EchoMessagePipeHandleCallback callback(runnable);
      
      mojo::ScopedMessagePipeHandle p_a {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_a.reset(mojo::internal::FetchAndReset(&params->a));
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->EchoMessagePipeHandle(p_a.Pass(), callback);
      return true;
    }
    case internal::Provider_Base::MessageOrdinals::EchoEnum: {
      internal::Provider_EchoEnum_Params_Data* params =
          reinterpret_cast<internal::Provider_EchoEnum_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Provider::EchoEnumCallback::Runnable* runnable =
          new Provider_EchoEnum_ProxyToResponder(
              message->request_id(), responder);
      Provider::EchoEnumCallback callback(runnable);
      
      Enum p_a {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_a = static_cast<Enum>(params->a);
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->EchoEnum(p_a, callback);
      return true;
    }
    case internal::Provider_Base::MessageOrdinals::EchoInt: {
      internal::Provider_EchoInt_Params_Data* params =
          reinterpret_cast<internal::Provider_EchoInt_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Provider::EchoIntCallback::Runnable* runnable =
          new Provider_EchoInt_ProxyToResponder(
              message->request_id(), responder);
      Provider::EchoIntCallback callback(runnable);
      
      int32_t p_a {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_a = params->a;
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->EchoInt(p_a, callback);
      return true;
    }
  }
  return false;
}

class IntegerAccessor_GetInteger_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  IntegerAccessor_GetInteger_ForwardToCallback(
      const IntegerAccessor::GetIntegerCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  IntegerAccessor::GetIntegerCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(IntegerAccessor_GetInteger_ForwardToCallback);
};
bool IntegerAccessor_GetInteger_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::IntegerAccessor_GetInteger_ResponseParams_Data* params =
      reinterpret_cast<internal::IntegerAccessor_GetInteger_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  int64_t p_data {};
  Enum p_type {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    p_data = params->data;
    if (params->header_.version < 2)
      break;
    p_type = static_cast<Enum>(params->type);
  } while (false);
  callback_.Run(p_data, p_type);
  return true;
}

IntegerAccessorProxy::IntegerAccessorProxy(mojo::MessageReceiverWithResponder* receiver)
    : ControlMessageProxy(receiver) {
}
void IntegerAccessorProxy::GetInteger(
    const GetIntegerCallback& callback) {
  size_t size = sizeof(internal::IntegerAccessor_GetInteger_Params_Data);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::IntegerAccessor_Base::MessageOrdinals::GetInteger), size);

  internal::IntegerAccessor_GetInteger_Params_Data* params =
      internal::IntegerAccessor_GetInteger_Params_Data::New(builder.buffer());
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new IntegerAccessor_GetInteger_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void IntegerAccessorProxy::SetInteger(
    int64_t in_data, Enum in_type) {
  size_t size = sizeof(internal::IntegerAccessor_SetInteger_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::IntegerAccessor_Base::MessageOrdinals::SetInteger), size);

  internal::IntegerAccessor_SetInteger_Params_Data* params =
      internal::IntegerAccessor_SetInteger_Params_Data::New(builder.buffer());
  params->data = in_data;
  params->type =
    static_cast<int32_t>(in_type);
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class IntegerAccessor_GetInteger_ProxyToResponder
    : public IntegerAccessor::GetIntegerCallback::Runnable {
 public:
  ~IntegerAccessor_GetInteger_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "IntegerAccessor::GetInteger(callback) "
        "was never run.";
  }

  IntegerAccessor_GetInteger_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(int64_t in_data, Enum in_type) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(IntegerAccessor_GetInteger_ProxyToResponder);
};

void IntegerAccessor_GetInteger_ProxyToResponder::Run(
    int64_t in_data, Enum in_type) const {
  size_t size = sizeof(internal::IntegerAccessor_GetInteger_ResponseParams_Data);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::IntegerAccessor_Base::MessageOrdinals::GetInteger), size, request_id_);
  internal::IntegerAccessor_GetInteger_ResponseParams_Data* params =
      internal::IntegerAccessor_GetInteger_ResponseParams_Data::New(builder.buffer());
  params->data = in_data;
  params->type =
    static_cast<int32_t>(in_type);
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}

IntegerAccessorStub::IntegerAccessorStub()
    : sink_(nullptr),
      control_message_handler_(IntegerAccessor::Version_) {
}

IntegerAccessorStub::~IntegerAccessorStub() {}

bool IntegerAccessorStub::Accept(mojo::Message* message) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.Accept(message);
  internal::IntegerAccessor_Base::MessageOrdinals method_ordinal =
      static_cast<internal::IntegerAccessor_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::IntegerAccessor_Base::MessageOrdinals::GetInteger: {
      break;
    }
    case internal::IntegerAccessor_Base::MessageOrdinals::SetInteger: {
      internal::IntegerAccessor_SetInteger_Params_Data* params =
          reinterpret_cast<internal::IntegerAccessor_SetInteger_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      int64_t p_data {};
      Enum p_type {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_data = params->data;
        if (params->header_.version < 3)
          break;
        p_type = static_cast<Enum>(params->type);
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->SetInteger(p_data, p_type);
      return true;
    }
  }
  return false;
}

bool IntegerAccessorStub::AcceptWithResponder(
    mojo::Message* message, mojo::MessageReceiverWithStatus* responder) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.AcceptWithResponder(message, responder);
  internal::IntegerAccessor_Base::MessageOrdinals method_ordinal =
      static_cast<internal::IntegerAccessor_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::IntegerAccessor_Base::MessageOrdinals::GetInteger: {
      internal::IntegerAccessor_GetInteger_Params_Data* params =
          reinterpret_cast<internal::IntegerAccessor_GetInteger_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      IntegerAccessor::GetIntegerCallback::Runnable* runnable =
          new IntegerAccessor_GetInteger_ProxyToResponder(
              message->request_id(), responder);
      IntegerAccessor::GetIntegerCallback callback(runnable);
      
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->GetInteger(callback);
      return true;
    }
    case internal::IntegerAccessor_Base::MessageOrdinals::SetInteger: {
      break;
    }
  }
  return false;
}

class SampleInterface_SampleMethod1_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SampleInterface_SampleMethod1_ForwardToCallback(
      const SampleInterface::SampleMethod1Callback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  SampleInterface::SampleMethod1Callback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(SampleInterface_SampleMethod1_ForwardToCallback);
};
bool SampleInterface_SampleMethod1_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::SampleInterface_SampleMethod1_ResponseParams_Data* params =
      reinterpret_cast<internal::SampleInterface_SampleMethod1_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::String p_out1 {};
  Enum p_out2 {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    Deserialize_(params->out1.ptr, &p_out1);
    p_out2 = static_cast<Enum>(params->out2);
  } while (false);
  callback_.Run(p_out1, p_out2);
  return true;
}

SampleInterfaceProxy::SampleInterfaceProxy(mojo::MessageReceiverWithResponder* receiver)
    : ControlMessageProxy(receiver) {
}
void SampleInterfaceProxy::SampleMethod1(
    int32_t in_in1, const mojo::String& in_in2, const SampleMethod1Callback& callback) {
  size_t size = sizeof(internal::SampleInterface_SampleMethod1_Params_Data);
  size += GetSerializedSize_(in_in2);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::SampleInterface_Base::MessageOrdinals::SampleMethod1), size);

  internal::SampleInterface_SampleMethod1_Params_Data* params =
      internal::SampleInterface_SampleMethod1_Params_Data::New(builder.buffer());
  params->in1 = in_in1;
  SerializeString_(in_in2, builder.buffer(), &params->in2.ptr);
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new SampleInterface_SampleMethod1_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void SampleInterfaceProxy::SampleMethod0(
    ) {
  size_t size = sizeof(internal::SampleInterface_SampleMethod0_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::SampleInterface_Base::MessageOrdinals::SampleMethod0), size);

  internal::SampleInterface_SampleMethod0_Params_Data* params =
      internal::SampleInterface_SampleMethod0_Params_Data::New(builder.buffer());
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
void SampleInterfaceProxy::SampleMethod2(
    ) {
  size_t size = sizeof(internal::SampleInterface_SampleMethod2_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::SampleInterface_Base::MessageOrdinals::SampleMethod2), size);

  internal::SampleInterface_SampleMethod2_Params_Data* params =
      internal::SampleInterface_SampleMethod2_Params_Data::New(builder.buffer());
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class SampleInterface_SampleMethod1_ProxyToResponder
    : public SampleInterface::SampleMethod1Callback::Runnable {
 public:
  ~SampleInterface_SampleMethod1_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "SampleInterface::SampleMethod1(p_in1, p_in2, callback) "
        "was never run.";
  }

  SampleInterface_SampleMethod1_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(const mojo::String& in_out1, Enum in_out2) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(SampleInterface_SampleMethod1_ProxyToResponder);
};

void SampleInterface_SampleMethod1_ProxyToResponder::Run(
    const mojo::String& in_out1, Enum in_out2) const {
  size_t size = sizeof(internal::SampleInterface_SampleMethod1_ResponseParams_Data);
  size += GetSerializedSize_(in_out1);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::SampleInterface_Base::MessageOrdinals::SampleMethod1), size, request_id_);
  internal::SampleInterface_SampleMethod1_ResponseParams_Data* params =
      internal::SampleInterface_SampleMethod1_ResponseParams_Data::New(builder.buffer());
  SerializeString_(in_out1, builder.buffer(), &params->out1.ptr);
  params->out2 =
    static_cast<int32_t>(in_out2);
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}

SampleInterfaceStub::SampleInterfaceStub()
    : sink_(nullptr),
      control_message_handler_(SampleInterface::Version_) {
}

SampleInterfaceStub::~SampleInterfaceStub() {}

bool SampleInterfaceStub::Accept(mojo::Message* message) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.Accept(message);
  internal::SampleInterface_Base::MessageOrdinals method_ordinal =
      static_cast<internal::SampleInterface_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::SampleInterface_Base::MessageOrdinals::SampleMethod1: {
      break;
    }
    case internal::SampleInterface_Base::MessageOrdinals::SampleMethod0: {
      internal::SampleInterface_SampleMethod0_Params_Data* params =
          reinterpret_cast<internal::SampleInterface_SampleMethod0_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->SampleMethod0();
      return true;
    }
    case internal::SampleInterface_Base::MessageOrdinals::SampleMethod2: {
      internal::SampleInterface_SampleMethod2_Params_Data* params =
          reinterpret_cast<internal::SampleInterface_SampleMethod2_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->SampleMethod2();
      return true;
    }
  }
  return false;
}

bool SampleInterfaceStub::AcceptWithResponder(
    mojo::Message* message, mojo::MessageReceiverWithStatus* responder) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.AcceptWithResponder(message, responder);
  internal::SampleInterface_Base::MessageOrdinals method_ordinal =
      static_cast<internal::SampleInterface_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::SampleInterface_Base::MessageOrdinals::SampleMethod1: {
      internal::SampleInterface_SampleMethod1_Params_Data* params =
          reinterpret_cast<internal::SampleInterface_SampleMethod1_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      SampleInterface::SampleMethod1Callback::Runnable* runnable =
          new SampleInterface_SampleMethod1_ProxyToResponder(
              message->request_id(), responder);
      SampleInterface::SampleMethod1Callback callback(runnable);
      
      int32_t p_in1 {};
      mojo::String p_in2 {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_in1 = params->in1;
        Deserialize_(params->in2.ptr, &p_in2);
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->SampleMethod1(p_in1, p_in2, callback);
      return true;
    }
    case internal::SampleInterface_Base::MessageOrdinals::SampleMethod0: {
      break;
    }
    case internal::SampleInterface_Base::MessageOrdinals::SampleMethod2: {
      break;
    }
  }
  return false;
}

}  // namespace sample
