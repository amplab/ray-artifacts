// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/services/network/interfaces/net_address.mojom
//

package net_address

import (
	sort "sort"
	fmt "fmt"
	bindings "mojo/public/go/bindings"
)


type NetAddressFamily int32

const (
	NetAddressFamily_Unspecified NetAddressFamily = 0
	NetAddressFamily_Ipv4 = NetAddressFamily_Unspecified + 1;
	NetAddressFamily_Ipv6 = NetAddressFamily_Ipv4 + 1;
)


type NetAddressIPv4 struct {
	Port uint16
	Addr [4]uint8
}


func (s *NetAddressIPv4) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteUint16(s.Port); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.Addr)), 8)
	for _, elem0 := range s.Addr {
		if err := encoder.WriteUint8(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var netAddressIPv4_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *NetAddressIPv4) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(netAddressIPv4_Versions), func(i int) bool {
		return netAddressIPv4_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(netAddressIPv4_Versions) {
		if netAddressIPv4_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := netAddressIPv4_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint16()
		if err != nil {
			return err
		}
		s.Port = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			if len0 != 4 {
				return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
					fmt.Sprintf("invalid array length: expected %d, got %d", 4, len0),
				}
			}
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadUint8()
				if err != nil {
					return err
				}
				s.Addr[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type NetAddressIPv6 struct {
	Port uint16
	Addr [16]uint8
}


func (s *NetAddressIPv6) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteUint16(s.Port); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.Addr)), 8)
	for _, elem0 := range s.Addr {
		if err := encoder.WriteUint8(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var netAddressIPv6_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *NetAddressIPv6) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(netAddressIPv6_Versions), func(i int) bool {
		return netAddressIPv6_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(netAddressIPv6_Versions) {
		if netAddressIPv6_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := netAddressIPv6_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint16()
		if err != nil {
			return err
		}
		s.Port = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(8)
			if err != nil {
				return err
			}
			if len0 != 16 {
				return &bindings.ValidationError{bindings.UnexpectedArrayHeader,
					fmt.Sprintf("invalid array length: expected %d, got %d", 16, len0),
				}
			}
			for i0 := uint32(0); i0 < len0; i0++ {
				value1, err := decoder.ReadUint8()
				if err != nil {
					return err
				}
				s.Addr[i0] = value1
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type NetAddress struct {
	Family NetAddressFamily
	Ipv4 *NetAddressIPv4
	Ipv6 *NetAddressIPv6
}


func (s *NetAddress) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if err := encoder.WriteInt32(int32(s.Family)); err != nil {
		return err
	}
	if s.Ipv4 == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.Ipv4).Encode(encoder); err != nil {
			return err
		}
	}
	if s.Ipv6 == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.Ipv6).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var netAddress_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *NetAddress) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(netAddress_Versions), func(i int) bool {
		return netAddress_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(netAddress_Versions) {
		if netAddress_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := netAddress_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.Family = NetAddressFamily(value0)
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Ipv4 = nil
		} else {
			s.Ipv4 = new(NetAddressIPv4)
			if err := (*s.Ipv4).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Ipv6 = nil
		} else {
			s.Ipv6 = new(NetAddressIPv6)
			if err := (*s.Ipv6).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

