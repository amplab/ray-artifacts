// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/services/notifications/interfaces/notifications.mojom
//

package notifications

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	fmt "fmt"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
)


type NotificationClient interface {
	OnSelected() (err error)
	OnDismissed() (err error)
}




type NotificationClient_Request bindings.InterfaceRequest



type NotificationClient_Pointer bindings.InterfacePointer


type NotificationClient_ServiceFactory struct{
	Delegate NotificationClient_Factory
}

type NotificationClient_Factory interface {
	Create(request NotificationClient_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *NotificationClient_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &NotificationClient_ServiceDescription{}
}

func (f *NotificationClient_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := NotificationClient_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForNotificationClient creates a message pipe for use with the
// NotificationClient interface with a NotificationClient_Request on one end and a NotificationClient_Pointer on the other.
func CreateMessagePipeForNotificationClient() (NotificationClient_Request, NotificationClient_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return NotificationClient_Request(r), NotificationClient_Pointer(p)
}

const notificationClient_OnSelected_Name uint32 = 0
const notificationClient_OnDismissed_Name uint32 = 1

type NotificationClient_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewNotificationClientProxy(p NotificationClient_Pointer, waiter bindings.AsyncWaiter) *NotificationClient_Proxy {
	return &NotificationClient_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *NotificationClient_Proxy) Close_Proxy() {
	p.router.Close()
}

type notificationClient_OnSelected_Params struct {
}


func (s *notificationClient_OnSelected_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var notificationClient_OnSelected_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *notificationClient_OnSelected_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(notificationClient_OnSelected_Params_Versions), func(i int) bool {
		return notificationClient_OnSelected_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(notificationClient_OnSelected_Params_Versions) {
		if notificationClient_OnSelected_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := notificationClient_OnSelected_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *NotificationClient_Proxy) OnSelected() (err error) {
	payload := &notificationClient_OnSelected_Params{
	}
	header := bindings.MessageHeader{
		Type: notificationClient_OnSelected_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type notificationClient_OnDismissed_Params struct {
}


func (s *notificationClient_OnDismissed_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var notificationClient_OnDismissed_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *notificationClient_OnDismissed_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(notificationClient_OnDismissed_Params_Versions), func(i int) bool {
		return notificationClient_OnDismissed_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(notificationClient_OnDismissed_Params_Versions) {
		if notificationClient_OnDismissed_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := notificationClient_OnDismissed_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *NotificationClient_Proxy) OnDismissed() (err error) {
	payload := &notificationClient_OnDismissed_Params{
	}
	header := bindings.MessageHeader{
		Type: notificationClient_OnDismissed_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type notificationClient_Stub struct {
	connector *bindings.Connector
	impl NotificationClient
}

func NewNotificationClientStub(r NotificationClient_Request, impl NotificationClient, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &notificationClient_Stub{connector, impl})
}


func (f *NotificationClient_Request) ServiceDescription() service_describer.ServiceDescription {
	return &NotificationClient_ServiceDescription{}
}


type NotificationClient_ServiceDescription struct{}

func (sd *NotificationClient_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *NotificationClient_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *NotificationClient_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*NotificationClient_ServiceDescription)(nil)


func (s *notificationClient_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case notificationClient_OnSelected_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request notificationClient_OnSelected_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.OnSelected()
		if err != nil {
			return
		}
	case notificationClient_OnDismissed_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request notificationClient_OnDismissed_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.OnDismissed()
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type Notification interface {
	Update(inNotificationData NotificationData) (err error)
	Cancel() (err error)
}




type Notification_Request bindings.InterfaceRequest



type Notification_Pointer bindings.InterfacePointer


type Notification_ServiceFactory struct{
	Delegate Notification_Factory
}

type Notification_Factory interface {
	Create(request Notification_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *Notification_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &Notification_ServiceDescription{}
}

func (f *Notification_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := Notification_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForNotification creates a message pipe for use with the
// Notification interface with a Notification_Request on one end and a Notification_Pointer on the other.
func CreateMessagePipeForNotification() (Notification_Request, Notification_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return Notification_Request(r), Notification_Pointer(p)
}

const notification_Update_Name uint32 = 0
const notification_Cancel_Name uint32 = 1

type Notification_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewNotificationProxy(p Notification_Pointer, waiter bindings.AsyncWaiter) *Notification_Proxy {
	return &Notification_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *Notification_Proxy) Close_Proxy() {
	p.router.Close()
}

type notification_Update_Params struct {
	inNotificationData NotificationData
}


func (s *notification_Update_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inNotificationData.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var notification_Update_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *notification_Update_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(notification_Update_Params_Versions), func(i int) bool {
		return notification_Update_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(notification_Update_Params_Versions) {
		if notification_Update_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := notification_Update_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inNotificationData.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Notification_Proxy) Update(inNotificationData NotificationData) (err error) {
	payload := &notification_Update_Params{
		inNotificationData,
	}
	header := bindings.MessageHeader{
		Type: notification_Update_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type notification_Cancel_Params struct {
}


func (s *notification_Cancel_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var notification_Cancel_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *notification_Cancel_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(notification_Cancel_Params_Versions), func(i int) bool {
		return notification_Cancel_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(notification_Cancel_Params_Versions) {
		if notification_Cancel_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := notification_Cancel_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Notification_Proxy) Cancel() (err error) {
	payload := &notification_Cancel_Params{
	}
	header := bindings.MessageHeader{
		Type: notification_Cancel_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type notification_Stub struct {
	connector *bindings.Connector
	impl Notification
}

func NewNotificationStub(r Notification_Request, impl Notification, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &notification_Stub{connector, impl})
}


func (f *Notification_Request) ServiceDescription() service_describer.ServiceDescription {
	return &Notification_ServiceDescription{}
}


type Notification_ServiceDescription struct{}

func (sd *Notification_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *Notification_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *Notification_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*Notification_ServiceDescription)(nil)


func (s *notification_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case notification_Update_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request notification_Update_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Update(request.inNotificationData)
		if err != nil {
			return
		}
	case notification_Cancel_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request notification_Cancel_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Cancel()
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type NotificationService interface {
	Post(inNotificationData NotificationData, inClient *NotificationClient_Pointer, inNotification *Notification_Request) (err error)
}



var notificationService_Name = "notifications::NotificationService"

type NotificationService_Request bindings.InterfaceRequest

func (r *NotificationService_Request) Name() string {
	return notificationService_Name
}


type NotificationService_Pointer bindings.InterfacePointer

func (p *NotificationService_Pointer) Name() string {
	return notificationService_Name
}

type NotificationService_ServiceFactory struct{
	Delegate NotificationService_Factory
}

type NotificationService_Factory interface {
	Create(request NotificationService_Request)
}

func (f *NotificationService_ServiceFactory) Name() string {
	return notificationService_Name
}

// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *NotificationService_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &NotificationService_ServiceDescription{}
}

func (f *NotificationService_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := NotificationService_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForNotificationService creates a message pipe for use with the
// NotificationService interface with a NotificationService_Request on one end and a NotificationService_Pointer on the other.
func CreateMessagePipeForNotificationService() (NotificationService_Request, NotificationService_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return NotificationService_Request(r), NotificationService_Pointer(p)
}

const notificationService_Post_Name uint32 = 0

type NotificationService_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewNotificationServiceProxy(p NotificationService_Pointer, waiter bindings.AsyncWaiter) *NotificationService_Proxy {
	return &NotificationService_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *NotificationService_Proxy) Close_Proxy() {
	p.router.Close()
}

type notificationService_Post_Params struct {
	inNotificationData NotificationData
	inClient *NotificationClient_Pointer
	inNotification *Notification_Request
}


func (s *notificationService_Post_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.inNotificationData.Encode(encoder); err != nil {
		return err
	}
	if s.inClient == nil {
		encoder.WriteInvalidInterface()
	} else {
		if err := encoder.WriteInterface((*s.inClient).PassMessagePipe()); err != nil {
			return err
		}
	}
	if s.inNotification == nil {
		encoder.WriteInvalidHandle()
	} else {
		if err := encoder.WriteHandle((*s.inNotification).PassMessagePipe()); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var notificationService_Post_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *notificationService_Post_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(notificationService_Post_Params_Versions), func(i int) bool {
		return notificationService_Post_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(notificationService_Post_Params_Versions) {
		if notificationService_Post_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := notificationService_Post_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.inNotificationData.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadInterface()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inClient = &NotificationClient_Pointer{handleOwner}
		} else {
			s.inClient = nil
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
			s.inNotification = &Notification_Request{handleOwner}
		} else {
			s.inNotification = nil
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *NotificationService_Proxy) Post(inNotificationData NotificationData, inClient *NotificationClient_Pointer, inNotification *Notification_Request) (err error) {
	payload := &notificationService_Post_Params{
		inNotificationData,
		inClient,
		inNotification,
	}
	header := bindings.MessageHeader{
		Type: notificationService_Post_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type notificationService_Stub struct {
	connector *bindings.Connector
	impl NotificationService
}

func NewNotificationServiceStub(r NotificationService_Request, impl NotificationService, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &notificationService_Stub{connector, impl})
}


func (f *NotificationService_Request) ServiceDescription() service_describer.ServiceDescription {
	return &NotificationService_ServiceDescription{}
}


type NotificationService_ServiceDescription struct{}

func (sd *NotificationService_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *NotificationService_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *NotificationService_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*NotificationService_ServiceDescription)(nil)


func (s *notificationService_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case notificationService_Post_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request notificationService_Post_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.Post(request.inNotificationData, request.inClient, request.inNotification)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type NotificationData struct {
	Title *string
	Text *string
	PlaySound bool
	Vibrate bool
	SetLights bool
}


func (s *NotificationData) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if s.Title == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.Title)); err != nil {
			return err
		}
	}
	if s.Text == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.Text)); err != nil {
			return err
		}
	}
	if err := encoder.WriteBool(s.PlaySound); err != nil {
		return err
	}
	if err := encoder.WriteBool(s.Vibrate); err != nil {
		return err
	}
	if err := encoder.WriteBool(s.SetLights); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var notificationData_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *NotificationData) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(notificationData_Versions), func(i int) bool {
		return notificationData_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(notificationData_Versions) {
		if notificationData_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := notificationData_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Title = nil
		} else {
			s.Title = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.Title) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Text = nil
		} else {
			s.Text = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.Text) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.PlaySound = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.Vibrate = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.SetLights = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

