// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library regression_tests_mojom;
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/mojom_types.mojom.dart' as mojom_types;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;

class EnumWithReference extends bindings.MojoEnum {
  static const EnumWithReference kStereoAndKeyboardMic = const EnumWithReference._(30);
  static const EnumWithReference kMax = const EnumWithReference._(30);

  const EnumWithReference._(int v) : super(v);

  static const Map<String, EnumWithReference> valuesMap = const {
    "kStereoAndKeyboardMic": kStereoAndKeyboardMic,
    "kMax": kMax,
  };
  static const List<EnumWithReference> values = const [
    kStereoAndKeyboardMic,
    kMax,
  ];

  static EnumWithReference valueOf(String name) => valuesMap[name];

  factory EnumWithReference(int v) {
    switch (v) {
      case 30:
        return EnumWithReference.kStereoAndKeyboardMic;
      case 30:
        return EnumWithReference.kMax;
      default:
        return null;
    }
  }

  static EnumWithReference decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithReference result = new EnumWithReference(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithReference.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case kStereoAndKeyboardMic:
        return 'EnumWithReference.kStereoAndKeyboardMic';
      case kMax:
        return 'EnumWithReference.kMax';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithLowercase extends bindings.MojoEnum {
  static const EnumWithLowercase planarF16 = const EnumWithLowercase._(0);
  static const EnumWithLowercase planarF32 = const EnumWithLowercase._(1);

  const EnumWithLowercase._(int v) : super(v);

  static const Map<String, EnumWithLowercase> valuesMap = const {
    "planarF16": planarF16,
    "planarF32": planarF32,
  };
  static const List<EnumWithLowercase> values = const [
    planarF16,
    planarF32,
  ];

  static EnumWithLowercase valueOf(String name) => valuesMap[name];

  factory EnumWithLowercase(int v) {
    switch (v) {
      case 0:
        return EnumWithLowercase.planarF16;
      case 1:
        return EnumWithLowercase.planarF32;
      default:
        return null;
    }
  }

  static EnumWithLowercase decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithLowercase result = new EnumWithLowercase(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithLowercase.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case planarF16:
        return 'EnumWithLowercase.planarF16';
      case planarF32:
        return 'EnumWithLowercase.planarF32';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithNumbers extends bindings.MojoEnum {
  static const EnumWithNumbers k21 = const EnumWithNumbers._(4);

  const EnumWithNumbers._(int v) : super(v);

  static const Map<String, EnumWithNumbers> valuesMap = const {
    "k21": k21,
  };
  static const List<EnumWithNumbers> values = const [
    k21,
  ];

  static EnumWithNumbers valueOf(String name) => valuesMap[name];

  factory EnumWithNumbers(int v) {
    switch (v) {
      case 4:
        return EnumWithNumbers.k21;
      default:
        return null;
    }
  }

  static EnumWithNumbers decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithNumbers result = new EnumWithNumbers(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithNumbers.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case k21:
        return 'EnumWithNumbers.k21';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithK extends bindings.MojoEnum {
  static const EnumWithK k = const EnumWithK._(0);

  const EnumWithK._(int v) : super(v);

  static const Map<String, EnumWithK> valuesMap = const {
    "k": k,
  };
  static const List<EnumWithK> values = const [
    k,
  ];

  static EnumWithK valueOf(String name) => valuesMap[name];

  factory EnumWithK(int v) {
    switch (v) {
      case 0:
        return EnumWithK.k;
      default:
        return null;
    }
  }

  static EnumWithK decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithK result = new EnumWithK(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithK.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case k:
        return 'EnumWithK.k';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithInternalAllCaps extends bindings.MojoEnum {
  static const EnumWithInternalAllCaps standard = const EnumWithInternalAllCaps._(0);
  static const EnumWithInternalAllCaps fullscreen = const EnumWithInternalAllCaps._(1);
  static const EnumWithInternalAllCaps immersive = const EnumWithInternalAllCaps._(2);

  const EnumWithInternalAllCaps._(int v) : super(v);

  static const Map<String, EnumWithInternalAllCaps> valuesMap = const {
    "standard": standard,
    "fullscreen": fullscreen,
    "immersive": immersive,
  };
  static const List<EnumWithInternalAllCaps> values = const [
    standard,
    fullscreen,
    immersive,
  ];

  static EnumWithInternalAllCaps valueOf(String name) => valuesMap[name];

  factory EnumWithInternalAllCaps(int v) {
    switch (v) {
      case 0:
        return EnumWithInternalAllCaps.standard;
      case 1:
        return EnumWithInternalAllCaps.fullscreen;
      case 2:
        return EnumWithInternalAllCaps.immersive;
      default:
        return null;
    }
  }

  static EnumWithInternalAllCaps decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithInternalAllCaps result = new EnumWithInternalAllCaps(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithInternalAllCaps.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case standard:
        return 'EnumWithInternalAllCaps.standard';
      case fullscreen:
        return 'EnumWithInternalAllCaps.fullscreen';
      case immersive:
        return 'EnumWithInternalAllCaps.immersive';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class NormalEnum extends bindings.MojoEnum {
  static const NormalEnum first = const NormalEnum._(0);
  static const NormalEnum second = const NormalEnum._(1);

  const NormalEnum._(int v) : super(v);

  static const Map<String, NormalEnum> valuesMap = const {
    "first": first,
    "second": second,
  };
  static const List<NormalEnum> values = const [
    first,
    second,
  ];

  static NormalEnum valueOf(String name) => valuesMap[name];

  factory NormalEnum(int v) {
    switch (v) {
      case 0:
        return NormalEnum.first;
      case 1:
        return NormalEnum.second;
      default:
        return null;
    }
  }

  static NormalEnum decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    NormalEnum result = new NormalEnum(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum NormalEnum.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case first:
        return 'NormalEnum.first';
      case second:
        return 'NormalEnum.second';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class CamelCaseTestEnum extends bindings.MojoEnum {
  static const CamelCaseTestEnum boolThing = const CamelCaseTestEnum._(0);
  static const CamelCaseTestEnum doubleThing = const CamelCaseTestEnum._(1);
  static const CamelCaseTestEnum floatThing = const CamelCaseTestEnum._(2);
  static const CamelCaseTestEnum int8Thing = const CamelCaseTestEnum._(3);
  static const CamelCaseTestEnum int16Thing = const CamelCaseTestEnum._(4);
  static const CamelCaseTestEnum int32Th1Ng = const CamelCaseTestEnum._(5);
  static const CamelCaseTestEnum int64Th1ng = const CamelCaseTestEnum._(6);
  static const CamelCaseTestEnum uint8TH1ng = const CamelCaseTestEnum._(7);
  static const CamelCaseTestEnum uint16tH1Ng = const CamelCaseTestEnum._(8);
  static const CamelCaseTestEnum uint32Th1ng = const CamelCaseTestEnum._(9);
  static const CamelCaseTestEnum uint64Th1Ng = const CamelCaseTestEnum._(10);

  const CamelCaseTestEnum._(int v) : super(v);

  static const Map<String, CamelCaseTestEnum> valuesMap = const {
    "boolThing": boolThing,
    "doubleThing": doubleThing,
    "floatThing": floatThing,
    "int8Thing": int8Thing,
    "int16Thing": int16Thing,
    "int32Th1Ng": int32Th1Ng,
    "int64Th1ng": int64Th1ng,
    "uint8TH1ng": uint8TH1ng,
    "uint16tH1Ng": uint16tH1Ng,
    "uint32Th1ng": uint32Th1ng,
    "uint64Th1Ng": uint64Th1Ng,
  };
  static const List<CamelCaseTestEnum> values = const [
    boolThing,
    doubleThing,
    floatThing,
    int8Thing,
    int16Thing,
    int32Th1Ng,
    int64Th1ng,
    uint8TH1ng,
    uint16tH1Ng,
    uint32Th1ng,
    uint64Th1Ng,
  ];

  static CamelCaseTestEnum valueOf(String name) => valuesMap[name];

  factory CamelCaseTestEnum(int v) {
    switch (v) {
      case 0:
        return CamelCaseTestEnum.boolThing;
      case 1:
        return CamelCaseTestEnum.doubleThing;
      case 2:
        return CamelCaseTestEnum.floatThing;
      case 3:
        return CamelCaseTestEnum.int8Thing;
      case 4:
        return CamelCaseTestEnum.int16Thing;
      case 5:
        return CamelCaseTestEnum.int32Th1Ng;
      case 6:
        return CamelCaseTestEnum.int64Th1ng;
      case 7:
        return CamelCaseTestEnum.uint8TH1ng;
      case 8:
        return CamelCaseTestEnum.uint16tH1Ng;
      case 9:
        return CamelCaseTestEnum.uint32Th1ng;
      case 10:
        return CamelCaseTestEnum.uint64Th1Ng;
      default:
        return null;
    }
  }

  static CamelCaseTestEnum decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    CamelCaseTestEnum result = new CamelCaseTestEnum(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum CamelCaseTestEnum.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case boolThing:
        return 'CamelCaseTestEnum.boolThing';
      case doubleThing:
        return 'CamelCaseTestEnum.doubleThing';
      case floatThing:
        return 'CamelCaseTestEnum.floatThing';
      case int8Thing:
        return 'CamelCaseTestEnum.int8Thing';
      case int16Thing:
        return 'CamelCaseTestEnum.int16Thing';
      case int32Th1Ng:
        return 'CamelCaseTestEnum.int32Th1Ng';
      case int64Th1ng:
        return 'CamelCaseTestEnum.int64Th1ng';
      case uint8TH1ng:
        return 'CamelCaseTestEnum.uint8TH1ng';
      case uint16tH1Ng:
        return 'CamelCaseTestEnum.uint16tH1Ng';
      case uint32Th1ng:
        return 'CamelCaseTestEnum.uint32Th1ng';
      case uint64Th1Ng:
        return 'CamelCaseTestEnum.uint64Th1Ng';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}



class Edge extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Vertex v = null;

  Edge() : super(kVersions.last.size);

  Edge.init(
    Vertex this.v
  ) : super(kVersions.last.size);

  static Edge deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Edge decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Edge result = new Edge();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.v = Vertex.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Edge";
    String fieldName;
    try {
      fieldName = "v";
      encoder0.encodeStruct(v, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Edge("
           "v: $v" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["v"] = v;
    return map;
  }
}


class Vertex extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EmptyStruct e = null;

  Vertex() : super(kVersions.last.size);

  Vertex.init(
    EmptyStruct this.e
  ) : super(kVersions.last.size);

  static Vertex deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Vertex decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Vertex result = new Vertex();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.e = EmptyStruct.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Vertex";
    String fieldName;
    try {
      fieldName = "e";
      encoder0.encodeStruct(e, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Vertex("
           "e: $e" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["e"] = e;
    return map;
  }
}


class EmptyStruct extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  EmptyStruct() : super(kVersions.last.size);

  EmptyStruct.init(
  ) : super(kVersions.last.size);

  static EmptyStruct deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static EmptyStruct decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    EmptyStruct result = new EmptyStruct();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "EmptyStruct";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "EmptyStruct("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class A extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  B b = null;

  A() : super(kVersions.last.size);

  A.init(
    B this.b
  ) : super(kVersions.last.size);

  static A deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static A decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    A result = new A();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.b = B.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "A";
    String fieldName;
    try {
      fieldName = "b";
      encoder0.encodeStruct(b, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "A("
           "b: $b" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["b"] = b;
    return map;
  }
}


class B extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  A a = null;

  B() : super(kVersions.last.size);

  B.init(
    A this.a
  ) : super(kVersions.last.size);

  static B deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static B decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    B result = new B();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.a = A.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "B";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeStruct(a, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "B("
           "a: $a" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    return map;
  }
}


class StructWithHandleCalledHandles extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  core.MojoHandle handles = null;

  StructWithHandleCalledHandles() : super(kVersions.last.size);

  StructWithHandleCalledHandles.init(
    core.MojoHandle this.handles
  ) : super(kVersions.last.size);

  static StructWithHandleCalledHandles deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithHandleCalledHandles decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithHandleCalledHandles result = new StructWithHandleCalledHandles();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handles = decoder0.decodeHandle(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithHandleCalledHandles";
    String fieldName;
    try {
      fieldName = "handles";
      encoder0.encodeHandle(handles, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithHandleCalledHandles("
           "handles: $handles" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithArrayOfHandlesCalledHandles extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<core.MojoHandle> handles = null;

  StructWithArrayOfHandlesCalledHandles() : super(kVersions.last.size);

  StructWithArrayOfHandlesCalledHandles.init(
    List<core.MojoHandle> this.handles
  ) : super(kVersions.last.size);

  static StructWithArrayOfHandlesCalledHandles deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithArrayOfHandlesCalledHandles decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithArrayOfHandlesCalledHandles result = new StructWithArrayOfHandlesCalledHandles();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handles = decoder0.decodeHandleArray(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithArrayOfHandlesCalledHandles";
    String fieldName;
    try {
      fieldName = "handles";
      encoder0.encodeHandleArray(handles, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithArrayOfHandlesCalledHandles("
           "handles: $handles" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithInterfaceCalledHandles extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  TestInterfaceInterface handles = null;

  StructWithInterfaceCalledHandles() : super(kVersions.last.size);

  StructWithInterfaceCalledHandles.init(
    TestInterfaceInterface this.handles
  ) : super(kVersions.last.size);

  static StructWithInterfaceCalledHandles deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithInterfaceCalledHandles decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithInterfaceCalledHandles result = new StructWithInterfaceCalledHandles();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handles = decoder0.decodeServiceInterface(8, false, TestInterfaceProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithInterfaceCalledHandles";
    String fieldName;
    try {
      fieldName = "handles";
      encoder0.encodeInterface(handles, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithInterfaceCalledHandles("
           "handles: $handles" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class ContainsArrayOfEnum extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<NormalEnum> arrayOfEnums = null;

  ContainsArrayOfEnum() : super(kVersions.last.size);

  ContainsArrayOfEnum.init(
    List<NormalEnum> this.arrayOfEnums
  ) : super(kVersions.last.size);

  static ContainsArrayOfEnum deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ContainsArrayOfEnum decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ContainsArrayOfEnum result = new ContainsArrayOfEnum();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForEnumArray(bindings.kUnspecifiedArrayLength);
        result.arrayOfEnums = new List<NormalEnum>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
            result.arrayOfEnums[i1] = NormalEnum.decode(decoder1, bindings.ArrayDataHeader.kHeaderSize + bindings.kEnumSize * i1);
            if (result.arrayOfEnums[i1] == null) {
              throw new bindings.MojoCodecError(
                'Trying to decode null union for non-nullable NormalEnum.');
            }
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ContainsArrayOfEnum";
    String fieldName;
    try {
      fieldName = "arrayOfEnums";
      encoder0.encodeEnumArray(arrayOfEnums, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ContainsArrayOfEnum("
           "arrayOfEnums: $arrayOfEnums" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["arrayOfEnums"] = arrayOfEnums;
    return map;
  }
}


class _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams() : super(kVersions.last.size);

  _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams.init(
  ) : super(kVersions.last.size);

  static _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams result = new _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams() : super(kVersions.last.size);

  CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams.init(
  ) : super(kVersions.last.size);

  static CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams result = new CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool b = false;

  _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams() : super(kVersions.last.size);

  _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams.init(
    bool this.b
  ) : super(kVersions.last.size);

  static _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams result = new _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.b = decoder0.decodeBool(8, 0);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams";
    String fieldName;
    try {
      fieldName = "b";
      encoder0.encodeBool(b, 8, 0);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams("
           "b: $b" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["b"] = b;
    return map;
  }
}


class CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams() : super(kVersions.last.size);

  CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams.init(
  ) : super(kVersions.last.size);

  static CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams result = new CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CheckNameCollisionWithNameCollisionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool message = false;
  bool response = false;

  _CheckNameCollisionWithNameCollisionParams() : super(kVersions.last.size);

  _CheckNameCollisionWithNameCollisionParams.init(
    bool this.message, 
    bool this.response
  ) : super(kVersions.last.size);

  static _CheckNameCollisionWithNameCollisionParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckNameCollisionWithNameCollisionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckNameCollisionWithNameCollisionParams result = new _CheckNameCollisionWithNameCollisionParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.message = decoder0.decodeBool(8, 0);
    }
    if (mainDataHeader.version >= 0) {
      
      result.response = decoder0.decodeBool(8, 1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckNameCollisionWithNameCollisionParams";
    String fieldName;
    try {
      fieldName = "message";
      encoder0.encodeBool(message, 8, 0);
      fieldName = "response";
      encoder0.encodeBool(response, 8, 1);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckNameCollisionWithNameCollisionParams("
           "message: $message" ", "
           "response: $response" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["message"] = message;
    map["response"] = response;
    return map;
  }
}


class CheckNameCollisionWithNameCollisionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool message = false;
  bool response = false;

  CheckNameCollisionWithNameCollisionResponseParams() : super(kVersions.last.size);

  CheckNameCollisionWithNameCollisionResponseParams.init(
    bool this.message, 
    bool this.response
  ) : super(kVersions.last.size);

  static CheckNameCollisionWithNameCollisionResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CheckNameCollisionWithNameCollisionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CheckNameCollisionWithNameCollisionResponseParams result = new CheckNameCollisionWithNameCollisionResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.message = decoder0.decodeBool(8, 0);
    }
    if (mainDataHeader.version >= 0) {
      
      result.response = decoder0.decodeBool(8, 1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CheckNameCollisionWithNameCollisionResponseParams";
    String fieldName;
    try {
      fieldName = "message";
      encoder0.encodeBool(message, 8, 0);
      fieldName = "response";
      encoder0.encodeBool(response, 8, 1);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CheckNameCollisionWithNameCollisionResponseParams("
           "message: $message" ", "
           "response: $response" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["message"] = message;
    map["response"] = response;
    return map;
  }
}


class _CheckEnumCapsSetEnumWithInternalAllCapsParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EnumWithInternalAllCaps e = null;

  _CheckEnumCapsSetEnumWithInternalAllCapsParams() : super(kVersions.last.size);

  _CheckEnumCapsSetEnumWithInternalAllCapsParams.init(
    EnumWithInternalAllCaps this.e
  ) : super(kVersions.last.size);

  static _CheckEnumCapsSetEnumWithInternalAllCapsParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckEnumCapsSetEnumWithInternalAllCapsParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckEnumCapsSetEnumWithInternalAllCapsParams result = new _CheckEnumCapsSetEnumWithInternalAllCapsParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.e = EnumWithInternalAllCaps.decode(decoder0, 8);
        if (result.e == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable EnumWithInternalAllCaps.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckEnumCapsSetEnumWithInternalAllCapsParams";
    String fieldName;
    try {
      fieldName = "e";
      encoder0.encodeEnum(e, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckEnumCapsSetEnumWithInternalAllCapsParams("
           "e: $e" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["e"] = e;
    return map;
  }
}


class _TestInterfaceSomeMessageParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _TestInterfaceSomeMessageParams() : super(kVersions.last.size);

  _TestInterfaceSomeMessageParams.init(
  ) : super(kVersions.last.size);

  static _TestInterfaceSomeMessageParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestInterfaceSomeMessageParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestInterfaceSomeMessageParams result = new _TestInterfaceSomeMessageParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestInterfaceSomeMessageParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestInterfaceSomeMessageParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _Regression551GetParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<String> keyPrefixes = null;

  _Regression551GetParams() : super(kVersions.last.size);

  _Regression551GetParams.init(
    List<String> this.keyPrefixes
  ) : super(kVersions.last.size);

  static _Regression551GetParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _Regression551GetParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _Regression551GetParams result = new _Regression551GetParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.keyPrefixes = new List<String>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.keyPrefixes[i1] = decoder1.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_Regression551GetParams";
    String fieldName;
    try {
      fieldName = "keyPrefixes";
      if (keyPrefixes == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(keyPrefixes.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < keyPrefixes.length; ++i0) {
          encoder1.encodeString(keyPrefixes[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_Regression551GetParams("
           "keyPrefixes: $keyPrefixes" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["keyPrefixes"] = keyPrefixes;
    return map;
  }
}


class Regression551GetResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int result = 0;

  Regression551GetResponseParams() : super(kVersions.last.size);

  Regression551GetResponseParams.init(
    int this.result
  ) : super(kVersions.last.size);

  static Regression551GetResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Regression551GetResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Regression551GetResponseParams result = new Regression551GetResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.result = decoder0.decodeInt32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Regression551GetResponseParams";
    String fieldName;
    try {
      fieldName = "result";
      encoder0.encodeInt32(result, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Regression551GetResponseParams("
           "result: $result" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["result"] = result;
    return map;
  }
}


class _ServiceNameServiceNameParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _ServiceNameServiceNameParams() : super(kVersions.last.size);

  _ServiceNameServiceNameParams.init(
  ) : super(kVersions.last.size);

  static _ServiceNameServiceNameParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ServiceNameServiceNameParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ServiceNameServiceNameParams result = new _ServiceNameServiceNameParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ServiceNameServiceNameParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ServiceNameServiceNameParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class ServiceNameServiceNameResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String serviceName_ = null;

  ServiceNameServiceNameResponseParams() : super(kVersions.last.size);

  ServiceNameServiceNameResponseParams.init(
    String this.serviceName_
  ) : super(kVersions.last.size);

  static ServiceNameServiceNameResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ServiceNameServiceNameResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ServiceNameServiceNameResponseParams result = new ServiceNameServiceNameResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.serviceName_ = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ServiceNameServiceNameResponseParams";
    String fieldName;
    try {
      fieldName = "serviceName_";
      encoder0.encodeString(serviceName_, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ServiceNameServiceNameResponseParams("
           "serviceName_: $serviceName_" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["serviceName_"] = serviceName_;
    return map;
  }
}

const int _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName = 0;
const int _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName = 1;

class _CheckMethodWithEmptyResponseServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CheckMethodWithEmptyResponse {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CheckMethodWithEmptyResponseServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CheckMethodWithEmptyResponseProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CheckMethodWithEmptyResponseProxy p = new CheckMethodWithEmptyResponseProxy.unbound();
    String name = serviceName ?? CheckMethodWithEmptyResponse.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void withoutParameterAndEmptyResponse(void callback());
  void withParameterAndEmptyResponse(bool b,void callback());
}

abstract class CheckMethodWithEmptyResponseInterface
    implements bindings.MojoInterface<CheckMethodWithEmptyResponse>,
               CheckMethodWithEmptyResponse {
  factory CheckMethodWithEmptyResponseInterface([CheckMethodWithEmptyResponse impl]) =>
      new CheckMethodWithEmptyResponseStub.unbound(impl);

  factory CheckMethodWithEmptyResponseInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CheckMethodWithEmptyResponse impl]) =>
      new CheckMethodWithEmptyResponseStub.fromEndpoint(endpoint, impl);

  factory CheckMethodWithEmptyResponseInterface.fromMock(
      CheckMethodWithEmptyResponse mock) =>
      new CheckMethodWithEmptyResponseProxy.fromMock(mock);
}

abstract class CheckMethodWithEmptyResponseInterfaceRequest
    implements bindings.MojoInterface<CheckMethodWithEmptyResponse>,
               CheckMethodWithEmptyResponse {
  factory CheckMethodWithEmptyResponseInterfaceRequest() =>
      new CheckMethodWithEmptyResponseProxy.unbound();
}

class _CheckMethodWithEmptyResponseProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CheckMethodWithEmptyResponse> {
  CheckMethodWithEmptyResponse impl;

  _CheckMethodWithEmptyResponseProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CheckMethodWithEmptyResponseProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CheckMethodWithEmptyResponseProxyControl.unbound() : super.unbound();

  String get serviceName => CheckMethodWithEmptyResponse.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName:
        var r = CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback();
        break;
      case _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName:
        var r = CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback();
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckMethodWithEmptyResponseProxyControl($superString)";
  }
}

class CheckMethodWithEmptyResponseProxy
    extends bindings.Proxy<CheckMethodWithEmptyResponse>
    implements CheckMethodWithEmptyResponse,
               CheckMethodWithEmptyResponseInterface,
               CheckMethodWithEmptyResponseInterfaceRequest {
  CheckMethodWithEmptyResponseProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CheckMethodWithEmptyResponseProxyControl.fromEndpoint(endpoint));

  CheckMethodWithEmptyResponseProxy.fromHandle(core.MojoHandle handle)
      : super(new _CheckMethodWithEmptyResponseProxyControl.fromHandle(handle));

  CheckMethodWithEmptyResponseProxy.unbound()
      : super(new _CheckMethodWithEmptyResponseProxyControl.unbound());

  factory CheckMethodWithEmptyResponseProxy.fromMock(CheckMethodWithEmptyResponse mock) {
    CheckMethodWithEmptyResponseProxy newMockedProxy =
        new CheckMethodWithEmptyResponseProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CheckMethodWithEmptyResponseProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckMethodWithEmptyResponseProxy"));
    return new CheckMethodWithEmptyResponseProxy.fromEndpoint(endpoint);
  }


  void withoutParameterAndEmptyResponse(void callback()) {
    if (impl != null) {
      impl.withoutParameterAndEmptyResponse(callback);
      return;
    }
    var params = new _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void withParameterAndEmptyResponse(bool b,void callback()) {
    if (impl != null) {
      impl.withParameterAndEmptyResponse(b,callback);
      return;
    }
    var params = new _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams();
    params.b = b;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _CheckMethodWithEmptyResponseStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CheckMethodWithEmptyResponse> {
  CheckMethodWithEmptyResponse _impl;

  _CheckMethodWithEmptyResponseStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckMethodWithEmptyResponse impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckMethodWithEmptyResponseStubControl.fromHandle(
      core.MojoHandle handle, [CheckMethodWithEmptyResponse impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckMethodWithEmptyResponseStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CheckMethodWithEmptyResponse.serviceName;


  Function _checkMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParamsResponder(
      int requestId) {
  return () {
      var result = new CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _checkMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParamsResponder(
      int requestId) {
  return () {
      var result = new CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName:
        _impl.withoutParameterAndEmptyResponse(_checkMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParamsResponder(message.header.requestId));
        break;
      case _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName:
        var params = _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams.deserialize(
            message.payload);
        _impl.withParameterAndEmptyResponse(params.b, _checkMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CheckMethodWithEmptyResponse get impl => _impl;
  set impl(CheckMethodWithEmptyResponse d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckMethodWithEmptyResponseStubControl($superString)";
  }

  int get version => 0;
}

class CheckMethodWithEmptyResponseStub
    extends bindings.Stub<CheckMethodWithEmptyResponse>
    implements CheckMethodWithEmptyResponse,
               CheckMethodWithEmptyResponseInterface,
               CheckMethodWithEmptyResponseInterfaceRequest {
  CheckMethodWithEmptyResponseStub.unbound([CheckMethodWithEmptyResponse impl])
      : super(new _CheckMethodWithEmptyResponseStubControl.unbound(impl));

  CheckMethodWithEmptyResponseStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckMethodWithEmptyResponse impl])
      : super(new _CheckMethodWithEmptyResponseStubControl.fromEndpoint(endpoint, impl));

  CheckMethodWithEmptyResponseStub.fromHandle(
      core.MojoHandle handle, [CheckMethodWithEmptyResponse impl])
      : super(new _CheckMethodWithEmptyResponseStubControl.fromHandle(handle, impl));

  static CheckMethodWithEmptyResponseStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckMethodWithEmptyResponseStub"));
    return new CheckMethodWithEmptyResponseStub.fromEndpoint(endpoint);
  }


  void withoutParameterAndEmptyResponse(void callback()) {
    return impl.withoutParameterAndEmptyResponse(callback);
  }
  void withParameterAndEmptyResponse(bool b,void callback()) {
    return impl.withParameterAndEmptyResponse(b,callback);
  }
}

const int _checkNameCollisionMethodWithNameCollisionName = 0;

class _CheckNameCollisionServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CheckNameCollision {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CheckNameCollisionServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CheckNameCollisionProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CheckNameCollisionProxy p = new CheckNameCollisionProxy.unbound();
    String name = serviceName ?? CheckNameCollision.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void withNameCollision(bool message,bool response,void callback(bool message, bool response));
}

abstract class CheckNameCollisionInterface
    implements bindings.MojoInterface<CheckNameCollision>,
               CheckNameCollision {
  factory CheckNameCollisionInterface([CheckNameCollision impl]) =>
      new CheckNameCollisionStub.unbound(impl);

  factory CheckNameCollisionInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CheckNameCollision impl]) =>
      new CheckNameCollisionStub.fromEndpoint(endpoint, impl);

  factory CheckNameCollisionInterface.fromMock(
      CheckNameCollision mock) =>
      new CheckNameCollisionProxy.fromMock(mock);
}

abstract class CheckNameCollisionInterfaceRequest
    implements bindings.MojoInterface<CheckNameCollision>,
               CheckNameCollision {
  factory CheckNameCollisionInterfaceRequest() =>
      new CheckNameCollisionProxy.unbound();
}

class _CheckNameCollisionProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CheckNameCollision> {
  CheckNameCollision impl;

  _CheckNameCollisionProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CheckNameCollisionProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CheckNameCollisionProxyControl.unbound() : super.unbound();

  String get serviceName => CheckNameCollision.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _checkNameCollisionMethodWithNameCollisionName:
        var r = CheckNameCollisionWithNameCollisionResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.message , r.response );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckNameCollisionProxyControl($superString)";
  }
}

class CheckNameCollisionProxy
    extends bindings.Proxy<CheckNameCollision>
    implements CheckNameCollision,
               CheckNameCollisionInterface,
               CheckNameCollisionInterfaceRequest {
  CheckNameCollisionProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CheckNameCollisionProxyControl.fromEndpoint(endpoint));

  CheckNameCollisionProxy.fromHandle(core.MojoHandle handle)
      : super(new _CheckNameCollisionProxyControl.fromHandle(handle));

  CheckNameCollisionProxy.unbound()
      : super(new _CheckNameCollisionProxyControl.unbound());

  factory CheckNameCollisionProxy.fromMock(CheckNameCollision mock) {
    CheckNameCollisionProxy newMockedProxy =
        new CheckNameCollisionProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CheckNameCollisionProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckNameCollisionProxy"));
    return new CheckNameCollisionProxy.fromEndpoint(endpoint);
  }


  void withNameCollision(bool message,bool response,void callback(bool message, bool response)) {
    if (impl != null) {
      impl.withNameCollision(message,response,callback);
      return;
    }
    var params = new _CheckNameCollisionWithNameCollisionParams();
    params.message = message;
    params.response = response;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((bool message, bool response) {
        z.bindCallback(() {
          callback(message, response);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _checkNameCollisionMethodWithNameCollisionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _CheckNameCollisionStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CheckNameCollision> {
  CheckNameCollision _impl;

  _CheckNameCollisionStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckNameCollision impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckNameCollisionStubControl.fromHandle(
      core.MojoHandle handle, [CheckNameCollision impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckNameCollisionStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CheckNameCollision.serviceName;


  Function _checkNameCollisionWithNameCollisionResponseParamsResponder(
      int requestId) {
  return (bool message, bool response) {
      var result = new CheckNameCollisionWithNameCollisionResponseParams();
      result.message = message;
      result.response = response;
      sendResponse(buildResponseWithId(
          result,
          _checkNameCollisionMethodWithNameCollisionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _checkNameCollisionMethodWithNameCollisionName:
        var params = _CheckNameCollisionWithNameCollisionParams.deserialize(
            message.payload);
        _impl.withNameCollision(params.message, params.response, _checkNameCollisionWithNameCollisionResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CheckNameCollision get impl => _impl;
  set impl(CheckNameCollision d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckNameCollisionStubControl($superString)";
  }

  int get version => 0;
}

class CheckNameCollisionStub
    extends bindings.Stub<CheckNameCollision>
    implements CheckNameCollision,
               CheckNameCollisionInterface,
               CheckNameCollisionInterfaceRequest {
  CheckNameCollisionStub.unbound([CheckNameCollision impl])
      : super(new _CheckNameCollisionStubControl.unbound(impl));

  CheckNameCollisionStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckNameCollision impl])
      : super(new _CheckNameCollisionStubControl.fromEndpoint(endpoint, impl));

  CheckNameCollisionStub.fromHandle(
      core.MojoHandle handle, [CheckNameCollision impl])
      : super(new _CheckNameCollisionStubControl.fromHandle(handle, impl));

  static CheckNameCollisionStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckNameCollisionStub"));
    return new CheckNameCollisionStub.fromEndpoint(endpoint);
  }


  void withNameCollision(bool message,bool response,void callback(bool message, bool response)) {
    return impl.withNameCollision(message,response,callback);
  }
}

const int _checkEnumCapsMethodSetEnumWithInternalAllCapsName = 0;

class _CheckEnumCapsServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CheckEnumCaps {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CheckEnumCapsServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CheckEnumCapsProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CheckEnumCapsProxy p = new CheckEnumCapsProxy.unbound();
    String name = serviceName ?? CheckEnumCaps.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void setEnumWithInternalAllCaps(EnumWithInternalAllCaps e);
}

abstract class CheckEnumCapsInterface
    implements bindings.MojoInterface<CheckEnumCaps>,
               CheckEnumCaps {
  factory CheckEnumCapsInterface([CheckEnumCaps impl]) =>
      new CheckEnumCapsStub.unbound(impl);

  factory CheckEnumCapsInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CheckEnumCaps impl]) =>
      new CheckEnumCapsStub.fromEndpoint(endpoint, impl);

  factory CheckEnumCapsInterface.fromMock(
      CheckEnumCaps mock) =>
      new CheckEnumCapsProxy.fromMock(mock);
}

abstract class CheckEnumCapsInterfaceRequest
    implements bindings.MojoInterface<CheckEnumCaps>,
               CheckEnumCaps {
  factory CheckEnumCapsInterfaceRequest() =>
      new CheckEnumCapsProxy.unbound();
}

class _CheckEnumCapsProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CheckEnumCaps> {
  CheckEnumCaps impl;

  _CheckEnumCapsProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CheckEnumCapsProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CheckEnumCapsProxyControl.unbound() : super.unbound();

  String get serviceName => CheckEnumCaps.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckEnumCapsProxyControl($superString)";
  }
}

class CheckEnumCapsProxy
    extends bindings.Proxy<CheckEnumCaps>
    implements CheckEnumCaps,
               CheckEnumCapsInterface,
               CheckEnumCapsInterfaceRequest {
  CheckEnumCapsProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CheckEnumCapsProxyControl.fromEndpoint(endpoint));

  CheckEnumCapsProxy.fromHandle(core.MojoHandle handle)
      : super(new _CheckEnumCapsProxyControl.fromHandle(handle));

  CheckEnumCapsProxy.unbound()
      : super(new _CheckEnumCapsProxyControl.unbound());

  factory CheckEnumCapsProxy.fromMock(CheckEnumCaps mock) {
    CheckEnumCapsProxy newMockedProxy =
        new CheckEnumCapsProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CheckEnumCapsProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckEnumCapsProxy"));
    return new CheckEnumCapsProxy.fromEndpoint(endpoint);
  }


  void setEnumWithInternalAllCaps(EnumWithInternalAllCaps e) {
    if (impl != null) {
      impl.setEnumWithInternalAllCaps(e);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CheckEnumCapsSetEnumWithInternalAllCapsParams();
    params.e = e;
    ctrl.sendMessage(params,
        _checkEnumCapsMethodSetEnumWithInternalAllCapsName);
  }
}

class _CheckEnumCapsStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CheckEnumCaps> {
  CheckEnumCaps _impl;

  _CheckEnumCapsStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckEnumCaps impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckEnumCapsStubControl.fromHandle(
      core.MojoHandle handle, [CheckEnumCaps impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckEnumCapsStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CheckEnumCaps.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _checkEnumCapsMethodSetEnumWithInternalAllCapsName:
        var params = _CheckEnumCapsSetEnumWithInternalAllCapsParams.deserialize(
            message.payload);
        _impl.setEnumWithInternalAllCaps(params.e);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CheckEnumCaps get impl => _impl;
  set impl(CheckEnumCaps d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckEnumCapsStubControl($superString)";
  }

  int get version => 0;
}

class CheckEnumCapsStub
    extends bindings.Stub<CheckEnumCaps>
    implements CheckEnumCaps,
               CheckEnumCapsInterface,
               CheckEnumCapsInterfaceRequest {
  CheckEnumCapsStub.unbound([CheckEnumCaps impl])
      : super(new _CheckEnumCapsStubControl.unbound(impl));

  CheckEnumCapsStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckEnumCaps impl])
      : super(new _CheckEnumCapsStubControl.fromEndpoint(endpoint, impl));

  CheckEnumCapsStub.fromHandle(
      core.MojoHandle handle, [CheckEnumCaps impl])
      : super(new _CheckEnumCapsStubControl.fromHandle(handle, impl));

  static CheckEnumCapsStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckEnumCapsStub"));
    return new CheckEnumCapsStub.fromEndpoint(endpoint);
  }


  void setEnumWithInternalAllCaps(EnumWithInternalAllCaps e) {
    return impl.setEnumWithInternalAllCaps(e);
  }
}

const int _testInterfaceMethodSomeMessageName = 0;

class _TestInterfaceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class TestInterface {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _TestInterfaceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static TestInterfaceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    TestInterfaceProxy p = new TestInterfaceProxy.unbound();
    String name = serviceName ?? TestInterface.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void someMessage();
}

abstract class TestInterfaceInterface
    implements bindings.MojoInterface<TestInterface>,
               TestInterface {
  factory TestInterfaceInterface([TestInterface impl]) =>
      new TestInterfaceStub.unbound(impl);

  factory TestInterfaceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [TestInterface impl]) =>
      new TestInterfaceStub.fromEndpoint(endpoint, impl);

  factory TestInterfaceInterface.fromMock(
      TestInterface mock) =>
      new TestInterfaceProxy.fromMock(mock);
}

abstract class TestInterfaceInterfaceRequest
    implements bindings.MojoInterface<TestInterface>,
               TestInterface {
  factory TestInterfaceInterfaceRequest() =>
      new TestInterfaceProxy.unbound();
}

class _TestInterfaceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<TestInterface> {
  TestInterface impl;

  _TestInterfaceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _TestInterfaceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _TestInterfaceProxyControl.unbound() : super.unbound();

  String get serviceName => TestInterface.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestInterfaceProxyControl($superString)";
  }
}

class TestInterfaceProxy
    extends bindings.Proxy<TestInterface>
    implements TestInterface,
               TestInterfaceInterface,
               TestInterfaceInterfaceRequest {
  TestInterfaceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _TestInterfaceProxyControl.fromEndpoint(endpoint));

  TestInterfaceProxy.fromHandle(core.MojoHandle handle)
      : super(new _TestInterfaceProxyControl.fromHandle(handle));

  TestInterfaceProxy.unbound()
      : super(new _TestInterfaceProxyControl.unbound());

  factory TestInterfaceProxy.fromMock(TestInterface mock) {
    TestInterfaceProxy newMockedProxy =
        new TestInterfaceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static TestInterfaceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestInterfaceProxy"));
    return new TestInterfaceProxy.fromEndpoint(endpoint);
  }


  void someMessage() {
    if (impl != null) {
      impl.someMessage();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _TestInterfaceSomeMessageParams();
    ctrl.sendMessage(params,
        _testInterfaceMethodSomeMessageName);
  }
}

class _TestInterfaceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<TestInterface> {
  TestInterface _impl;

  _TestInterfaceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestInterface impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestInterfaceStubControl.fromHandle(
      core.MojoHandle handle, [TestInterface impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestInterfaceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => TestInterface.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _testInterfaceMethodSomeMessageName:
        _impl.someMessage();
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  TestInterface get impl => _impl;
  set impl(TestInterface d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestInterfaceStubControl($superString)";
  }

  int get version => 0;
}

class TestInterfaceStub
    extends bindings.Stub<TestInterface>
    implements TestInterface,
               TestInterfaceInterface,
               TestInterfaceInterfaceRequest {
  TestInterfaceStub.unbound([TestInterface impl])
      : super(new _TestInterfaceStubControl.unbound(impl));

  TestInterfaceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestInterface impl])
      : super(new _TestInterfaceStubControl.fromEndpoint(endpoint, impl));

  TestInterfaceStub.fromHandle(
      core.MojoHandle handle, [TestInterface impl])
      : super(new _TestInterfaceStubControl.fromHandle(handle, impl));

  static TestInterfaceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestInterfaceStub"));
    return new TestInterfaceStub.fromEndpoint(endpoint);
  }


  void someMessage() {
    return impl.someMessage();
  }
}

const int _regression551MethodGetName = 0;

class _Regression551ServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class Regression551 {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _Regression551ServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static Regression551Proxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    Regression551Proxy p = new Regression551Proxy.unbound();
    String name = serviceName ?? Regression551.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void get(List<String> keyPrefixes,void callback(int result));
}

abstract class Regression551Interface
    implements bindings.MojoInterface<Regression551>,
               Regression551 {
  factory Regression551Interface([Regression551 impl]) =>
      new Regression551Stub.unbound(impl);

  factory Regression551Interface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [Regression551 impl]) =>
      new Regression551Stub.fromEndpoint(endpoint, impl);

  factory Regression551Interface.fromMock(
      Regression551 mock) =>
      new Regression551Proxy.fromMock(mock);
}

abstract class Regression551InterfaceRequest
    implements bindings.MojoInterface<Regression551>,
               Regression551 {
  factory Regression551InterfaceRequest() =>
      new Regression551Proxy.unbound();
}

class _Regression551ProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<Regression551> {
  Regression551 impl;

  _Regression551ProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _Regression551ProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _Regression551ProxyControl.unbound() : super.unbound();

  String get serviceName => Regression551.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _regression551MethodGetName:
        var r = Regression551GetResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.result );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_Regression551ProxyControl($superString)";
  }
}

class Regression551Proxy
    extends bindings.Proxy<Regression551>
    implements Regression551,
               Regression551Interface,
               Regression551InterfaceRequest {
  Regression551Proxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _Regression551ProxyControl.fromEndpoint(endpoint));

  Regression551Proxy.fromHandle(core.MojoHandle handle)
      : super(new _Regression551ProxyControl.fromHandle(handle));

  Regression551Proxy.unbound()
      : super(new _Regression551ProxyControl.unbound());

  factory Regression551Proxy.fromMock(Regression551 mock) {
    Regression551Proxy newMockedProxy =
        new Regression551Proxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static Regression551Proxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For Regression551Proxy"));
    return new Regression551Proxy.fromEndpoint(endpoint);
  }


  void get(List<String> keyPrefixes,void callback(int result)) {
    if (impl != null) {
      impl.get(keyPrefixes,callback);
      return;
    }
    var params = new _Regression551GetParams();
    params.keyPrefixes = keyPrefixes;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((int result) {
        z.bindCallback(() {
          callback(result);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _regression551MethodGetName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _Regression551StubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<Regression551> {
  Regression551 _impl;

  _Regression551StubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Regression551 impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _Regression551StubControl.fromHandle(
      core.MojoHandle handle, [Regression551 impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _Regression551StubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => Regression551.serviceName;


  Function _regression551GetResponseParamsResponder(
      int requestId) {
  return (int result) {
      var result = new Regression551GetResponseParams();
      result.result = result;
      sendResponse(buildResponseWithId(
          result,
          _regression551MethodGetName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _regression551MethodGetName:
        var params = _Regression551GetParams.deserialize(
            message.payload);
        _impl.get(params.keyPrefixes, _regression551GetResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  Regression551 get impl => _impl;
  set impl(Regression551 d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_Regression551StubControl($superString)";
  }

  int get version => 0;
}

class Regression551Stub
    extends bindings.Stub<Regression551>
    implements Regression551,
               Regression551Interface,
               Regression551InterfaceRequest {
  Regression551Stub.unbound([Regression551 impl])
      : super(new _Regression551StubControl.unbound(impl));

  Regression551Stub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Regression551 impl])
      : super(new _Regression551StubControl.fromEndpoint(endpoint, impl));

  Regression551Stub.fromHandle(
      core.MojoHandle handle, [Regression551 impl])
      : super(new _Regression551StubControl.fromHandle(handle, impl));

  static Regression551Stub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For Regression551Stub"));
    return new Regression551Stub.fromEndpoint(endpoint);
  }


  void get(List<String> keyPrefixes,void callback(int result)) {
    return impl.get(keyPrefixes,callback);
  }
}

const int _serviceNameMethodServiceNameName = 0;

class _ServiceNameServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class ServiceName {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _ServiceNameServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static ServiceNameProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    ServiceNameProxy p = new ServiceNameProxy.unbound();
    String name = serviceName ?? ServiceName.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void serviceName_(void callback(String serviceName_));
}

abstract class ServiceNameInterface
    implements bindings.MojoInterface<ServiceName>,
               ServiceName {
  factory ServiceNameInterface([ServiceName impl]) =>
      new ServiceNameStub.unbound(impl);

  factory ServiceNameInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [ServiceName impl]) =>
      new ServiceNameStub.fromEndpoint(endpoint, impl);

  factory ServiceNameInterface.fromMock(
      ServiceName mock) =>
      new ServiceNameProxy.fromMock(mock);
}

abstract class ServiceNameInterfaceRequest
    implements bindings.MojoInterface<ServiceName>,
               ServiceName {
  factory ServiceNameInterfaceRequest() =>
      new ServiceNameProxy.unbound();
}

class _ServiceNameProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<ServiceName> {
  ServiceName impl;

  _ServiceNameProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _ServiceNameProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _ServiceNameProxyControl.unbound() : super.unbound();

  String get serviceName => ServiceName.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _serviceNameMethodServiceNameName:
        var r = ServiceNameServiceNameResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.serviceName_ );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ServiceNameProxyControl($superString)";
  }
}

class ServiceNameProxy
    extends bindings.Proxy<ServiceName>
    implements ServiceName,
               ServiceNameInterface,
               ServiceNameInterfaceRequest {
  ServiceNameProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _ServiceNameProxyControl.fromEndpoint(endpoint));

  ServiceNameProxy.fromHandle(core.MojoHandle handle)
      : super(new _ServiceNameProxyControl.fromHandle(handle));

  ServiceNameProxy.unbound()
      : super(new _ServiceNameProxyControl.unbound());

  factory ServiceNameProxy.fromMock(ServiceName mock) {
    ServiceNameProxy newMockedProxy =
        new ServiceNameProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static ServiceNameProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ServiceNameProxy"));
    return new ServiceNameProxy.fromEndpoint(endpoint);
  }


  void serviceName_(void callback(String serviceName_)) {
    if (impl != null) {
      impl.serviceName_(callback);
      return;
    }
    var params = new _ServiceNameServiceNameParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((String serviceName_) {
        z.bindCallback(() {
          callback(serviceName_);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _serviceNameMethodServiceNameName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _ServiceNameStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<ServiceName> {
  ServiceName _impl;

  _ServiceNameStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ServiceName impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _ServiceNameStubControl.fromHandle(
      core.MojoHandle handle, [ServiceName impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _ServiceNameStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => ServiceName.serviceName;


  Function _serviceNameServiceNameResponseParamsResponder(
      int requestId) {
  return (String serviceName_) {
      var result = new ServiceNameServiceNameResponseParams();
      result.serviceName_ = serviceName_;
      sendResponse(buildResponseWithId(
          result,
          _serviceNameMethodServiceNameName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _serviceNameMethodServiceNameName:
        _impl.serviceName_(_serviceNameServiceNameResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  ServiceName get impl => _impl;
  set impl(ServiceName d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ServiceNameStubControl($superString)";
  }

  int get version => 0;
}

class ServiceNameStub
    extends bindings.Stub<ServiceName>
    implements ServiceName,
               ServiceNameInterface,
               ServiceNameInterfaceRequest {
  ServiceNameStub.unbound([ServiceName impl])
      : super(new _ServiceNameStubControl.unbound(impl));

  ServiceNameStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ServiceName impl])
      : super(new _ServiceNameStubControl.fromEndpoint(endpoint, impl));

  ServiceNameStub.fromHandle(
      core.MojoHandle handle, [ServiceName impl])
      : super(new _ServiceNameStubControl.fromHandle(handle, impl));

  static ServiceNameStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ServiceNameStub"));
    return new ServiceNameStub.fromEndpoint(endpoint);
  }


  void serviceName_(void callback(String serviceName_)) {
    return impl.serviceName_(callback);
  }
}


mojom_types.RuntimeTypeInfo getRuntimeTypeInfo() => _runtimeTypeInfo ??
    _initRuntimeTypeInfo();

Map<String, mojom_types.UserDefinedType> getAllMojomTypeDefinitions() {
  return getRuntimeTypeInfo().typeMap;
}

var _runtimeTypeInfo;
mojom_types.RuntimeTypeInfo  _initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this
  // file. The string contains the base64 encoding of the gzip-compressed bytes.
  var serializedRuntimeTypeInfo = "H4sIAAAJbogC/+xdT3fbxhEHKDmWbSWR2ziR41Rx7DZRY5sUbcthnDYRRVF/KonUI2lHfs17DE1BIiP+K0ilck8+6thjP0KPPvrYj5CPkKOPPurW7hKzJHaIBRY0CIBW8R7eGtQOsPvb2ZmdP7ueVYxrBsoFKPHvrJxCJa63c84oX5L7Q3K/gN9/gfI1lNdVo1yH8jmUL6D8FUolYhTzUP4I5QmUL6F8BeXshFEuQVmB8p9Q/gLl1CR8H8oWlDfJfY3chSc76eJm+slDXTvQtXa72mwUO1q7044mJestd+vdI/ct23qpUl2rpUptrUAe042jepcuRu4v7OkqWvmQ1k+VWm3lW1L3gXP9ba1Tae59X+1U0vVW51lOa7eajbamKPcJ7W1n+gxpbKpZq1XpH2g7F8l9x56u2eiUqo12UtdLz7L70MPPyT1nS5feO9CMd//Bvh7tSL6jH5U7pN7X5I7b1ycNoABsZArpXCa5lazVugga1y0YW2f6TcnxZfW3mn/X9HKJgg1t/KMUXeao/lTTWfvkv5fT9jVda5SN79Gx/b0tXaap10s1xoDO/Jfr/bC4GJcYp7ym/1wta5SDSL01cn9nX787pLQnwDnrpcZeTWunSrWatgcP3Xd8Jfkeg4anp7P0oST9RqOj6fulMnqF5Hyl07v3BmWeykDb+o81vaMdV1RDjlL5SkXirtqXt/SfryZ4+Xv8Tv+Z/un0A/555mP++eQm/77nt/nnSox/Po0jfXGPf1YS/HPiIf/8nz+j+kv88/wK377na/zzToZvz1SBf37xmH+ef8LTKz+g/hVBHyF9dqrw+mZJ4a8FvrvKf+FaV6yvC/C9JDzTYfgNuQXqRbHSy+dpeygPUH6rNOtarFWuN/Vq5x8xMkHulJu6Fmvr5Vi9+VMz1jp6WquWY1XGce3Y02pjr9o4aMe6H4oNfJmS1Xu48sPT6yf9+zmTHne6RLgpJty64+6A21PBeiMO7Rk1Low/VPT9WdTOZUVxtT7AeM+a+q6avuMXfy478eey9TjcP+P8WRLw52LI+DOpuFvnyvLngL2g2uO7jviyIsD3Krkvk9t6lawoX5L7hhWfCghwO8s+jQ99/yX4htne+XeEt0tOwQ65Dnp8/TzYJzAA/7oAevQi2D2XQG8iOeGW35ckx4PKBPrp5Wx2q1hY38is9fn8jtQ4RDlSPB57YPKNejyc8FI9wosuv6bJvZJ9tLyV7iP2FawZJfDiSDFeWkjwiniE129hnqxuZZMFE4NR2zYqhxdHivHaDwleEx7PR2LNJoacjxwpxusgJHhNeo9X/MHQePVJMV6VkOB1zuP5SDp97y7hkrj7+ciRYryqIcHrHe/xenC/WKjEGwdD4NUnxXj9FBK8znuM1yMqhQrFYfDiSDFehyHBa8rj9cSjrhTqkF67Xk9wpBivWkjwujACvAwpZDCYS7x6pBivekjwujgCvKgUWh+Ov3qkGK9GwHhNqcPZQ7sCvK6Q+11qn3LRmH58wyFsM4DPtzCWo8ZnVuAnmDbZPlb2P8b19A39KksC+hvgg8prHduADe7Hdz7xl8gfdxKR77+dP475NcT9v6NrfzsiDbLGgV1n1R+nKWL+WPSRPxT0fdbuT8n9EblFzP2mcUxZv51ITs5LyskdxM/HgnGhscdPmJwURqHt7DB7QjzOFwOWozMmn4gKv0dM9U4m7OUpy3fwSp6yeCPFrnnU2SnpRG+TriYbexyUuD+XApanp4o38nQBMHDqP5OqQcnTKYn5a7YnMG495a26w21HgBvLU5DArT+JA9RHbvETzb/EhJwf2IyjajP/aG7E7wBHIYgWuE0HPP+mPFrPsPwQ2/6bljRhXs+4uUYd/54GXP3GxW2c2is5HgXbyomP2IQaVznErlnJdZhsPJXF9a2z+fr5b5LpfwP4vj9m9iuzSxKTw83bhEPcupvBNwizZX5tEHKe9X9mwt38FOm5z6DvA/3mzdXA5iVeh+M8haDk/PvgU6+TJpcONEv+uOoDPsPgoLrEQbXBYQbmqi6wR2YgzzJIfRex0XdezyfmB7OaT+YF9//nk7v5dBnqnPX5dBnskrDOJ7b+eRnxZv1zDWKO1rsS+nnyktsYBvjq+xDlQUZs/PPDzrcFAT3NUX+P5kFSeIrN/aJGALKIb+xCjMlP/yttO/NDTwnW2Zj/WJ4IvyvC/T6KsOT3TkMOjbGrxpjzV6z4HCrgcftcOdv5vT8L1q1f+GTvXEe6Ads970EOi7FrRJHeXzIsf7I46pTqTRyV5YHwu7n6cQOHbV8D4xL1iV/d2vmjypN2iicx/7dsGAm3M6H4l8c+YcJpCfBpRez9JLLzPiGJJ1s35QvJzEoyt8LicbL4RRmhYNy/VsYzz7nlkFe5+mhrK5/KpdOwT+sbxdizKI0begHG7aEynvnOItwug47Z2N5O5/Ibj9Omft51gxt6AcbtG59wG7BDPdIPDCd+923fPnbYpjuAxw2f5JmT/3HGyuhzIb92HNYtmyj+LsYpummF002f+Ka3P3PEepL5Za13ZdvsJxIQ4HZe9YmvsN8loXqjH2XzBNl83KmVGiV9Nf4AfmfnCDjjF+VIMY4fK2/XPiCE1727Q+NlkGK8ro25fP8I/HH41ANmxzgdj4DbNRcy+c7spEmX8l2E17vQv8Pi3WLcFBd1wikKBBivT32W85M+y3n+NAwJOY8IcDs/CEjOV1R7PmN6YM5l3t6JQzzvsJgn6810tkisGupPWM4S26a4vZGCetTO+ZMUnlHbV2Gcr/jMl3M28zhimsdzns/j7eSuKU9NCkdCgvH6MKA4cmJIvhn2PJtR6SGR35ftl3dw9w60KxeQnJhXR+MvceLj1Y1cvgA5g5/Z4xVlda1wy4/J+k8WH+afzadT2cyKjf4x4cPqWuFTUN7OfTT8qVI2+2hQRYzPX8csD+lXhteEt/GLS6DX1rSOJR/9EJC+YP2dd5lfuuAQPyD95DKNwpxH6md8lu3rO9SeFVu6tl89Nk4us+KHoOKzZrxmLPzxw8SpGJ+9Vr3hM4ajwWf9DJyw5yuf8yleyvQcaepRrWPNX7eV8OQr+6XfmHziT0G08cuiihjH4pjpt1cM14i3co3h2ka44nb/GJCee4VKWfmTcMhfMvU3FPruTfctMXxmIt7g9AnIah6n8ZDXqo/rAjfz55pP+Hih95kf7NiBn3Yl/WBs/5LcqbRK7zzmIY+1HcB/NWR5hX7lX7E83goAg3FZg38HsV6dHMF6lflt1iPu/Leifdds36H9Kcg25+04EOLxWA4Rn06GiE9TEP8bF/m5gM6nlOXD5wJ8WBzP6TRtYZ6V3DHcA7hnzmjeqhM/ZgOQm4oFvzG/H386uvvz1MNm74n6JfRnoop4vP4ypvbeqNaredL9bdjbYzXvN98ye8/U37fC3mP2Tcuj/Q04/53lQwvS3gdw+1I52/sbROd23FL82Sd3HcXbsJ4Q7Q9w+//DyOqJ/wUAAP//scwfnBhpAAA=";

  // Deserialize RuntimeTypeInfo
  var bytes = BASE64.decode(serializedRuntimeTypeInfo);
  var unzippedBytes = new ZLibDecoder().convert(bytes);
  var bdata = new ByteData.view(unzippedBytes.buffer);
  var message = new bindings.Message(bdata, null, unzippedBytes.length, 0);
  _runtimeTypeInfo = mojom_types.RuntimeTypeInfo.deserialize(message);
  return _runtimeTypeInfo;
}
