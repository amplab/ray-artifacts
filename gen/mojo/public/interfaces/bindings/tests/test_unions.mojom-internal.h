// NOTE: This file was generated by the Mojo bindings generator.
#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_INTERNAL_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_INTERNAL_H_

#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/buffer.h"
#include "mojo/public/cpp/bindings/lib/union_accessor.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/system/buffer.h"
#include "mojo/public/cpp/system/data_pipe.h"
#include "mojo/public/cpp/system/handle.h"
#include "mojo/public/cpp/system/message_pipe.h"
#include "mojo/public/interfaces/bindings/tests/test_included_unions.mojom-internal.h"

namespace mojo {
namespace internal {
class BoundsChecker;
}
}
namespace mojo {
namespace test {

class StructOfUnions;
class WrapperStruct;
class DummyStruct;
class SmallStruct;
class SmallStructNonNullableUnion;
class StructNullObjectUnion;
class SmallObjStruct;
class TryNonNullStruct;
class IncludingStruct;

class PodUnion;
class UnionOfUnions;
class ObjectUnion;
class HandleUnion;
class ObjectOnlyUnion;
class OldUnion;
class NewUnion;

namespace internal {

class StructOfUnions_Data;
class WrapperStruct_Data;
class DummyStruct_Data;
class SmallStruct_Data;
class SmallStructNonNullableUnion_Data;
class StructNullObjectUnion_Data;
class SmallObjStruct_Data;
class TryNonNullStruct_Data;
class IncludingStruct_Data;


class PodUnion_Data;
class UnionOfUnions_Data;
class ObjectUnion_Data;
class HandleUnion_Data;
class ObjectOnlyUnion_Data;
class OldUnion_Data;
class NewUnion_Data;

#pragma pack(push, 1)



class PodUnion_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;
  static PodUnion_Data* New(mojo::internal::Buffer* buf);
  PodUnion_Data();
  // Do nothing in the destructor since it won't be called.
  ~PodUnion_Data() {}

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      bool inlined,
      std::string* err);

  bool is_null() const {
    return size == 0;
  }

  void set_null();

  enum class PodUnion_Tag : uint32_t {

    F_INT8,
    F_INT8_OTHER,
    F_UINT8,
    F_INT16,
    F_UINT16,
    F_INT32,
    F_UINT32,
    F_INT64,
    F_UINT64,
    F_FLOAT,
    F_DOUBLE,
    F_BOOL,
    F_ENUM,
    __UNKNOWN__ = 0xFFFFFFFF,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    int8_t f_f_int8;
    int8_t f_f_int8_other;
    uint8_t f_f_uint8;
    int16_t f_f_int16;
    uint16_t f_f_uint16;
    int32_t f_f_int32;
    uint32_t f_f_uint32;
    int64_t f_f_int64;
    uint64_t f_f_uint64;
    float f_f_float;
    double f_f_double;
    uint8_t f_f_bool : 1;
    int32_t f_f_enum;
    uint64_t unknown;
  };

  uint32_t size;
  PodUnion_Tag tag;
  Union_ data;

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);
};
static_assert(sizeof(PodUnion_Data) == 16,
              "Bad sizeof(PodUnion_Data)");
static_assert(sizeof(PodUnion_Data::Union_) == 8,
              "Bad sizeof(PodUnion_Data::Union_)");



class UnionOfUnions_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;
  static UnionOfUnions_Data* New(mojo::internal::Buffer* buf);
  UnionOfUnions_Data();
  // Do nothing in the destructor since it won't be called.
  ~UnionOfUnions_Data() {}

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      bool inlined,
      std::string* err);

  bool is_null() const {
    return size == 0;
  }

  void set_null();

  enum class UnionOfUnions_Tag : uint32_t {

    U,
    A_OU,
    A_HU,
    M_OU,
    M_HU,
    __UNKNOWN__ = 0xFFFFFFFF,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    mojo::internal::UnionPointer<internal::ObjectUnion_Data> f_u;
    mojo::internal::ArrayPointer<internal::ObjectUnion_Data> f_a_ou;
    mojo::internal::ArrayPointer<internal::HandleUnion_Data> f_a_hu;
    mojo::internal::StructPointer<mojo::internal::Map_Data<int64_t, internal::ObjectUnion_Data>> f_m_ou;
    mojo::internal::StructPointer<mojo::internal::Map_Data<int64_t, internal::HandleUnion_Data>> f_m_hu;
    uint64_t unknown;
  };

  uint32_t size;
  UnionOfUnions_Tag tag;
  Union_ data;

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);
};
static_assert(sizeof(UnionOfUnions_Data) == 16,
              "Bad sizeof(UnionOfUnions_Data)");
static_assert(sizeof(UnionOfUnions_Data::Union_) == 8,
              "Bad sizeof(UnionOfUnions_Data::Union_)");



class ObjectUnion_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;
  static ObjectUnion_Data* New(mojo::internal::Buffer* buf);
  ObjectUnion_Data();
  // Do nothing in the destructor since it won't be called.
  ~ObjectUnion_Data() {}

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      bool inlined,
      std::string* err);

  bool is_null() const {
    return size == 0;
  }

  void set_null();

  enum class ObjectUnion_Tag : uint32_t {

    F_INT8,
    F_STRING,
    F_DUMMY,
    F_NULLABLE,
    F_ARRAY_INT8,
    F_MAP_INT8,
    F_POD_UNION,
    __UNKNOWN__ = 0xFFFFFFFF,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    int8_t f_f_int8;
    mojo::internal::StringPointer f_f_string;
    mojo::internal::StructPointer<internal::DummyStruct_Data> f_f_dummy;
    mojo::internal::StructPointer<internal::DummyStruct_Data> f_f_nullable;
    mojo::internal::ArrayPointer<int8_t> f_f_array_int8;
    mojo::internal::StructPointer<mojo::internal::Map_Data<mojo::internal::String_Data*, int8_t>> f_f_map_int8;
    mojo::internal::UnionPointer<internal::PodUnion_Data> f_f_pod_union;
    uint64_t unknown;
  };

  uint32_t size;
  ObjectUnion_Tag tag;
  Union_ data;

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);
};
static_assert(sizeof(ObjectUnion_Data) == 16,
              "Bad sizeof(ObjectUnion_Data)");
static_assert(sizeof(ObjectUnion_Data::Union_) == 8,
              "Bad sizeof(ObjectUnion_Data::Union_)");



class HandleUnion_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;
  static HandleUnion_Data* New(mojo::internal::Buffer* buf);
  HandleUnion_Data();
  // Do nothing in the destructor since it won't be called.
  ~HandleUnion_Data() {}

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      bool inlined,
      std::string* err);

  bool is_null() const {
    return size == 0;
  }

  void set_null();

  enum class HandleUnion_Tag : uint32_t {

    F_HANDLE,
    F_MESSAGE_PIPE,
    F_DATA_PIPE_CONSUMER,
    F_DATA_PIPE_PRODUCER,
    F_SHARED_BUFFER,
    F_SMALL_CACHE,
    __UNKNOWN__ = 0xFFFFFFFF,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    MojoHandle f_f_handle;
    MojoHandle f_f_message_pipe;
    MojoHandle f_f_data_pipe_consumer;
    MojoHandle f_f_data_pipe_producer;
    MojoHandle f_f_shared_buffer;
    uint64_t f_f_small_cache;
    uint64_t unknown;
  };

  uint32_t size;
  HandleUnion_Tag tag;
  Union_ data;

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);
};
static_assert(sizeof(HandleUnion_Data) == 16,
              "Bad sizeof(HandleUnion_Data)");
static_assert(sizeof(HandleUnion_Data::Union_) == 8,
              "Bad sizeof(HandleUnion_Data::Union_)");



class ObjectOnlyUnion_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;
  static ObjectOnlyUnion_Data* New(mojo::internal::Buffer* buf);
  ObjectOnlyUnion_Data();
  // Do nothing in the destructor since it won't be called.
  ~ObjectOnlyUnion_Data() {}

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      bool inlined,
      std::string* err);

  bool is_null() const {
    return size == 0;
  }

  void set_null();

  enum class ObjectOnlyUnion_Tag : uint32_t {

    DUMMY1,
    __UNKNOWN__ = 0xFFFFFFFF,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    mojo::internal::StructPointer<internal::DummyStruct_Data> f_dummy1;
    uint64_t unknown;
  };

  uint32_t size;
  ObjectOnlyUnion_Tag tag;
  Union_ data;

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);
};
static_assert(sizeof(ObjectOnlyUnion_Data) == 16,
              "Bad sizeof(ObjectOnlyUnion_Data)");
static_assert(sizeof(ObjectOnlyUnion_Data::Union_) == 8,
              "Bad sizeof(ObjectOnlyUnion_Data::Union_)");



class OldUnion_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;
  static OldUnion_Data* New(mojo::internal::Buffer* buf);
  OldUnion_Data();
  // Do nothing in the destructor since it won't be called.
  ~OldUnion_Data() {}

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      bool inlined,
      std::string* err);

  bool is_null() const {
    return size == 0;
  }

  void set_null();

  enum class OldUnion_Tag : uint32_t {

    F_INT8,
    __UNKNOWN__ = 0xFFFFFFFF,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    int8_t f_f_int8;
    uint64_t unknown;
  };

  uint32_t size;
  OldUnion_Tag tag;
  Union_ data;

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);
};
static_assert(sizeof(OldUnion_Data) == 16,
              "Bad sizeof(OldUnion_Data)");
static_assert(sizeof(OldUnion_Data::Union_) == 8,
              "Bad sizeof(OldUnion_Data::Union_)");



class NewUnion_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;
  static NewUnion_Data* New(mojo::internal::Buffer* buf);
  NewUnion_Data();
  // Do nothing in the destructor since it won't be called.
  ~NewUnion_Data() {}

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      bool inlined,
      std::string* err);

  bool is_null() const {
    return size == 0;
  }

  void set_null();

  enum class NewUnion_Tag : uint32_t {

    F_INT8,
    F_INT16,
    __UNKNOWN__ = 0xFFFFFFFF,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    int8_t f_f_int8;
    int16_t f_f_int16;
    uint64_t unknown;
  };

  uint32_t size;
  NewUnion_Tag tag;
  Union_ data;

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);
};
static_assert(sizeof(NewUnion_Data) == 16,
              "Bad sizeof(NewUnion_Data)");
static_assert(sizeof(NewUnion_Data::Union_) == 8,
              "Bad sizeof(NewUnion_Data::Union_)");


class StructOfUnions_Data {
 public:
  static StructOfUnions_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;
  internal::ObjectUnion_Data u;
  mojo::internal::ArrayPointer<internal::ObjectUnion_Data> a_ou;
  mojo::internal::ArrayPointer<internal::HandleUnion_Data> a_hu;
  mojo::internal::StructPointer<mojo::internal::Map_Data<int64_t, internal::ObjectUnion_Data>> m_ou;
  mojo::internal::StructPointer<mojo::internal::Map_Data<int64_t, internal::HandleUnion_Data>> m_hu;

 private:
  StructOfUnions_Data();
  ~StructOfUnions_Data() = delete;
};
static_assert(sizeof(StructOfUnions_Data) == 56,
              "Bad sizeof(StructOfUnions_Data)");

class WrapperStruct_Data {
 public:
  static WrapperStruct_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;
  internal::ObjectUnion_Data object_union;
  internal::PodUnion_Data pod_union;
  internal::HandleUnion_Data handle_union;

 private:
  WrapperStruct_Data();
  ~WrapperStruct_Data() = delete;
};
static_assert(sizeof(WrapperStruct_Data) == 56,
              "Bad sizeof(WrapperStruct_Data)");

class DummyStruct_Data {
 public:
  static DummyStruct_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;
  int8_t f_int8;
  uint8_t padfinal_[7];

 private:
  DummyStruct_Data();
  ~DummyStruct_Data() = delete;
};
static_assert(sizeof(DummyStruct_Data) == 16,
              "Bad sizeof(DummyStruct_Data)");

class SmallStruct_Data {
 public:
  static SmallStruct_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;
  mojo::internal::StructPointer<internal::DummyStruct_Data> dummy_struct;
  internal::PodUnion_Data pod_union;
  mojo::internal::ArrayPointer<internal::PodUnion_Data> pod_union_array;
  mojo::internal::ArrayPointer<internal::PodUnion_Data> nullable_pod_union_array;
  mojo::internal::ArrayPointer<internal::DummyStruct_Data*> s_array;
  mojo::internal::StructPointer<mojo::internal::Map_Data<mojo::internal::String_Data*, internal::PodUnion_Data>> pod_union_map;
  mojo::internal::StructPointer<mojo::internal::Map_Data<mojo::internal::String_Data*, internal::PodUnion_Data>> nullable_pod_union_map;

 private:
  SmallStruct_Data();
  ~SmallStruct_Data() = delete;
};
static_assert(sizeof(SmallStruct_Data) == 72,
              "Bad sizeof(SmallStruct_Data)");

class SmallStructNonNullableUnion_Data {
 public:
  static SmallStructNonNullableUnion_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;
  internal::PodUnion_Data pod_union;

 private:
  SmallStructNonNullableUnion_Data();
  ~SmallStructNonNullableUnion_Data() = delete;
};
static_assert(sizeof(SmallStructNonNullableUnion_Data) == 24,
              "Bad sizeof(SmallStructNonNullableUnion_Data)");

class StructNullObjectUnion_Data {
 public:
  static StructNullObjectUnion_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;
  internal::ObjectOnlyUnion_Data obj_union;

 private:
  StructNullObjectUnion_Data();
  ~StructNullObjectUnion_Data() = delete;
};
static_assert(sizeof(StructNullObjectUnion_Data) == 24,
              "Bad sizeof(StructNullObjectUnion_Data)");

class SmallObjStruct_Data {
 public:
  static SmallObjStruct_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;
  internal::ObjectUnion_Data obj_union;
  int8_t f_int8;
  uint8_t padfinal_[7];

 private:
  SmallObjStruct_Data();
  ~SmallObjStruct_Data() = delete;
};
static_assert(sizeof(SmallObjStruct_Data) == 32,
              "Bad sizeof(SmallObjStruct_Data)");

class TryNonNullStruct_Data {
 public:
  static TryNonNullStruct_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;
  mojo::internal::StructPointer<internal::DummyStruct_Data> nullable;
  mojo::internal::StructPointer<internal::DummyStruct_Data> non_nullable;

 private:
  TryNonNullStruct_Data();
  ~TryNonNullStruct_Data() = delete;
};
static_assert(sizeof(TryNonNullStruct_Data) == 24,
              "Bad sizeof(TryNonNullStruct_Data)");

class IncludingStruct_Data {
 public:
  static IncludingStruct_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;
  mojo::test::internal::IncludedUnion_Data a;

 private:
  IncludingStruct_Data();
  ~IncludingStruct_Data() = delete;
};
static_assert(sizeof(IncludingStruct_Data) == 24,
              "Bad sizeof(IncludingStruct_Data)");


class SmallCache_SetIntValue_Params_Data {
 public:
  static SmallCache_SetIntValue_Params_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;
  int64_t int_value;

 private:
  SmallCache_SetIntValue_Params_Data();
  ~SmallCache_SetIntValue_Params_Data() = delete;
};
static_assert(sizeof(SmallCache_SetIntValue_Params_Data) == 16,
              "Bad sizeof(SmallCache_SetIntValue_Params_Data)");


class SmallCache_GetIntValue_Params_Data {
 public:
  static SmallCache_GetIntValue_Params_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;

 private:
  SmallCache_GetIntValue_Params_Data();
  ~SmallCache_GetIntValue_Params_Data() = delete;
};
static_assert(sizeof(SmallCache_GetIntValue_Params_Data) == 8,
              "Bad sizeof(SmallCache_GetIntValue_Params_Data)");

class SmallCache_GetIntValue_ResponseParams_Data {
 public:
  static SmallCache_GetIntValue_ResponseParams_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;
  int64_t int_value;

 private:
  SmallCache_GetIntValue_ResponseParams_Data();
  ~SmallCache_GetIntValue_ResponseParams_Data() = delete;
};
static_assert(sizeof(SmallCache_GetIntValue_ResponseParams_Data) == 16,
              "Bad sizeof(SmallCache_GetIntValue_ResponseParams_Data)");


class UnionInterface_Echo_Params_Data {
 public:
  static UnionInterface_Echo_Params_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;
  internal::PodUnion_Data in_val;

 private:
  UnionInterface_Echo_Params_Data();
  ~UnionInterface_Echo_Params_Data() = delete;
};
static_assert(sizeof(UnionInterface_Echo_Params_Data) == 24,
              "Bad sizeof(UnionInterface_Echo_Params_Data)");

class UnionInterface_Echo_ResponseParams_Data {
 public:
  static UnionInterface_Echo_ResponseParams_Data* New(mojo::internal::Buffer* buf);

  static mojo::internal::ValidationError Validate(
      const void* data,
      mojo::internal::BoundsChecker* bounds_checker,
      std::string* err);

  void EncodePointersAndHandles(std::vector<mojo::Handle>* handles);
  void DecodePointersAndHandles(std::vector<mojo::Handle>* handles);

  mojo::internal::StructHeader header_;
  internal::PodUnion_Data out_val;

 private:
  UnionInterface_Echo_ResponseParams_Data();
  ~UnionInterface_Echo_ResponseParams_Data() = delete;
};
static_assert(sizeof(UnionInterface_Echo_ResponseParams_Data) == 24,
              "Bad sizeof(UnionInterface_Echo_ResponseParams_Data)");


#pragma pack(pop)

}  // namespace internal
}  // namespace test
}  // namespace mojo

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_INTERNAL_H_
