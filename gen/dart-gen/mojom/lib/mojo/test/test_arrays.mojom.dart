// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library test_arrays_mojom;
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/mojom_types.mojom.dart' as mojom_types;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;



class StructWithInterface extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  TestInterfaceInterface iptr = null;

  StructWithInterface() : super(kVersions.last.size);

  StructWithInterface.init(
    TestInterfaceInterface this.iptr
  ) : super(kVersions.last.size);

  static StructWithInterface deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithInterface decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithInterface result = new StructWithInterface();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.iptr = decoder0.decodeServiceInterface(8, false, TestInterfaceProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithInterface";
    String fieldName;
    try {
      fieldName = "iptr";
      encoder0.encodeInterface(iptr, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithInterface("
           "iptr: $iptr" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithInterfaceArray extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(40, 0)
  ];
  List<StructWithInterface> structsArray = null;
  List<StructWithInterface> structsNullableArray = null;
  List<StructWithInterface> nullableStructsArray = null;
  List<StructWithInterface> nullableStructsNullableArray = null;

  StructWithInterfaceArray() : super(kVersions.last.size);

  StructWithInterfaceArray.init(
    List<StructWithInterface> this.structsArray, 
    List<StructWithInterface> this.structsNullableArray, 
    List<StructWithInterface> this.nullableStructsArray, 
    List<StructWithInterface> this.nullableStructsNullableArray
  ) : super(kVersions.last.size);

  static StructWithInterfaceArray deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithInterfaceArray decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithInterfaceArray result = new StructWithInterfaceArray();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.structsArray = new List<StructWithInterface>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.structsArray[i1] = StructWithInterface.decode(decoder2);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      if (decoder1 == null) {
        result.structsNullableArray = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.structsNullableArray = new List<StructWithInterface>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.structsNullableArray[i1] = StructWithInterface.decode(decoder2);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(24, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.nullableStructsArray = new List<StructWithInterface>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, true);
          result.nullableStructsArray[i1] = StructWithInterface.decode(decoder2);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(32, true);
      if (decoder1 == null) {
        result.nullableStructsNullableArray = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.nullableStructsNullableArray = new List<StructWithInterface>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, true);
          result.nullableStructsNullableArray[i1] = StructWithInterface.decode(decoder2);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithInterfaceArray";
    String fieldName;
    try {
      fieldName = "structsArray";
      if (structsArray == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(structsArray.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < structsArray.length; ++i0) {
          encoder1.encodeStruct(structsArray[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
      fieldName = "structsNullableArray";
      if (structsNullableArray == null) {
        encoder0.encodeNullPointer(16, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(structsNullableArray.length, 16, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < structsNullableArray.length; ++i0) {
          encoder1.encodeStruct(structsNullableArray[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
      fieldName = "nullableStructsArray";
      if (nullableStructsArray == null) {
        encoder0.encodeNullPointer(24, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(nullableStructsArray.length, 24, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < nullableStructsArray.length; ++i0) {
          encoder1.encodeStruct(nullableStructsArray[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, true);
        }
      }
      fieldName = "nullableStructsNullableArray";
      if (nullableStructsNullableArray == null) {
        encoder0.encodeNullPointer(32, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(nullableStructsNullableArray.length, 32, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < nullableStructsNullableArray.length; ++i0) {
          encoder1.encodeStruct(nullableStructsNullableArray[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, true);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithInterfaceArray("
           "structsArray: $structsArray" ", "
           "structsNullableArray: $structsNullableArray" ", "
           "nullableStructsArray: $nullableStructsArray" ", "
           "nullableStructsNullableArray: $nullableStructsNullableArray" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithDataPipeConsumers extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(40, 0)
  ];
  List<core.MojoDataPipeConsumer> handlesArray = null;
  List<core.MojoDataPipeConsumer> handlesNullableArray = null;
  List<core.MojoDataPipeConsumer> nullableHandlesArray = null;
  List<core.MojoDataPipeConsumer> nullableHandlesNullableArray = null;

  StructWithDataPipeConsumers() : super(kVersions.last.size);

  StructWithDataPipeConsumers.init(
    List<core.MojoDataPipeConsumer> this.handlesArray, 
    List<core.MojoDataPipeConsumer> this.handlesNullableArray, 
    List<core.MojoDataPipeConsumer> this.nullableHandlesArray, 
    List<core.MojoDataPipeConsumer> this.nullableHandlesNullableArray
  ) : super(kVersions.last.size);

  static StructWithDataPipeConsumers deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithDataPipeConsumers decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithDataPipeConsumers result = new StructWithDataPipeConsumers();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handlesArray = decoder0.decodeConsumerHandleArray(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.handlesNullableArray = decoder0.decodeConsumerHandleArray(16, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.nullableHandlesArray = decoder0.decodeConsumerHandleArray(24, bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.nullableHandlesNullableArray = decoder0.decodeConsumerHandleArray(32, bindings.kArrayNullable | bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithDataPipeConsumers";
    String fieldName;
    try {
      fieldName = "handlesArray";
      encoder0.encodeConsumerHandleArray(handlesArray, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "handlesNullableArray";
      encoder0.encodeConsumerHandleArray(handlesNullableArray, 16, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "nullableHandlesArray";
      encoder0.encodeConsumerHandleArray(nullableHandlesArray, 24, bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "nullableHandlesNullableArray";
      encoder0.encodeConsumerHandleArray(nullableHandlesNullableArray, 32, bindings.kArrayNullable | bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithDataPipeConsumers("
           "handlesArray: $handlesArray" ", "
           "handlesNullableArray: $handlesNullableArray" ", "
           "nullableHandlesArray: $nullableHandlesArray" ", "
           "nullableHandlesNullableArray: $nullableHandlesNullableArray" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithDataPipeProducers extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(40, 0)
  ];
  List<core.MojoDataPipeProducer> handlesArray = null;
  List<core.MojoDataPipeProducer> handlesNullableArray = null;
  List<core.MojoDataPipeProducer> nullableHandlesArray = null;
  List<core.MojoDataPipeProducer> nullableHandlesNullableArray = null;

  StructWithDataPipeProducers() : super(kVersions.last.size);

  StructWithDataPipeProducers.init(
    List<core.MojoDataPipeProducer> this.handlesArray, 
    List<core.MojoDataPipeProducer> this.handlesNullableArray, 
    List<core.MojoDataPipeProducer> this.nullableHandlesArray, 
    List<core.MojoDataPipeProducer> this.nullableHandlesNullableArray
  ) : super(kVersions.last.size);

  static StructWithDataPipeProducers deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithDataPipeProducers decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithDataPipeProducers result = new StructWithDataPipeProducers();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handlesArray = decoder0.decodeProducerHandleArray(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.handlesNullableArray = decoder0.decodeProducerHandleArray(16, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.nullableHandlesArray = decoder0.decodeProducerHandleArray(24, bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.nullableHandlesNullableArray = decoder0.decodeProducerHandleArray(32, bindings.kArrayNullable | bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithDataPipeProducers";
    String fieldName;
    try {
      fieldName = "handlesArray";
      encoder0.encodeProducerHandleArray(handlesArray, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "handlesNullableArray";
      encoder0.encodeProducerHandleArray(handlesNullableArray, 16, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "nullableHandlesArray";
      encoder0.encodeProducerHandleArray(nullableHandlesArray, 24, bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "nullableHandlesNullableArray";
      encoder0.encodeProducerHandleArray(nullableHandlesNullableArray, 32, bindings.kArrayNullable | bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithDataPipeProducers("
           "handlesArray: $handlesArray" ", "
           "handlesNullableArray: $handlesNullableArray" ", "
           "nullableHandlesArray: $nullableHandlesArray" ", "
           "nullableHandlesNullableArray: $nullableHandlesNullableArray" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithSharedBuffers extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(40, 0)
  ];
  List<core.MojoSharedBuffer> handlesArray = null;
  List<core.MojoSharedBuffer> handlesNullableArray = null;
  List<core.MojoSharedBuffer> nullableHandlesArray = null;
  List<core.MojoSharedBuffer> nullableHandlesNullableArray = null;

  StructWithSharedBuffers() : super(kVersions.last.size);

  StructWithSharedBuffers.init(
    List<core.MojoSharedBuffer> this.handlesArray, 
    List<core.MojoSharedBuffer> this.handlesNullableArray, 
    List<core.MojoSharedBuffer> this.nullableHandlesArray, 
    List<core.MojoSharedBuffer> this.nullableHandlesNullableArray
  ) : super(kVersions.last.size);

  static StructWithSharedBuffers deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithSharedBuffers decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithSharedBuffers result = new StructWithSharedBuffers();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handlesArray = decoder0.decodeSharedBufferHandleArray(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.handlesNullableArray = decoder0.decodeSharedBufferHandleArray(16, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.nullableHandlesArray = decoder0.decodeSharedBufferHandleArray(24, bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.nullableHandlesNullableArray = decoder0.decodeSharedBufferHandleArray(32, bindings.kArrayNullable | bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithSharedBuffers";
    String fieldName;
    try {
      fieldName = "handlesArray";
      encoder0.encodeSharedBufferHandleArray(handlesArray, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "handlesNullableArray";
      encoder0.encodeSharedBufferHandleArray(handlesNullableArray, 16, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "nullableHandlesArray";
      encoder0.encodeSharedBufferHandleArray(nullableHandlesArray, 24, bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "nullableHandlesNullableArray";
      encoder0.encodeSharedBufferHandleArray(nullableHandlesNullableArray, 32, bindings.kArrayNullable | bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithSharedBuffers("
           "handlesArray: $handlesArray" ", "
           "handlesNullableArray: $handlesNullableArray" ", "
           "nullableHandlesArray: $nullableHandlesArray" ", "
           "nullableHandlesNullableArray: $nullableHandlesNullableArray" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithMessagePipes extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(40, 0)
  ];
  List<core.MojoMessagePipeEndpoint> handlesArray = null;
  List<core.MojoMessagePipeEndpoint> handlesNullableArray = null;
  List<core.MojoMessagePipeEndpoint> nullableHandlesArray = null;
  List<core.MojoMessagePipeEndpoint> nullableHandlesNullableArray = null;

  StructWithMessagePipes() : super(kVersions.last.size);

  StructWithMessagePipes.init(
    List<core.MojoMessagePipeEndpoint> this.handlesArray, 
    List<core.MojoMessagePipeEndpoint> this.handlesNullableArray, 
    List<core.MojoMessagePipeEndpoint> this.nullableHandlesArray, 
    List<core.MojoMessagePipeEndpoint> this.nullableHandlesNullableArray
  ) : super(kVersions.last.size);

  static StructWithMessagePipes deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithMessagePipes decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithMessagePipes result = new StructWithMessagePipes();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handlesArray = decoder0.decodeMessagePipeHandleArray(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.handlesNullableArray = decoder0.decodeMessagePipeHandleArray(16, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.nullableHandlesArray = decoder0.decodeMessagePipeHandleArray(24, bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.nullableHandlesNullableArray = decoder0.decodeMessagePipeHandleArray(32, bindings.kArrayNullable | bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithMessagePipes";
    String fieldName;
    try {
      fieldName = "handlesArray";
      encoder0.encodeMessagePipeHandleArray(handlesArray, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "handlesNullableArray";
      encoder0.encodeMessagePipeHandleArray(handlesNullableArray, 16, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "nullableHandlesArray";
      encoder0.encodeMessagePipeHandleArray(nullableHandlesArray, 24, bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "nullableHandlesNullableArray";
      encoder0.encodeMessagePipeHandleArray(nullableHandlesNullableArray, 32, bindings.kArrayNullable | bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithMessagePipes("
           "handlesArray: $handlesArray" ", "
           "handlesNullableArray: $handlesNullableArray" ", "
           "nullableHandlesArray: $nullableHandlesArray" ", "
           "nullableHandlesNullableArray: $nullableHandlesNullableArray" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithHandles extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(40, 0)
  ];
  List<core.MojoHandle> handlesArray = null;
  List<core.MojoHandle> handlesNullableArray = null;
  List<core.MojoHandle> nullableHandlesArray = null;
  List<core.MojoHandle> nullableHandlesNullableArray = null;

  StructWithHandles() : super(kVersions.last.size);

  StructWithHandles.init(
    List<core.MojoHandle> this.handlesArray, 
    List<core.MojoHandle> this.handlesNullableArray, 
    List<core.MojoHandle> this.nullableHandlesArray, 
    List<core.MojoHandle> this.nullableHandlesNullableArray
  ) : super(kVersions.last.size);

  static StructWithHandles deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithHandles decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithHandles result = new StructWithHandles();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handlesArray = decoder0.decodeHandleArray(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.handlesNullableArray = decoder0.decodeHandleArray(16, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.nullableHandlesArray = decoder0.decodeHandleArray(24, bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.nullableHandlesNullableArray = decoder0.decodeHandleArray(32, bindings.kArrayNullable | bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithHandles";
    String fieldName;
    try {
      fieldName = "handlesArray";
      encoder0.encodeHandleArray(handlesArray, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "handlesNullableArray";
      encoder0.encodeHandleArray(handlesNullableArray, 16, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "nullableHandlesArray";
      encoder0.encodeHandleArray(nullableHandlesArray, 24, bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "nullableHandlesNullableArray";
      encoder0.encodeHandleArray(nullableHandlesNullableArray, 32, bindings.kArrayNullable | bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithHandles("
           "handlesArray: $handlesArray" ", "
           "handlesNullableArray: $handlesNullableArray" ", "
           "nullableHandlesArray: $nullableHandlesArray" ", "
           "nullableHandlesNullableArray: $nullableHandlesNullableArray" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithInterfaceRequests extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(40, 0)
  ];
  List<TestInterfaceInterfaceRequest> reqArray = null;
  List<TestInterfaceInterfaceRequest> reqNullableArray = null;
  List<TestInterfaceInterfaceRequest> nullableReqArray = null;
  List<TestInterfaceInterfaceRequest> nullableReqNullableArray = null;

  StructWithInterfaceRequests() : super(kVersions.last.size);

  StructWithInterfaceRequests.init(
    List<TestInterfaceInterfaceRequest> this.reqArray, 
    List<TestInterfaceInterfaceRequest> this.reqNullableArray, 
    List<TestInterfaceInterfaceRequest> this.nullableReqArray, 
    List<TestInterfaceInterfaceRequest> this.nullableReqNullableArray
  ) : super(kVersions.last.size);

  static StructWithInterfaceRequests deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithInterfaceRequests decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithInterfaceRequests result = new StructWithInterfaceRequests();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.reqArray = decoder0.decodeInterfaceRequestArray(8, bindings.kNothingNullable, TestInterfaceStub.newFromEndpoint, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.reqNullableArray = decoder0.decodeInterfaceRequestArray(16, bindings.kArrayNullable, TestInterfaceStub.newFromEndpoint, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.nullableReqArray = decoder0.decodeInterfaceRequestArray(24, bindings.kElementNullable, TestInterfaceStub.newFromEndpoint, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.nullableReqNullableArray = decoder0.decodeInterfaceRequestArray(32, bindings.kArrayNullable | bindings.kElementNullable, TestInterfaceStub.newFromEndpoint, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithInterfaceRequests";
    String fieldName;
    try {
      fieldName = "reqArray";
      encoder0.encodeInterfaceRequestArray(reqArray, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "reqNullableArray";
      encoder0.encodeInterfaceRequestArray(reqNullableArray, 16, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "nullableReqArray";
      encoder0.encodeInterfaceRequestArray(nullableReqArray, 24, bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "nullableReqNullableArray";
      encoder0.encodeInterfaceRequestArray(nullableReqNullableArray, 32, bindings.kArrayNullable | bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithInterfaceRequests("
           "reqArray: $reqArray" ", "
           "reqNullableArray: $reqNullableArray" ", "
           "nullableReqArray: $nullableReqArray" ", "
           "nullableReqNullableArray: $nullableReqNullableArray" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _TestInterfaceFooParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _TestInterfaceFooParams() : super(kVersions.last.size);

  _TestInterfaceFooParams.init(
  ) : super(kVersions.last.size);

  static _TestInterfaceFooParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestInterfaceFooParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestInterfaceFooParams result = new _TestInterfaceFooParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestInterfaceFooParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestInterfaceFooParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}

const int _testInterfaceMethodFooName = 0;

class _TestInterfaceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class TestInterface {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _TestInterfaceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static TestInterfaceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    TestInterfaceProxy p = new TestInterfaceProxy.unbound();
    String name = serviceName ?? TestInterface.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void foo();
}

abstract class TestInterfaceInterface
    implements bindings.MojoInterface<TestInterface>,
               TestInterface {
  factory TestInterfaceInterface([TestInterface impl]) =>
      new TestInterfaceStub.unbound(impl);

  factory TestInterfaceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [TestInterface impl]) =>
      new TestInterfaceStub.fromEndpoint(endpoint, impl);

  factory TestInterfaceInterface.fromMock(
      TestInterface mock) =>
      new TestInterfaceProxy.fromMock(mock);
}

abstract class TestInterfaceInterfaceRequest
    implements bindings.MojoInterface<TestInterface>,
               TestInterface {
  factory TestInterfaceInterfaceRequest() =>
      new TestInterfaceProxy.unbound();
}

class _TestInterfaceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<TestInterface> {
  TestInterface impl;

  _TestInterfaceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _TestInterfaceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _TestInterfaceProxyControl.unbound() : super.unbound();

  String get serviceName => TestInterface.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestInterfaceProxyControl($superString)";
  }
}

class TestInterfaceProxy
    extends bindings.Proxy<TestInterface>
    implements TestInterface,
               TestInterfaceInterface,
               TestInterfaceInterfaceRequest {
  TestInterfaceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _TestInterfaceProxyControl.fromEndpoint(endpoint));

  TestInterfaceProxy.fromHandle(core.MojoHandle handle)
      : super(new _TestInterfaceProxyControl.fromHandle(handle));

  TestInterfaceProxy.unbound()
      : super(new _TestInterfaceProxyControl.unbound());

  factory TestInterfaceProxy.fromMock(TestInterface mock) {
    TestInterfaceProxy newMockedProxy =
        new TestInterfaceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static TestInterfaceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestInterfaceProxy"));
    return new TestInterfaceProxy.fromEndpoint(endpoint);
  }


  void foo() {
    if (impl != null) {
      impl.foo();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _TestInterfaceFooParams();
    ctrl.sendMessage(params,
        _testInterfaceMethodFooName);
  }
}

class _TestInterfaceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<TestInterface> {
  TestInterface _impl;

  _TestInterfaceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestInterface impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestInterfaceStubControl.fromHandle(
      core.MojoHandle handle, [TestInterface impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestInterfaceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => TestInterface.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _testInterfaceMethodFooName:
        _impl.foo();
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  TestInterface get impl => _impl;
  set impl(TestInterface d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestInterfaceStubControl($superString)";
  }

  int get version => 0;
}

class TestInterfaceStub
    extends bindings.Stub<TestInterface>
    implements TestInterface,
               TestInterfaceInterface,
               TestInterfaceInterfaceRequest {
  TestInterfaceStub.unbound([TestInterface impl])
      : super(new _TestInterfaceStubControl.unbound(impl));

  TestInterfaceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestInterface impl])
      : super(new _TestInterfaceStubControl.fromEndpoint(endpoint, impl));

  TestInterfaceStub.fromHandle(
      core.MojoHandle handle, [TestInterface impl])
      : super(new _TestInterfaceStubControl.fromHandle(handle, impl));

  static TestInterfaceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestInterfaceStub"));
    return new TestInterfaceStub.fromEndpoint(endpoint);
  }


  void foo() {
    return impl.foo();
  }
}


mojom_types.RuntimeTypeInfo getRuntimeTypeInfo() => _runtimeTypeInfo ??
    _initRuntimeTypeInfo();

Map<String, mojom_types.UserDefinedType> getAllMojomTypeDefinitions() {
  return getRuntimeTypeInfo().typeMap;
}

var _runtimeTypeInfo;
mojom_types.RuntimeTypeInfo  _initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this
  // file. The string contains the base64 encoding of the gzip-compressed bytes.
  var serializedRuntimeTypeInfo = "H4sIAAAJbogC/+xbT5PbNBS343QTKH+yLbThT7eBttvQNnHbBWYpHMqfMsswzGRoZ9gOh9abeBszSZzazgxw4tiP0CPHPXLkI3DkuMf9CBx7o1L8lMqKVDne2JZnohlFK8cvtn7vPf2e9LR1LSw1aK9Dy14nbZVp5+RLYdtB9RVUd+D6r9AeQPsvtM+gbephuwvtE2j/hvZTVNuo3rvfufPg+zv3bw3dX9x2YPtB+27gTbrBT07Q/8YKrI4ztr92R/5kaHv+gnIdz+1NulO5a0jmokxuxxr1BravwTM2Zfd/Nwpsb9/q2pq2he69Gvv+Lz3P+i0+DjO5H+3HE/QVesMbSOYjmdwPtu9bj2wMhQ96uYnqFZnc3b7l2b2vJvv7U+ym+kS1wZe7hz5mb/gU7ATbD1b1E8qecL9eifYPXo/2m29F+4dnov2jjWj/r81o/3rrRd/A9rYV9huMfTfADh+uhe1tLVqI33Sg/R/KWOOXC6i+h+pLjRcV/HqXUI1p7nP++DaqGMKf8bNQNfvu0DbH3aHrOcHvJjKrVtf1bNP3uiZ+hjme7A2crukQBfnmnjPqOaNHvokfH34+sLBB+m0sMZzpu0zhRvz4KcwHh0YUt23qPUvUPCArItw1CnfedY3CA5tQP3TdcCAc3M6A/6eNW4N59xrgWGXeRwOcRPhpOn+81QT46dTvs2UDsCH4jSaDgbU3sAmQLI5nwX6zwlFPCcdaAhxLMXCc4ccYJItjPWMcZfaoS3CsCnCsJ8DR4NxHymVUz/NwZAyTxfMd4GtV7JLgSXipysGrDPNsvvxEBUkx+YmWYPXw/oqfEvHTOQX5ySggP20oyE9GAfnpvIL8ZBSYnxoK8pNxDH6qAd4dCT/tMPz0UIAr5u/1CD9Ri3GKvyTL9jncb6z4KBEf3YS/VeIjrYB8tAV2rRIfaQXko48zxjEOH2kF5qNPUD2lGB9pS+CjP0rL4SPMNacjfERt9kJsdE7AR/SdLO6vZsRHLI48Oz2B6n9L5p2mQP410J8zDjweT5/MgW/Y+Izmx8im9gL73y+zX53zPPJ9Hez3sLKY/fYFeDfgt0XJB5wD+FBmvy/SFHP6eiOnuIrkj3YhnnpWViuu8qcoiuOqN2HeyIPHTlB2KfKDZsz5b9H8mCpxG9GPLG6rgUwe/FgkPaUeFzIOxeppPWM9yfxJz1lPucWdAsdi9XUK5FTxq6z0ddw8wJ+VtPIAnMMFkjwAT4LV83ZO8cEB4LUN8cE/isQH63AuwrMfz2IDXlz1GVxTZT4rpRQn5x0PvAtzEdYHGwvw9HIL9ihVmbdU0cuy+Z/oZaYTxmFYvXyesV5k/mJkrJes+J7wRkQvHMdh9fMF6FQVvzFyWPdnmUch8bPoECAZj+y4IKvHK6s8SqI8ytUc1yei/X+9gHmUazmuG5aJY955lFbGOMbJo+gFzqO0Yawq5VH0Y+RRyD707tpy9qExpmcjfBQ9XI7PsH8g4CPOMfQ5/C+seCkRL11UbB4gdlk0XrqkmP8nxTFvXtrMGMc4vFQuMC9dhnlVJV4qL8BLTUH+g7VfEb63GX7qSOZLdt1HeEuw3JvDew1y+2njzfs/ApJf1xl/pnFm8TxKKc9/EtbY37ou930r4D9Z2WWdGe/RAuPERcSzp2GsaJwtL9wG546XlLTHW41xfoa+73kAAAD//zUoldooOgAA";

  // Deserialize RuntimeTypeInfo
  var bytes = BASE64.decode(serializedRuntimeTypeInfo);
  var unzippedBytes = new ZLibDecoder().convert(bytes);
  var bdata = new ByteData.view(unzippedBytes.buffer);
  var message = new bindings.Message(bdata, null, unzippedBytes.length, 0);
  _runtimeTypeInfo = mojom_types.RuntimeTypeInfo.deserialize(message);
  return _runtimeTypeInfo;
}
