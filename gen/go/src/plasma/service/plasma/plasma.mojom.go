// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     plasma/service/plasma.mojom
//

package plasma

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	fmt "fmt"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
)


type Plasma interface {
	CreateObject(inObjectId string, inSize uint64, inName string, inCreatorId int64) (outBuffer system.SharedBufferHandle, err error)
	ResizeObject(inObjectId string, inNewSize uint64) (outBuffer system.SharedBufferHandle, err error)
	SealObject(inObjectId string) (err error)
	GetObject(inObjectId string, inBlock bool) (outBuffer system.SharedBufferHandle, outSize uint64, err error)
	ListObjects() (outInfo []ObjectInfo, err error)
}



var plasma_Name = "plasma::service::Plasma"

type Plasma_Request bindings.InterfaceRequest

func (r *Plasma_Request) Name() string {
	return plasma_Name
}


type Plasma_Pointer bindings.InterfacePointer

func (p *Plasma_Pointer) Name() string {
	return plasma_Name
}

type Plasma_ServiceFactory struct{
	Delegate Plasma_Factory
}

type Plasma_Factory interface {
	Create(request Plasma_Request)
}

func (f *Plasma_ServiceFactory) Name() string {
	return plasma_Name
}

// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *Plasma_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &Plasma_ServiceDescription{}
}

func (f *Plasma_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := Plasma_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForPlasma creates a message pipe for use with the
// Plasma interface with a Plasma_Request on one end and a Plasma_Pointer on the other.
func CreateMessagePipeForPlasma() (Plasma_Request, Plasma_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return Plasma_Request(r), Plasma_Pointer(p)
}

const plasma_CreateObject_Name uint32 = 0
const plasma_ResizeObject_Name uint32 = 1
const plasma_SealObject_Name uint32 = 2
const plasma_GetObject_Name uint32 = 3
const plasma_ListObjects_Name uint32 = 4

type Plasma_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewPlasmaProxy(p Plasma_Pointer, waiter bindings.AsyncWaiter) *Plasma_Proxy {
	return &Plasma_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *Plasma_Proxy) Close_Proxy() {
	p.router.Close()
}

type plasma_CreateObject_Params struct {
	inObjectId string
	inSize uint64
	inName string
	inCreatorId int64
}


func (s *plasma_CreateObject_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(32, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inObjectId); err != nil {
		return err
	}
	if err := encoder.WriteUint64(s.inSize); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inName); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.inCreatorId); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var plasma_CreateObject_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{40, 0},
}

func (s *plasma_CreateObject_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(plasma_CreateObject_Params_Versions), func(i int) bool {
		return plasma_CreateObject_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(plasma_CreateObject_Params_Versions) {
		if plasma_CreateObject_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := plasma_CreateObject_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inObjectId = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint64()
		if err != nil {
			return err
		}
		s.inSize = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inName = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.inCreatorId = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type plasma_CreateObject_ResponseParams struct {
	outBuffer system.SharedBufferHandle
}


func (s *plasma_CreateObject_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteHandle(s.outBuffer); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var plasma_CreateObject_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *plasma_CreateObject_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(plasma_CreateObject_ResponseParams_Versions), func(i int) bool {
		return plasma_CreateObject_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(plasma_CreateObject_ResponseParams_Versions) {
		if plasma_CreateObject_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := plasma_CreateObject_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadSharedBufferHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.outBuffer = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Plasma_Proxy) CreateObject(inObjectId string, inSize uint64, inName string, inCreatorId int64) (outBuffer system.SharedBufferHandle, err error) {
	payload := &plasma_CreateObject_Params{
		inObjectId,
		inSize,
		inName,
		inCreatorId,
	}
	header := bindings.MessageHeader{
		Type: plasma_CreateObject_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, plasma_CreateObject_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response plasma_CreateObject_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outBuffer = response.outBuffer
	return
}

type plasma_ResizeObject_Params struct {
	inObjectId string
	inNewSize uint64
}


func (s *plasma_ResizeObject_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inObjectId); err != nil {
		return err
	}
	if err := encoder.WriteUint64(s.inNewSize); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var plasma_ResizeObject_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *plasma_ResizeObject_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(plasma_ResizeObject_Params_Versions), func(i int) bool {
		return plasma_ResizeObject_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(plasma_ResizeObject_Params_Versions) {
		if plasma_ResizeObject_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := plasma_ResizeObject_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inObjectId = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint64()
		if err != nil {
			return err
		}
		s.inNewSize = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type plasma_ResizeObject_ResponseParams struct {
	outBuffer system.SharedBufferHandle
}


func (s *plasma_ResizeObject_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteHandle(s.outBuffer); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var plasma_ResizeObject_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *plasma_ResizeObject_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(plasma_ResizeObject_ResponseParams_Versions), func(i int) bool {
		return plasma_ResizeObject_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(plasma_ResizeObject_ResponseParams_Versions) {
		if plasma_ResizeObject_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := plasma_ResizeObject_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadSharedBufferHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.outBuffer = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Plasma_Proxy) ResizeObject(inObjectId string, inNewSize uint64) (outBuffer system.SharedBufferHandle, err error) {
	payload := &plasma_ResizeObject_Params{
		inObjectId,
		inNewSize,
	}
	header := bindings.MessageHeader{
		Type: plasma_ResizeObject_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, plasma_ResizeObject_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response plasma_ResizeObject_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outBuffer = response.outBuffer
	return
}

type plasma_SealObject_Params struct {
	inObjectId string
}


func (s *plasma_SealObject_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inObjectId); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var plasma_SealObject_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *plasma_SealObject_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(plasma_SealObject_Params_Versions), func(i int) bool {
		return plasma_SealObject_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(plasma_SealObject_Params_Versions) {
		if plasma_SealObject_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := plasma_SealObject_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inObjectId = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Plasma_Proxy) SealObject(inObjectId string) (err error) {
	payload := &plasma_SealObject_Params{
		inObjectId,
	}
	header := bindings.MessageHeader{
		Type: plasma_SealObject_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type plasma_GetObject_Params struct {
	inObjectId string
	inBlock bool
}


func (s *plasma_GetObject_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inObjectId); err != nil {
		return err
	}
	if err := encoder.WriteBool(s.inBlock); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var plasma_GetObject_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *plasma_GetObject_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(plasma_GetObject_Params_Versions), func(i int) bool {
		return plasma_GetObject_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(plasma_GetObject_Params_Versions) {
		if plasma_GetObject_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := plasma_GetObject_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inObjectId = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		s.inBlock = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type plasma_GetObject_ResponseParams struct {
	outBuffer system.SharedBufferHandle
	outSize uint64
}


func (s *plasma_GetObject_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteHandle(s.outBuffer); err != nil {
		return err
	}
	if err := encoder.WriteUint64(s.outSize); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var plasma_GetObject_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *plasma_GetObject_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(plasma_GetObject_ResponseParams_Versions), func(i int) bool {
		return plasma_GetObject_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(plasma_GetObject_ResponseParams_Versions) {
		if plasma_GetObject_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := plasma_GetObject_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadSharedBufferHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.outBuffer = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint64()
		if err != nil {
			return err
		}
		s.outSize = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Plasma_Proxy) GetObject(inObjectId string, inBlock bool) (outBuffer system.SharedBufferHandle, outSize uint64, err error) {
	payload := &plasma_GetObject_Params{
		inObjectId,
		inBlock,
	}
	header := bindings.MessageHeader{
		Type: plasma_GetObject_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, plasma_GetObject_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response plasma_GetObject_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outBuffer = response.outBuffer
	outSize = response.outSize
	return
}

type plasma_ListObjects_Params struct {
}


func (s *plasma_ListObjects_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var plasma_ListObjects_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *plasma_ListObjects_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(plasma_ListObjects_Params_Versions), func(i int) bool {
		return plasma_ListObjects_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(plasma_ListObjects_Params_Versions) {
		if plasma_ListObjects_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := plasma_ListObjects_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type plasma_ListObjects_ResponseParams struct {
	outInfo []ObjectInfo
}


func (s *plasma_ListObjects_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.outInfo)), 64)
	for _, elem0 := range s.outInfo {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var plasma_ListObjects_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *plasma_ListObjects_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(plasma_ListObjects_ResponseParams_Versions), func(i int) bool {
		return plasma_ListObjects_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(plasma_ListObjects_ResponseParams_Versions) {
		if plasma_ListObjects_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := plasma_ListObjects_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			s.outInfo = make([]ObjectInfo, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := s.outInfo[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Plasma_Proxy) ListObjects() (outInfo []ObjectInfo, err error) {
	payload := &plasma_ListObjects_Params{
	}
	header := bindings.MessageHeader{
		Type: plasma_ListObjects_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, plasma_ListObjects_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response plasma_ListObjects_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outInfo = response.outInfo
	return
}

type plasma_Stub struct {
	connector *bindings.Connector
	impl Plasma
}

func NewPlasmaStub(r Plasma_Request, impl Plasma, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &plasma_Stub{connector, impl})
}


func (f *Plasma_Request) ServiceDescription() service_describer.ServiceDescription {
	return &Plasma_ServiceDescription{}
}


type Plasma_ServiceDescription struct{}

func (sd *Plasma_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *Plasma_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *Plasma_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*Plasma_ServiceDescription)(nil)


func (s *plasma_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case plasma_CreateObject_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request plasma_CreateObject_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response plasma_CreateObject_ResponseParams
		response.outBuffer, err = s.impl.CreateObject(request.inObjectId, request.inSize, request.inName, request.inCreatorId)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: plasma_CreateObject_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case plasma_ResizeObject_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request plasma_ResizeObject_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response plasma_ResizeObject_ResponseParams
		response.outBuffer, err = s.impl.ResizeObject(request.inObjectId, request.inNewSize)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: plasma_ResizeObject_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case plasma_SealObject_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request plasma_SealObject_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SealObject(request.inObjectId)
		if err != nil {
			return
		}
	case plasma_GetObject_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request plasma_GetObject_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response plasma_GetObject_ResponseParams
		response.outBuffer, 		response.outSize, err = s.impl.GetObject(request.inObjectId, request.inBlock)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: plasma_GetObject_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case plasma_ListObjects_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request plasma_ListObjects_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response plasma_ListObjects_ResponseParams
		response.outInfo, err = s.impl.ListObjects()
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: plasma_ListObjects_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type ObjectInfo struct {
	Name string
	Size uint64
	CreateTime int64
	ConstructDuration int64
	CreatorId int64
}


func (s *ObjectInfo) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(40, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.Name); err != nil {
		return err
	}
	if err := encoder.WriteUint64(s.Size); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.CreateTime); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.ConstructDuration); err != nil {
		return err
	}
	if err := encoder.WriteInt64(s.CreatorId); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var objectInfo_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{48, 0},
}

func (s *ObjectInfo) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(objectInfo_Versions), func(i int) bool {
		return objectInfo_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(objectInfo_Versions) {
		if objectInfo_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := objectInfo_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.Name = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadUint64()
		if err != nil {
			return err
		}
		s.Size = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.CreateTime = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.ConstructDuration = value0
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.CreatorId = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

