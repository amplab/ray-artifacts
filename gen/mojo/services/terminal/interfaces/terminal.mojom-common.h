// NOTE: This file was generated by the Mojo bindings generator.
#ifndef MOJO_SERVICES_TERMINAL_INTERFACES_TERMINAL_MOJOM_COMMON_H_
#define MOJO_SERVICES_TERMINAL_INTERFACES_TERMINAL_MOJOM_COMMON_H_

#include <stdint.h>
#include <iosfwd>

#include "mojo/public/cpp/bindings/array.h"
#include "mojo/public/cpp/bindings/callback.h"
#include "mojo/public/cpp/bindings/interface_handle.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/map.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/bindings/string.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/system/buffer.h"
#include "mojo/public/cpp/system/data_pipe.h"
#include "mojo/public/cpp/system/handle.h"
#include "mojo/public/cpp/system/message_pipe.h"
#include "mojo/services/terminal/interfaces/terminal.mojom-internal.h"
#include "mojo/services/files/interfaces/file.mojom-common.h"
#include "mojo/services/files/interfaces/types.mojom-common.h"
#include "mojo/services/terminal/interfaces/terminal_client.mojom-common.h"
namespace mojo {
namespace terminal {

// --- Interface Forward Declarations ---
class Terminal;
class TerminalRequestValidator;
class TerminalResponseValidator;
class Terminal_Synchronous;

// --- Struct Forward Declarations ---

// --- Union Forward Declarations ---

// --- Enums Declarations ---

// --- Constants ---

// --- Interface declarations ---
namespace internal {
class Terminal_Base {
 public:
  static const char Name_[];
  static const uint32_t Version_ = 0;

  using RequestValidator_ = TerminalRequestValidator;
  using ResponseValidator_ = TerminalResponseValidator;
  using Synchronous_ = Terminal_Synchronous;
  enum class MessageOrdinals : uint32_t {
    Connect = 0,
    ConnectToClient = 1,
    GetSize = 2,
    SetSize = 3,
  };


  virtual ~Terminal_Base() {}
};

}  // namespace internal

// Async interface declaration

class TerminalProxy;
class TerminalStub;
class Terminal_Synchronous;

class TerminalRequestValidator;
class TerminalResponseValidator;

class Terminal : public internal::Terminal_Base {
 public:
  virtual ~Terminal() override {}

  using Proxy_ = TerminalProxy;
  using Stub_ = TerminalStub;
  using ConnectCallback = mojo::Callback<void(mojo::files::Error)>;
  virtual void Connect(mojo::InterfaceRequest<mojo::files::File> terminal_file, bool force, const ConnectCallback& callback) = 0;
  using ConnectToClientCallback = mojo::Callback<void(mojo::files::Error)>;
  virtual void ConnectToClient(mojo::InterfaceHandle<mojo::terminal::TerminalClient> terminal_client, bool force, const ConnectToClientCallback& callback) = 0;
  using GetSizeCallback = mojo::Callback<void(mojo::files::Error, uint32_t, uint32_t)>;
  virtual void GetSize(const GetSizeCallback& callback) = 0;
  using SetSizeCallback = mojo::Callback<void(mojo::files::Error, uint32_t, uint32_t)>;
  virtual void SetSize(uint32_t rows, uint32_t columns, bool reset, const SetSizeCallback& callback) = 0;
};

}  // namespace terminal
}  // namespace mojo

// --- Internal Template Specializations ---

namespace mojo {
namespace internal {

}  // internal
}  // mojo
namespace mojo {
namespace terminal {

// --- Interface Request Validators ---
class TerminalRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface Response Validators ---
class TerminalResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface enum operators ---

// --- Unions ---
// Unions must be declared first because they can be members of structs.

// --- Inlined structs ---

// --- Non-inlined structs ---

// --- Struct serialization helpers ---

// --- Union serialization helpers ---

// --- Request and response parameter structs for Interface methods ---
      

class Terminal_Connect_Params;

using Terminal_Connect_ParamsPtr = mojo::StructPtr<Terminal_Connect_Params>;


size_t GetSerializedSize_(const Terminal_Connect_Params& input);
mojo::internal::ValidationError Serialize_(
    Terminal_Connect_Params* input,
    mojo::internal::Buffer* buffer,
    internal::Terminal_Connect_Params_Data** output);
void Deserialize_(internal::Terminal_Connect_Params_Data* input,
                  Terminal_Connect_Params* output);

class Terminal_Connect_Params {
 public:
  using Data_ = internal::Terminal_Connect_Params_Data;

  static Terminal_Connect_ParamsPtr New();

  template <typename U>
  static Terminal_Connect_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<Terminal_Connect_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Terminal_Connect_Params>::Convert(*this);
  }

  Terminal_Connect_Params();
  ~Terminal_Connect_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const Terminal_Connect_Params& other) const;

  mojo::InterfaceRequest<mojo::files::File> terminal_file;
  bool force;
};



class Terminal_Connect_ResponseParams;

using Terminal_Connect_ResponseParamsPtr = mojo::InlinedStructPtr<Terminal_Connect_ResponseParams>;


size_t GetSerializedSize_(const Terminal_Connect_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    Terminal_Connect_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::Terminal_Connect_ResponseParams_Data** output);
void Deserialize_(internal::Terminal_Connect_ResponseParams_Data* input,
                  Terminal_Connect_ResponseParams* output);

class Terminal_Connect_ResponseParams {
 public:
  using Data_ = internal::Terminal_Connect_ResponseParams_Data;

  static Terminal_Connect_ResponseParamsPtr New();

  template <typename U>
  static Terminal_Connect_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<Terminal_Connect_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Terminal_Connect_ResponseParams>::Convert(*this);
  }

  Terminal_Connect_ResponseParams();
  ~Terminal_Connect_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  Terminal_Connect_ResponseParamsPtr Clone() const;
  bool Equals(const Terminal_Connect_ResponseParams& other) const;

  mojo::files::Error error;
};



class Terminal_ConnectToClient_Params;

using Terminal_ConnectToClient_ParamsPtr = mojo::StructPtr<Terminal_ConnectToClient_Params>;


size_t GetSerializedSize_(const Terminal_ConnectToClient_Params& input);
mojo::internal::ValidationError Serialize_(
    Terminal_ConnectToClient_Params* input,
    mojo::internal::Buffer* buffer,
    internal::Terminal_ConnectToClient_Params_Data** output);
void Deserialize_(internal::Terminal_ConnectToClient_Params_Data* input,
                  Terminal_ConnectToClient_Params* output);

class Terminal_ConnectToClient_Params {
 public:
  using Data_ = internal::Terminal_ConnectToClient_Params_Data;

  static Terminal_ConnectToClient_ParamsPtr New();

  template <typename U>
  static Terminal_ConnectToClient_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<Terminal_ConnectToClient_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Terminal_ConnectToClient_Params>::Convert(*this);
  }

  Terminal_ConnectToClient_Params();
  ~Terminal_ConnectToClient_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const Terminal_ConnectToClient_Params& other) const;

  mojo::InterfaceHandle<mojo::terminal::TerminalClient> terminal_client;
  bool force;
};



class Terminal_ConnectToClient_ResponseParams;

using Terminal_ConnectToClient_ResponseParamsPtr = mojo::InlinedStructPtr<Terminal_ConnectToClient_ResponseParams>;


size_t GetSerializedSize_(const Terminal_ConnectToClient_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    Terminal_ConnectToClient_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::Terminal_ConnectToClient_ResponseParams_Data** output);
void Deserialize_(internal::Terminal_ConnectToClient_ResponseParams_Data* input,
                  Terminal_ConnectToClient_ResponseParams* output);

class Terminal_ConnectToClient_ResponseParams {
 public:
  using Data_ = internal::Terminal_ConnectToClient_ResponseParams_Data;

  static Terminal_ConnectToClient_ResponseParamsPtr New();

  template <typename U>
  static Terminal_ConnectToClient_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<Terminal_ConnectToClient_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Terminal_ConnectToClient_ResponseParams>::Convert(*this);
  }

  Terminal_ConnectToClient_ResponseParams();
  ~Terminal_ConnectToClient_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  Terminal_ConnectToClient_ResponseParamsPtr Clone() const;
  bool Equals(const Terminal_ConnectToClient_ResponseParams& other) const;

  mojo::files::Error error;
};



class Terminal_GetSize_Params;

using Terminal_GetSize_ParamsPtr = mojo::InlinedStructPtr<Terminal_GetSize_Params>;


size_t GetSerializedSize_(const Terminal_GetSize_Params& input);
mojo::internal::ValidationError Serialize_(
    Terminal_GetSize_Params* input,
    mojo::internal::Buffer* buffer,
    internal::Terminal_GetSize_Params_Data** output);
void Deserialize_(internal::Terminal_GetSize_Params_Data* input,
                  Terminal_GetSize_Params* output);

class Terminal_GetSize_Params {
 public:
  using Data_ = internal::Terminal_GetSize_Params_Data;

  static Terminal_GetSize_ParamsPtr New();

  template <typename U>
  static Terminal_GetSize_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<Terminal_GetSize_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Terminal_GetSize_Params>::Convert(*this);
  }

  Terminal_GetSize_Params();
  ~Terminal_GetSize_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  Terminal_GetSize_ParamsPtr Clone() const;
  bool Equals(const Terminal_GetSize_Params& other) const;

};



class Terminal_GetSize_ResponseParams;

using Terminal_GetSize_ResponseParamsPtr = mojo::InlinedStructPtr<Terminal_GetSize_ResponseParams>;


size_t GetSerializedSize_(const Terminal_GetSize_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    Terminal_GetSize_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::Terminal_GetSize_ResponseParams_Data** output);
void Deserialize_(internal::Terminal_GetSize_ResponseParams_Data* input,
                  Terminal_GetSize_ResponseParams* output);

class Terminal_GetSize_ResponseParams {
 public:
  using Data_ = internal::Terminal_GetSize_ResponseParams_Data;

  static Terminal_GetSize_ResponseParamsPtr New();

  template <typename U>
  static Terminal_GetSize_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<Terminal_GetSize_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Terminal_GetSize_ResponseParams>::Convert(*this);
  }

  Terminal_GetSize_ResponseParams();
  ~Terminal_GetSize_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  Terminal_GetSize_ResponseParamsPtr Clone() const;
  bool Equals(const Terminal_GetSize_ResponseParams& other) const;

  mojo::files::Error error;
  uint32_t rows;
  uint32_t columns;
};



class Terminal_SetSize_Params;

using Terminal_SetSize_ParamsPtr = mojo::InlinedStructPtr<Terminal_SetSize_Params>;


size_t GetSerializedSize_(const Terminal_SetSize_Params& input);
mojo::internal::ValidationError Serialize_(
    Terminal_SetSize_Params* input,
    mojo::internal::Buffer* buffer,
    internal::Terminal_SetSize_Params_Data** output);
void Deserialize_(internal::Terminal_SetSize_Params_Data* input,
                  Terminal_SetSize_Params* output);

class Terminal_SetSize_Params {
 public:
  using Data_ = internal::Terminal_SetSize_Params_Data;

  static Terminal_SetSize_ParamsPtr New();

  template <typename U>
  static Terminal_SetSize_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<Terminal_SetSize_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Terminal_SetSize_Params>::Convert(*this);
  }

  Terminal_SetSize_Params();
  ~Terminal_SetSize_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  Terminal_SetSize_ParamsPtr Clone() const;
  bool Equals(const Terminal_SetSize_Params& other) const;

  uint32_t rows;
  uint32_t columns;
  bool reset;
};



class Terminal_SetSize_ResponseParams;

using Terminal_SetSize_ResponseParamsPtr = mojo::InlinedStructPtr<Terminal_SetSize_ResponseParams>;


size_t GetSerializedSize_(const Terminal_SetSize_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    Terminal_SetSize_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::Terminal_SetSize_ResponseParams_Data** output);
void Deserialize_(internal::Terminal_SetSize_ResponseParams_Data* input,
                  Terminal_SetSize_ResponseParams* output);

class Terminal_SetSize_ResponseParams {
 public:
  using Data_ = internal::Terminal_SetSize_ResponseParams_Data;

  static Terminal_SetSize_ResponseParamsPtr New();

  template <typename U>
  static Terminal_SetSize_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<Terminal_SetSize_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Terminal_SetSize_ResponseParams>::Convert(*this);
  }

  Terminal_SetSize_ResponseParams();
  ~Terminal_SetSize_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  Terminal_SetSize_ResponseParamsPtr Clone() const;
  bool Equals(const Terminal_SetSize_ResponseParams& other) const;

  mojo::files::Error error;
  uint32_t rows;
  uint32_t columns;
};


}  // namespace terminal
}  // namespace mojo

#endif  // MOJO_SERVICES_TERMINAL_INTERFACES_TERMINAL_MOJOM_COMMON_H_
