// NOTE: This file was generated by the Mojo bindings generator.
#ifndef MOJO_SERVICES_NATIVE_VIEWPORT_INTERFACES_NATIVE_VIEWPORT_MOJOM_COMMON_H_
#define MOJO_SERVICES_NATIVE_VIEWPORT_INTERFACES_NATIVE_VIEWPORT_MOJOM_COMMON_H_

#include <stdint.h>
#include <iosfwd>

#include "mojo/public/cpp/bindings/array.h"
#include "mojo/public/cpp/bindings/callback.h"
#include "mojo/public/cpp/bindings/interface_handle.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/map.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/bindings/string.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/system/buffer.h"
#include "mojo/public/cpp/system/data_pipe.h"
#include "mojo/public/cpp/system/handle.h"
#include "mojo/public/cpp/system/message_pipe.h"
#include "mojo/services/native_viewport/interfaces/native_viewport.mojom-internal.h"
#include "mojo/services/geometry/interfaces/geometry.mojom-common.h"
#include "mojo/services/gpu/interfaces/context_provider.mojom-common.h"
#include "mojo/services/native_viewport/interfaces/native_viewport_event_dispatcher.mojom-common.h"
namespace mojo {

// --- Interface Forward Declarations ---
class NativeViewport;
class NativeViewportRequestValidator;
class NativeViewportResponseValidator;
class NativeViewport_Synchronous;

// --- Struct Forward Declarations ---
class ViewportMetrics;

using ViewportMetricsPtr = mojo::StructPtr<ViewportMetrics>;


class SurfaceConfiguration;

using SurfaceConfigurationPtr = mojo::StructPtr<SurfaceConfiguration>;



// --- Union Forward Declarations ---

// --- Enums Declarations ---

// --- Constants ---

// --- Interface declarations ---
namespace internal {
class NativeViewport_Base {
 public:
  static const char Name_[];
  static const uint32_t Version_ = 0;

  using RequestValidator_ = NativeViewportRequestValidator;
  using ResponseValidator_ = NativeViewportResponseValidator;
  using Synchronous_ = NativeViewport_Synchronous;
  enum class MessageOrdinals : uint32_t {
    Create = 0,
    Show = 1,
    Hide = 2,
    Close = 3,
    SetSize = 4,
    SetEventDispatcher = 5,
    GetContextProvider = 6,
    RequestMetrics = 7,
  };


  virtual ~NativeViewport_Base() {}
};

}  // namespace internal

// Async interface declaration

class NativeViewportProxy;
class NativeViewportStub;
class NativeViewport_Synchronous;

class NativeViewportRequestValidator;
class NativeViewportResponseValidator;

class NativeViewport : public internal::NativeViewport_Base {
 public:
  virtual ~NativeViewport() override {}

  using Proxy_ = NativeViewportProxy;
  using Stub_ = NativeViewportStub;
  using CreateCallback = mojo::Callback<void(ViewportMetricsPtr)>;
  virtual void Create(mojo::SizePtr size, SurfaceConfigurationPtr requested_configuration, const CreateCallback& callback) = 0;
  virtual void Show() = 0;
  virtual void Hide() = 0;
  virtual void Close() = 0;
  virtual void SetSize(mojo::SizePtr size) = 0;
  virtual void SetEventDispatcher(mojo::InterfaceHandle<mojo::NativeViewportEventDispatcher> dispatcher) = 0;
  virtual void GetContextProvider(mojo::InterfaceRequest<mojo::ContextProvider> provider) = 0;
  using RequestMetricsCallback = mojo::Callback<void(ViewportMetricsPtr)>;
  virtual void RequestMetrics(const RequestMetricsCallback& callback) = 0;
};

}  // namespace mojo

// --- Internal Template Specializations ---

namespace mojo {
namespace internal {
template <>
struct WrapperTraits<mojo::ViewportMetricsPtr, true, false> {
  using DataType = mojo::internal::ViewportMetrics_Data*;
};
template <>
struct WrapperTraits<mojo::SurfaceConfigurationPtr, true, false> {
  using DataType = mojo::internal::SurfaceConfiguration_Data*;
};

}  // internal
}  // mojo
namespace mojo {

// --- Interface Request Validators ---
class NativeViewportRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface Response Validators ---
class NativeViewportResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface enum operators ---

// --- Unions ---
// Unions must be declared first because they can be members of structs.

// --- Inlined structs ---

// --- Non-inlined structs ---
class ViewportMetrics {
 public:
  using Data_ = internal::ViewportMetrics_Data;

  static ViewportMetricsPtr New();

  template <typename U>
  static ViewportMetricsPtr From(const U& u) {
    return mojo::TypeConverter<ViewportMetricsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ViewportMetrics>::Convert(*this);
  }

  ViewportMetrics();
  ~ViewportMetrics();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ViewportMetricsPtr Clone() const;
  bool Equals(const ViewportMetrics& other) const;

  mojo::SizePtr size;
  float device_pixel_ratio;
};


class SurfaceConfiguration {
 public:
  using Data_ = internal::SurfaceConfiguration_Data;

  static SurfaceConfigurationPtr New();

  template <typename U>
  static SurfaceConfigurationPtr From(const U& u) {
    return mojo::TypeConverter<SurfaceConfigurationPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SurfaceConfiguration>::Convert(*this);
  }

  SurfaceConfiguration();
  ~SurfaceConfiguration();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  SurfaceConfigurationPtr Clone() const;
  bool Equals(const SurfaceConfiguration& other) const;

  uint8_t red_bits;
  uint8_t green_bits;
  uint8_t blue_bits;
  uint8_t alpha_bits;
  uint8_t depth_bits;
  uint8_t stencil_bits;
};



// --- Struct serialization helpers ---
size_t GetSerializedSize_(const ViewportMetrics& input);
mojo::internal::ValidationError Serialize_(
    ViewportMetrics* input,
    mojo::internal::Buffer* buffer,
    internal::ViewportMetrics_Data** output);
void Deserialize_(internal::ViewportMetrics_Data* input,
                  ViewportMetrics* output);

size_t GetSerializedSize_(const SurfaceConfiguration& input);
mojo::internal::ValidationError Serialize_(
    SurfaceConfiguration* input,
    mojo::internal::Buffer* buffer,
    internal::SurfaceConfiguration_Data** output);
void Deserialize_(internal::SurfaceConfiguration_Data* input,
                  SurfaceConfiguration* output);


// --- Union serialization helpers ---

// --- Request and response parameter structs for Interface methods ---
      

class NativeViewport_Create_Params;

using NativeViewport_Create_ParamsPtr = mojo::StructPtr<NativeViewport_Create_Params>;


size_t GetSerializedSize_(const NativeViewport_Create_Params& input);
mojo::internal::ValidationError Serialize_(
    NativeViewport_Create_Params* input,
    mojo::internal::Buffer* buffer,
    internal::NativeViewport_Create_Params_Data** output);
void Deserialize_(internal::NativeViewport_Create_Params_Data* input,
                  NativeViewport_Create_Params* output);

class NativeViewport_Create_Params {
 public:
  using Data_ = internal::NativeViewport_Create_Params_Data;

  static NativeViewport_Create_ParamsPtr New();

  template <typename U>
  static NativeViewport_Create_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<NativeViewport_Create_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NativeViewport_Create_Params>::Convert(*this);
  }

  NativeViewport_Create_Params();
  ~NativeViewport_Create_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  NativeViewport_Create_ParamsPtr Clone() const;
  bool Equals(const NativeViewport_Create_Params& other) const;

  mojo::SizePtr size;
  SurfaceConfigurationPtr requested_configuration;
};



class NativeViewport_Create_ResponseParams;

using NativeViewport_Create_ResponseParamsPtr = mojo::StructPtr<NativeViewport_Create_ResponseParams>;


size_t GetSerializedSize_(const NativeViewport_Create_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    NativeViewport_Create_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::NativeViewport_Create_ResponseParams_Data** output);
void Deserialize_(internal::NativeViewport_Create_ResponseParams_Data* input,
                  NativeViewport_Create_ResponseParams* output);

class NativeViewport_Create_ResponseParams {
 public:
  using Data_ = internal::NativeViewport_Create_ResponseParams_Data;

  static NativeViewport_Create_ResponseParamsPtr New();

  template <typename U>
  static NativeViewport_Create_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<NativeViewport_Create_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NativeViewport_Create_ResponseParams>::Convert(*this);
  }

  NativeViewport_Create_ResponseParams();
  ~NativeViewport_Create_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  NativeViewport_Create_ResponseParamsPtr Clone() const;
  bool Equals(const NativeViewport_Create_ResponseParams& other) const;

  ViewportMetricsPtr metrics;
};



class NativeViewport_Show_Params;

using NativeViewport_Show_ParamsPtr = mojo::InlinedStructPtr<NativeViewport_Show_Params>;


size_t GetSerializedSize_(const NativeViewport_Show_Params& input);
mojo::internal::ValidationError Serialize_(
    NativeViewport_Show_Params* input,
    mojo::internal::Buffer* buffer,
    internal::NativeViewport_Show_Params_Data** output);
void Deserialize_(internal::NativeViewport_Show_Params_Data* input,
                  NativeViewport_Show_Params* output);

class NativeViewport_Show_Params {
 public:
  using Data_ = internal::NativeViewport_Show_Params_Data;

  static NativeViewport_Show_ParamsPtr New();

  template <typename U>
  static NativeViewport_Show_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<NativeViewport_Show_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NativeViewport_Show_Params>::Convert(*this);
  }

  NativeViewport_Show_Params();
  ~NativeViewport_Show_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  NativeViewport_Show_ParamsPtr Clone() const;
  bool Equals(const NativeViewport_Show_Params& other) const;

};




class NativeViewport_Hide_Params;

using NativeViewport_Hide_ParamsPtr = mojo::InlinedStructPtr<NativeViewport_Hide_Params>;


size_t GetSerializedSize_(const NativeViewport_Hide_Params& input);
mojo::internal::ValidationError Serialize_(
    NativeViewport_Hide_Params* input,
    mojo::internal::Buffer* buffer,
    internal::NativeViewport_Hide_Params_Data** output);
void Deserialize_(internal::NativeViewport_Hide_Params_Data* input,
                  NativeViewport_Hide_Params* output);

class NativeViewport_Hide_Params {
 public:
  using Data_ = internal::NativeViewport_Hide_Params_Data;

  static NativeViewport_Hide_ParamsPtr New();

  template <typename U>
  static NativeViewport_Hide_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<NativeViewport_Hide_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NativeViewport_Hide_Params>::Convert(*this);
  }

  NativeViewport_Hide_Params();
  ~NativeViewport_Hide_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  NativeViewport_Hide_ParamsPtr Clone() const;
  bool Equals(const NativeViewport_Hide_Params& other) const;

};




class NativeViewport_Close_Params;

using NativeViewport_Close_ParamsPtr = mojo::InlinedStructPtr<NativeViewport_Close_Params>;


size_t GetSerializedSize_(const NativeViewport_Close_Params& input);
mojo::internal::ValidationError Serialize_(
    NativeViewport_Close_Params* input,
    mojo::internal::Buffer* buffer,
    internal::NativeViewport_Close_Params_Data** output);
void Deserialize_(internal::NativeViewport_Close_Params_Data* input,
                  NativeViewport_Close_Params* output);

class NativeViewport_Close_Params {
 public:
  using Data_ = internal::NativeViewport_Close_Params_Data;

  static NativeViewport_Close_ParamsPtr New();

  template <typename U>
  static NativeViewport_Close_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<NativeViewport_Close_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NativeViewport_Close_Params>::Convert(*this);
  }

  NativeViewport_Close_Params();
  ~NativeViewport_Close_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  NativeViewport_Close_ParamsPtr Clone() const;
  bool Equals(const NativeViewport_Close_Params& other) const;

};




class NativeViewport_SetSize_Params;

using NativeViewport_SetSize_ParamsPtr = mojo::StructPtr<NativeViewport_SetSize_Params>;


size_t GetSerializedSize_(const NativeViewport_SetSize_Params& input);
mojo::internal::ValidationError Serialize_(
    NativeViewport_SetSize_Params* input,
    mojo::internal::Buffer* buffer,
    internal::NativeViewport_SetSize_Params_Data** output);
void Deserialize_(internal::NativeViewport_SetSize_Params_Data* input,
                  NativeViewport_SetSize_Params* output);

class NativeViewport_SetSize_Params {
 public:
  using Data_ = internal::NativeViewport_SetSize_Params_Data;

  static NativeViewport_SetSize_ParamsPtr New();

  template <typename U>
  static NativeViewport_SetSize_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<NativeViewport_SetSize_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NativeViewport_SetSize_Params>::Convert(*this);
  }

  NativeViewport_SetSize_Params();
  ~NativeViewport_SetSize_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  NativeViewport_SetSize_ParamsPtr Clone() const;
  bool Equals(const NativeViewport_SetSize_Params& other) const;

  mojo::SizePtr size;
};




class NativeViewport_SetEventDispatcher_Params;

using NativeViewport_SetEventDispatcher_ParamsPtr = mojo::StructPtr<NativeViewport_SetEventDispatcher_Params>;


size_t GetSerializedSize_(const NativeViewport_SetEventDispatcher_Params& input);
mojo::internal::ValidationError Serialize_(
    NativeViewport_SetEventDispatcher_Params* input,
    mojo::internal::Buffer* buffer,
    internal::NativeViewport_SetEventDispatcher_Params_Data** output);
void Deserialize_(internal::NativeViewport_SetEventDispatcher_Params_Data* input,
                  NativeViewport_SetEventDispatcher_Params* output);

class NativeViewport_SetEventDispatcher_Params {
 public:
  using Data_ = internal::NativeViewport_SetEventDispatcher_Params_Data;

  static NativeViewport_SetEventDispatcher_ParamsPtr New();

  template <typename U>
  static NativeViewport_SetEventDispatcher_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<NativeViewport_SetEventDispatcher_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NativeViewport_SetEventDispatcher_Params>::Convert(*this);
  }

  NativeViewport_SetEventDispatcher_Params();
  ~NativeViewport_SetEventDispatcher_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const NativeViewport_SetEventDispatcher_Params& other) const;

  mojo::InterfaceHandle<mojo::NativeViewportEventDispatcher> dispatcher;
};




class NativeViewport_GetContextProvider_Params;

using NativeViewport_GetContextProvider_ParamsPtr = mojo::StructPtr<NativeViewport_GetContextProvider_Params>;


size_t GetSerializedSize_(const NativeViewport_GetContextProvider_Params& input);
mojo::internal::ValidationError Serialize_(
    NativeViewport_GetContextProvider_Params* input,
    mojo::internal::Buffer* buffer,
    internal::NativeViewport_GetContextProvider_Params_Data** output);
void Deserialize_(internal::NativeViewport_GetContextProvider_Params_Data* input,
                  NativeViewport_GetContextProvider_Params* output);

class NativeViewport_GetContextProvider_Params {
 public:
  using Data_ = internal::NativeViewport_GetContextProvider_Params_Data;

  static NativeViewport_GetContextProvider_ParamsPtr New();

  template <typename U>
  static NativeViewport_GetContextProvider_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<NativeViewport_GetContextProvider_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NativeViewport_GetContextProvider_Params>::Convert(*this);
  }

  NativeViewport_GetContextProvider_Params();
  ~NativeViewport_GetContextProvider_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const NativeViewport_GetContextProvider_Params& other) const;

  mojo::InterfaceRequest<mojo::ContextProvider> provider;
};




class NativeViewport_RequestMetrics_Params;

using NativeViewport_RequestMetrics_ParamsPtr = mojo::InlinedStructPtr<NativeViewport_RequestMetrics_Params>;


size_t GetSerializedSize_(const NativeViewport_RequestMetrics_Params& input);
mojo::internal::ValidationError Serialize_(
    NativeViewport_RequestMetrics_Params* input,
    mojo::internal::Buffer* buffer,
    internal::NativeViewport_RequestMetrics_Params_Data** output);
void Deserialize_(internal::NativeViewport_RequestMetrics_Params_Data* input,
                  NativeViewport_RequestMetrics_Params* output);

class NativeViewport_RequestMetrics_Params {
 public:
  using Data_ = internal::NativeViewport_RequestMetrics_Params_Data;

  static NativeViewport_RequestMetrics_ParamsPtr New();

  template <typename U>
  static NativeViewport_RequestMetrics_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<NativeViewport_RequestMetrics_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NativeViewport_RequestMetrics_Params>::Convert(*this);
  }

  NativeViewport_RequestMetrics_Params();
  ~NativeViewport_RequestMetrics_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  NativeViewport_RequestMetrics_ParamsPtr Clone() const;
  bool Equals(const NativeViewport_RequestMetrics_Params& other) const;

};



class NativeViewport_RequestMetrics_ResponseParams;

using NativeViewport_RequestMetrics_ResponseParamsPtr = mojo::StructPtr<NativeViewport_RequestMetrics_ResponseParams>;


size_t GetSerializedSize_(const NativeViewport_RequestMetrics_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    NativeViewport_RequestMetrics_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::NativeViewport_RequestMetrics_ResponseParams_Data** output);
void Deserialize_(internal::NativeViewport_RequestMetrics_ResponseParams_Data* input,
                  NativeViewport_RequestMetrics_ResponseParams* output);

class NativeViewport_RequestMetrics_ResponseParams {
 public:
  using Data_ = internal::NativeViewport_RequestMetrics_ResponseParams_Data;

  static NativeViewport_RequestMetrics_ResponseParamsPtr New();

  template <typename U>
  static NativeViewport_RequestMetrics_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<NativeViewport_RequestMetrics_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NativeViewport_RequestMetrics_ResponseParams>::Convert(*this);
  }

  NativeViewport_RequestMetrics_ResponseParams();
  ~NativeViewport_RequestMetrics_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  NativeViewport_RequestMetrics_ResponseParamsPtr Clone() const;
  bool Equals(const NativeViewport_RequestMetrics_ResponseParams& other) const;

  ViewportMetricsPtr metrics;
};


}  // namespace mojo

#endif  // MOJO_SERVICES_NATIVE_VIEWPORT_INTERFACES_NATIVE_VIEWPORT_MOJOM_COMMON_H_
