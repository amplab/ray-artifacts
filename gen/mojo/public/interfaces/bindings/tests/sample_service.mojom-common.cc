// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/public/interfaces/bindings/tests/sample_service.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace sample {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// static
Bar_Data* Bar_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Bar_Data))) Bar_Data();
}

// static
mojo::internal::ValidationError Bar_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Bar_Data* object = static_cast<const Bar_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void Bar_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void Bar_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

Bar_Data::Bar_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
Foo_Data* Foo_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Foo_Data))) Foo_Data();
}

// static
mojo::internal::ValidationError Foo_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Foo_Data* object = static_cast<const Foo_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 96 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->bar.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = Bar::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->bar.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams data_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<uint8_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->data.offset),
          bounds_checker, &data_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->extra_bars.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams extra_bars_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<BarPtr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->extra_bars.offset),
          bounds_checker, &extra_bars_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->name.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null name field in Foo struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->name.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams name_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->name.offset),
          bounds_checker, &name_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  const mojo::Handle source_handle = object->source;
  if (!bounds_checker->ClaimHandle(source_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->input_streams.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams input_streams_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<mojo::ScopedDataPipeConsumerHandle>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->input_streams.offset),
          bounds_checker, &input_streams_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->output_streams.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams output_streams_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<mojo::ScopedDataPipeProducerHandle>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->output_streams.offset),
          bounds_checker, &output_streams_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->array_of_array_of_bools.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams array_of_array_of_bools_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval =
      mojo::Array<mojo::Array<bool> >::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->array_of_array_of_bools.offset),
          bounds_checker, &array_of_array_of_bools_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->multi_array_of_strings.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams multi_array_of_strings_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr))));
  auto validate_retval =
      mojo::Array<mojo::Array<mojo::Array<mojo::String> > >::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->multi_array_of_strings.offset),
          bounds_checker, &multi_array_of_strings_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->array_of_bools.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams array_of_bools_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<bool>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->array_of_bools.offset),
          bounds_checker, &array_of_bools_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Foo_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->bar, handles);
  mojo::internal::Encode(&this->data, handles);
  mojo::internal::Encode(&this->extra_bars, handles);
  mojo::internal::Encode(&this->name, handles);
  mojo::internal::EncodeHandle(&this->source, handles);
  mojo::internal::Encode(&this->input_streams, handles);
  mojo::internal::Encode(&this->output_streams, handles);
  mojo::internal::Encode(&this->array_of_array_of_bools, handles);
  mojo::internal::Encode(&this->multi_array_of_strings, handles);
  mojo::internal::Encode(&this->array_of_bools, handles);
}

void Foo_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->bar, handles);
  mojo::internal::Decode(&this->data, handles);
  mojo::internal::Decode(&this->extra_bars, handles);
  mojo::internal::Decode(&this->name, handles);
  mojo::internal::DecodeHandle(&this->source, handles);
  mojo::internal::Decode(&this->input_streams, handles);
  mojo::internal::Decode(&this->output_streams, handles);
  mojo::internal::Decode(&this->array_of_array_of_bools, handles);
  mojo::internal::Decode(&this->multi_array_of_strings, handles);
  mojo::internal::Decode(&this->array_of_bools, handles);
}

Foo_Data::Foo_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
DefaultsTest_Data* DefaultsTest_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(DefaultsTest_Data))) DefaultsTest_Data();
}

// static
mojo::internal::ValidationError DefaultsTest_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const DefaultsTest_Data* object = static_cast<const DefaultsTest_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 184 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->a18.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null a18 field in DefaultsTest struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->a18.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams a18_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<uint8_t>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->a18.offset),
          bounds_checker, &a18_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->a19.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null a19 field in DefaultsTest struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->a19.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams a19_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->a19.offset),
          bounds_checker, &a19_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->a21.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null a21 field in DefaultsTest struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->a21.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = imported::Point::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->a21.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->a22.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null a22 field in DefaultsTest struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->a22.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = imported::Thing::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->a22.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void DefaultsTest_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->a18, handles);
  mojo::internal::Encode(&this->a19, handles);
  mojo::internal::Encode(&this->a21, handles);
  mojo::internal::Encode(&this->a22, handles);
}

void DefaultsTest_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->a18, handles);
  mojo::internal::Decode(&this->a19, handles);
  mojo::internal::Decode(&this->a21, handles);
  mojo::internal::Decode(&this->a22, handles);
}

DefaultsTest_Data::DefaultsTest_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructWithHoleV1_Data* StructWithHoleV1_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructWithHoleV1_Data))) StructWithHoleV1_Data();
}

// static
mojo::internal::ValidationError StructWithHoleV1_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructWithHoleV1_Data* object = static_cast<const StructWithHoleV1_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void StructWithHoleV1_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void StructWithHoleV1_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

StructWithHoleV1_Data::StructWithHoleV1_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructWithHoleV2_Data* StructWithHoleV2_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructWithHoleV2_Data))) StructWithHoleV2_Data();
}

// static
mojo::internal::ValidationError StructWithHoleV2_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructWithHoleV2_Data* object = static_cast<const StructWithHoleV2_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void StructWithHoleV2_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void StructWithHoleV2_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

StructWithHoleV2_Data::StructWithHoleV2_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
NonNullableMapStruct_Data* NonNullableMapStruct_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(NonNullableMapStruct_Data))) NonNullableMapStruct_Data();
}

// static
mojo::internal::ValidationError NonNullableMapStruct_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const NonNullableMapStruct_Data* object = static_cast<const NonNullableMapStruct_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->map_field.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null map_field field in NonNullableMapStruct struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->map_field.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams map_field_validate_params(
      0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));
  auto validate_retval = mojo::Map<mojo::String, mojo::String>::Data_::Validate(
              mojo::internal::DecodePointerRaw(&object->map_field.offset),
              bounds_checker, &map_field_validate_params, err); 
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void NonNullableMapStruct_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->map_field, handles);
}

void NonNullableMapStruct_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->map_field, handles);
}

NonNullableMapStruct_Data::NonNullableMapStruct_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// --- Union definitions ---


// --- Definitions of the data structs for interface methods ---


// static
Service_Frobinate_Params_Data* Service_Frobinate_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Service_Frobinate_Params_Data))) Service_Frobinate_Params_Data();
}

// static
mojo::internal::ValidationError Service_Frobinate_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Service_Frobinate_Params_Data* object = static_cast<const Service_Frobinate_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->foo.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = Foo::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->foo.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  const mojo::Handle port_handle = object->port.handle;
  if (!bounds_checker->ClaimHandle(port_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Service_Frobinate_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->foo, handles);
  mojo::internal::EncodeHandle(&this->port, handles);
}

void Service_Frobinate_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->foo, handles);
  mojo::internal::DecodeHandle(&this->port, handles);
}

Service_Frobinate_Params_Data::Service_Frobinate_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
Service_Frobinate_ResponseParams_Data* Service_Frobinate_ResponseParams_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Service_Frobinate_ResponseParams_Data))) Service_Frobinate_ResponseParams_Data();
}

// static
mojo::internal::ValidationError Service_Frobinate_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Service_Frobinate_ResponseParams_Data* object = static_cast<const Service_Frobinate_ResponseParams_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void Service_Frobinate_ResponseParams_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void Service_Frobinate_ResponseParams_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

Service_Frobinate_ResponseParams_Data::Service_Frobinate_ResponseParams_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
Service_GetPort_Params_Data* Service_GetPort_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Service_GetPort_Params_Data))) Service_GetPort_Params_Data();
}

// static
mojo::internal::ValidationError Service_GetPort_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Service_GetPort_Params_Data* object = static_cast<const Service_GetPort_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle port_handle = object->port;
  if (port_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid port field in Service_GetPort_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(port_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Service_GetPort_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->port, handles);
}

void Service_GetPort_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->port, handles);
}

Service_GetPort_Params_Data::Service_GetPort_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
Port_PostMessage_Params_Data* Port_PostMessage_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Port_PostMessage_Params_Data))) Port_PostMessage_Params_Data();
}

// static
mojo::internal::ValidationError Port_PostMessage_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Port_PostMessage_Params_Data* object = static_cast<const Port_PostMessage_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->message_text.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null message_text field in Port_PostMessage_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->message_text.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams message_text_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->message_text.offset),
          bounds_checker, &message_text_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  const mojo::Handle port_handle = object->port.handle;
  if (port_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid port field in Port_PostMessage_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(port_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Port_PostMessage_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->message_text, handles);
  mojo::internal::EncodeHandle(&this->port, handles);
}

void Port_PostMessage_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->message_text, handles);
  mojo::internal::DecodeHandle(&this->port, handles);
}

Port_PostMessage_Params_Data::Port_PostMessage_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


}  // namespace internal

// --- Request and response validator definitions for interfaces ---
mojo::internal::ValidationError ServiceRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'Service', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::Service_Base::MessageOrdinals method_ordinal =
      static_cast<internal::Service_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::Service_Base::MessageOrdinals::Frobinate: {
      retval =
          mojo::internal::ValidateMessageIsRequestExpectingResponse(message,
                                                                    err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'Service', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::Service_Frobinate_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'Service', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::Service_Base::MessageOrdinals::GetPort: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'Service', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::Service_GetPort_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'Service', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'Service'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError ServiceResponseValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlResponse(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "response validation error for interface 'Service', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  retval = mojo::internal::ValidateMessageIsResponse(message, err);
  if (retval != mojo::internal::ValidationError::NONE) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'Service', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
    ReportValidationError(retval, err);
    return retval;
  }

  internal::Service_Base::MessageOrdinals method_ordinal =
      static_cast<internal::Service_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::Service_Base::MessageOrdinals::Frobinate: {
      retval = mojo::internal::ValidateMessagePayload<
                  internal::Service_Frobinate_ResponseParams_Data>(
                      message, err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "response validation error for interface 'Service',"
               " message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown response message name '"
                                          << message->header()->name
                                          << "' for interface "
                                             "'Service'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError PortRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'Port', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::Port_Base::MessageOrdinals method_ordinal =
      static_cast<internal::Port_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::Port_Base::MessageOrdinals::PostMessage: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'Port', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::Port_PostMessage_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'Port', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'Port'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
} 

// --- Enums ---

// Base interface definitions (Name_, Version_, Constants, Enums)
const uint32_t internal::Service_Base::Version_;

// Constants
const uint8_t internal::Service_Base::kFavoriteBaz;

// Enums
  
// static
bool internal::Service_Base::BazOptions_IsValidValue(BazOptions value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream,
                         const internal::Service_Base::BazOptions& val) {
  return (stream << static_cast<int32_t>(val));
}
const uint32_t internal::Port_Base::Version_;

// Constants

// Enums

// Struct Constants
const char* Foo::kFooby = "Fooby";

// --- Struct builder definitions ---
// static
bool Bar::Type_IsValidValue(Type value) {
  switch (static_cast<int32_t>(value)) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream,
                         const Bar::Type& val) {
  return (stream << static_cast<int32_t>(val));
}

// static
BarPtr Bar::New() {
  BarPtr rv;
  mojo::internal::StructHelper<Bar>::Initialize(&rv);
  return rv;
}

Bar::Bar()
    : alpha(255U),
      beta(),
      gamma(),
      type(Bar::Type::VERTICAL) {
}

Bar::~Bar() {
}


BarPtr Bar::Clone() const {
  BarPtr rv(New());
  rv->alpha = alpha;
  rv->beta = beta;
  rv->gamma = gamma;
  rv->type = type;
  return rv;
}


bool Bar::Equals(const Bar& other) const {
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->alpha, other.alpha))
    return false;
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->beta, other.beta))
    return false;
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->gamma, other.gamma))
    return false;
  if (!mojo::internal::ValueTraits<Bar::Type>::Equals(this->type, other.type))
    return false;
  return true;
}


// static
FooPtr Foo::New() {
  FooPtr rv;
  mojo::internal::StructHelper<Foo>::Initialize(&rv);
  return rv;
}

Foo::Foo()
    : name(Foo::kFooby),
      x(),
      y(),
      a(true),
      b(),
      c(),
      bar(),
      extra_bars(),
      data(),
      source(),
      input_streams(),
      output_streams(),
      array_of_array_of_bools(),
      multi_array_of_strings(),
      array_of_bools() {
}

Foo::~Foo() {
}



bool Foo::Equals(const Foo& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->name, other.name))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->x, other.x))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->y, other.y))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->a, other.a))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->b, other.b))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->c, other.c))
    return false;
  if (!mojo::internal::ValueTraits<BarPtr>::Equals(this->bar, other.bar))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<BarPtr>>::Equals(this->extra_bars, other.extra_bars))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<uint8_t>>::Equals(this->data, other.data))
    return false;
  if (!mojo::internal::ValueTraits<mojo::ScopedMessagePipeHandle>::Equals(this->source, other.source))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::ScopedDataPipeConsumerHandle>>::Equals(this->input_streams, other.input_streams))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::ScopedDataPipeProducerHandle>>::Equals(this->output_streams, other.output_streams))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::Array<bool> >>::Equals(this->array_of_array_of_bools, other.array_of_array_of_bools))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<mojo::Array<mojo::Array<mojo::String> > >>::Equals(this->multi_array_of_strings, other.multi_array_of_strings))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<bool>>::Equals(this->array_of_bools, other.array_of_bools))
    return false;
  return true;
}


// static
DefaultsTestPtr DefaultsTest::New() {
  DefaultsTestPtr rv;
  mojo::internal::StructHelper<DefaultsTest>::Initialize(&rv);
  return rv;
}

DefaultsTest::DefaultsTest()
    : a0(-12),
      a1(kTwelve),
      a2(1234),
      a3(34567U),
      a4(123456),
      a5(3456789012U),
      a6(-111111111111),
      a7(9999999999999999999ULL),
      a8(74565),
      a9(-74565),
      a10(1234),
      a11(true),
      a12(false),
      a13(123.25f),
      a14(1234567890.123),
      a15(10000000000.0),
      a16(-1.2e+20),
      a17(1.23e-20),
      a18(),
      a19(),
      a20(Bar::Type::BOTH),
      a21(),
      a22(imported::Thing::New()),
      a23(18446744073709551615ULL),
      a24(4886718345),
      a25(-4886718345),
      a26(INFINITY),
      a27(-INFINITY),
      a28(NAN),
      a29(INFINITY),
      a30(-INFINITY),
      a31(NAN) {
}

DefaultsTest::~DefaultsTest() {
}


DefaultsTestPtr DefaultsTest::Clone() const {
  DefaultsTestPtr rv(New());
  rv->a0 = a0;
  rv->a1 = a1;
  rv->a2 = a2;
  rv->a3 = a3;
  rv->a4 = a4;
  rv->a5 = a5;
  rv->a6 = a6;
  rv->a7 = a7;
  rv->a8 = a8;
  rv->a9 = a9;
  rv->a10 = a10;
  rv->a11 = a11;
  rv->a12 = a12;
  rv->a13 = a13;
  rv->a14 = a14;
  rv->a15 = a15;
  rv->a16 = a16;
  rv->a17 = a17;
  rv->a18 = a18.Clone();
  rv->a19 = a19;
  rv->a20 = a20;
  rv->a21 = a21.Clone();
  rv->a22 = a22.Clone();
  rv->a23 = a23;
  rv->a24 = a24;
  rv->a25 = a25;
  rv->a26 = a26;
  rv->a27 = a27;
  rv->a28 = a28;
  rv->a29 = a29;
  rv->a30 = a30;
  rv->a31 = a31;
  return rv;
}


bool DefaultsTest::Equals(const DefaultsTest& other) const {
  if (!mojo::internal::ValueTraits<int8_t>::Equals(this->a0, other.a0))
    return false;
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->a1, other.a1))
    return false;
  if (!mojo::internal::ValueTraits<int16_t>::Equals(this->a2, other.a2))
    return false;
  if (!mojo::internal::ValueTraits<uint16_t>::Equals(this->a3, other.a3))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->a4, other.a4))
    return false;
  if (!mojo::internal::ValueTraits<uint32_t>::Equals(this->a5, other.a5))
    return false;
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->a6, other.a6))
    return false;
  if (!mojo::internal::ValueTraits<uint64_t>::Equals(this->a7, other.a7))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->a8, other.a8))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->a9, other.a9))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->a10, other.a10))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->a11, other.a11))
    return false;
  if (!mojo::internal::ValueTraits<bool>::Equals(this->a12, other.a12))
    return false;
  if (!mojo::internal::ValueTraits<float>::Equals(this->a13, other.a13))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->a14, other.a14))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->a15, other.a15))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->a16, other.a16))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->a17, other.a17))
    return false;
  if (!mojo::internal::ValueTraits<mojo::Array<uint8_t>>::Equals(this->a18, other.a18))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->a19, other.a19))
    return false;
  if (!mojo::internal::ValueTraits<Bar::Type>::Equals(this->a20, other.a20))
    return false;
  if (!mojo::internal::ValueTraits<imported::PointPtr>::Equals(this->a21, other.a21))
    return false;
  if (!mojo::internal::ValueTraits<imported::ThingPtr>::Equals(this->a22, other.a22))
    return false;
  if (!mojo::internal::ValueTraits<uint64_t>::Equals(this->a23, other.a23))
    return false;
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->a24, other.a24))
    return false;
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->a25, other.a25))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->a26, other.a26))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->a27, other.a27))
    return false;
  if (!mojo::internal::ValueTraits<double>::Equals(this->a28, other.a28))
    return false;
  if (!mojo::internal::ValueTraits<float>::Equals(this->a29, other.a29))
    return false;
  if (!mojo::internal::ValueTraits<float>::Equals(this->a30, other.a30))
    return false;
  if (!mojo::internal::ValueTraits<float>::Equals(this->a31, other.a31))
    return false;
  return true;
}


// static
StructWithHoleV1Ptr StructWithHoleV1::New() {
  StructWithHoleV1Ptr rv;
  mojo::internal::StructHelper<StructWithHoleV1>::Initialize(&rv);
  return rv;
}

StructWithHoleV1::StructWithHoleV1()
    : v1(1),
      v2(2) {
}

StructWithHoleV1::~StructWithHoleV1() {
}


StructWithHoleV1Ptr StructWithHoleV1::Clone() const {
  StructWithHoleV1Ptr rv(New());
  rv->v1 = v1;
  rv->v2 = v2;
  return rv;
}


bool StructWithHoleV1::Equals(const StructWithHoleV1& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->v1, other.v1))
    return false;
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->v2, other.v2))
    return false;
  return true;
}


// static
StructWithHoleV2Ptr StructWithHoleV2::New() {
  StructWithHoleV2Ptr rv;
  mojo::internal::StructHelper<StructWithHoleV2>::Initialize(&rv);
  return rv;
}

StructWithHoleV2::StructWithHoleV2()
    : v1(1),
      v2(2),
      v3(3) {
}

StructWithHoleV2::~StructWithHoleV2() {
}


StructWithHoleV2Ptr StructWithHoleV2::Clone() const {
  StructWithHoleV2Ptr rv(New());
  rv->v1 = v1;
  rv->v2 = v2;
  rv->v3 = v3;
  return rv;
}


bool StructWithHoleV2::Equals(const StructWithHoleV2& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->v1, other.v1))
    return false;
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->v2, other.v2))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->v3, other.v3))
    return false;
  return true;
}


// static
NonNullableMapStructPtr NonNullableMapStruct::New() {
  NonNullableMapStructPtr rv;
  mojo::internal::StructHelper<NonNullableMapStruct>::Initialize(&rv);
  return rv;
}

NonNullableMapStruct::NonNullableMapStruct()
    : map_field() {
}

NonNullableMapStruct::~NonNullableMapStruct() {
}


NonNullableMapStructPtr NonNullableMapStruct::Clone() const {
  NonNullableMapStructPtr rv(New());
  rv->map_field = map_field.Clone();
  return rv;
}


bool NonNullableMapStruct::Equals(const NonNullableMapStruct& other) const {
  if (!mojo::internal::ValueTraits<mojo::Map<mojo::String, mojo::String>>::Equals(this->map_field, other.map_field))
    return false;
  return true;
}


// --- Union builder definitions ---

// --- Struct Serialization Helpers ---

size_t Bar::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Bar::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Bar_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Bar::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Bar_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Bar::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Bar_Data* input =
      static_cast<internal::Bar_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Bar& input) {
  size_t size = sizeof(internal::Bar_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Bar* input,
    mojo::internal::Buffer* buf,
    internal::Bar_Data** output) {
  if (input) {
    internal::Bar_Data* result =
        internal::Bar_Data::New(buf);
    result->alpha = input->alpha;
    result->beta = input->beta;
    result->gamma = input->gamma;
    result->type =
      static_cast<int32_t>(input->type);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Bar_Data* input,
                  Bar* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->alpha = input->alpha;
      result->beta = input->beta;
      result->gamma = input->gamma;
      result->type = static_cast<Bar::Type>(input->type);
    } while (false);
  }
}


size_t Foo::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Foo::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Foo_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Foo::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Foo_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Foo::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Foo_Data* input =
      static_cast<internal::Foo_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Foo& input) {
  size_t size = sizeof(internal::Foo_Data);
  size += input.bar.is_null()
              ? 0
              : GetSerializedSize_(*input.bar);
  size += GetSerializedSize_(input.data);
  size += GetSerializedSize_(input.extra_bars);
  size += GetSerializedSize_(input.name);
  size += GetSerializedSize_(input.input_streams);
  size += GetSerializedSize_(input.output_streams);
  size += GetSerializedSize_(input.array_of_array_of_bools);
  size += GetSerializedSize_(input.multi_array_of_strings);
  size += GetSerializedSize_(input.array_of_bools);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Foo* input,
    mojo::internal::Buffer* buf,
    internal::Foo_Data** output) {
  if (input) {
    internal::Foo_Data* result =
        internal::Foo_Data::New(buf);
    result->x = input->x;
    result->y = input->y;
    result->a = input->a;
    result->b = input->b;
    result->c = input->c;
    {auto retval =Serialize_(input->bar.get(),
                 buf,
                 &result->bar.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams data_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->data, buf, &result->data.ptr,
                            &data_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams extra_bars_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->extra_bars, buf, &result->extra_bars.ptr,
                            &extra_bars_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    SerializeString_(input->name, buf, &result->name.ptr);
    if (!result->name.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null name in Foo struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->source = input->source.release();
    {
      const mojo::internal::ArrayValidateParams input_streams_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->input_streams, buf, &result->input_streams.ptr,
                            &input_streams_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams output_streams_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->output_streams, buf, &result->output_streams.ptr,
                            &output_streams_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams array_of_array_of_bools_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeArray_(&input->array_of_array_of_bools, buf, &result->array_of_array_of_bools.ptr,
                            &array_of_array_of_bools_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams multi_array_of_strings_validate_params(
        0, false, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr))));auto retval =mojo::SerializeArray_(&input->multi_array_of_strings, buf, &result->multi_array_of_strings.ptr,
                            &multi_array_of_strings_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    {
      const mojo::internal::ArrayValidateParams array_of_bools_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->array_of_bools, buf, &result->array_of_bools.ptr,
                            &array_of_bools_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Foo_Data* input,
                  Foo* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->x = input->x;
      result->y = input->y;
      result->a = input->a;
      result->b = input->b;
      result->c = input->c;
      if (input->bar.ptr) {
        result->bar = Bar::New();
        Deserialize_(input->bar.ptr, result->bar.get());
      }
      Deserialize_(input->data.ptr, &result->data);
      Deserialize_(input->extra_bars.ptr, &result->extra_bars);
      Deserialize_(input->name.ptr, &result->name);
      result->source.reset(mojo::internal::FetchAndReset(&input->source));
      Deserialize_(input->input_streams.ptr, &result->input_streams);
      Deserialize_(input->output_streams.ptr, &result->output_streams);
      Deserialize_(input->array_of_array_of_bools.ptr, &result->array_of_array_of_bools);
      Deserialize_(input->multi_array_of_strings.ptr, &result->multi_array_of_strings);
      Deserialize_(input->array_of_bools.ptr, &result->array_of_bools);
    } while (false);
  }
}


size_t DefaultsTest::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool DefaultsTest::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::DefaultsTest_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool DefaultsTest::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::DefaultsTest_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void DefaultsTest::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::DefaultsTest_Data* input =
      static_cast<internal::DefaultsTest_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const DefaultsTest& input) {
  size_t size = sizeof(internal::DefaultsTest_Data);
  size += GetSerializedSize_(input.a18);
  size += GetSerializedSize_(input.a19);
  size += input.a21.is_null()
              ? 0
              : GetSerializedSize_(*input.a21);
  size += input.a22.is_null()
              ? 0
              : GetSerializedSize_(*input.a22);
  return size;
}

mojo::internal::ValidationError Serialize_(
    DefaultsTest* input,
    mojo::internal::Buffer* buf,
    internal::DefaultsTest_Data** output) {
  if (input) {
    internal::DefaultsTest_Data* result =
        internal::DefaultsTest_Data::New(buf);
    result->a0 = input->a0;
    result->a1 = input->a1;
    result->a2 = input->a2;
    result->a3 = input->a3;
    result->a4 = input->a4;
    result->a5 = input->a5;
    result->a6 = input->a6;
    result->a7 = input->a7;
    result->a8 = input->a8;
    result->a9 = input->a9;
    result->a10 = input->a10;
    result->a11 = input->a11;
    result->a12 = input->a12;
    result->a13 = input->a13;
    result->a14 = input->a14;
    result->a15 = input->a15;
    result->a16 = input->a16;
    result->a17 = input->a17;
    {
      const mojo::internal::ArrayValidateParams a18_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->a18, buf, &result->a18.ptr,
                            &a18_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->a18.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a18 in DefaultsTest struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    SerializeString_(input->a19, buf, &result->a19.ptr);
    if (!result->a19.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a19 in DefaultsTest struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->a20 =
      static_cast<int32_t>(input->a20);
    {auto retval =Serialize_(input->a21.get(),
                 buf,
                 &result->a21.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->a21.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a21 in DefaultsTest struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    {auto retval =Serialize_(input->a22.get(),
                 buf,
                 &result->a22.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->a22.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null a22 in DefaultsTest struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->a23 = input->a23;
    result->a24 = input->a24;
    result->a25 = input->a25;
    result->a26 = input->a26;
    result->a27 = input->a27;
    result->a28 = input->a28;
    result->a29 = input->a29;
    result->a30 = input->a30;
    result->a31 = input->a31;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::DefaultsTest_Data* input,
                  DefaultsTest* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->a0 = input->a0;
      result->a1 = input->a1;
      result->a2 = input->a2;
      result->a3 = input->a3;
      result->a4 = input->a4;
      result->a5 = input->a5;
      result->a6 = input->a6;
      result->a7 = input->a7;
      result->a8 = input->a8;
      result->a9 = input->a9;
      result->a10 = input->a10;
      result->a11 = input->a11;
      result->a12 = input->a12;
      result->a13 = input->a13;
      result->a14 = input->a14;
      result->a15 = input->a15;
      result->a16 = input->a16;
      result->a17 = input->a17;
      Deserialize_(input->a18.ptr, &result->a18);
      Deserialize_(input->a19.ptr, &result->a19);
      result->a20 = static_cast<Bar::Type>(input->a20);
      if (input->a21.ptr) {
        result->a21 = imported::Point::New();
        Deserialize_(input->a21.ptr, result->a21.get());
      }
      if (input->a22.ptr) {
        result->a22 = imported::Thing::New();
        Deserialize_(input->a22.ptr, result->a22.get());
      }
      result->a23 = input->a23;
      result->a24 = input->a24;
      result->a25 = input->a25;
      result->a26 = input->a26;
      result->a27 = input->a27;
      result->a28 = input->a28;
      result->a29 = input->a29;
      result->a30 = input->a30;
      result->a31 = input->a31;
    } while (false);
  }
}


size_t StructWithHoleV1::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructWithHoleV1::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructWithHoleV1_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructWithHoleV1::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructWithHoleV1_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructWithHoleV1::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructWithHoleV1_Data* input =
      static_cast<internal::StructWithHoleV1_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructWithHoleV1& input) {
  size_t size = sizeof(internal::StructWithHoleV1_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructWithHoleV1* input,
    mojo::internal::Buffer* buf,
    internal::StructWithHoleV1_Data** output) {
  if (input) {
    internal::StructWithHoleV1_Data* result =
        internal::StructWithHoleV1_Data::New(buf);
    result->v1 = input->v1;
    result->v2 = input->v2;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructWithHoleV1_Data* input,
                  StructWithHoleV1* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->v1 = input->v1;
      result->v2 = input->v2;
    } while (false);
  }
}


size_t StructWithHoleV2::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructWithHoleV2::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructWithHoleV2_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructWithHoleV2::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructWithHoleV2_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructWithHoleV2::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructWithHoleV2_Data* input =
      static_cast<internal::StructWithHoleV2_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructWithHoleV2& input) {
  size_t size = sizeof(internal::StructWithHoleV2_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructWithHoleV2* input,
    mojo::internal::Buffer* buf,
    internal::StructWithHoleV2_Data** output) {
  if (input) {
    internal::StructWithHoleV2_Data* result =
        internal::StructWithHoleV2_Data::New(buf);
    result->v1 = input->v1;
    result->v2 = input->v2;
    result->v3 = input->v3;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructWithHoleV2_Data* input,
                  StructWithHoleV2* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->v1 = input->v1;
      result->v2 = input->v2;
      result->v3 = input->v3;
    } while (false);
  }
}


size_t NonNullableMapStruct::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool NonNullableMapStruct::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::NonNullableMapStruct_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool NonNullableMapStruct::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::NonNullableMapStruct_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void NonNullableMapStruct::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::NonNullableMapStruct_Data* input =
      static_cast<internal::NonNullableMapStruct_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const NonNullableMapStruct& input) {
  size_t size = sizeof(internal::NonNullableMapStruct_Data);
  size += GetSerializedSize_(input.map_field);
  return size;
}

mojo::internal::ValidationError Serialize_(
    NonNullableMapStruct* input,
    mojo::internal::Buffer* buf,
    internal::NonNullableMapStruct_Data** output) {
  if (input) {
    internal::NonNullableMapStruct_Data* result =
        internal::NonNullableMapStruct_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams map_field_validate_params(
          0, false, new mojo::internal::ArrayValidateParams(0, false, nullptr));auto retval =mojo::SerializeMap_(
          &input->map_field, buf, &result->map_field.ptr,
          &map_field_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->map_field.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null map_field in NonNullableMapStruct struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::NonNullableMapStruct_Data* input,
                  NonNullableMapStruct* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->map_field.ptr, &result->map_field);
    } while (false);
  }
}


// --- Union Serialization Helpers ---

// --- Structs for interface method parameters ---


// static
Service_Frobinate_ParamsPtr Service_Frobinate_Params::New() {
  Service_Frobinate_ParamsPtr rv;
  mojo::internal::StructHelper<Service_Frobinate_Params>::Initialize(&rv);
  return rv;
}

Service_Frobinate_Params::Service_Frobinate_Params()
    : foo(),
      baz(),
      port() {
}

Service_Frobinate_Params::~Service_Frobinate_Params() {
}



bool Service_Frobinate_Params::Equals(const Service_Frobinate_Params& other) const {
  if (!mojo::internal::ValueTraits<FooPtr>::Equals(this->foo, other.foo))
    return false;
  if (!mojo::internal::ValueTraits<Service::BazOptions>::Equals(this->baz, other.baz))
    return false;
  if (!mojo::internal::ValueTraits<mojo::InterfaceHandle<Port>>::Equals(this->port, other.port))
    return false;
  return true;
}


size_t Service_Frobinate_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Service_Frobinate_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Service_Frobinate_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Service_Frobinate_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Service_Frobinate_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Service_Frobinate_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Service_Frobinate_Params_Data* input =
      static_cast<internal::Service_Frobinate_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Service_Frobinate_Params& input) {
  size_t size = sizeof(internal::Service_Frobinate_Params_Data);
  size += input.foo.is_null()
              ? 0
              : GetSerializedSize_(*input.foo);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Service_Frobinate_Params* input,
    mojo::internal::Buffer* buf,
    internal::Service_Frobinate_Params_Data** output) {
  if (input) {
    internal::Service_Frobinate_Params_Data* result =
        internal::Service_Frobinate_Params_Data::New(buf);
    {auto retval =Serialize_(input->foo.get(),
                 buf,
                 &result->foo.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    result->baz =
      static_cast<int32_t>(input->baz);
    mojo::internal::InterfaceHandleToData(input->port.Pass(),
                                          &result->port);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Service_Frobinate_Params_Data* input,
                  Service_Frobinate_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->foo.ptr) {
        result->foo = Foo::New();
        Deserialize_(input->foo.ptr, result->foo.get());
      }
      result->baz = static_cast<Service::BazOptions>(input->baz);
      mojo::internal::InterfaceDataToHandle(&input->port, &result->port);
    } while (false);
  }
}


// static
Service_Frobinate_ResponseParamsPtr Service_Frobinate_ResponseParams::New() {
  Service_Frobinate_ResponseParamsPtr rv;
  mojo::internal::StructHelper<Service_Frobinate_ResponseParams>::Initialize(&rv);
  return rv;
}

Service_Frobinate_ResponseParams::Service_Frobinate_ResponseParams()
    : result() {
}

Service_Frobinate_ResponseParams::~Service_Frobinate_ResponseParams() {
}


Service_Frobinate_ResponseParamsPtr Service_Frobinate_ResponseParams::Clone() const {
  Service_Frobinate_ResponseParamsPtr rv(New());
  rv->result = result;
  return rv;
}


bool Service_Frobinate_ResponseParams::Equals(const Service_Frobinate_ResponseParams& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->result, other.result))
    return false;
  return true;
}


size_t Service_Frobinate_ResponseParams::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Service_Frobinate_ResponseParams::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Service_Frobinate_ResponseParams_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Service_Frobinate_ResponseParams::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Service_Frobinate_ResponseParams_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Service_Frobinate_ResponseParams::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Service_Frobinate_ResponseParams_Data* input =
      static_cast<internal::Service_Frobinate_ResponseParams_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Service_Frobinate_ResponseParams& input) {
  size_t size = sizeof(internal::Service_Frobinate_ResponseParams_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Service_Frobinate_ResponseParams* input,
    mojo::internal::Buffer* buf,
    internal::Service_Frobinate_ResponseParams_Data** output) {
  if (input) {
    internal::Service_Frobinate_ResponseParams_Data* result =
        internal::Service_Frobinate_ResponseParams_Data::New(buf);
    result->result = input->result;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Service_Frobinate_ResponseParams_Data* input,
                  Service_Frobinate_ResponseParams* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->result = input->result;
    } while (false);
  }
}



// static
Service_GetPort_ParamsPtr Service_GetPort_Params::New() {
  Service_GetPort_ParamsPtr rv;
  mojo::internal::StructHelper<Service_GetPort_Params>::Initialize(&rv);
  return rv;
}

Service_GetPort_Params::Service_GetPort_Params()
    : port() {
}

Service_GetPort_Params::~Service_GetPort_Params() {
}



bool Service_GetPort_Params::Equals(const Service_GetPort_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::InterfaceRequest<Port>>::Equals(this->port, other.port))
    return false;
  return true;
}


size_t Service_GetPort_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Service_GetPort_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Service_GetPort_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Service_GetPort_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Service_GetPort_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Service_GetPort_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Service_GetPort_Params_Data* input =
      static_cast<internal::Service_GetPort_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Service_GetPort_Params& input) {
  size_t size = sizeof(internal::Service_GetPort_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Service_GetPort_Params* input,
    mojo::internal::Buffer* buf,
    internal::Service_GetPort_Params_Data** output) {
  if (input) {
    internal::Service_GetPort_Params_Data* result =
        internal::Service_GetPort_Params_Data::New(buf);
    result->port = input->port.PassMessagePipe().release();
    if (!result->port.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid port in Service_GetPort_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Service_GetPort_Params_Data* input,
                  Service_GetPort_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->port.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&input->port)));
    } while (false);
  }
}



// static
Port_PostMessage_ParamsPtr Port_PostMessage_Params::New() {
  Port_PostMessage_ParamsPtr rv;
  mojo::internal::StructHelper<Port_PostMessage_Params>::Initialize(&rv);
  return rv;
}

Port_PostMessage_Params::Port_PostMessage_Params()
    : message_text(),
      port() {
}

Port_PostMessage_Params::~Port_PostMessage_Params() {
}



bool Port_PostMessage_Params::Equals(const Port_PostMessage_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->message_text, other.message_text))
    return false;
  if (!mojo::internal::ValueTraits<mojo::InterfaceHandle<Port>>::Equals(this->port, other.port))
    return false;
  return true;
}


size_t Port_PostMessage_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Port_PostMessage_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Port_PostMessage_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Port_PostMessage_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Port_PostMessage_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Port_PostMessage_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Port_PostMessage_Params_Data* input =
      static_cast<internal::Port_PostMessage_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Port_PostMessage_Params& input) {
  size_t size = sizeof(internal::Port_PostMessage_Params_Data);
  size += GetSerializedSize_(input.message_text);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Port_PostMessage_Params* input,
    mojo::internal::Buffer* buf,
    internal::Port_PostMessage_Params_Data** output) {
  if (input) {
    internal::Port_PostMessage_Params_Data* result =
        internal::Port_PostMessage_Params_Data::New(buf);
    SerializeString_(input->message_text, buf, &result->message_text.ptr);
    if (!result->message_text.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null message_text in Port_PostMessage_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    mojo::internal::InterfaceHandleToData(input->port.Pass(),
                                          &result->port);
    if (!result->port.handle.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid port in Port_PostMessage_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Port_PostMessage_Params_Data* input,
                  Port_PostMessage_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->message_text.ptr, &result->message_text);
      mojo::internal::InterfaceDataToHandle(&input->port, &result->port);
    } while (false);
  }
}

}  // namespace sample
