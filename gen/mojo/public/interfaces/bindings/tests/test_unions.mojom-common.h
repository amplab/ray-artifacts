// NOTE: This file was generated by the Mojo bindings generator.
#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_COMMON_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_COMMON_H_

#include <stdint.h>
#include <iosfwd>

#include "mojo/public/cpp/bindings/array.h"
#include "mojo/public/cpp/bindings/callback.h"
#include "mojo/public/cpp/bindings/interface_handle.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/map.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/bindings/string.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/system/buffer.h"
#include "mojo/public/cpp/system/data_pipe.h"
#include "mojo/public/cpp/system/handle.h"
#include "mojo/public/cpp/system/message_pipe.h"
#include "mojo/public/interfaces/bindings/tests/test_unions.mojom-internal.h"
#include "mojo/public/interfaces/bindings/tests/test_included_unions.mojom-common.h"
namespace mojo {
namespace test {

// --- Interface Forward Declarations ---
class SmallCache;
class SmallCacheRequestValidator;
class SmallCacheResponseValidator;
class SmallCache_Synchronous;
class UnionInterface;
class UnionInterfaceRequestValidator;
class UnionInterfaceResponseValidator;
class UnionInterface_Synchronous;

// --- Struct Forward Declarations ---
class StructOfUnions;

using StructOfUnionsPtr = mojo::StructPtr<StructOfUnions>;


class WrapperStruct;

using WrapperStructPtr = mojo::StructPtr<WrapperStruct>;


class DummyStruct;

using DummyStructPtr = mojo::InlinedStructPtr<DummyStruct>;


class SmallStruct;

using SmallStructPtr = mojo::StructPtr<SmallStruct>;


class SmallStructNonNullableUnion;

using SmallStructNonNullableUnionPtr = mojo::StructPtr<SmallStructNonNullableUnion>;


class StructNullObjectUnion;

using StructNullObjectUnionPtr = mojo::StructPtr<StructNullObjectUnion>;


class SmallObjStruct;

using SmallObjStructPtr = mojo::StructPtr<SmallObjStruct>;


class TryNonNullStruct;

using TryNonNullStructPtr = mojo::StructPtr<TryNonNullStruct>;


class IncludingStruct;

using IncludingStructPtr = mojo::StructPtr<IncludingStruct>;



// --- Union Forward Declarations ---
class PodUnion;
typedef mojo::InlinedStructPtr<PodUnion> PodUnionPtr;
class UnionOfUnions;
typedef mojo::StructPtr<UnionOfUnions> UnionOfUnionsPtr;
class ObjectUnion;
typedef mojo::StructPtr<ObjectUnion> ObjectUnionPtr;
class HandleUnion;
typedef mojo::StructPtr<HandleUnion> HandleUnionPtr;
class ObjectOnlyUnion;
typedef mojo::StructPtr<ObjectOnlyUnion> ObjectOnlyUnionPtr;
class OldUnion;
typedef mojo::InlinedStructPtr<OldUnion> OldUnionPtr;
class NewUnion;
typedef mojo::InlinedStructPtr<NewUnion> NewUnionPtr;

// --- Enums Declarations ---
  
enum class AnEnum : int32_t {
  FIRST,
  SECOND,
};

bool AnEnum_IsValidValue(AnEnum value);
  
std::ostream& operator<<(std::ostream& stream, const AnEnum& val);

// --- Constants ---

// --- Interface declarations ---
namespace internal {
class SmallCache_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = SmallCacheRequestValidator;
  using ResponseValidator_ = SmallCacheResponseValidator;
  using Synchronous_ = SmallCache_Synchronous;
  enum class MessageOrdinals : uint32_t {
    SetIntValue = 0,
    GetIntValue = 1,
  };


  virtual ~SmallCache_Base() {}
};

}  // namespace internal

// Async interface declaration

class SmallCacheProxy;
class SmallCacheStub;
class SmallCache_Synchronous;

class SmallCacheRequestValidator;
class SmallCacheResponseValidator;

class SmallCache : public internal::SmallCache_Base {
 public:
  virtual ~SmallCache() override {}

  using Proxy_ = SmallCacheProxy;
  using Stub_ = SmallCacheStub;
  virtual void SetIntValue(int64_t int_value) = 0;
  using GetIntValueCallback = mojo::Callback<void(int64_t)>;
  virtual void GetIntValue(const GetIntValueCallback& callback) = 0;
};

namespace internal {
class UnionInterface_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = UnionInterfaceRequestValidator;
  using ResponseValidator_ = UnionInterfaceResponseValidator;
  using Synchronous_ = UnionInterface_Synchronous;
  enum class MessageOrdinals : uint32_t {
    Echo = 0,
  };


  virtual ~UnionInterface_Base() {}
};

}  // namespace internal

// Async interface declaration

class UnionInterfaceProxy;
class UnionInterfaceStub;
class UnionInterface_Synchronous;

class UnionInterfaceRequestValidator;
class UnionInterfaceResponseValidator;

class UnionInterface : public internal::UnionInterface_Base {
 public:
  virtual ~UnionInterface() override {}

  using Proxy_ = UnionInterfaceProxy;
  using Stub_ = UnionInterfaceStub;
  using EchoCallback = mojo::Callback<void(PodUnionPtr)>;
  virtual void Echo(PodUnionPtr in_val, const EchoCallback& callback) = 0;
};

}  // namespace test
}  // namespace mojo

// --- Internal Template Specializations ---

namespace mojo {
namespace internal {
template <>
struct WrapperTraits<mojo::test::StructOfUnionsPtr, true, false> {
  using DataType = mojo::test::internal::StructOfUnions_Data*;
};
template <>
struct WrapperTraits<mojo::test::WrapperStructPtr, true, false> {
  using DataType = mojo::test::internal::WrapperStruct_Data*;
};
template <>
struct WrapperTraits<mojo::test::DummyStructPtr, true, false> {
  using DataType = mojo::test::internal::DummyStruct_Data*;
};
template <>
struct WrapperTraits<mojo::test::SmallStructPtr, true, false> {
  using DataType = mojo::test::internal::SmallStruct_Data*;
};
template <>
struct WrapperTraits<mojo::test::SmallStructNonNullableUnionPtr, true, false> {
  using DataType = mojo::test::internal::SmallStructNonNullableUnion_Data*;
};
template <>
struct WrapperTraits<mojo::test::StructNullObjectUnionPtr, true, false> {
  using DataType = mojo::test::internal::StructNullObjectUnion_Data*;
};
template <>
struct WrapperTraits<mojo::test::SmallObjStructPtr, true, false> {
  using DataType = mojo::test::internal::SmallObjStruct_Data*;
};
template <>
struct WrapperTraits<mojo::test::TryNonNullStructPtr, true, false> {
  using DataType = mojo::test::internal::TryNonNullStruct_Data*;
};
template <>
struct WrapperTraits<mojo::test::IncludingStructPtr, true, false> {
  using DataType = mojo::test::internal::IncludingStruct_Data*;
};

}  // internal
}  // mojo
namespace mojo {
namespace test {

// --- Interface Request Validators ---
class SmallCacheRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class UnionInterfaceRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface Response Validators ---
class SmallCacheResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class UnionInterfaceResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface enum operators ---

// --- Unions ---
// Unions must be declared first because they can be members of structs.
class PodUnion {
 public:
  using Data_ = internal::PodUnion_Data;
  using Tag = Data_::PodUnion_Tag;

  static PodUnionPtr New();

  template <typename U>
  static PodUnionPtr From(const U& u) {
    return mojo::TypeConverter<PodUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PodUnion>::Convert(*this);
  }

  PodUnion();
  ~PodUnion();


  PodUnionPtr Clone() const;
  bool Equals(const PodUnion& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_f_int8() const;
  int8_t get_f_int8() const;
  void set_f_int8(int8_t f_int8);
  bool is_f_int8_other() const;
  int8_t get_f_int8_other() const;
  void set_f_int8_other(int8_t f_int8_other);
  bool is_f_uint8() const;
  uint8_t get_f_uint8() const;
  void set_f_uint8(uint8_t f_uint8);
  bool is_f_int16() const;
  int16_t get_f_int16() const;
  void set_f_int16(int16_t f_int16);
  bool is_f_uint16() const;
  uint16_t get_f_uint16() const;
  void set_f_uint16(uint16_t f_uint16);
  bool is_f_int32() const;
  int32_t get_f_int32() const;
  void set_f_int32(int32_t f_int32);
  bool is_f_uint32() const;
  uint32_t get_f_uint32() const;
  void set_f_uint32(uint32_t f_uint32);
  bool is_f_int64() const;
  int64_t get_f_int64() const;
  void set_f_int64(int64_t f_int64);
  bool is_f_uint64() const;
  uint64_t get_f_uint64() const;
  void set_f_uint64(uint64_t f_uint64);
  bool is_f_float() const;
  float get_f_float() const;
  void set_f_float(float f_float);
  bool is_f_double() const;
  double get_f_double() const;
  void set_f_double(double f_double);
  bool is_f_bool() const;
  bool get_f_bool() const;
  void set_f_bool(bool f_bool);
  bool is_f_enum() const;
  AnEnum get_f_enum() const;
  void set_f_enum(AnEnum f_enum);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<PodUnion>;
  union Union_ {
    Union_() {}
    ~Union_() {}

int8_t f_int8;

int8_t f_int8_other;

uint8_t f_uint8;

int16_t f_int16;

uint16_t f_uint16;

int32_t f_int32;

uint32_t f_uint32;

int64_t f_int64;

uint64_t f_uint64;

float f_float;

double f_double;

bool f_bool;

AnEnum f_enum;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};

class UnionOfUnions {
 public:
  using Data_ = internal::UnionOfUnions_Data;
  using Tag = Data_::UnionOfUnions_Tag;

  static UnionOfUnionsPtr New();

  template <typename U>
  static UnionOfUnionsPtr From(const U& u) {
    return mojo::TypeConverter<UnionOfUnionsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UnionOfUnions>::Convert(*this);
  }

  UnionOfUnions();
  ~UnionOfUnions();


  bool Equals(const UnionOfUnions& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_u() const;
  ObjectUnionPtr& get_u() const;
  void set_u(ObjectUnionPtr u);
  bool is_a_ou() const;
  mojo::Array<ObjectUnionPtr>& get_a_ou() const;
  void set_a_ou(mojo::Array<ObjectUnionPtr> a_ou);
  bool is_a_hu() const;
  mojo::Array<HandleUnionPtr>& get_a_hu() const;
  void set_a_hu(mojo::Array<HandleUnionPtr> a_hu);
  bool is_m_ou() const;
  mojo::Map<int64_t, ObjectUnionPtr>& get_m_ou() const;
  void set_m_ou(mojo::Map<int64_t, ObjectUnionPtr> m_ou);
  bool is_m_hu() const;
  mojo::Map<int64_t, HandleUnionPtr>& get_m_hu() const;
  void set_m_hu(mojo::Map<int64_t, HandleUnionPtr> m_hu);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<UnionOfUnions>;
  union Union_ {
    Union_() {}
    ~Union_() {}

ObjectUnionPtr* u;

mojo::Array<ObjectUnionPtr>* a_ou;

mojo::Array<HandleUnionPtr>* a_hu;

mojo::Map<int64_t, ObjectUnionPtr>* m_ou;

mojo::Map<int64_t, HandleUnionPtr>* m_hu;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};

class ObjectUnion {
 public:
  using Data_ = internal::ObjectUnion_Data;
  using Tag = Data_::ObjectUnion_Tag;

  static ObjectUnionPtr New();

  template <typename U>
  static ObjectUnionPtr From(const U& u) {
    return mojo::TypeConverter<ObjectUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ObjectUnion>::Convert(*this);
  }

  ObjectUnion();
  ~ObjectUnion();


  ObjectUnionPtr Clone() const;
  bool Equals(const ObjectUnion& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_f_int8() const;
  int8_t get_f_int8() const;
  void set_f_int8(int8_t f_int8);
  bool is_f_string() const;
  mojo::String get_f_string() const;
  void set_f_string(const mojo::String& f_string);
  bool is_f_dummy() const;
  DummyStructPtr& get_f_dummy() const;
  void set_f_dummy(DummyStructPtr f_dummy);
  bool is_f_nullable() const;
  DummyStructPtr& get_f_nullable() const;
  void set_f_nullable(DummyStructPtr f_nullable);
  bool is_f_array_int8() const;
  mojo::Array<int8_t>& get_f_array_int8() const;
  void set_f_array_int8(mojo::Array<int8_t> f_array_int8);
  bool is_f_map_int8() const;
  mojo::Map<mojo::String, int8_t>& get_f_map_int8() const;
  void set_f_map_int8(mojo::Map<mojo::String, int8_t> f_map_int8);
  bool is_f_pod_union() const;
  PodUnionPtr& get_f_pod_union() const;
  void set_f_pod_union(PodUnionPtr f_pod_union);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<ObjectUnion>;
  union Union_ {
    Union_() {}
    ~Union_() {}

int8_t f_int8;

mojo::String* f_string;

DummyStructPtr* f_dummy;

DummyStructPtr* f_nullable;

mojo::Array<int8_t>* f_array_int8;

mojo::Map<mojo::String, int8_t>* f_map_int8;

PodUnionPtr* f_pod_union;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};

class HandleUnion {
 public:
  using Data_ = internal::HandleUnion_Data;
  using Tag = Data_::HandleUnion_Tag;

  static HandleUnionPtr New();

  template <typename U>
  static HandleUnionPtr From(const U& u) {
    return mojo::TypeConverter<HandleUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HandleUnion>::Convert(*this);
  }

  HandleUnion();
  ~HandleUnion();


  bool Equals(const HandleUnion& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_f_handle() const;
  mojo::ScopedHandle& get_f_handle() const;
  void set_f_handle(mojo::ScopedHandle f_handle);
  bool is_f_message_pipe() const;
  mojo::ScopedMessagePipeHandle& get_f_message_pipe() const;
  void set_f_message_pipe(mojo::ScopedMessagePipeHandle f_message_pipe);
  bool is_f_data_pipe_consumer() const;
  mojo::ScopedDataPipeConsumerHandle& get_f_data_pipe_consumer() const;
  void set_f_data_pipe_consumer(mojo::ScopedDataPipeConsumerHandle f_data_pipe_consumer);
  bool is_f_data_pipe_producer() const;
  mojo::ScopedDataPipeProducerHandle& get_f_data_pipe_producer() const;
  void set_f_data_pipe_producer(mojo::ScopedDataPipeProducerHandle f_data_pipe_producer);
  bool is_f_shared_buffer() const;
  mojo::ScopedSharedBufferHandle& get_f_shared_buffer() const;
  void set_f_shared_buffer(mojo::ScopedSharedBufferHandle f_shared_buffer);
  bool is_f_small_cache() const;
  mojo::InterfaceHandle<SmallCache>& get_f_small_cache() const;
  void set_f_small_cache(mojo::InterfaceHandle<SmallCache> f_small_cache);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<HandleUnion>;
  union Union_ {
    Union_() {}
    ~Union_() {}

mojo::ScopedHandle* f_handle;

mojo::ScopedMessagePipeHandle* f_message_pipe;

mojo::ScopedDataPipeConsumerHandle* f_data_pipe_consumer;

mojo::ScopedDataPipeProducerHandle* f_data_pipe_producer;

mojo::ScopedSharedBufferHandle* f_shared_buffer;

mojo::InterfaceHandle<SmallCache>* f_small_cache;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};

class ObjectOnlyUnion {
 public:
  using Data_ = internal::ObjectOnlyUnion_Data;
  using Tag = Data_::ObjectOnlyUnion_Tag;

  static ObjectOnlyUnionPtr New();

  template <typename U>
  static ObjectOnlyUnionPtr From(const U& u) {
    return mojo::TypeConverter<ObjectOnlyUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ObjectOnlyUnion>::Convert(*this);
  }

  ObjectOnlyUnion();
  ~ObjectOnlyUnion();


  ObjectOnlyUnionPtr Clone() const;
  bool Equals(const ObjectOnlyUnion& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_dummy1() const;
  DummyStructPtr& get_dummy1() const;
  void set_dummy1(DummyStructPtr dummy1);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<ObjectOnlyUnion>;
  union Union_ {
    Union_() {}
    ~Union_() {}

DummyStructPtr* dummy1;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};

class OldUnion {
 public:
  using Data_ = internal::OldUnion_Data;
  using Tag = Data_::OldUnion_Tag;

  static OldUnionPtr New();

  template <typename U>
  static OldUnionPtr From(const U& u) {
    return mojo::TypeConverter<OldUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, OldUnion>::Convert(*this);
  }

  OldUnion();
  ~OldUnion();


  OldUnionPtr Clone() const;
  bool Equals(const OldUnion& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_f_int8() const;
  int8_t get_f_int8() const;
  void set_f_int8(int8_t f_int8);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<OldUnion>;
  union Union_ {
    Union_() {}
    ~Union_() {}

int8_t f_int8;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};

class NewUnion {
 public:
  using Data_ = internal::NewUnion_Data;
  using Tag = Data_::NewUnion_Tag;

  static NewUnionPtr New();

  template <typename U>
  static NewUnionPtr From(const U& u) {
    return mojo::TypeConverter<NewUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NewUnion>::Convert(*this);
  }

  NewUnion();
  ~NewUnion();


  NewUnionPtr Clone() const;
  bool Equals(const NewUnion& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_f_int8() const;
  int8_t get_f_int8() const;
  void set_f_int8(int8_t f_int8);
  bool is_f_int16() const;
  int16_t get_f_int16() const;
  void set_f_int16(int16_t f_int16);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<NewUnion>;
  union Union_ {
    Union_() {}
    ~Union_() {}

int8_t f_int8;

int16_t f_int16;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};


// --- Inlined structs ---
class DummyStruct {
 public:
  using Data_ = internal::DummyStruct_Data;

  static DummyStructPtr New();

  template <typename U>
  static DummyStructPtr From(const U& u) {
    return mojo::TypeConverter<DummyStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DummyStruct>::Convert(*this);
  }

  DummyStruct();
  ~DummyStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  DummyStructPtr Clone() const;
  bool Equals(const DummyStruct& other) const;

  int8_t f_int8;
};



// --- Non-inlined structs ---
class StructOfUnions {
 public:
  using Data_ = internal::StructOfUnions_Data;

  static StructOfUnionsPtr New();

  template <typename U>
  static StructOfUnionsPtr From(const U& u) {
    return mojo::TypeConverter<StructOfUnionsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructOfUnions>::Convert(*this);
  }

  StructOfUnions();
  ~StructOfUnions();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const StructOfUnions& other) const;

  ObjectUnionPtr u;
  mojo::Array<ObjectUnionPtr> a_ou;
  mojo::Array<HandleUnionPtr> a_hu;
  mojo::Map<int64_t, ObjectUnionPtr> m_ou;
  mojo::Map<int64_t, HandleUnionPtr> m_hu;
};


class WrapperStruct {
 public:
  using Data_ = internal::WrapperStruct_Data;

  static WrapperStructPtr New();

  template <typename U>
  static WrapperStructPtr From(const U& u) {
    return mojo::TypeConverter<WrapperStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WrapperStruct>::Convert(*this);
  }

  WrapperStruct();
  ~WrapperStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const WrapperStruct& other) const;

  ObjectUnionPtr object_union;
  PodUnionPtr pod_union;
  HandleUnionPtr handle_union;
};


class SmallStruct {
 public:
  using Data_ = internal::SmallStruct_Data;

  static SmallStructPtr New();

  template <typename U>
  static SmallStructPtr From(const U& u) {
    return mojo::TypeConverter<SmallStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SmallStruct>::Convert(*this);
  }

  SmallStruct();
  ~SmallStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  SmallStructPtr Clone() const;
  bool Equals(const SmallStruct& other) const;

  DummyStructPtr dummy_struct;
  PodUnionPtr pod_union;
  mojo::Array<PodUnionPtr> pod_union_array;
  mojo::Array<PodUnionPtr> nullable_pod_union_array;
  mojo::Array<DummyStructPtr> s_array;
  mojo::Map<mojo::String, PodUnionPtr> pod_union_map;
  mojo::Map<mojo::String, PodUnionPtr> nullable_pod_union_map;
};


class SmallStructNonNullableUnion {
 public:
  using Data_ = internal::SmallStructNonNullableUnion_Data;

  static SmallStructNonNullableUnionPtr New();

  template <typename U>
  static SmallStructNonNullableUnionPtr From(const U& u) {
    return mojo::TypeConverter<SmallStructNonNullableUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SmallStructNonNullableUnion>::Convert(*this);
  }

  SmallStructNonNullableUnion();
  ~SmallStructNonNullableUnion();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  SmallStructNonNullableUnionPtr Clone() const;
  bool Equals(const SmallStructNonNullableUnion& other) const;

  PodUnionPtr pod_union;
};


class StructNullObjectUnion {
 public:
  using Data_ = internal::StructNullObjectUnion_Data;

  static StructNullObjectUnionPtr New();

  template <typename U>
  static StructNullObjectUnionPtr From(const U& u) {
    return mojo::TypeConverter<StructNullObjectUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructNullObjectUnion>::Convert(*this);
  }

  StructNullObjectUnion();
  ~StructNullObjectUnion();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  StructNullObjectUnionPtr Clone() const;
  bool Equals(const StructNullObjectUnion& other) const;

  ObjectOnlyUnionPtr obj_union;
};


class SmallObjStruct {
 public:
  using Data_ = internal::SmallObjStruct_Data;

  static SmallObjStructPtr New();

  template <typename U>
  static SmallObjStructPtr From(const U& u) {
    return mojo::TypeConverter<SmallObjStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SmallObjStruct>::Convert(*this);
  }

  SmallObjStruct();
  ~SmallObjStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  SmallObjStructPtr Clone() const;
  bool Equals(const SmallObjStruct& other) const;

  ObjectUnionPtr obj_union;
  int8_t f_int8;
};


class TryNonNullStruct {
 public:
  using Data_ = internal::TryNonNullStruct_Data;

  static TryNonNullStructPtr New();

  template <typename U>
  static TryNonNullStructPtr From(const U& u) {
    return mojo::TypeConverter<TryNonNullStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, TryNonNullStruct>::Convert(*this);
  }

  TryNonNullStruct();
  ~TryNonNullStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  TryNonNullStructPtr Clone() const;
  bool Equals(const TryNonNullStruct& other) const;

  DummyStructPtr nullable;
  DummyStructPtr non_nullable;
};


class IncludingStruct {
 public:
  using Data_ = internal::IncludingStruct_Data;

  static IncludingStructPtr New();

  template <typename U>
  static IncludingStructPtr From(const U& u) {
    return mojo::TypeConverter<IncludingStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, IncludingStruct>::Convert(*this);
  }

  IncludingStruct();
  ~IncludingStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  IncludingStructPtr Clone() const;
  bool Equals(const IncludingStruct& other) const;

  mojo::test::IncludedUnionPtr a;
};



// --- Struct serialization helpers ---
size_t GetSerializedSize_(const StructOfUnions& input);
mojo::internal::ValidationError Serialize_(
    StructOfUnions* input,
    mojo::internal::Buffer* buffer,
    internal::StructOfUnions_Data** output);
void Deserialize_(internal::StructOfUnions_Data* input,
                  StructOfUnions* output);

size_t GetSerializedSize_(const WrapperStruct& input);
mojo::internal::ValidationError Serialize_(
    WrapperStruct* input,
    mojo::internal::Buffer* buffer,
    internal::WrapperStruct_Data** output);
void Deserialize_(internal::WrapperStruct_Data* input,
                  WrapperStruct* output);

size_t GetSerializedSize_(const DummyStruct& input);
mojo::internal::ValidationError Serialize_(
    DummyStruct* input,
    mojo::internal::Buffer* buffer,
    internal::DummyStruct_Data** output);
void Deserialize_(internal::DummyStruct_Data* input,
                  DummyStruct* output);

size_t GetSerializedSize_(const SmallStruct& input);
mojo::internal::ValidationError Serialize_(
    SmallStruct* input,
    mojo::internal::Buffer* buffer,
    internal::SmallStruct_Data** output);
void Deserialize_(internal::SmallStruct_Data* input,
                  SmallStruct* output);

size_t GetSerializedSize_(const SmallStructNonNullableUnion& input);
mojo::internal::ValidationError Serialize_(
    SmallStructNonNullableUnion* input,
    mojo::internal::Buffer* buffer,
    internal::SmallStructNonNullableUnion_Data** output);
void Deserialize_(internal::SmallStructNonNullableUnion_Data* input,
                  SmallStructNonNullableUnion* output);

size_t GetSerializedSize_(const StructNullObjectUnion& input);
mojo::internal::ValidationError Serialize_(
    StructNullObjectUnion* input,
    mojo::internal::Buffer* buffer,
    internal::StructNullObjectUnion_Data** output);
void Deserialize_(internal::StructNullObjectUnion_Data* input,
                  StructNullObjectUnion* output);

size_t GetSerializedSize_(const SmallObjStruct& input);
mojo::internal::ValidationError Serialize_(
    SmallObjStruct* input,
    mojo::internal::Buffer* buffer,
    internal::SmallObjStruct_Data** output);
void Deserialize_(internal::SmallObjStruct_Data* input,
                  SmallObjStruct* output);

size_t GetSerializedSize_(const TryNonNullStruct& input);
mojo::internal::ValidationError Serialize_(
    TryNonNullStruct* input,
    mojo::internal::Buffer* buffer,
    internal::TryNonNullStruct_Data** output);
void Deserialize_(internal::TryNonNullStruct_Data* input,
                  TryNonNullStruct* output);

size_t GetSerializedSize_(const IncludingStruct& input);
mojo::internal::ValidationError Serialize_(
    IncludingStruct* input,
    mojo::internal::Buffer* buffer,
    internal::IncludingStruct_Data** output);
void Deserialize_(internal::IncludingStruct_Data* input,
                  IncludingStruct* output);


// --- Union serialization helpers ---
size_t GetSerializedSize_(const PodUnionPtr& input);
mojo::internal::ValidationError SerializeUnion_(
    PodUnion* input,
    mojo::internal::Buffer* buffer,
    internal::PodUnion_Data** output);
void Deserialize_(internal::PodUnion_Data* input,
                  PodUnion* output);

size_t GetSerializedSize_(const UnionOfUnionsPtr& input);
mojo::internal::ValidationError SerializeUnion_(
    UnionOfUnions* input,
    mojo::internal::Buffer* buffer,
    internal::UnionOfUnions_Data** output);
void Deserialize_(internal::UnionOfUnions_Data* input,
                  UnionOfUnions* output);

size_t GetSerializedSize_(const ObjectUnionPtr& input);
mojo::internal::ValidationError SerializeUnion_(
    ObjectUnion* input,
    mojo::internal::Buffer* buffer,
    internal::ObjectUnion_Data** output);
void Deserialize_(internal::ObjectUnion_Data* input,
                  ObjectUnion* output);

size_t GetSerializedSize_(const HandleUnionPtr& input);
mojo::internal::ValidationError SerializeUnion_(
    HandleUnion* input,
    mojo::internal::Buffer* buffer,
    internal::HandleUnion_Data** output);
void Deserialize_(internal::HandleUnion_Data* input,
                  HandleUnion* output);

size_t GetSerializedSize_(const ObjectOnlyUnionPtr& input);
mojo::internal::ValidationError SerializeUnion_(
    ObjectOnlyUnion* input,
    mojo::internal::Buffer* buffer,
    internal::ObjectOnlyUnion_Data** output);
void Deserialize_(internal::ObjectOnlyUnion_Data* input,
                  ObjectOnlyUnion* output);

size_t GetSerializedSize_(const OldUnionPtr& input);
mojo::internal::ValidationError SerializeUnion_(
    OldUnion* input,
    mojo::internal::Buffer* buffer,
    internal::OldUnion_Data** output);
void Deserialize_(internal::OldUnion_Data* input,
                  OldUnion* output);

size_t GetSerializedSize_(const NewUnionPtr& input);
mojo::internal::ValidationError SerializeUnion_(
    NewUnion* input,
    mojo::internal::Buffer* buffer,
    internal::NewUnion_Data** output);
void Deserialize_(internal::NewUnion_Data* input,
                  NewUnion* output);


// --- Request and response parameter structs for Interface methods ---
      

class SmallCache_SetIntValue_Params;

using SmallCache_SetIntValue_ParamsPtr = mojo::InlinedStructPtr<SmallCache_SetIntValue_Params>;


size_t GetSerializedSize_(const SmallCache_SetIntValue_Params& input);
mojo::internal::ValidationError Serialize_(
    SmallCache_SetIntValue_Params* input,
    mojo::internal::Buffer* buffer,
    internal::SmallCache_SetIntValue_Params_Data** output);
void Deserialize_(internal::SmallCache_SetIntValue_Params_Data* input,
                  SmallCache_SetIntValue_Params* output);

class SmallCache_SetIntValue_Params {
 public:
  using Data_ = internal::SmallCache_SetIntValue_Params_Data;

  static SmallCache_SetIntValue_ParamsPtr New();

  template <typename U>
  static SmallCache_SetIntValue_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<SmallCache_SetIntValue_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SmallCache_SetIntValue_Params>::Convert(*this);
  }

  SmallCache_SetIntValue_Params();
  ~SmallCache_SetIntValue_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  SmallCache_SetIntValue_ParamsPtr Clone() const;
  bool Equals(const SmallCache_SetIntValue_Params& other) const;

  int64_t int_value;
};




class SmallCache_GetIntValue_Params;

using SmallCache_GetIntValue_ParamsPtr = mojo::InlinedStructPtr<SmallCache_GetIntValue_Params>;


size_t GetSerializedSize_(const SmallCache_GetIntValue_Params& input);
mojo::internal::ValidationError Serialize_(
    SmallCache_GetIntValue_Params* input,
    mojo::internal::Buffer* buffer,
    internal::SmallCache_GetIntValue_Params_Data** output);
void Deserialize_(internal::SmallCache_GetIntValue_Params_Data* input,
                  SmallCache_GetIntValue_Params* output);

class SmallCache_GetIntValue_Params {
 public:
  using Data_ = internal::SmallCache_GetIntValue_Params_Data;

  static SmallCache_GetIntValue_ParamsPtr New();

  template <typename U>
  static SmallCache_GetIntValue_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<SmallCache_GetIntValue_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SmallCache_GetIntValue_Params>::Convert(*this);
  }

  SmallCache_GetIntValue_Params();
  ~SmallCache_GetIntValue_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  SmallCache_GetIntValue_ParamsPtr Clone() const;
  bool Equals(const SmallCache_GetIntValue_Params& other) const;

};



class SmallCache_GetIntValue_ResponseParams;

using SmallCache_GetIntValue_ResponseParamsPtr = mojo::InlinedStructPtr<SmallCache_GetIntValue_ResponseParams>;


size_t GetSerializedSize_(const SmallCache_GetIntValue_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    SmallCache_GetIntValue_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::SmallCache_GetIntValue_ResponseParams_Data** output);
void Deserialize_(internal::SmallCache_GetIntValue_ResponseParams_Data* input,
                  SmallCache_GetIntValue_ResponseParams* output);

class SmallCache_GetIntValue_ResponseParams {
 public:
  using Data_ = internal::SmallCache_GetIntValue_ResponseParams_Data;

  static SmallCache_GetIntValue_ResponseParamsPtr New();

  template <typename U>
  static SmallCache_GetIntValue_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<SmallCache_GetIntValue_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SmallCache_GetIntValue_ResponseParams>::Convert(*this);
  }

  SmallCache_GetIntValue_ResponseParams();
  ~SmallCache_GetIntValue_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  SmallCache_GetIntValue_ResponseParamsPtr Clone() const;
  bool Equals(const SmallCache_GetIntValue_ResponseParams& other) const;

  int64_t int_value;
};


      

class UnionInterface_Echo_Params;

using UnionInterface_Echo_ParamsPtr = mojo::StructPtr<UnionInterface_Echo_Params>;


size_t GetSerializedSize_(const UnionInterface_Echo_Params& input);
mojo::internal::ValidationError Serialize_(
    UnionInterface_Echo_Params* input,
    mojo::internal::Buffer* buffer,
    internal::UnionInterface_Echo_Params_Data** output);
void Deserialize_(internal::UnionInterface_Echo_Params_Data* input,
                  UnionInterface_Echo_Params* output);

class UnionInterface_Echo_Params {
 public:
  using Data_ = internal::UnionInterface_Echo_Params_Data;

  static UnionInterface_Echo_ParamsPtr New();

  template <typename U>
  static UnionInterface_Echo_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<UnionInterface_Echo_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UnionInterface_Echo_Params>::Convert(*this);
  }

  UnionInterface_Echo_Params();
  ~UnionInterface_Echo_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  UnionInterface_Echo_ParamsPtr Clone() const;
  bool Equals(const UnionInterface_Echo_Params& other) const;

  PodUnionPtr in_val;
};



class UnionInterface_Echo_ResponseParams;

using UnionInterface_Echo_ResponseParamsPtr = mojo::StructPtr<UnionInterface_Echo_ResponseParams>;


size_t GetSerializedSize_(const UnionInterface_Echo_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    UnionInterface_Echo_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::UnionInterface_Echo_ResponseParams_Data** output);
void Deserialize_(internal::UnionInterface_Echo_ResponseParams_Data* input,
                  UnionInterface_Echo_ResponseParams* output);

class UnionInterface_Echo_ResponseParams {
 public:
  using Data_ = internal::UnionInterface_Echo_ResponseParams_Data;

  static UnionInterface_Echo_ResponseParamsPtr New();

  template <typename U>
  static UnionInterface_Echo_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<UnionInterface_Echo_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UnionInterface_Echo_ResponseParams>::Convert(*this);
  }

  UnionInterface_Echo_ResponseParams();
  ~UnionInterface_Echo_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  UnionInterface_Echo_ResponseParamsPtr Clone() const;
  bool Equals(const UnionInterface_Echo_ResponseParams& other) const;

  PodUnionPtr out_val;
};


}  // namespace test
}  // namespace mojo

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_UNIONS_MOJOM_COMMON_H_
