// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library test_service_mojom;
import 'dart:async';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;



class _TestServicePingParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _TestServicePingParams() : super(kVersions.last.size);

  _TestServicePingParams.init(
  ) : super(kVersions.last.size);

  static _TestServicePingParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestServicePingParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestServicePingParams result = new _TestServicePingParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestServicePingParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestServicePingParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class TestServicePingResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  TestServicePingResponseParams() : super(kVersions.last.size);

  TestServicePingResponseParams.init(
  ) : super(kVersions.last.size);

  static TestServicePingResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static TestServicePingResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    TestServicePingResponseParams result = new TestServicePingResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "TestServicePingResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "TestServicePingResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _TestServiceConnectToAppAndGetTimeParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String appUrl = null;

  _TestServiceConnectToAppAndGetTimeParams() : super(kVersions.last.size);

  _TestServiceConnectToAppAndGetTimeParams.init(
    String this.appUrl
  ) : super(kVersions.last.size);

  static _TestServiceConnectToAppAndGetTimeParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestServiceConnectToAppAndGetTimeParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestServiceConnectToAppAndGetTimeParams result = new _TestServiceConnectToAppAndGetTimeParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.appUrl = decoder0.decodeString(8, true);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestServiceConnectToAppAndGetTimeParams";
    String fieldName;
    try {
      fieldName = "appUrl";
      encoder0.encodeString(appUrl, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestServiceConnectToAppAndGetTimeParams("
           "appUrl: $appUrl" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["appUrl"] = appUrl;
    return map;
  }
}


class TestServiceConnectToAppAndGetTimeResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int timeUsec = 0;

  TestServiceConnectToAppAndGetTimeResponseParams() : super(kVersions.last.size);

  TestServiceConnectToAppAndGetTimeResponseParams.init(
    int this.timeUsec
  ) : super(kVersions.last.size);

  static TestServiceConnectToAppAndGetTimeResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static TestServiceConnectToAppAndGetTimeResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    TestServiceConnectToAppAndGetTimeResponseParams result = new TestServiceConnectToAppAndGetTimeResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.timeUsec = decoder0.decodeInt64(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "TestServiceConnectToAppAndGetTimeResponseParams";
    String fieldName;
    try {
      fieldName = "timeUsec";
      encoder0.encodeInt64(timeUsec, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "TestServiceConnectToAppAndGetTimeResponseParams("
           "timeUsec: $timeUsec" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["timeUsec"] = timeUsec;
    return map;
  }
}


class _TestServiceStartTrackingRequestsParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _TestServiceStartTrackingRequestsParams() : super(kVersions.last.size);

  _TestServiceStartTrackingRequestsParams.init(
  ) : super(kVersions.last.size);

  static _TestServiceStartTrackingRequestsParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestServiceStartTrackingRequestsParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestServiceStartTrackingRequestsParams result = new _TestServiceStartTrackingRequestsParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestServiceStartTrackingRequestsParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestServiceStartTrackingRequestsParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class TestServiceStartTrackingRequestsResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  TestServiceStartTrackingRequestsResponseParams() : super(kVersions.last.size);

  TestServiceStartTrackingRequestsResponseParams.init(
  ) : super(kVersions.last.size);

  static TestServiceStartTrackingRequestsResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static TestServiceStartTrackingRequestsResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    TestServiceStartTrackingRequestsResponseParams result = new TestServiceStartTrackingRequestsResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "TestServiceStartTrackingRequestsResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "TestServiceStartTrackingRequestsResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _TestTimeServiceGetPartyTimeParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _TestTimeServiceGetPartyTimeParams() : super(kVersions.last.size);

  _TestTimeServiceGetPartyTimeParams.init(
  ) : super(kVersions.last.size);

  static _TestTimeServiceGetPartyTimeParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestTimeServiceGetPartyTimeParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestTimeServiceGetPartyTimeParams result = new _TestTimeServiceGetPartyTimeParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestTimeServiceGetPartyTimeParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestTimeServiceGetPartyTimeParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class TestTimeServiceGetPartyTimeResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int timeUsec = 0;

  TestTimeServiceGetPartyTimeResponseParams() : super(kVersions.last.size);

  TestTimeServiceGetPartyTimeResponseParams.init(
    int this.timeUsec
  ) : super(kVersions.last.size);

  static TestTimeServiceGetPartyTimeResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static TestTimeServiceGetPartyTimeResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    TestTimeServiceGetPartyTimeResponseParams result = new TestTimeServiceGetPartyTimeResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.timeUsec = decoder0.decodeInt64(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "TestTimeServiceGetPartyTimeResponseParams";
    String fieldName;
    try {
      fieldName = "timeUsec";
      encoder0.encodeInt64(timeUsec, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "TestTimeServiceGetPartyTimeResponseParams("
           "timeUsec: $timeUsec" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["timeUsec"] = timeUsec;
    return map;
  }
}


class _TestTimeServiceStartTrackingRequestsParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _TestTimeServiceStartTrackingRequestsParams() : super(kVersions.last.size);

  _TestTimeServiceStartTrackingRequestsParams.init(
  ) : super(kVersions.last.size);

  static _TestTimeServiceStartTrackingRequestsParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestTimeServiceStartTrackingRequestsParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestTimeServiceStartTrackingRequestsParams result = new _TestTimeServiceStartTrackingRequestsParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestTimeServiceStartTrackingRequestsParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestTimeServiceStartTrackingRequestsParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class TestTimeServiceStartTrackingRequestsResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  TestTimeServiceStartTrackingRequestsResponseParams() : super(kVersions.last.size);

  TestTimeServiceStartTrackingRequestsResponseParams.init(
  ) : super(kVersions.last.size);

  static TestTimeServiceStartTrackingRequestsResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static TestTimeServiceStartTrackingRequestsResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    TestTimeServiceStartTrackingRequestsResponseParams result = new TestTimeServiceStartTrackingRequestsResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "TestTimeServiceStartTrackingRequestsResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "TestTimeServiceStartTrackingRequestsResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}

const int _testServiceMethodPingName = 0;
const int _testServiceMethodConnectToAppAndGetTimeName = 1;
const int _testServiceMethodStartTrackingRequestsName = 2;

class _TestServiceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class TestService {
  static const String serviceName = "mojo::test::TestService";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _TestServiceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static TestServiceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    TestServiceProxy p = new TestServiceProxy.unbound();
    String name = serviceName ?? TestService.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void ping(void callback());
  void connectToAppAndGetTime(String appUrl,void callback(int timeUsec));
  void startTrackingRequests(void callback());
}

abstract class TestServiceInterface
    implements bindings.MojoInterface<TestService>,
               TestService {
  factory TestServiceInterface([TestService impl]) =>
      new TestServiceStub.unbound(impl);

  factory TestServiceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [TestService impl]) =>
      new TestServiceStub.fromEndpoint(endpoint, impl);

  factory TestServiceInterface.fromMock(
      TestService mock) =>
      new TestServiceProxy.fromMock(mock);
}

abstract class TestServiceInterfaceRequest
    implements bindings.MojoInterface<TestService>,
               TestService {
  factory TestServiceInterfaceRequest() =>
      new TestServiceProxy.unbound();
}

class _TestServiceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<TestService> {
  TestService impl;

  _TestServiceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _TestServiceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _TestServiceProxyControl.unbound() : super.unbound();

  String get serviceName => TestService.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _testServiceMethodPingName:
        var r = TestServicePingResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback();
        break;
      case _testServiceMethodConnectToAppAndGetTimeName:
        var r = TestServiceConnectToAppAndGetTimeResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.timeUsec );
        break;
      case _testServiceMethodStartTrackingRequestsName:
        var r = TestServiceStartTrackingRequestsResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback();
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestServiceProxyControl($superString)";
  }
}

class TestServiceProxy
    extends bindings.Proxy<TestService>
    implements TestService,
               TestServiceInterface,
               TestServiceInterfaceRequest {
  TestServiceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _TestServiceProxyControl.fromEndpoint(endpoint));

  TestServiceProxy.fromHandle(core.MojoHandle handle)
      : super(new _TestServiceProxyControl.fromHandle(handle));

  TestServiceProxy.unbound()
      : super(new _TestServiceProxyControl.unbound());

  factory TestServiceProxy.fromMock(TestService mock) {
    TestServiceProxy newMockedProxy =
        new TestServiceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static TestServiceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestServiceProxy"));
    return new TestServiceProxy.fromEndpoint(endpoint);
  }


  void ping(void callback()) {
    if (impl != null) {
      impl.ping(callback);
      return;
    }
    var params = new _TestServicePingParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _testServiceMethodPingName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void connectToAppAndGetTime(String appUrl,void callback(int timeUsec)) {
    if (impl != null) {
      impl.connectToAppAndGetTime(appUrl,callback);
      return;
    }
    var params = new _TestServiceConnectToAppAndGetTimeParams();
    params.appUrl = appUrl;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((int timeUsec) {
        z.bindCallback(() {
          callback(timeUsec);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _testServiceMethodConnectToAppAndGetTimeName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void startTrackingRequests(void callback()) {
    if (impl != null) {
      impl.startTrackingRequests(callback);
      return;
    }
    var params = new _TestServiceStartTrackingRequestsParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _testServiceMethodStartTrackingRequestsName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _TestServiceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<TestService> {
  TestService _impl;

  _TestServiceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestService impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestServiceStubControl.fromHandle(
      core.MojoHandle handle, [TestService impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestServiceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => TestService.serviceName;


  Function _testServicePingResponseParamsResponder(
      int requestId) {
  return () {
      var result = new TestServicePingResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _testServiceMethodPingName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _testServiceConnectToAppAndGetTimeResponseParamsResponder(
      int requestId) {
  return (int timeUsec) {
      var result = new TestServiceConnectToAppAndGetTimeResponseParams();
      result.timeUsec = timeUsec;
      sendResponse(buildResponseWithId(
          result,
          _testServiceMethodConnectToAppAndGetTimeName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _testServiceStartTrackingRequestsResponseParamsResponder(
      int requestId) {
  return () {
      var result = new TestServiceStartTrackingRequestsResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _testServiceMethodStartTrackingRequestsName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _testServiceMethodPingName:
        _impl.ping(_testServicePingResponseParamsResponder(message.header.requestId));
        break;
      case _testServiceMethodConnectToAppAndGetTimeName:
        var params = _TestServiceConnectToAppAndGetTimeParams.deserialize(
            message.payload);
        _impl.connectToAppAndGetTime(params.appUrl, _testServiceConnectToAppAndGetTimeResponseParamsResponder(message.header.requestId));
        break;
      case _testServiceMethodStartTrackingRequestsName:
        _impl.startTrackingRequests(_testServiceStartTrackingRequestsResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  TestService get impl => _impl;
  set impl(TestService d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestServiceStubControl($superString)";
  }

  int get version => 0;
}

class TestServiceStub
    extends bindings.Stub<TestService>
    implements TestService,
               TestServiceInterface,
               TestServiceInterfaceRequest {
  TestServiceStub.unbound([TestService impl])
      : super(new _TestServiceStubControl.unbound(impl));

  TestServiceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestService impl])
      : super(new _TestServiceStubControl.fromEndpoint(endpoint, impl));

  TestServiceStub.fromHandle(
      core.MojoHandle handle, [TestService impl])
      : super(new _TestServiceStubControl.fromHandle(handle, impl));

  static TestServiceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestServiceStub"));
    return new TestServiceStub.fromEndpoint(endpoint);
  }


  void ping(void callback()) {
    return impl.ping(callback);
  }
  void connectToAppAndGetTime(String appUrl,void callback(int timeUsec)) {
    return impl.connectToAppAndGetTime(appUrl,callback);
  }
  void startTrackingRequests(void callback()) {
    return impl.startTrackingRequests(callback);
  }
}

const int _testTimeServiceMethodGetPartyTimeName = 0;
const int _testTimeServiceMethodStartTrackingRequestsName = 1;

class _TestTimeServiceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class TestTimeService {
  static const String serviceName = "mojo::test::TestTimeService";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _TestTimeServiceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static TestTimeServiceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    TestTimeServiceProxy p = new TestTimeServiceProxy.unbound();
    String name = serviceName ?? TestTimeService.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void getPartyTime(void callback(int timeUsec));
  void startTrackingRequests(void callback());
}

abstract class TestTimeServiceInterface
    implements bindings.MojoInterface<TestTimeService>,
               TestTimeService {
  factory TestTimeServiceInterface([TestTimeService impl]) =>
      new TestTimeServiceStub.unbound(impl);

  factory TestTimeServiceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [TestTimeService impl]) =>
      new TestTimeServiceStub.fromEndpoint(endpoint, impl);

  factory TestTimeServiceInterface.fromMock(
      TestTimeService mock) =>
      new TestTimeServiceProxy.fromMock(mock);
}

abstract class TestTimeServiceInterfaceRequest
    implements bindings.MojoInterface<TestTimeService>,
               TestTimeService {
  factory TestTimeServiceInterfaceRequest() =>
      new TestTimeServiceProxy.unbound();
}

class _TestTimeServiceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<TestTimeService> {
  TestTimeService impl;

  _TestTimeServiceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _TestTimeServiceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _TestTimeServiceProxyControl.unbound() : super.unbound();

  String get serviceName => TestTimeService.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _testTimeServiceMethodGetPartyTimeName:
        var r = TestTimeServiceGetPartyTimeResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.timeUsec );
        break;
      case _testTimeServiceMethodStartTrackingRequestsName:
        var r = TestTimeServiceStartTrackingRequestsResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback();
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestTimeServiceProxyControl($superString)";
  }
}

class TestTimeServiceProxy
    extends bindings.Proxy<TestTimeService>
    implements TestTimeService,
               TestTimeServiceInterface,
               TestTimeServiceInterfaceRequest {
  TestTimeServiceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _TestTimeServiceProxyControl.fromEndpoint(endpoint));

  TestTimeServiceProxy.fromHandle(core.MojoHandle handle)
      : super(new _TestTimeServiceProxyControl.fromHandle(handle));

  TestTimeServiceProxy.unbound()
      : super(new _TestTimeServiceProxyControl.unbound());

  factory TestTimeServiceProxy.fromMock(TestTimeService mock) {
    TestTimeServiceProxy newMockedProxy =
        new TestTimeServiceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static TestTimeServiceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestTimeServiceProxy"));
    return new TestTimeServiceProxy.fromEndpoint(endpoint);
  }


  void getPartyTime(void callback(int timeUsec)) {
    if (impl != null) {
      impl.getPartyTime(callback);
      return;
    }
    var params = new _TestTimeServiceGetPartyTimeParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((int timeUsec) {
        z.bindCallback(() {
          callback(timeUsec);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _testTimeServiceMethodGetPartyTimeName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void startTrackingRequests(void callback()) {
    if (impl != null) {
      impl.startTrackingRequests(callback);
      return;
    }
    var params = new _TestTimeServiceStartTrackingRequestsParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _testTimeServiceMethodStartTrackingRequestsName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _TestTimeServiceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<TestTimeService> {
  TestTimeService _impl;

  _TestTimeServiceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestTimeService impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestTimeServiceStubControl.fromHandle(
      core.MojoHandle handle, [TestTimeService impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestTimeServiceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => TestTimeService.serviceName;


  Function _testTimeServiceGetPartyTimeResponseParamsResponder(
      int requestId) {
  return (int timeUsec) {
      var result = new TestTimeServiceGetPartyTimeResponseParams();
      result.timeUsec = timeUsec;
      sendResponse(buildResponseWithId(
          result,
          _testTimeServiceMethodGetPartyTimeName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _testTimeServiceStartTrackingRequestsResponseParamsResponder(
      int requestId) {
  return () {
      var result = new TestTimeServiceStartTrackingRequestsResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _testTimeServiceMethodStartTrackingRequestsName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _testTimeServiceMethodGetPartyTimeName:
        _impl.getPartyTime(_testTimeServiceGetPartyTimeResponseParamsResponder(message.header.requestId));
        break;
      case _testTimeServiceMethodStartTrackingRequestsName:
        _impl.startTrackingRequests(_testTimeServiceStartTrackingRequestsResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  TestTimeService get impl => _impl;
  set impl(TestTimeService d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestTimeServiceStubControl($superString)";
  }

  int get version => 0;
}

class TestTimeServiceStub
    extends bindings.Stub<TestTimeService>
    implements TestTimeService,
               TestTimeServiceInterface,
               TestTimeServiceInterfaceRequest {
  TestTimeServiceStub.unbound([TestTimeService impl])
      : super(new _TestTimeServiceStubControl.unbound(impl));

  TestTimeServiceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestTimeService impl])
      : super(new _TestTimeServiceStubControl.fromEndpoint(endpoint, impl));

  TestTimeServiceStub.fromHandle(
      core.MojoHandle handle, [TestTimeService impl])
      : super(new _TestTimeServiceStubControl.fromHandle(handle, impl));

  static TestTimeServiceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestTimeServiceStub"));
    return new TestTimeServiceStub.fromEndpoint(endpoint);
  }


  void getPartyTime(void callback(int timeUsec)) {
    return impl.getPartyTime(callback);
  }
  void startTrackingRequests(void callback()) {
    return impl.startTrackingRequests(callback);
  }
}



