// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/public/interfaces/bindings/tests/sample_factory.mojom.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
namespace sample {

// --- Interface definitions ---
class NamedObject_GetName_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NamedObject_GetName_ForwardToCallback(
      const NamedObject::GetNameCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  NamedObject::GetNameCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(NamedObject_GetName_ForwardToCallback);
};
bool NamedObject_GetName_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::NamedObject_GetName_ResponseParams_Data* params =
      reinterpret_cast<internal::NamedObject_GetName_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::String p_name {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    Deserialize_(params->name.ptr, &p_name);
  } while (false);
  callback_.Run(p_name);
  return true;
}

NamedObjectProxy::NamedObjectProxy(mojo::MessageReceiverWithResponder* receiver)
    : ControlMessageProxy(receiver) {
}
void NamedObjectProxy::SetName(
    const mojo::String& in_name) {
  size_t size = sizeof(internal::NamedObject_SetName_Params_Data);
  size += GetSerializedSize_(in_name);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::NamedObject_Base::MessageOrdinals::SetName), size);

  internal::NamedObject_SetName_Params_Data* params =
      internal::NamedObject_SetName_Params_Data::New(builder.buffer());
  SerializeString_(in_name, builder.buffer(), &params->name.ptr);
  if (!params->name.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null name in NamedObject.SetName request");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
void NamedObjectProxy::GetName(
    const GetNameCallback& callback) {
  size_t size = sizeof(internal::NamedObject_GetName_Params_Data);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::NamedObject_Base::MessageOrdinals::GetName), size);

  internal::NamedObject_GetName_Params_Data* params =
      internal::NamedObject_GetName_Params_Data::New(builder.buffer());
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new NamedObject_GetName_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class NamedObject_GetName_ProxyToResponder
    : public NamedObject::GetNameCallback::Runnable {
 public:
  ~NamedObject_GetName_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "NamedObject::GetName(callback) "
        "was never run.";
  }

  NamedObject_GetName_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(const mojo::String& in_name) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(NamedObject_GetName_ProxyToResponder);
};

void NamedObject_GetName_ProxyToResponder::Run(
    const mojo::String& in_name) const {
  size_t size = sizeof(internal::NamedObject_GetName_ResponseParams_Data);
  size += GetSerializedSize_(in_name);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::NamedObject_Base::MessageOrdinals::GetName), size, request_id_);
  internal::NamedObject_GetName_ResponseParams_Data* params =
      internal::NamedObject_GetName_ResponseParams_Data::New(builder.buffer());
  SerializeString_(in_name, builder.buffer(), &params->name.ptr);
  if (!params->name.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null name in NamedObject.GetName response");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}

NamedObjectStub::NamedObjectStub()
    : sink_(nullptr),
      control_message_handler_(NamedObject::Version_) {
}

NamedObjectStub::~NamedObjectStub() {}

bool NamedObjectStub::Accept(mojo::Message* message) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.Accept(message);
  internal::NamedObject_Base::MessageOrdinals method_ordinal =
      static_cast<internal::NamedObject_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::NamedObject_Base::MessageOrdinals::SetName: {
      internal::NamedObject_SetName_Params_Data* params =
          reinterpret_cast<internal::NamedObject_SetName_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      mojo::String p_name {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        Deserialize_(params->name.ptr, &p_name);
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->SetName(p_name);
      return true;
    }
    case internal::NamedObject_Base::MessageOrdinals::GetName: {
      break;
    }
  }
  return false;
}

bool NamedObjectStub::AcceptWithResponder(
    mojo::Message* message, mojo::MessageReceiverWithStatus* responder) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.AcceptWithResponder(message, responder);
  internal::NamedObject_Base::MessageOrdinals method_ordinal =
      static_cast<internal::NamedObject_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::NamedObject_Base::MessageOrdinals::SetName: {
      break;
    }
    case internal::NamedObject_Base::MessageOrdinals::GetName: {
      internal::NamedObject_GetName_Params_Data* params =
          reinterpret_cast<internal::NamedObject_GetName_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      NamedObject::GetNameCallback::Runnable* runnable =
          new NamedObject_GetName_ProxyToResponder(
              message->request_id(), responder);
      NamedObject::GetNameCallback callback(runnable);
      
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->GetName(callback);
      return true;
    }
  }
  return false;
}

class Factory_DoStuff_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Factory_DoStuff_ForwardToCallback(
      const Factory::DoStuffCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Factory::DoStuffCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Factory_DoStuff_ForwardToCallback);
};
bool Factory_DoStuff_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Factory_DoStuff_ResponseParams_Data* params =
      reinterpret_cast<internal::Factory_DoStuff_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  ResponsePtr p_response {};
  mojo::String p_text {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    if (params->response.ptr) {
      p_response = Response::New();
      Deserialize_(params->response.ptr, p_response.get());
    }
    Deserialize_(params->text.ptr, &p_text);
  } while (false);
  callback_.Run(p_response.Pass(), p_text);
  return true;
}
class Factory_DoStuff2_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Factory_DoStuff2_ForwardToCallback(
      const Factory::DoStuff2Callback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Factory::DoStuff2Callback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Factory_DoStuff2_ForwardToCallback);
};
bool Factory_DoStuff2_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Factory_DoStuff2_ResponseParams_Data* params =
      reinterpret_cast<internal::Factory_DoStuff2_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::String p_text {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    Deserialize_(params->text.ptr, &p_text);
  } while (false);
  callback_.Run(p_text);
  return true;
}
class Factory_RequestImportedInterface_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Factory_RequestImportedInterface_ForwardToCallback(
      const Factory::RequestImportedInterfaceCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Factory::RequestImportedInterfaceCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Factory_RequestImportedInterface_ForwardToCallback);
};
bool Factory_RequestImportedInterface_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Factory_RequestImportedInterface_ResponseParams_Data* params =
      reinterpret_cast<internal::Factory_RequestImportedInterface_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::InterfaceRequest<imported::ImportedInterface> p_obj {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    p_obj.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&params->obj)));
  } while (false);
  callback_.Run(p_obj.Pass());
  return true;
}
class Factory_TakeImportedInterface_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Factory_TakeImportedInterface_ForwardToCallback(
      const Factory::TakeImportedInterfaceCallback& callback)
      : callback_(callback) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Factory::TakeImportedInterfaceCallback callback_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Factory_TakeImportedInterface_ForwardToCallback);
};
bool Factory_TakeImportedInterface_ForwardToCallback::Accept(
    mojo::Message* message) {
  internal::Factory_TakeImportedInterface_ResponseParams_Data* params =
      reinterpret_cast<internal::Factory_TakeImportedInterface_ResponseParams_Data*>(
          message->mutable_payload());

  params->DecodePointersAndHandles(message->mutable_handles());
  
  mojo::InterfaceHandle<imported::ImportedInterface> p_obj {};
  do {
    // NOTE: The memory backing |params| may has be smaller than
    // |sizeof(*params)| if the message comes from an older version.
    mojo::internal::InterfaceDataToHandle(&params->obj, &p_obj);
  } while (false);
  callback_.Run(p_obj.Pass());
  return true;
}

FactoryProxy::FactoryProxy(mojo::MessageReceiverWithResponder* receiver)
    : ControlMessageProxy(receiver) {
}
void FactoryProxy::DoStuff(
    RequestPtr in_request, mojo::ScopedMessagePipeHandle in_pipe, const DoStuffCallback& callback) {
  size_t size = sizeof(internal::Factory_DoStuff_Params_Data);
  size += in_request.is_null()
              ? 0
              : GetSerializedSize_(*in_request);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Factory_Base::MessageOrdinals::DoStuff), size);

  internal::Factory_DoStuff_Params_Data* params =
      internal::Factory_DoStuff_Params_Data::New(builder.buffer());
  {Serialize_(in_request.get(),
               builder.buffer(),
               &params->request.ptr);
  }
  if (!params->request.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null request in Factory.DoStuff request");
  }
  params->pipe = in_pipe.release();
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Factory_DoStuff_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void FactoryProxy::DoStuff2(
    mojo::ScopedDataPipeConsumerHandle in_pipe, const DoStuff2Callback& callback) {
  size_t size = sizeof(internal::Factory_DoStuff2_Params_Data);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Factory_Base::MessageOrdinals::DoStuff2), size);

  internal::Factory_DoStuff2_Params_Data* params =
      internal::Factory_DoStuff2_Params_Data::New(builder.buffer());
  params->pipe = in_pipe.release();
  if (!params->pipe.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid pipe in Factory.DoStuff2 request");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Factory_DoStuff2_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void FactoryProxy::CreateNamedObject(
    mojo::InterfaceRequest<NamedObject> in_obj) {
  size_t size = sizeof(internal::Factory_CreateNamedObject_Params_Data);
  mojo::MessageBuilder builder(
    static_cast<uint32_t>(internal::Factory_Base::MessageOrdinals::CreateNamedObject), size);

  internal::Factory_CreateNamedObject_Params_Data* params =
      internal::Factory_CreateNamedObject_Params_Data::New(builder.buffer());
  params->obj = in_obj.PassMessagePipe().release();
  if (!params->obj.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid obj in Factory.CreateNamedObject request");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = receiver_->Accept(builder.message());
  // This return value may be ignored as !ok implies the Connector has
  // encountered an error, which will be visible through other means.
  MOJO_ALLOW_UNUSED_LOCAL(ok);
}
void FactoryProxy::RequestImportedInterface(
    mojo::InterfaceRequest<imported::ImportedInterface> in_obj, const RequestImportedInterfaceCallback& callback) {
  size_t size = sizeof(internal::Factory_RequestImportedInterface_Params_Data);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Factory_Base::MessageOrdinals::RequestImportedInterface), size);

  internal::Factory_RequestImportedInterface_Params_Data* params =
      internal::Factory_RequestImportedInterface_Params_Data::New(builder.buffer());
  params->obj = in_obj.PassMessagePipe().release();
  if (!params->obj.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid obj in Factory.RequestImportedInterface request");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Factory_RequestImportedInterface_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
void FactoryProxy::TakeImportedInterface(
    mojo::InterfaceHandle<imported::ImportedInterface> in_obj, const TakeImportedInterfaceCallback& callback) {
  size_t size = sizeof(internal::Factory_TakeImportedInterface_Params_Data);
  mojo::RequestMessageBuilder builder(
      static_cast<uint32_t>(internal::Factory_Base::MessageOrdinals::TakeImportedInterface), size);

  internal::Factory_TakeImportedInterface_Params_Data* params =
      internal::Factory_TakeImportedInterface_Params_Data::New(builder.buffer());
  mojo::internal::InterfaceHandleToData(in_obj.Pass(),
                                        &params->obj);
  if (!params->obj.handle.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid obj in Factory.TakeImportedInterface request");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  mojo::MessageReceiver* responder =
      new Factory_TakeImportedInterface_ForwardToCallback(callback);
  if (!receiver_->AcceptWithResponder(builder.message(), responder))
    delete responder;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Factory_DoStuff_ProxyToResponder
    : public Factory::DoStuffCallback::Runnable {
 public:
  ~Factory_DoStuff_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Factory::DoStuff(p_request.Pass(), p_pipe.Pass(), callback) "
        "was never run.";
  }

  Factory_DoStuff_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(ResponsePtr in_response, const mojo::String& in_text) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Factory_DoStuff_ProxyToResponder);
};

void Factory_DoStuff_ProxyToResponder::Run(
    ResponsePtr in_response, const mojo::String& in_text) const {
  size_t size = sizeof(internal::Factory_DoStuff_ResponseParams_Data);
  size += in_response.is_null()
              ? 0
              : GetSerializedSize_(*in_response);
  size += GetSerializedSize_(in_text);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Factory_Base::MessageOrdinals::DoStuff), size, request_id_);
  internal::Factory_DoStuff_ResponseParams_Data* params =
      internal::Factory_DoStuff_ResponseParams_Data::New(builder.buffer());
  {Serialize_(in_response.get(),
               builder.buffer(),
               &params->response.ptr);
  }
  if (!params->response.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null response in Factory.DoStuff response");
  }
  SerializeString_(in_text, builder.buffer(), &params->text.ptr);
  if (!params->text.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null text in Factory.DoStuff response");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Factory_DoStuff2_ProxyToResponder
    : public Factory::DoStuff2Callback::Runnable {
 public:
  ~Factory_DoStuff2_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Factory::DoStuff2(p_pipe.Pass(), callback) "
        "was never run.";
  }

  Factory_DoStuff2_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(const mojo::String& in_text) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Factory_DoStuff2_ProxyToResponder);
};

void Factory_DoStuff2_ProxyToResponder::Run(
    const mojo::String& in_text) const {
  size_t size = sizeof(internal::Factory_DoStuff2_ResponseParams_Data);
  size += GetSerializedSize_(in_text);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Factory_Base::MessageOrdinals::DoStuff2), size, request_id_);
  internal::Factory_DoStuff2_ResponseParams_Data* params =
      internal::Factory_DoStuff2_ResponseParams_Data::New(builder.buffer());
  SerializeString_(in_text, builder.buffer(), &params->text.ptr);
  if (!params->text.ptr) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null text in Factory.DoStuff2 response");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Factory_RequestImportedInterface_ProxyToResponder
    : public Factory::RequestImportedInterfaceCallback::Runnable {
 public:
  ~Factory_RequestImportedInterface_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Factory::RequestImportedInterface(p_obj.Pass(), callback) "
        "was never run.";
  }

  Factory_RequestImportedInterface_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(mojo::InterfaceRequest<imported::ImportedInterface> in_obj) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Factory_RequestImportedInterface_ProxyToResponder);
};

void Factory_RequestImportedInterface_ProxyToResponder::Run(
    mojo::InterfaceRequest<imported::ImportedInterface> in_obj) const {
  size_t size = sizeof(internal::Factory_RequestImportedInterface_ResponseParams_Data);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Factory_Base::MessageOrdinals::RequestImportedInterface), size, request_id_);
  internal::Factory_RequestImportedInterface_ResponseParams_Data* params =
      internal::Factory_RequestImportedInterface_ResponseParams_Data::New(builder.buffer());
  params->obj = in_obj.PassMessagePipe().release();
  if (!params->obj.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid obj in Factory.RequestImportedInterface response");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}
// This class implements a method's response callback: it serializes the
// response args into a mojo message and passes it to the MessageReceiver it
// was created with.
class Factory_TakeImportedInterface_ProxyToResponder
    : public Factory::TakeImportedInterfaceCallback::Runnable {
 public:
  ~Factory_TakeImportedInterface_ProxyToResponder() override {
    // Is the Mojo application destroying the callback without running it
    // and without first closing the pipe?
    bool callback_was_dropped = responder_ && responder_->IsValid();
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    delete responder_;
    MOJO_DCHECK(!callback_was_dropped)  << "The callback passed to "
        "Factory::TakeImportedInterface(p_obj.Pass(), callback) "
        "was never run.";
  }

  Factory_TakeImportedInterface_ProxyToResponder(
      uint64_t request_id,
      mojo::MessageReceiverWithStatus* responder)
      : request_id_(request_id),
        responder_(responder) {
  }

  void Run(mojo::InterfaceHandle<imported::ImportedInterface> in_obj) const override;

 private:
  uint64_t request_id_;
  mutable mojo::MessageReceiverWithStatus* responder_;
  MOJO_DISALLOW_COPY_AND_ASSIGN(Factory_TakeImportedInterface_ProxyToResponder);
};

void Factory_TakeImportedInterface_ProxyToResponder::Run(
    mojo::InterfaceHandle<imported::ImportedInterface> in_obj) const {
  size_t size = sizeof(internal::Factory_TakeImportedInterface_ResponseParams_Data);
  mojo::ResponseMessageBuilder builder(
      static_cast<uint32_t>(internal::Factory_Base::MessageOrdinals::TakeImportedInterface), size, request_id_);
  internal::Factory_TakeImportedInterface_ResponseParams_Data* params =
      internal::Factory_TakeImportedInterface_ResponseParams_Data::New(builder.buffer());
  mojo::internal::InterfaceHandleToData(in_obj.Pass(),
                                        &params->obj);
  if (!params->obj.handle.is_valid()) {
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid obj in Factory.TakeImportedInterface response");
  }
  params->EncodePointersAndHandles(builder.message()->mutable_handles());
  bool ok = responder_->Accept(builder.message());
  MOJO_ALLOW_UNUSED_LOCAL(ok);
  // TODO(darin): !ok returned here indicates a malformed message, and that may
  // be good reason to close the connection. However, we don't have a way to do
  // that from here. We should add a way.
  delete responder_;
  responder_ = nullptr;
}

FactoryStub::FactoryStub()
    : sink_(nullptr),
      control_message_handler_(Factory::Version_) {
}

FactoryStub::~FactoryStub() {}

bool FactoryStub::Accept(mojo::Message* message) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.Accept(message);
  internal::Factory_Base::MessageOrdinals method_ordinal =
      static_cast<internal::Factory_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::Factory_Base::MessageOrdinals::DoStuff: {
      break;
    }
    case internal::Factory_Base::MessageOrdinals::DoStuff2: {
      break;
    }
    case internal::Factory_Base::MessageOrdinals::CreateNamedObject: {
      internal::Factory_CreateNamedObject_Params_Data* params =
          reinterpret_cast<internal::Factory_CreateNamedObject_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      
      mojo::InterfaceRequest<NamedObject> p_obj {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_obj.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&params->obj)));
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->CreateNamedObject(p_obj.Pass());
      return true;
    }
    case internal::Factory_Base::MessageOrdinals::RequestImportedInterface: {
      break;
    }
    case internal::Factory_Base::MessageOrdinals::TakeImportedInterface: {
      break;
    }
  }
  return false;
}

bool FactoryStub::AcceptWithResponder(
    mojo::Message* message, mojo::MessageReceiverWithStatus* responder) {
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message))
    return control_message_handler_.AcceptWithResponder(message, responder);
  internal::Factory_Base::MessageOrdinals method_ordinal =
      static_cast<internal::Factory_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::Factory_Base::MessageOrdinals::DoStuff: {
      internal::Factory_DoStuff_Params_Data* params =
          reinterpret_cast<internal::Factory_DoStuff_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Factory::DoStuffCallback::Runnable* runnable =
          new Factory_DoStuff_ProxyToResponder(
              message->request_id(), responder);
      Factory::DoStuffCallback callback(runnable);
      
      RequestPtr p_request {};
      mojo::ScopedMessagePipeHandle p_pipe {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        if (params->request.ptr) {
          p_request = Request::New();
          Deserialize_(params->request.ptr, p_request.get());
        }
        p_pipe.reset(mojo::internal::FetchAndReset(&params->pipe));
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->DoStuff(p_request.Pass(), p_pipe.Pass(), callback);
      return true;
    }
    case internal::Factory_Base::MessageOrdinals::DoStuff2: {
      internal::Factory_DoStuff2_Params_Data* params =
          reinterpret_cast<internal::Factory_DoStuff2_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Factory::DoStuff2Callback::Runnable* runnable =
          new Factory_DoStuff2_ProxyToResponder(
              message->request_id(), responder);
      Factory::DoStuff2Callback callback(runnable);
      
      mojo::ScopedDataPipeConsumerHandle p_pipe {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_pipe.reset(mojo::internal::FetchAndReset(&params->pipe));
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->DoStuff2(p_pipe.Pass(), callback);
      return true;
    }
    case internal::Factory_Base::MessageOrdinals::CreateNamedObject: {
      break;
    }
    case internal::Factory_Base::MessageOrdinals::RequestImportedInterface: {
      internal::Factory_RequestImportedInterface_Params_Data* params =
          reinterpret_cast<internal::Factory_RequestImportedInterface_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Factory::RequestImportedInterfaceCallback::Runnable* runnable =
          new Factory_RequestImportedInterface_ProxyToResponder(
              message->request_id(), responder);
      Factory::RequestImportedInterfaceCallback callback(runnable);
      
      mojo::InterfaceRequest<imported::ImportedInterface> p_obj {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        p_obj.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&params->obj)));
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->RequestImportedInterface(p_obj.Pass(), callback);
      return true;
    }
    case internal::Factory_Base::MessageOrdinals::TakeImportedInterface: {
      internal::Factory_TakeImportedInterface_Params_Data* params =
          reinterpret_cast<internal::Factory_TakeImportedInterface_Params_Data*>(
              message->mutable_payload());

      params->DecodePointersAndHandles(message->mutable_handles());
      Factory::TakeImportedInterfaceCallback::Runnable* runnable =
          new Factory_TakeImportedInterface_ProxyToResponder(
              message->request_id(), responder);
      Factory::TakeImportedInterfaceCallback callback(runnable);
      
      mojo::InterfaceHandle<imported::ImportedInterface> p_obj {};
      do {
        // NOTE: The memory backing |params| may has be smaller than
        // |sizeof(*params)| if the message comes from an older version.
        mojo::internal::InterfaceDataToHandle(&params->obj, &p_obj);
      } while (false);
      // A null |sink_| means no implementation was bound.
      assert(sink_);
      sink_->TakeImportedInterface(p_obj.Pass(), callback);
      return true;
    }
  }
  return false;
}

}  // namespace sample
