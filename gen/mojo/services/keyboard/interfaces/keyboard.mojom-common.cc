// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/services/keyboard/interfaces/keyboard.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace keyboard {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// static
CompletionData_Data* CompletionData_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(CompletionData_Data))) CompletionData_Data();
}

// static
mojo::internal::ValidationError CompletionData_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const CompletionData_Data* object = static_cast<const CompletionData_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 40 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->text.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null text field in CompletionData struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->text.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams text_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->text.offset),
          bounds_checker, &text_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->label.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null label field in CompletionData struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->label.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams label_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->label.offset),
          bounds_checker, &label_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void CompletionData_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->text, handles);
  mojo::internal::Encode(&this->label, handles);
}

void CompletionData_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->text, handles);
  mojo::internal::Decode(&this->label, handles);
}

CompletionData_Data::CompletionData_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
CorrectionData_Data* CorrectionData_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(CorrectionData_Data))) CorrectionData_Data();
}

// static
mojo::internal::ValidationError CorrectionData_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const CorrectionData_Data* object = static_cast<const CorrectionData_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->old_text.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null old_text field in CorrectionData struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->old_text.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams old_text_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->old_text.offset),
          bounds_checker, &old_text_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!object->new_text.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null new_text field in CorrectionData struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->new_text.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams new_text_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->new_text.offset),
          bounds_checker, &new_text_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void CorrectionData_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->old_text, handles);
  mojo::internal::Encode(&this->new_text, handles);
}

void CorrectionData_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->old_text, handles);
  mojo::internal::Decode(&this->new_text, handles);
}

CorrectionData_Data::CorrectionData_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// --- Union definitions ---


// --- Definitions of the data structs for interface methods ---


// static
KeyboardClient_CommitCompletion_Params_Data* KeyboardClient_CommitCompletion_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardClient_CommitCompletion_Params_Data))) KeyboardClient_CommitCompletion_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardClient_CommitCompletion_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardClient_CommitCompletion_Params_Data* object = static_cast<const KeyboardClient_CommitCompletion_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->completion.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null completion field in KeyboardClient_CommitCompletion_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->completion.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = CompletionData::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->completion.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardClient_CommitCompletion_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->completion, handles);
}

void KeyboardClient_CommitCompletion_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->completion, handles);
}

KeyboardClient_CommitCompletion_Params_Data::KeyboardClient_CommitCompletion_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
KeyboardClient_CommitCorrection_Params_Data* KeyboardClient_CommitCorrection_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardClient_CommitCorrection_Params_Data))) KeyboardClient_CommitCorrection_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardClient_CommitCorrection_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardClient_CommitCorrection_Params_Data* object = static_cast<const KeyboardClient_CommitCorrection_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->correction.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null correction field in KeyboardClient_CommitCorrection_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->correction.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = CorrectionData::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->correction.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardClient_CommitCorrection_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->correction, handles);
}

void KeyboardClient_CommitCorrection_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->correction, handles);
}

KeyboardClient_CommitCorrection_Params_Data::KeyboardClient_CommitCorrection_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
KeyboardClient_CommitText_Params_Data* KeyboardClient_CommitText_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardClient_CommitText_Params_Data))) KeyboardClient_CommitText_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardClient_CommitText_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardClient_CommitText_Params_Data* object = static_cast<const KeyboardClient_CommitText_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->text.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null text field in KeyboardClient_CommitText_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->text.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams text_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->text.offset),
          bounds_checker, &text_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardClient_CommitText_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->text, handles);
}

void KeyboardClient_CommitText_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->text, handles);
}

KeyboardClient_CommitText_Params_Data::KeyboardClient_CommitText_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
KeyboardClient_DeleteSurroundingText_Params_Data* KeyboardClient_DeleteSurroundingText_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardClient_DeleteSurroundingText_Params_Data))) KeyboardClient_DeleteSurroundingText_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardClient_DeleteSurroundingText_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardClient_DeleteSurroundingText_Params_Data* object = static_cast<const KeyboardClient_DeleteSurroundingText_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardClient_DeleteSurroundingText_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void KeyboardClient_DeleteSurroundingText_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

KeyboardClient_DeleteSurroundingText_Params_Data::KeyboardClient_DeleteSurroundingText_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
KeyboardClient_SetComposingRegion_Params_Data* KeyboardClient_SetComposingRegion_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardClient_SetComposingRegion_Params_Data))) KeyboardClient_SetComposingRegion_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardClient_SetComposingRegion_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardClient_SetComposingRegion_Params_Data* object = static_cast<const KeyboardClient_SetComposingRegion_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardClient_SetComposingRegion_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void KeyboardClient_SetComposingRegion_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

KeyboardClient_SetComposingRegion_Params_Data::KeyboardClient_SetComposingRegion_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
KeyboardClient_SetComposingText_Params_Data* KeyboardClient_SetComposingText_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardClient_SetComposingText_Params_Data))) KeyboardClient_SetComposingText_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardClient_SetComposingText_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardClient_SetComposingText_Params_Data* object = static_cast<const KeyboardClient_SetComposingText_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->text.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null text field in KeyboardClient_SetComposingText_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->text.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams text_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->text.offset),
          bounds_checker, &text_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardClient_SetComposingText_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->text, handles);
}

void KeyboardClient_SetComposingText_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->text, handles);
}

KeyboardClient_SetComposingText_Params_Data::KeyboardClient_SetComposingText_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
KeyboardClient_SetSelection_Params_Data* KeyboardClient_SetSelection_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardClient_SetSelection_Params_Data))) KeyboardClient_SetSelection_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardClient_SetSelection_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardClient_SetSelection_Params_Data* object = static_cast<const KeyboardClient_SetSelection_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardClient_SetSelection_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void KeyboardClient_SetSelection_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

KeyboardClient_SetSelection_Params_Data::KeyboardClient_SetSelection_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
KeyboardClient_Submit_Params_Data* KeyboardClient_Submit_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardClient_Submit_Params_Data))) KeyboardClient_Submit_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardClient_Submit_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardClient_Submit_Params_Data* object = static_cast<const KeyboardClient_Submit_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardClient_Submit_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void KeyboardClient_Submit_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

KeyboardClient_Submit_Params_Data::KeyboardClient_Submit_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
KeyboardService_Show_Params_Data* KeyboardService_Show_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardService_Show_Params_Data))) KeyboardService_Show_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardService_Show_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardService_Show_Params_Data* object = static_cast<const KeyboardService_Show_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle client_handle = object->client.handle;
  if (client_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid client field in KeyboardService_Show_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(client_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardService_Show_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->client, handles);
}

void KeyboardService_Show_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->client, handles);
}

KeyboardService_Show_Params_Data::KeyboardService_Show_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
KeyboardService_ShowByRequest_Params_Data* KeyboardService_ShowByRequest_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardService_ShowByRequest_Params_Data))) KeyboardService_ShowByRequest_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardService_ShowByRequest_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardService_ShowByRequest_Params_Data* object = static_cast<const KeyboardService_ShowByRequest_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardService_ShowByRequest_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void KeyboardService_ShowByRequest_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

KeyboardService_ShowByRequest_Params_Data::KeyboardService_ShowByRequest_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
KeyboardService_Hide_Params_Data* KeyboardService_Hide_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardService_Hide_Params_Data))) KeyboardService_Hide_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardService_Hide_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardService_Hide_Params_Data* object = static_cast<const KeyboardService_Hide_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardService_Hide_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void KeyboardService_Hide_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

KeyboardService_Hide_Params_Data::KeyboardService_Hide_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
KeyboardService_SetText_Params_Data* KeyboardService_SetText_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardService_SetText_Params_Data))) KeyboardService_SetText_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardService_SetText_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardService_SetText_Params_Data* object = static_cast<const KeyboardService_SetText_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->text.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null text field in KeyboardService_SetText_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->text.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams text_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->text.offset),
          bounds_checker, &text_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardService_SetText_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->text, handles);
}

void KeyboardService_SetText_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->text, handles);
}

KeyboardService_SetText_Params_Data::KeyboardService_SetText_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
KeyboardService_SetSelection_Params_Data* KeyboardService_SetSelection_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardService_SetSelection_Params_Data))) KeyboardService_SetSelection_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardService_SetSelection_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardService_SetSelection_Params_Data* object = static_cast<const KeyboardService_SetSelection_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardService_SetSelection_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void KeyboardService_SetSelection_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

KeyboardService_SetSelection_Params_Data::KeyboardService_SetSelection_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}



// static
KeyboardServiceFactory_CreateKeyboardService_Params_Data* KeyboardServiceFactory_CreateKeyboardService_Params_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(KeyboardServiceFactory_CreateKeyboardService_Params_Data))) KeyboardServiceFactory_CreateKeyboardService_Params_Data();
}

// static
mojo::internal::ValidationError KeyboardServiceFactory_CreateKeyboardService_Params_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const KeyboardServiceFactory_CreateKeyboardService_Params_Data* object = static_cast<const KeyboardServiceFactory_CreateKeyboardService_Params_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle keyEventDispatcher_handle = object->keyEventDispatcher;
  if (keyEventDispatcher_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid keyEventDispatcher field in KeyboardServiceFactory_CreateKeyboardService_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(keyEventDispatcher_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  const mojo::Handle serviceRequest_handle = object->serviceRequest;
  if (serviceRequest_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid serviceRequest field in KeyboardServiceFactory_CreateKeyboardService_Params struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(serviceRequest_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void KeyboardServiceFactory_CreateKeyboardService_Params_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->keyEventDispatcher, handles);
  mojo::internal::EncodeHandle(&this->serviceRequest, handles);
}

void KeyboardServiceFactory_CreateKeyboardService_Params_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->keyEventDispatcher, handles);
  mojo::internal::DecodeHandle(&this->serviceRequest, handles);
}

KeyboardServiceFactory_CreateKeyboardService_Params_Data::KeyboardServiceFactory_CreateKeyboardService_Params_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


}  // namespace internal

// --- Request and response validator definitions for interfaces ---
mojo::internal::ValidationError KeyboardClientRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'KeyboardClient', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::KeyboardClient_Base::MessageOrdinals method_ordinal =
      static_cast<internal::KeyboardClient_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::KeyboardClient_Base::MessageOrdinals::CommitCompletion: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardClient', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardClient_CommitCompletion_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardClient', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::KeyboardClient_Base::MessageOrdinals::CommitCorrection: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardClient', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardClient_CommitCorrection_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardClient', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::KeyboardClient_Base::MessageOrdinals::CommitText: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardClient', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardClient_CommitText_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardClient', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::KeyboardClient_Base::MessageOrdinals::DeleteSurroundingText: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardClient', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardClient_DeleteSurroundingText_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardClient', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::KeyboardClient_Base::MessageOrdinals::SetComposingRegion: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardClient', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardClient_SetComposingRegion_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardClient', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::KeyboardClient_Base::MessageOrdinals::SetComposingText: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardClient', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardClient_SetComposingText_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardClient', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::KeyboardClient_Base::MessageOrdinals::SetSelection: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardClient', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardClient_SetSelection_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardClient', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::KeyboardClient_Base::MessageOrdinals::Submit: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardClient', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardClient_Submit_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardClient', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'KeyboardClient'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError KeyboardServiceRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'KeyboardService', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::KeyboardService_Base::MessageOrdinals method_ordinal =
      static_cast<internal::KeyboardService_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::KeyboardService_Base::MessageOrdinals::Show: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardService', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardService_Show_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardService', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::KeyboardService_Base::MessageOrdinals::ShowByRequest: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardService', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardService_ShowByRequest_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardService', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::KeyboardService_Base::MessageOrdinals::Hide: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardService', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardService_Hide_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardService', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::KeyboardService_Base::MessageOrdinals::SetText: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardService', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardService_SetText_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardService', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    case internal::KeyboardService_Base::MessageOrdinals::SetSelection: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardService', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardService_SetSelection_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardService', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'KeyboardService'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
}
mojo::internal::ValidationError KeyboardServiceFactoryRequestValidator::Validate(
    const mojo::Message* message,
    std::string* err) {
  mojo::internal::ValidationError retval;
  if (mojo::internal::ControlMessageHandler::IsControlMessage(message)) {
    retval = mojo::internal::ValidateControlRequest(message, err);
    if (retval != mojo::internal::ValidationError::NONE) {
      MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "request validation error for interface 'KeyboardServiceFactory', "
           "message name '" << message->header()->name << "': " <<
           (err ? *err : "");
      ReportValidationError(retval, err);
      return retval;
    }
    return mojo::internal::ValidationError::NONE;
  }

  internal::KeyboardServiceFactory_Base::MessageOrdinals method_ordinal =
      static_cast<internal::KeyboardServiceFactory_Base::MessageOrdinals>(message->header()->name);
  switch (method_ordinal) {
    case internal::KeyboardServiceFactory_Base::MessageOrdinals::CreateKeyboardService: {
      retval = mojo::internal::ValidateMessageIsRequestWithoutResponse(message,
                                                                       err);
      if (retval != mojo::internal::ValidationError::NONE) {
        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
          << "request validation error for interface 'KeyboardServiceFactory', "
             "message name '" << message->header()->name << "': " <<
             (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      retval = mojo::internal::ValidateMessagePayload<
                 internal::KeyboardServiceFactory_CreateKeyboardService_Params_Data>(
                    message, err); 
      if (retval != mojo::internal::ValidationError::NONE) {
         MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
            << "request validation error for interface 'KeyboardServiceFactory', "
               "message name '" << message->header()->name << "': " <<
               (err ? *err : "");
        ReportValidationError(retval, err);
        return retval;
      }
      return mojo::internal::ValidationError::NONE;
    }
    default:
      break;
  }

  // Unrecognized message.
  MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "unknown request message name '"
                                         << message->header()->name
                                         << "' for interface "
                                            "'KeyboardServiceFactory'";
  ReportValidationError(
      mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD, err);
  return mojo::internal::ValidationError::MESSAGE_HEADER_UNKNOWN_METHOD;
} 

// --- Enums ---
bool SubmitAction_IsValidValue(SubmitAction value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const SubmitAction& val) {
  return (stream << static_cast<int32_t>(val));
}
bool KeyboardType_IsValidValue(KeyboardType value) {
  switch (static_cast<int32_t>(value)) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
  }
  return false;
}
  
std::ostream& operator<<(std::ostream& stream, const KeyboardType& val) {
  return (stream << static_cast<int32_t>(val));
}

// Base interface definitions (Name_, Version_, Constants, Enums)
const uint32_t internal::KeyboardClient_Base::Version_;

// Constants

// Enums
const char internal::KeyboardService_Base::Name_[] = "keyboard::KeyboardService";
const uint32_t internal::KeyboardService_Base::Version_;

// Constants

// Enums
const char internal::KeyboardServiceFactory_Base::Name_[] = "keyboard::KeyboardServiceFactory";
const uint32_t internal::KeyboardServiceFactory_Base::Version_;

// Constants

// Enums

// Struct Constants

// --- Struct builder definitions ---

// static
CompletionDataPtr CompletionData::New() {
  CompletionDataPtr rv;
  mojo::internal::StructHelper<CompletionData>::Initialize(&rv);
  return rv;
}

CompletionData::CompletionData()
    : id(),
      position(),
      text(),
      label() {
}

CompletionData::~CompletionData() {
}


CompletionDataPtr CompletionData::Clone() const {
  CompletionDataPtr rv(New());
  rv->id = id;
  rv->position = position;
  rv->text = text;
  rv->label = label;
  return rv;
}


bool CompletionData::Equals(const CompletionData& other) const {
  if (!mojo::internal::ValueTraits<int64_t>::Equals(this->id, other.id))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->position, other.position))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->text, other.text))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->label, other.label))
    return false;
  return true;
}


// static
CorrectionDataPtr CorrectionData::New() {
  CorrectionDataPtr rv;
  mojo::internal::StructHelper<CorrectionData>::Initialize(&rv);
  return rv;
}

CorrectionData::CorrectionData()
    : offset(),
      old_text(),
      new_text() {
}

CorrectionData::~CorrectionData() {
}


CorrectionDataPtr CorrectionData::Clone() const {
  CorrectionDataPtr rv(New());
  rv->offset = offset;
  rv->old_text = old_text;
  rv->new_text = new_text;
  return rv;
}


bool CorrectionData::Equals(const CorrectionData& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->offset, other.offset))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->old_text, other.old_text))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->new_text, other.new_text))
    return false;
  return true;
}


// --- Union builder definitions ---

// --- Struct Serialization Helpers ---

size_t CompletionData::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool CompletionData::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::CompletionData_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool CompletionData::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::CompletionData_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void CompletionData::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::CompletionData_Data* input =
      static_cast<internal::CompletionData_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const CompletionData& input) {
  size_t size = sizeof(internal::CompletionData_Data);
  size += GetSerializedSize_(input.text);
  size += GetSerializedSize_(input.label);
  return size;
}

mojo::internal::ValidationError Serialize_(
    CompletionData* input,
    mojo::internal::Buffer* buf,
    internal::CompletionData_Data** output) {
  if (input) {
    internal::CompletionData_Data* result =
        internal::CompletionData_Data::New(buf);
    result->id = input->id;
    result->position = input->position;
    SerializeString_(input->text, buf, &result->text.ptr);
    if (!result->text.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null text in CompletionData struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    SerializeString_(input->label, buf, &result->label.ptr);
    if (!result->label.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null label in CompletionData struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::CompletionData_Data* input,
                  CompletionData* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->id = input->id;
      result->position = input->position;
      Deserialize_(input->text.ptr, &result->text);
      Deserialize_(input->label.ptr, &result->label);
    } while (false);
  }
}


size_t CorrectionData::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool CorrectionData::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::CorrectionData_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool CorrectionData::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::CorrectionData_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void CorrectionData::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::CorrectionData_Data* input =
      static_cast<internal::CorrectionData_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const CorrectionData& input) {
  size_t size = sizeof(internal::CorrectionData_Data);
  size += GetSerializedSize_(input.old_text);
  size += GetSerializedSize_(input.new_text);
  return size;
}

mojo::internal::ValidationError Serialize_(
    CorrectionData* input,
    mojo::internal::Buffer* buf,
    internal::CorrectionData_Data** output) {
  if (input) {
    internal::CorrectionData_Data* result =
        internal::CorrectionData_Data::New(buf);
    result->offset = input->offset;
    SerializeString_(input->old_text, buf, &result->old_text.ptr);
    if (!result->old_text.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null old_text in CorrectionData struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    SerializeString_(input->new_text, buf, &result->new_text.ptr);
    if (!result->new_text.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null new_text in CorrectionData struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::CorrectionData_Data* input,
                  CorrectionData* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->offset = input->offset;
      Deserialize_(input->old_text.ptr, &result->old_text);
      Deserialize_(input->new_text.ptr, &result->new_text);
    } while (false);
  }
}


// --- Union Serialization Helpers ---

// --- Structs for interface method parameters ---


// static
KeyboardClient_CommitCompletion_ParamsPtr KeyboardClient_CommitCompletion_Params::New() {
  KeyboardClient_CommitCompletion_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardClient_CommitCompletion_Params>::Initialize(&rv);
  return rv;
}

KeyboardClient_CommitCompletion_Params::KeyboardClient_CommitCompletion_Params()
    : completion() {
}

KeyboardClient_CommitCompletion_Params::~KeyboardClient_CommitCompletion_Params() {
}


KeyboardClient_CommitCompletion_ParamsPtr KeyboardClient_CommitCompletion_Params::Clone() const {
  KeyboardClient_CommitCompletion_ParamsPtr rv(New());
  rv->completion = completion.Clone();
  return rv;
}


bool KeyboardClient_CommitCompletion_Params::Equals(const KeyboardClient_CommitCompletion_Params& other) const {
  if (!mojo::internal::ValueTraits<CompletionDataPtr>::Equals(this->completion, other.completion))
    return false;
  return true;
}


size_t KeyboardClient_CommitCompletion_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardClient_CommitCompletion_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardClient_CommitCompletion_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardClient_CommitCompletion_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardClient_CommitCompletion_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardClient_CommitCompletion_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardClient_CommitCompletion_Params_Data* input =
      static_cast<internal::KeyboardClient_CommitCompletion_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardClient_CommitCompletion_Params& input) {
  size_t size = sizeof(internal::KeyboardClient_CommitCompletion_Params_Data);
  size += input.completion.is_null()
              ? 0
              : GetSerializedSize_(*input.completion);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardClient_CommitCompletion_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardClient_CommitCompletion_Params_Data** output) {
  if (input) {
    internal::KeyboardClient_CommitCompletion_Params_Data* result =
        internal::KeyboardClient_CommitCompletion_Params_Data::New(buf);
    {auto retval =Serialize_(input->completion.get(),
                 buf,
                 &result->completion.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->completion.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null completion in KeyboardClient_CommitCompletion_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardClient_CommitCompletion_Params_Data* input,
                  KeyboardClient_CommitCompletion_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->completion.ptr) {
        result->completion = CompletionData::New();
        Deserialize_(input->completion.ptr, result->completion.get());
      }
    } while (false);
  }
}



// static
KeyboardClient_CommitCorrection_ParamsPtr KeyboardClient_CommitCorrection_Params::New() {
  KeyboardClient_CommitCorrection_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardClient_CommitCorrection_Params>::Initialize(&rv);
  return rv;
}

KeyboardClient_CommitCorrection_Params::KeyboardClient_CommitCorrection_Params()
    : correction() {
}

KeyboardClient_CommitCorrection_Params::~KeyboardClient_CommitCorrection_Params() {
}


KeyboardClient_CommitCorrection_ParamsPtr KeyboardClient_CommitCorrection_Params::Clone() const {
  KeyboardClient_CommitCorrection_ParamsPtr rv(New());
  rv->correction = correction.Clone();
  return rv;
}


bool KeyboardClient_CommitCorrection_Params::Equals(const KeyboardClient_CommitCorrection_Params& other) const {
  if (!mojo::internal::ValueTraits<CorrectionDataPtr>::Equals(this->correction, other.correction))
    return false;
  return true;
}


size_t KeyboardClient_CommitCorrection_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardClient_CommitCorrection_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardClient_CommitCorrection_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardClient_CommitCorrection_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardClient_CommitCorrection_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardClient_CommitCorrection_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardClient_CommitCorrection_Params_Data* input =
      static_cast<internal::KeyboardClient_CommitCorrection_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardClient_CommitCorrection_Params& input) {
  size_t size = sizeof(internal::KeyboardClient_CommitCorrection_Params_Data);
  size += input.correction.is_null()
              ? 0
              : GetSerializedSize_(*input.correction);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardClient_CommitCorrection_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardClient_CommitCorrection_Params_Data** output) {
  if (input) {
    internal::KeyboardClient_CommitCorrection_Params_Data* result =
        internal::KeyboardClient_CommitCorrection_Params_Data::New(buf);
    {auto retval =Serialize_(input->correction.get(),
                 buf,
                 &result->correction.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->correction.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null correction in KeyboardClient_CommitCorrection_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardClient_CommitCorrection_Params_Data* input,
                  KeyboardClient_CommitCorrection_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->correction.ptr) {
        result->correction = CorrectionData::New();
        Deserialize_(input->correction.ptr, result->correction.get());
      }
    } while (false);
  }
}



// static
KeyboardClient_CommitText_ParamsPtr KeyboardClient_CommitText_Params::New() {
  KeyboardClient_CommitText_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardClient_CommitText_Params>::Initialize(&rv);
  return rv;
}

KeyboardClient_CommitText_Params::KeyboardClient_CommitText_Params()
    : text(),
      newCursorPosition() {
}

KeyboardClient_CommitText_Params::~KeyboardClient_CommitText_Params() {
}


KeyboardClient_CommitText_ParamsPtr KeyboardClient_CommitText_Params::Clone() const {
  KeyboardClient_CommitText_ParamsPtr rv(New());
  rv->text = text;
  rv->newCursorPosition = newCursorPosition;
  return rv;
}


bool KeyboardClient_CommitText_Params::Equals(const KeyboardClient_CommitText_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->text, other.text))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->newCursorPosition, other.newCursorPosition))
    return false;
  return true;
}


size_t KeyboardClient_CommitText_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardClient_CommitText_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardClient_CommitText_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardClient_CommitText_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardClient_CommitText_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardClient_CommitText_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardClient_CommitText_Params_Data* input =
      static_cast<internal::KeyboardClient_CommitText_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardClient_CommitText_Params& input) {
  size_t size = sizeof(internal::KeyboardClient_CommitText_Params_Data);
  size += GetSerializedSize_(input.text);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardClient_CommitText_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardClient_CommitText_Params_Data** output) {
  if (input) {
    internal::KeyboardClient_CommitText_Params_Data* result =
        internal::KeyboardClient_CommitText_Params_Data::New(buf);
    SerializeString_(input->text, buf, &result->text.ptr);
    if (!result->text.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null text in KeyboardClient_CommitText_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->newCursorPosition = input->newCursorPosition;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardClient_CommitText_Params_Data* input,
                  KeyboardClient_CommitText_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->text.ptr, &result->text);
      result->newCursorPosition = input->newCursorPosition;
    } while (false);
  }
}



// static
KeyboardClient_DeleteSurroundingText_ParamsPtr KeyboardClient_DeleteSurroundingText_Params::New() {
  KeyboardClient_DeleteSurroundingText_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardClient_DeleteSurroundingText_Params>::Initialize(&rv);
  return rv;
}

KeyboardClient_DeleteSurroundingText_Params::KeyboardClient_DeleteSurroundingText_Params()
    : beforeLength(),
      afterLength() {
}

KeyboardClient_DeleteSurroundingText_Params::~KeyboardClient_DeleteSurroundingText_Params() {
}


KeyboardClient_DeleteSurroundingText_ParamsPtr KeyboardClient_DeleteSurroundingText_Params::Clone() const {
  KeyboardClient_DeleteSurroundingText_ParamsPtr rv(New());
  rv->beforeLength = beforeLength;
  rv->afterLength = afterLength;
  return rv;
}


bool KeyboardClient_DeleteSurroundingText_Params::Equals(const KeyboardClient_DeleteSurroundingText_Params& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->beforeLength, other.beforeLength))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->afterLength, other.afterLength))
    return false;
  return true;
}


size_t KeyboardClient_DeleteSurroundingText_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardClient_DeleteSurroundingText_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardClient_DeleteSurroundingText_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardClient_DeleteSurroundingText_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardClient_DeleteSurroundingText_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardClient_DeleteSurroundingText_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardClient_DeleteSurroundingText_Params_Data* input =
      static_cast<internal::KeyboardClient_DeleteSurroundingText_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardClient_DeleteSurroundingText_Params& input) {
  size_t size = sizeof(internal::KeyboardClient_DeleteSurroundingText_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardClient_DeleteSurroundingText_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardClient_DeleteSurroundingText_Params_Data** output) {
  if (input) {
    internal::KeyboardClient_DeleteSurroundingText_Params_Data* result =
        internal::KeyboardClient_DeleteSurroundingText_Params_Data::New(buf);
    result->beforeLength = input->beforeLength;
    result->afterLength = input->afterLength;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardClient_DeleteSurroundingText_Params_Data* input,
                  KeyboardClient_DeleteSurroundingText_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->beforeLength = input->beforeLength;
      result->afterLength = input->afterLength;
    } while (false);
  }
}



// static
KeyboardClient_SetComposingRegion_ParamsPtr KeyboardClient_SetComposingRegion_Params::New() {
  KeyboardClient_SetComposingRegion_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardClient_SetComposingRegion_Params>::Initialize(&rv);
  return rv;
}

KeyboardClient_SetComposingRegion_Params::KeyboardClient_SetComposingRegion_Params()
    : start(),
      end() {
}

KeyboardClient_SetComposingRegion_Params::~KeyboardClient_SetComposingRegion_Params() {
}


KeyboardClient_SetComposingRegion_ParamsPtr KeyboardClient_SetComposingRegion_Params::Clone() const {
  KeyboardClient_SetComposingRegion_ParamsPtr rv(New());
  rv->start = start;
  rv->end = end;
  return rv;
}


bool KeyboardClient_SetComposingRegion_Params::Equals(const KeyboardClient_SetComposingRegion_Params& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->start, other.start))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->end, other.end))
    return false;
  return true;
}


size_t KeyboardClient_SetComposingRegion_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardClient_SetComposingRegion_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardClient_SetComposingRegion_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardClient_SetComposingRegion_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardClient_SetComposingRegion_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardClient_SetComposingRegion_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardClient_SetComposingRegion_Params_Data* input =
      static_cast<internal::KeyboardClient_SetComposingRegion_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardClient_SetComposingRegion_Params& input) {
  size_t size = sizeof(internal::KeyboardClient_SetComposingRegion_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardClient_SetComposingRegion_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardClient_SetComposingRegion_Params_Data** output) {
  if (input) {
    internal::KeyboardClient_SetComposingRegion_Params_Data* result =
        internal::KeyboardClient_SetComposingRegion_Params_Data::New(buf);
    result->start = input->start;
    result->end = input->end;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardClient_SetComposingRegion_Params_Data* input,
                  KeyboardClient_SetComposingRegion_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->start = input->start;
      result->end = input->end;
    } while (false);
  }
}



// static
KeyboardClient_SetComposingText_ParamsPtr KeyboardClient_SetComposingText_Params::New() {
  KeyboardClient_SetComposingText_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardClient_SetComposingText_Params>::Initialize(&rv);
  return rv;
}

KeyboardClient_SetComposingText_Params::KeyboardClient_SetComposingText_Params()
    : text(),
      newCursorPosition() {
}

KeyboardClient_SetComposingText_Params::~KeyboardClient_SetComposingText_Params() {
}


KeyboardClient_SetComposingText_ParamsPtr KeyboardClient_SetComposingText_Params::Clone() const {
  KeyboardClient_SetComposingText_ParamsPtr rv(New());
  rv->text = text;
  rv->newCursorPosition = newCursorPosition;
  return rv;
}


bool KeyboardClient_SetComposingText_Params::Equals(const KeyboardClient_SetComposingText_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->text, other.text))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->newCursorPosition, other.newCursorPosition))
    return false;
  return true;
}


size_t KeyboardClient_SetComposingText_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardClient_SetComposingText_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardClient_SetComposingText_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardClient_SetComposingText_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardClient_SetComposingText_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardClient_SetComposingText_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardClient_SetComposingText_Params_Data* input =
      static_cast<internal::KeyboardClient_SetComposingText_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardClient_SetComposingText_Params& input) {
  size_t size = sizeof(internal::KeyboardClient_SetComposingText_Params_Data);
  size += GetSerializedSize_(input.text);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardClient_SetComposingText_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardClient_SetComposingText_Params_Data** output) {
  if (input) {
    internal::KeyboardClient_SetComposingText_Params_Data* result =
        internal::KeyboardClient_SetComposingText_Params_Data::New(buf);
    SerializeString_(input->text, buf, &result->text.ptr);
    if (!result->text.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null text in KeyboardClient_SetComposingText_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    result->newCursorPosition = input->newCursorPosition;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardClient_SetComposingText_Params_Data* input,
                  KeyboardClient_SetComposingText_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->text.ptr, &result->text);
      result->newCursorPosition = input->newCursorPosition;
    } while (false);
  }
}



// static
KeyboardClient_SetSelection_ParamsPtr KeyboardClient_SetSelection_Params::New() {
  KeyboardClient_SetSelection_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardClient_SetSelection_Params>::Initialize(&rv);
  return rv;
}

KeyboardClient_SetSelection_Params::KeyboardClient_SetSelection_Params()
    : start(),
      end() {
}

KeyboardClient_SetSelection_Params::~KeyboardClient_SetSelection_Params() {
}


KeyboardClient_SetSelection_ParamsPtr KeyboardClient_SetSelection_Params::Clone() const {
  KeyboardClient_SetSelection_ParamsPtr rv(New());
  rv->start = start;
  rv->end = end;
  return rv;
}


bool KeyboardClient_SetSelection_Params::Equals(const KeyboardClient_SetSelection_Params& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->start, other.start))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->end, other.end))
    return false;
  return true;
}


size_t KeyboardClient_SetSelection_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardClient_SetSelection_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardClient_SetSelection_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardClient_SetSelection_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardClient_SetSelection_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardClient_SetSelection_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardClient_SetSelection_Params_Data* input =
      static_cast<internal::KeyboardClient_SetSelection_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardClient_SetSelection_Params& input) {
  size_t size = sizeof(internal::KeyboardClient_SetSelection_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardClient_SetSelection_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardClient_SetSelection_Params_Data** output) {
  if (input) {
    internal::KeyboardClient_SetSelection_Params_Data* result =
        internal::KeyboardClient_SetSelection_Params_Data::New(buf);
    result->start = input->start;
    result->end = input->end;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardClient_SetSelection_Params_Data* input,
                  KeyboardClient_SetSelection_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->start = input->start;
      result->end = input->end;
    } while (false);
  }
}



// static
KeyboardClient_Submit_ParamsPtr KeyboardClient_Submit_Params::New() {
  KeyboardClient_Submit_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardClient_Submit_Params>::Initialize(&rv);
  return rv;
}

KeyboardClient_Submit_Params::KeyboardClient_Submit_Params()
    : action() {
}

KeyboardClient_Submit_Params::~KeyboardClient_Submit_Params() {
}


KeyboardClient_Submit_ParamsPtr KeyboardClient_Submit_Params::Clone() const {
  KeyboardClient_Submit_ParamsPtr rv(New());
  rv->action = action;
  return rv;
}


bool KeyboardClient_Submit_Params::Equals(const KeyboardClient_Submit_Params& other) const {
  if (!mojo::internal::ValueTraits<SubmitAction>::Equals(this->action, other.action))
    return false;
  return true;
}


size_t KeyboardClient_Submit_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardClient_Submit_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardClient_Submit_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardClient_Submit_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardClient_Submit_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardClient_Submit_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardClient_Submit_Params_Data* input =
      static_cast<internal::KeyboardClient_Submit_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardClient_Submit_Params& input) {
  size_t size = sizeof(internal::KeyboardClient_Submit_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardClient_Submit_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardClient_Submit_Params_Data** output) {
  if (input) {
    internal::KeyboardClient_Submit_Params_Data* result =
        internal::KeyboardClient_Submit_Params_Data::New(buf);
    result->action =
      static_cast<int32_t>(input->action);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardClient_Submit_Params_Data* input,
                  KeyboardClient_Submit_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->action = static_cast<SubmitAction>(input->action);
    } while (false);
  }
}



// static
KeyboardService_Show_ParamsPtr KeyboardService_Show_Params::New() {
  KeyboardService_Show_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardService_Show_Params>::Initialize(&rv);
  return rv;
}

KeyboardService_Show_Params::KeyboardService_Show_Params()
    : client(),
      type() {
}

KeyboardService_Show_Params::~KeyboardService_Show_Params() {
}



bool KeyboardService_Show_Params::Equals(const KeyboardService_Show_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::InterfaceHandle<KeyboardClient>>::Equals(this->client, other.client))
    return false;
  if (!mojo::internal::ValueTraits<KeyboardType>::Equals(this->type, other.type))
    return false;
  return true;
}


size_t KeyboardService_Show_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardService_Show_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardService_Show_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardService_Show_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardService_Show_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardService_Show_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardService_Show_Params_Data* input =
      static_cast<internal::KeyboardService_Show_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardService_Show_Params& input) {
  size_t size = sizeof(internal::KeyboardService_Show_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardService_Show_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardService_Show_Params_Data** output) {
  if (input) {
    internal::KeyboardService_Show_Params_Data* result =
        internal::KeyboardService_Show_Params_Data::New(buf);
    mojo::internal::InterfaceHandleToData(input->client.Pass(),
                                          &result->client);
    if (!result->client.handle.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid client in KeyboardService_Show_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    result->type =
      static_cast<int32_t>(input->type);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardService_Show_Params_Data* input,
                  KeyboardService_Show_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      mojo::internal::InterfaceDataToHandle(&input->client, &result->client);
      result->type = static_cast<KeyboardType>(input->type);
    } while (false);
  }
}



// static
KeyboardService_ShowByRequest_ParamsPtr KeyboardService_ShowByRequest_Params::New() {
  KeyboardService_ShowByRequest_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardService_ShowByRequest_Params>::Initialize(&rv);
  return rv;
}

KeyboardService_ShowByRequest_Params::KeyboardService_ShowByRequest_Params() {
}

KeyboardService_ShowByRequest_Params::~KeyboardService_ShowByRequest_Params() {
}


KeyboardService_ShowByRequest_ParamsPtr KeyboardService_ShowByRequest_Params::Clone() const {
  KeyboardService_ShowByRequest_ParamsPtr rv(New());
  return rv;
}


bool KeyboardService_ShowByRequest_Params::Equals(const KeyboardService_ShowByRequest_Params& other) const {
  return true;
}


size_t KeyboardService_ShowByRequest_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardService_ShowByRequest_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardService_ShowByRequest_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardService_ShowByRequest_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardService_ShowByRequest_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardService_ShowByRequest_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardService_ShowByRequest_Params_Data* input =
      static_cast<internal::KeyboardService_ShowByRequest_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardService_ShowByRequest_Params& input) {
  size_t size = sizeof(internal::KeyboardService_ShowByRequest_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardService_ShowByRequest_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardService_ShowByRequest_Params_Data** output) {
  if (input) {
    internal::KeyboardService_ShowByRequest_Params_Data* result =
        internal::KeyboardService_ShowByRequest_Params_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardService_ShowByRequest_Params_Data* input,
                  KeyboardService_ShowByRequest_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}



// static
KeyboardService_Hide_ParamsPtr KeyboardService_Hide_Params::New() {
  KeyboardService_Hide_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardService_Hide_Params>::Initialize(&rv);
  return rv;
}

KeyboardService_Hide_Params::KeyboardService_Hide_Params() {
}

KeyboardService_Hide_Params::~KeyboardService_Hide_Params() {
}


KeyboardService_Hide_ParamsPtr KeyboardService_Hide_Params::Clone() const {
  KeyboardService_Hide_ParamsPtr rv(New());
  return rv;
}


bool KeyboardService_Hide_Params::Equals(const KeyboardService_Hide_Params& other) const {
  return true;
}


size_t KeyboardService_Hide_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardService_Hide_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardService_Hide_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardService_Hide_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardService_Hide_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardService_Hide_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardService_Hide_Params_Data* input =
      static_cast<internal::KeyboardService_Hide_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardService_Hide_Params& input) {
  size_t size = sizeof(internal::KeyboardService_Hide_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardService_Hide_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardService_Hide_Params_Data** output) {
  if (input) {
    internal::KeyboardService_Hide_Params_Data* result =
        internal::KeyboardService_Hide_Params_Data::New(buf);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardService_Hide_Params_Data* input,
                  KeyboardService_Hide_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
    } while (false);
  }
}



// static
KeyboardService_SetText_ParamsPtr KeyboardService_SetText_Params::New() {
  KeyboardService_SetText_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardService_SetText_Params>::Initialize(&rv);
  return rv;
}

KeyboardService_SetText_Params::KeyboardService_SetText_Params()
    : text() {
}

KeyboardService_SetText_Params::~KeyboardService_SetText_Params() {
}


KeyboardService_SetText_ParamsPtr KeyboardService_SetText_Params::Clone() const {
  KeyboardService_SetText_ParamsPtr rv(New());
  rv->text = text;
  return rv;
}


bool KeyboardService_SetText_Params::Equals(const KeyboardService_SetText_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->text, other.text))
    return false;
  return true;
}


size_t KeyboardService_SetText_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardService_SetText_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardService_SetText_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardService_SetText_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardService_SetText_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardService_SetText_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardService_SetText_Params_Data* input =
      static_cast<internal::KeyboardService_SetText_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardService_SetText_Params& input) {
  size_t size = sizeof(internal::KeyboardService_SetText_Params_Data);
  size += GetSerializedSize_(input.text);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardService_SetText_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardService_SetText_Params_Data** output) {
  if (input) {
    internal::KeyboardService_SetText_Params_Data* result =
        internal::KeyboardService_SetText_Params_Data::New(buf);
    SerializeString_(input->text, buf, &result->text.ptr);
    if (!result->text.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null text in KeyboardService_SetText_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardService_SetText_Params_Data* input,
                  KeyboardService_SetText_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->text.ptr, &result->text);
    } while (false);
  }
}



// static
KeyboardService_SetSelection_ParamsPtr KeyboardService_SetSelection_Params::New() {
  KeyboardService_SetSelection_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardService_SetSelection_Params>::Initialize(&rv);
  return rv;
}

KeyboardService_SetSelection_Params::KeyboardService_SetSelection_Params()
    : start(),
      end() {
}

KeyboardService_SetSelection_Params::~KeyboardService_SetSelection_Params() {
}


KeyboardService_SetSelection_ParamsPtr KeyboardService_SetSelection_Params::Clone() const {
  KeyboardService_SetSelection_ParamsPtr rv(New());
  rv->start = start;
  rv->end = end;
  return rv;
}


bool KeyboardService_SetSelection_Params::Equals(const KeyboardService_SetSelection_Params& other) const {
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->start, other.start))
    return false;
  if (!mojo::internal::ValueTraits<int32_t>::Equals(this->end, other.end))
    return false;
  return true;
}


size_t KeyboardService_SetSelection_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardService_SetSelection_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardService_SetSelection_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardService_SetSelection_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardService_SetSelection_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardService_SetSelection_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardService_SetSelection_Params_Data* input =
      static_cast<internal::KeyboardService_SetSelection_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardService_SetSelection_Params& input) {
  size_t size = sizeof(internal::KeyboardService_SetSelection_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardService_SetSelection_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardService_SetSelection_Params_Data** output) {
  if (input) {
    internal::KeyboardService_SetSelection_Params_Data* result =
        internal::KeyboardService_SetSelection_Params_Data::New(buf);
    result->start = input->start;
    result->end = input->end;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardService_SetSelection_Params_Data* input,
                  KeyboardService_SetSelection_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->start = input->start;
      result->end = input->end;
    } while (false);
  }
}



// static
KeyboardServiceFactory_CreateKeyboardService_ParamsPtr KeyboardServiceFactory_CreateKeyboardService_Params::New() {
  KeyboardServiceFactory_CreateKeyboardService_ParamsPtr rv;
  mojo::internal::StructHelper<KeyboardServiceFactory_CreateKeyboardService_Params>::Initialize(&rv);
  return rv;
}

KeyboardServiceFactory_CreateKeyboardService_Params::KeyboardServiceFactory_CreateKeyboardService_Params()
    : keyEventDispatcher(),
      serviceRequest() {
}

KeyboardServiceFactory_CreateKeyboardService_Params::~KeyboardServiceFactory_CreateKeyboardService_Params() {
}



bool KeyboardServiceFactory_CreateKeyboardService_Params::Equals(const KeyboardServiceFactory_CreateKeyboardService_Params& other) const {
  if (!mojo::internal::ValueTraits<mojo::InterfaceRequest<mojo::NativeViewportEventDispatcher>>::Equals(this->keyEventDispatcher, other.keyEventDispatcher))
    return false;
  if (!mojo::internal::ValueTraits<mojo::InterfaceRequest<KeyboardService>>::Equals(this->serviceRequest, other.serviceRequest))
    return false;
  return true;
}


size_t KeyboardServiceFactory_CreateKeyboardService_Params::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool KeyboardServiceFactory_CreateKeyboardService_Params::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::KeyboardServiceFactory_CreateKeyboardService_Params_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool KeyboardServiceFactory_CreateKeyboardService_Params::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::KeyboardServiceFactory_CreateKeyboardService_Params_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void KeyboardServiceFactory_CreateKeyboardService_Params::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::KeyboardServiceFactory_CreateKeyboardService_Params_Data* input =
      static_cast<internal::KeyboardServiceFactory_CreateKeyboardService_Params_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const KeyboardServiceFactory_CreateKeyboardService_Params& input) {
  size_t size = sizeof(internal::KeyboardServiceFactory_CreateKeyboardService_Params_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    KeyboardServiceFactory_CreateKeyboardService_Params* input,
    mojo::internal::Buffer* buf,
    internal::KeyboardServiceFactory_CreateKeyboardService_Params_Data** output) {
  if (input) {
    internal::KeyboardServiceFactory_CreateKeyboardService_Params_Data* result =
        internal::KeyboardServiceFactory_CreateKeyboardService_Params_Data::New(buf);
    result->keyEventDispatcher = input->keyEventDispatcher.PassMessagePipe().release();
    if (!result->keyEventDispatcher.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid keyEventDispatcher in KeyboardServiceFactory_CreateKeyboardService_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    result->serviceRequest = input->serviceRequest.PassMessagePipe().release();
    if (!result->serviceRequest.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid serviceRequest in KeyboardServiceFactory_CreateKeyboardService_Params struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::KeyboardServiceFactory_CreateKeyboardService_Params_Data* input,
                  KeyboardServiceFactory_CreateKeyboardService_Params* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->keyEventDispatcher.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&input->keyEventDispatcher)));
      result->serviceRequest.Bind(mojo::MakeScopedHandle(mojo::internal::FetchAndReset(&input->serviceRequest)));
    } while (false);
  }
}

}  // namespace keyboard
