// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/services/network/interfaces/tcp_connected_socket.mojom
//

package tcp_connected_socket

import (
	service_describer "mojo/public/interfaces/bindings/service_describer"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	fmt "fmt"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
)


type TcpConnectedSocket interface {
}




type TcpConnectedSocket_Request bindings.InterfaceRequest



type TcpConnectedSocket_Pointer bindings.InterfacePointer


type TcpConnectedSocket_ServiceFactory struct{
	Delegate TcpConnectedSocket_Factory
}

type TcpConnectedSocket_Factory interface {
	Create(request TcpConnectedSocket_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *TcpConnectedSocket_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &TcpConnectedSocket_ServiceDescription{}
}

func (f *TcpConnectedSocket_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := TcpConnectedSocket_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForTcpConnectedSocket creates a message pipe for use with the
// TcpConnectedSocket interface with a TcpConnectedSocket_Request on one end and a TcpConnectedSocket_Pointer on the other.
func CreateMessagePipeForTcpConnectedSocket() (TcpConnectedSocket_Request, TcpConnectedSocket_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return TcpConnectedSocket_Request(r), TcpConnectedSocket_Pointer(p)
}


type TcpConnectedSocket_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewTcpConnectedSocketProxy(p TcpConnectedSocket_Pointer, waiter bindings.AsyncWaiter) *TcpConnectedSocket_Proxy {
	return &TcpConnectedSocket_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *TcpConnectedSocket_Proxy) Close_Proxy() {
	p.router.Close()
}

type tCPConnectedSocket_Stub struct {
	connector *bindings.Connector
	impl TcpConnectedSocket
}

func NewTcpConnectedSocketStub(r TcpConnectedSocket_Request, impl TcpConnectedSocket, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &tCPConnectedSocket_Stub{connector, impl})
}


func (f *TcpConnectedSocket_Request) ServiceDescription() service_describer.ServiceDescription {
	return &TcpConnectedSocket_ServiceDescription{}
}


type TcpConnectedSocket_ServiceDescription struct{}

func (sd *TcpConnectedSocket_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *TcpConnectedSocket_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *TcpConnectedSocket_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*TcpConnectedSocket_ServiceDescription)(nil)


func (s *tCPConnectedSocket_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

