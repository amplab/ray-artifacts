// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/public/interfaces/bindings/tests/test_unions.mojom
//

package test_unions

import (
	sort "sort"
	test_included_unions "mojo/public/interfaces/bindings/tests/test_included_unions"
	ioutil "io/ioutil"
	base64 "encoding/base64"
	fmt "fmt"
	bytes "bytes"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
	gzip "compress/gzip"
	service_describer "mojo/public/interfaces/bindings/service_describer"
)

// This global variable contains a mojom_types.RuntimeTypeInfo struct
// describing the types defined in this file and all of its imports as
// well as the top-level interfaces defined in this file.
var runtimeTypeInfo__ = mojom_types.RuntimeTypeInfo{}

func getRuntimeTypeInfo() mojom_types.RuntimeTypeInfo {
  if runtimeTypeInfo__.TypeMap == nil {
    initRuntimeTypeInfo()
  }
  return runtimeTypeInfo__
}

func initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this file.
  // The string contains the base64 encoding of the gzip-compressed bytes.
  serializedRuntimeTypeInfo := "H4sIAAAJbogC/+xdTXDbxhVekKJM2WrMxD9h4raRnaZVklqUf6py0rRVx1YiNRNJjdzEaTpDQSQYUkMSDEkkcdqZ6qhjjjn62KOPOfboo48++qijjr41APhWxD7sAgsaXMCSMQOvQT0C+773s2/fPiyLZHgUoF2EFn9O2zxqMd1Bdtjet89z9vkDfP4jtI+hfQrtnDZsl6FtQLsP7X+hfQjtAbSFDPQX2m1o96F9AO1jaAn0aw7ay/b5mn3e+XxzpfLRyufvtc1dc2Fg9AcLf+msdKw2fO3X9vlLPt1tq92+tzXoWdVBIN2q3qm1jL93mmaHkHdsmit8urVOtWXVmp0v6T2d4037vMSnXze+gZuSwPtu7Owa1cFGp3VvRB7U3yE90AY8f6NVG90wgG7T9NC9ZZ+/4NNttfVW65ZebRj2398GGYno7E56YQrix6WnxEs2zUIo3brZWbdaLX3nSG6OXcwLvjf8iuV2iiIX1H+XfqPu0vWh/+8Chhz6O7170B8PxwH3d++71hkYvbpeNeD+Tt/nAuhpdwLoPuvp3a7RG3airA3tm9r9vDbyA85/V6dG144J7k+zf19+if37QYG9fnSOvV68yF7ff4O9/v7y6Nox8b0S+7ztMntdfJ+93lxlrwsfsdePPkbXn7LPO/wH6u8OS7+/K/CX0C4T9qB+GLpN/g8HpqOHA6cDMXVeRXgGdmv4+TP2mbPPL+xzyz5LDbNtlLrVttlrDr4r9fR7V6tmzyj1e9WSc69S19ppNaulJtWvfmmn2XG8Vr/kPGb4b8VylWnB+Ub7iO+M57lFbaSXBHQu6JDFZ1Xw/Z8Bnx+sfbJ1B3zFRQ4+C0CAcToN/Z80TmF4aDHhQfVla+XWxvptQhxzepWHBxBgPM4owmMOxRkEjf8iHJYRDpsCHM4BL8xgDmPUBQYPlgLjsWafpxTgQf1JHvFZRv3JErlDhB/x4OfVS5Ee1Ss2J2U/Ln9NCJcispmCIF59SuLVIybY4+oRS4H78x7gOWm8yvCcRTR+z9O4GhSoDON4Ocf3106/pzxxfVx6VQBZ1isNFy+M0x9g7FKhV95DxP8TSf/s5V/jfE6Pi2Bb9Urb6Pf1L41Kt9k1/PryPvhtlThoATjQeCYTAYeMx3/h4+f2ed7FoaYPdBeEStXumtU2ejx7/iPYnEo8MhJ4ZCPgkY2IR7dn1qwqH48/JYBHVsJOpiLgMRVgJ47un3Xx6Df0nlGr7Fj1ug0FxuHPgI1KHKYEOOQ8OOQi4JALwOECxLg2Ds40tlKFeTTGYRnoVMVtBD2ffv4KxNTMpD9CfgDHhXlwvN9GjAvvhugVTsrQvFFI2saH+39SFB86enSoKD6cgf7oAlz24P9J6yO1n6E0jaOMVUA+hCENiz+LAv4PY5rP0XiJJgVfBxsTpAt9/fhOUdyJ8wBPA+Iq3jxm0vOVfymyUxG/U2PGkSJ+zwI/Lr/Xlnz8/hv0RoXcmfFRi9dP4yS3309z0+C+fn2hyA6wvxDFCY8npP81J5txzc//P4EmaX8sysvIrsdMep7PLJJw5/ksBW+dTYWeLYP9l9F6W5Gum4GDfQCO538QkB5Op8svX0vQL2seO4zLL4/yG/1Bz+4V5vd6ivIbXj8UdV4fPi65nsgn7xvHxA+Fzf+i5gVE8z86n6pXOrBwyR/fbgL2qnDVFOKamUB+wcm1zLq46j0bHPBOflx/l4C+On3H/piHS3YC+YaRvrX17hEqflyWAMNJ47LIsWON058sjkND/B7FbToCbtMBuFG9r1e6Zm3IBhe33wNdUv6viMYpWsQhW+cx6XkuLT7xz3OZshRfP75OUXyfRBz1jaI4atLyp8rmlz+jhr5+vKRI/l3IJzXguZt0vgsB1DwIvgAD1VNon4CDfggO58GpYfsDKNLeDNTJnYb7nkmXfp1NOH+SjXkdbjT+O/xWzEGDv85SSJjvUxOLzy1X0JjflxXljcLyZFHj53HzZK8kzG9+zLg2fP5puQxjfs8pmn+K+M2NGa9KyffGdZ98zycs35kx40w5+d64jvm9kLB8p5HfkuH3lKx8l2765HsxYfmeRnYsw29eWr5LNzG/ryYs3wzSaxl+Z6TkW2+Z+sAn32LC8tWQnGX4PS0l35pp99RX//RawvKlx5kI/J6Riit3TLPlj69eTzC+8uY/ZyPwOyvFr3FUr+3l95Ii+YbN/3Fduex7M8I6Zk1uPiK7HiOqI6F1UoLyER/eDbiP6nlxEeUvvfUC3nXy5Swf14NnrNsIy1NtGYO1zuBTvWUZ3P43STJ14AeEHWhk+HUOUV3dJeDZw+/VnvGVZXeGv37tWS9OQ733dMz1PCK9eBn8ks1H5esjreDrxXmSnrpvkd3kM/HmC6jdfBhiN7sJ280BidduPkyZ3eTROgBPP7x0k/YvdDxicep37V4bL/xLdP+yCzFhWvwL1h/qUPaz8cQ59H0A/PLrHDxT9Hosxq2qMP/vjV++1cT6lfPU56jSL3Nn17P65tevWsrqD3C9kez72yJ7zgbMO6PirT3DeoFBkn8/LOPBW2TH+dl468eYl9K59WMsBcbtY0W44fqx+xqrQHuQkM7DALEPCb35mXTYO12/cauMnForABzjuX5M6mKi4p0f097D/Ctb3eDHewPkkhTez1rfwMM5E4BzcQycMyT8vacjnIf1ST6cN0GnVOJM65JynPiaKJIDzjMRQT9k1w1FcT2Nv2jVXQUJBMvjb4rmxbLyUGUXoveN5seQx5TEOkFfYA+fQCydVnuY5DiQDfBPi2PIQeZ9xJE5tPUuZxzYgnyyqvpADeUFimicFM3DVfqvbID/Ko8hp+kA/0X3QeH4L1dgGI87iubdcckrbv8WNI9w/M6qYB5B37v4PiSftInmEV2B3Gh/Azetso+rZPhOreQ2Vz48PyPpem9VdZ4gLI69S57vOl3Z91axPhck9XkV6fO2AG86/+VupmZ//hsy3KMoZNs1n3wqJ1x/w/Jc2wnMD3jxjug9zqj7Go6rz7Rjj/Ix52vRZn+cfC1DgeUzr0h/F0E/aVxN99/MQ55nH/I8xelg/Va9r4Al0Ou3j3H+Nmg+FXf+1snROKLXK6bFw/kd8NtJvPc0znxKlRzGzfeEy6HBlcO7z5kc8D5psvvniuZLhyTefE+YHNoCe/it4vkREazTpsE+sgrzPiO58O3j6nMul3HtJSgeynnkheMhup/SYcT167sB/tDpC97M+ArIJWS7Y588v0poHburpSP+ofM9mrfB+PRerGfFsp5F1w87Zod5sx7j3SfHY7+CsHXyIvLfuD9x1/fSeRTe1Nw/j2IpsHwc9JKs751F0IS9H/yEzs+z8foNOk6uVBsmr78dkkxdIuV3NWK9XZjdOnx6CxLTXGencvygdTnNjlNmx9eDwgnMa8ath3QdDPTwqODzhR6y67Wm5dZ7cvXwrROgh5Par4zqH/MjH4S33z9LgfvzBlGzbwLOQ9J4m/6OzzLkIX8M2I98EvvmheUb545JvlG0r1Lc+5+F5RUvn5C8YhjeGUX5wysnJH8o2h+L4p1VlCd884TmCcPwn1KUD/zVCc0HitY9t3PxxhvMj4Vx4w2WAsvnlqL83hzoH33+HuDxJJOOdXw6jzVdIxot5WO8bqcs3xfnOkIQ3oWY832ydT8r5PjVrwfhPDfmemaYXg9/3Ues1x+kTK8nsQ7jrS//KQAA//+U2eFwkHUAAA=="

  // Deserialize RuntimeTypeInfo
  compressedBytes, err := base64.StdEncoding.DecodeString(serializedRuntimeTypeInfo)
  if err != nil {
    panic(fmt.Sprintf("Error while base64Decoding runtimeTypeInfo: %s", err.Error()))
  }
  reader, err := gzip.NewReader(bytes.NewBuffer(compressedBytes))
  if err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  uncompressedBytes, err := ioutil.ReadAll(reader)
  if err != nil {
     panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  if err = reader.Close(); err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  decoder := bindings.NewDecoder(uncompressedBytes, nil)
  runtimeTypeInfo__.Decode(decoder)

  for s, udt := range test_included_unions.GetAllMojomTypeDefinitions() {
    runtimeTypeInfo__.TypeMap[s] = udt
  }


}
func GetAllMojomTypeDefinitions() map[string]mojom_types.UserDefinedType {
  return getRuntimeTypeInfo().TypeMap
}

type AnEnum int32

const (
	AnEnum_First AnEnum = 0
	AnEnum_Second = AnEnum_First + 1;
)
// AnEnumMojomType returns the UserDefinedType that describes the Mojom
// type of AnEnum. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func AnEnumMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.AnEnum"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*AnEnum) MojomType() mojom_types.UserDefinedType {
	return AnEnumMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*AnEnum) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type SmallCache interface {
	SetIntValue(inIntValue int64) (err error)
	GetIntValue() (outIntValue int64, err error)
}


// SmallCacheMojomType returns the UserDefinedType that describes the Mojom
// type of SmallCache. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func SmallCacheMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.SmallCache"]
}




type SmallCache_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*SmallCache_Request) MojomType() mojom_types.UserDefinedType {
	return SmallCacheMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*SmallCache_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type SmallCache_Pointer bindings.InterfacePointer


type SmallCache_ServiceFactory struct{
	Delegate SmallCache_Factory
}

type SmallCache_Factory interface {
	Create(request SmallCache_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *SmallCache_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &SmallCache_ServiceDescription{}
}

func (f *SmallCache_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := SmallCache_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForSmallCache creates a message pipe for use with the
// SmallCache interface with a SmallCache_Request on one end and a SmallCache_Pointer on the other.
func CreateMessagePipeForSmallCache() (SmallCache_Request, SmallCache_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return SmallCache_Request(r), SmallCache_Pointer(p)
}

const smallCache_SetIntValue_Name uint32 = 0
const smallCache_GetIntValue_Name uint32 = 1

type SmallCache_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewSmallCacheProxy(p SmallCache_Pointer, waiter bindings.AsyncWaiter) *SmallCache_Proxy {
	return &SmallCache_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *SmallCache_Proxy) Close_Proxy() {
	p.router.Close()
}

type smallCache_SetIntValue_Params struct {
	inIntValue int64
}


func (s *smallCache_SetIntValue_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt64(s.inIntValue); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var smallCache_SetIntValue_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *smallCache_SetIntValue_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(smallCache_SetIntValue_Params_Versions), func(i int) bool {
		return smallCache_SetIntValue_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(smallCache_SetIntValue_Params_Versions) {
		if smallCache_SetIntValue_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := smallCache_SetIntValue_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.inIntValue = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *SmallCache_Proxy) SetIntValue(inIntValue int64) (err error) {
	payload := &smallCache_SetIntValue_Params{
		inIntValue,
	}
	header := bindings.MessageHeader{
		Type: smallCache_SetIntValue_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type smallCache_GetIntValue_Params struct {
}


func (s *smallCache_GetIntValue_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var smallCache_GetIntValue_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *smallCache_GetIntValue_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(smallCache_GetIntValue_Params_Versions), func(i int) bool {
		return smallCache_GetIntValue_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(smallCache_GetIntValue_Params_Versions) {
		if smallCache_GetIntValue_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := smallCache_GetIntValue_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type smallCache_GetIntValue_ResponseParams struct {
	outIntValue int64
}


func (s *smallCache_GetIntValue_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt64(s.outIntValue); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var smallCache_GetIntValue_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *smallCache_GetIntValue_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(smallCache_GetIntValue_ResponseParams_Versions), func(i int) bool {
		return smallCache_GetIntValue_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(smallCache_GetIntValue_ResponseParams_Versions) {
		if smallCache_GetIntValue_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := smallCache_GetIntValue_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.outIntValue = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *SmallCache_Proxy) GetIntValue() (outIntValue int64, err error) {
	payload := &smallCache_GetIntValue_Params{
	}
	header := bindings.MessageHeader{
		Type: smallCache_GetIntValue_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, smallCache_GetIntValue_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response smallCache_GetIntValue_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outIntValue = response.outIntValue
	return
}

type smallCache_Stub struct {
	connector *bindings.Connector
	impl SmallCache
}

func NewSmallCacheStub(r SmallCache_Request, impl SmallCache, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &smallCache_Stub{connector, impl})
}


func (f *SmallCache_Request) ServiceDescription() service_describer.ServiceDescription {
	return &SmallCache_ServiceDescription{}
}


type SmallCache_ServiceDescription struct{}

func (sd *SmallCache_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *SmallCache_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *SmallCache_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*SmallCache_ServiceDescription)(nil)


func (s *smallCache_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case smallCache_SetIntValue_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request smallCache_SetIntValue_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SetIntValue(request.inIntValue)
		if err != nil {
			return
		}
	case smallCache_GetIntValue_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request smallCache_GetIntValue_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response smallCache_GetIntValue_ResponseParams
		response.outIntValue, err = s.impl.GetIntValue()
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: smallCache_GetIntValue_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type UnionInterface interface {
	Echo(inInVal PodUnion) (outOutVal PodUnion, err error)
}


// UnionInterfaceMojomType returns the UserDefinedType that describes the Mojom
// type of UnionInterface. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func UnionInterfaceMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.UnionInterface"]
}




type UnionInterface_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionInterface_Request) MojomType() mojom_types.UserDefinedType {
	return UnionInterfaceMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionInterface_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionInterface_Pointer bindings.InterfacePointer


type UnionInterface_ServiceFactory struct{
	Delegate UnionInterface_Factory
}

type UnionInterface_Factory interface {
	Create(request UnionInterface_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *UnionInterface_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &UnionInterface_ServiceDescription{}
}

func (f *UnionInterface_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := UnionInterface_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForUnionInterface creates a message pipe for use with the
// UnionInterface interface with a UnionInterface_Request on one end and a UnionInterface_Pointer on the other.
func CreateMessagePipeForUnionInterface() (UnionInterface_Request, UnionInterface_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return UnionInterface_Request(r), UnionInterface_Pointer(p)
}

const unionInterface_Echo_Name uint32 = 0

type UnionInterface_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewUnionInterfaceProxy(p UnionInterface_Pointer, waiter bindings.AsyncWaiter) *UnionInterface_Proxy {
	return &UnionInterface_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *UnionInterface_Proxy) Close_Proxy() {
	p.router.Close()
}

type unionInterface_Echo_Params struct {
	inInVal PodUnion
}


func (s *unionInterface_Echo_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.inInVal == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.inInVal.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var unionInterface_Echo_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *unionInterface_Echo_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(unionInterface_Echo_Params_Versions), func(i int) bool {
		return unionInterface_Echo_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(unionInterface_Echo_Params_Versions) {
		if unionInterface_Echo_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := unionInterface_Echo_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.inInVal, err = DecodePodUnion(decoder)
		if err != nil {
			return err
		}
		if s.inInVal == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type unionInterface_Echo_ResponseParams struct {
	outOutVal PodUnion
}


func (s *unionInterface_Echo_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.outOutVal == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.outOutVal.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var unionInterface_Echo_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *unionInterface_Echo_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(unionInterface_Echo_ResponseParams_Versions), func(i int) bool {
		return unionInterface_Echo_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(unionInterface_Echo_ResponseParams_Versions) {
		if unionInterface_Echo_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := unionInterface_Echo_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.outOutVal, err = DecodePodUnion(decoder)
		if err != nil {
			return err
		}
		if s.outOutVal == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *UnionInterface_Proxy) Echo(inInVal PodUnion) (outOutVal PodUnion, err error) {
	payload := &unionInterface_Echo_Params{
		inInVal,
	}
	header := bindings.MessageHeader{
		Type: unionInterface_Echo_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, unionInterface_Echo_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response unionInterface_Echo_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outOutVal = response.outOutVal
	return
}

type unionInterface_Stub struct {
	connector *bindings.Connector
	impl UnionInterface
}

func NewUnionInterfaceStub(r UnionInterface_Request, impl UnionInterface, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &unionInterface_Stub{connector, impl})
}


func (f *UnionInterface_Request) ServiceDescription() service_describer.ServiceDescription {
	return &UnionInterface_ServiceDescription{}
}


type UnionInterface_ServiceDescription struct{}

func (sd *UnionInterface_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *UnionInterface_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *UnionInterface_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*UnionInterface_ServiceDescription)(nil)


func (s *unionInterface_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case unionInterface_Echo_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request unionInterface_Echo_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response unionInterface_Echo_ResponseParams
		response.outOutVal, err = s.impl.Echo(request.inInVal)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: unionInterface_Echo_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type StructOfUnions struct {
	U ObjectUnion
	AOu []ObjectUnion
	AHu []HandleUnion
	MOu map[int64]ObjectUnion
	MHu map[int64]HandleUnion
}
// StructOfUnionsMojomType returns the UserDefinedType that describes the Mojom
// type of StructOfUnions. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructOfUnionsMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructOfUnions"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructOfUnions) MojomType() mojom_types.UserDefinedType {
	return StructOfUnionsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructOfUnions) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructOfUnions) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(48, 0)
	if s.U == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.U.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.AOu)), 128)
	for _, elem0 := range s.AOu {
		if elem0 == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(s.AHu)), 128)
	for _, elem0 := range s.AHu {
		if elem0 == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []int64
		var values0 []ObjectUnion
		if encoder.Deterministic() {
		  for key0, _ := range s.MOu {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]ObjectUnion, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.MOu[key]
		  }
		} else {
		  for key0, value0 := range s.MOu {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WriteInt64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 128)
		for _, elem1 := range values0 {
			if elem1 == nil {
				return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
			}
			if err := elem1.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []int64
		var values0 []HandleUnion
		if encoder.Deterministic() {
		  for key0, _ := range s.MHu {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]HandleUnion, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = s.MHu[key]
		  }
		} else {
		  for key0, value0 := range s.MHu {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WriteInt64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 128)
		for _, elem1 := range values0 {
			if elem1 == nil {
				return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
			}
			if err := elem1.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structOfUnions_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{56, 0},
}

func (s *StructOfUnions) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structOfUnions_Versions), func(i int) bool {
		return structOfUnions_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structOfUnions_Versions) {
		if structOfUnions_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structOfUnions_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.U, err = DecodeObjectUnion(decoder)
		if err != nil {
			return err
		}
		if s.U == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(128)
			if err != nil {
				return err
			}
			s.AOu = make([]ObjectUnion, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				var err error
				s.AOu[i0], err = DecodeObjectUnion(decoder)
				if err != nil {
					return err
				}
				if s.AOu[i0] == nil {
					return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			len0, err := decoder.StartArray(128)
			if err != nil {
				return err
			}
			s.AHu = make([]HandleUnion, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				var err error
				s.AHu[i0], err = DecodeHandleUnion(decoder)
				if err != nil {
					return err
				}
				if s.AHu[i0] == nil {
					return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []int64
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]int64, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadInt64()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []ObjectUnion
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(128)
					if err != nil {
						return err
					}
					values0 = make([]ObjectUnion, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						var err error
						values0[i1], err = DecodeObjectUnion(decoder)
						if err != nil {
							return err
						}
						if values0[i1] == nil {
							return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[int64]ObjectUnion)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.MOu = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []int64
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]int64, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						value2, err := decoder.ReadInt64()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []HandleUnion
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(128)
					if err != nil {
						return err
					}
					values0 = make([]HandleUnion, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						var err error
						values0[i1], err = DecodeHandleUnion(decoder)
						if err != nil {
							return err
						}
						if values0[i1] == nil {
							return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[int64]HandleUnion)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			s.MHu = map0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type WrapperStruct struct {
	ObjectUnion ObjectUnion
	PodUnion PodUnion
	HandleUnion HandleUnion
}
// WrapperStructMojomType returns the UserDefinedType that describes the Mojom
// type of WrapperStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func WrapperStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.WrapperStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*WrapperStruct) MojomType() mojom_types.UserDefinedType {
	return WrapperStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*WrapperStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *WrapperStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(48, 0)
	if s.ObjectUnion == nil {
		encoder.WriteNullUnion()
	} else {
		if err := s.ObjectUnion.Encode(encoder); err != nil {
			return err
		}
	}
	if s.PodUnion == nil {
		encoder.WriteNullUnion()
	} else {
		if err := s.PodUnion.Encode(encoder); err != nil {
			return err
		}
	}
	if s.HandleUnion == nil {
		encoder.WriteNullUnion()
	} else {
		if err := s.HandleUnion.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var wrapperStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{56, 0},
}

func (s *WrapperStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(wrapperStruct_Versions), func(i int) bool {
		return wrapperStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(wrapperStruct_Versions) {
		if wrapperStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := wrapperStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.ObjectUnion, err = DecodeObjectUnion(decoder)
		if err != nil {
			return err
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.PodUnion, err = DecodePodUnion(decoder)
		if err != nil {
			return err
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.HandleUnion, err = DecodeHandleUnion(decoder)
		if err != nil {
			return err
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type DummyStruct struct {
	FInt8 int8
}
// DummyStructMojomType returns the UserDefinedType that describes the Mojom
// type of DummyStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func DummyStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.DummyStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*DummyStruct) MojomType() mojom_types.UserDefinedType {
	return DummyStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*DummyStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *DummyStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt8(s.FInt8); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var dummyStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *DummyStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(dummyStruct_Versions), func(i int) bool {
		return dummyStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(dummyStruct_Versions) {
		if dummyStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := dummyStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt8()
		if err != nil {
			return err
		}
		s.FInt8 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type SmallStruct struct {
	DummyStruct *DummyStruct
	PodUnion PodUnion
	PodUnionArray *[]PodUnion
	NullablePodUnionArray *[]PodUnion
	SArray *[]DummyStruct
	PodUnionMap *map[string]PodUnion
	NullablePodUnionMap *map[string]PodUnion
}
// SmallStructMojomType returns the UserDefinedType that describes the Mojom
// type of SmallStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func SmallStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.SmallStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*SmallStruct) MojomType() mojom_types.UserDefinedType {
	return SmallStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*SmallStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *SmallStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(64, 0)
	if s.DummyStruct == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.DummyStruct).Encode(encoder); err != nil {
			return err
		}
	}
	if s.PodUnion == nil {
		encoder.WriteNullUnion()
	} else {
		if err := s.PodUnion.Encode(encoder); err != nil {
			return err
		}
	}
	if s.PodUnionArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.PodUnionArray))), 128)
		for _, elem0 := range (*s.PodUnionArray) {
			if elem0 == nil {
				return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
			}
			if err := elem0.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if s.NullablePodUnionArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.NullablePodUnionArray))), 128)
		for _, elem0 := range (*s.NullablePodUnionArray) {
			if elem0 == nil {
				encoder.WriteNullUnion()
			} else {
				if err := elem0.Encode(encoder); err != nil {
					return err
				}
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if s.SArray == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len((*s.SArray))), 64)
		for _, elem0 := range (*s.SArray) {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := elem0.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if s.PodUnionMap == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartMap()
		{
			var keys0 []string
			var values0 []PodUnion
			if encoder.Deterministic() {
			  for key0, _ := range (*s.PodUnionMap) {
				keys0 = append(keys0, key0)
			  }
			  bindings.SortMapKeys(&keys0)
			  values0 = make([]PodUnion, len(keys0))
			  for i, key := range keys0 {
			    values0[i] = (*s.PodUnionMap)[key]
			  }
			} else {
			  for key0, value0 := range (*s.PodUnionMap) {
				keys0 = append(keys0, key0)
				values0 = append(values0, value0)
			  }
			}
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(keys0)), 64)
			for _, elem1 := range keys0 {
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				if err := encoder.WriteString(elem1); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(values0)), 128)
			for _, elem1 := range values0 {
				if elem1 == nil {
					return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
				}
				if err := elem1.Encode(encoder); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if s.NullablePodUnionMap == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartMap()
		{
			var keys0 []string
			var values0 []PodUnion
			if encoder.Deterministic() {
			  for key0, _ := range (*s.NullablePodUnionMap) {
				keys0 = append(keys0, key0)
			  }
			  bindings.SortMapKeys(&keys0)
			  values0 = make([]PodUnion, len(keys0))
			  for i, key := range keys0 {
			    values0[i] = (*s.NullablePodUnionMap)[key]
			  }
			} else {
			  for key0, value0 := range (*s.NullablePodUnionMap) {
				keys0 = append(keys0, key0)
				values0 = append(values0, value0)
			  }
			}
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(keys0)), 64)
			for _, elem1 := range keys0 {
				if err := encoder.WritePointer(); err != nil {
					return err
				}
				if err := encoder.WriteString(elem1); err != nil {
					return err
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			encoder.StartArray(uint32(len(values0)), 128)
			for _, elem1 := range values0 {
				if elem1 == nil {
					encoder.WriteNullUnion()
				} else {
					if err := elem1.Encode(encoder); err != nil {
						return err
					}
				}
			}
			if err := encoder.Finish(); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var smallStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{72, 0},
}

func (s *SmallStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(smallStruct_Versions), func(i int) bool {
		return smallStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(smallStruct_Versions) {
		if smallStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := smallStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.DummyStruct = nil
		} else {
			s.DummyStruct = new(DummyStruct)
			if err := (*s.DummyStruct).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.PodUnion, err = DecodePodUnion(decoder)
		if err != nil {
			return err
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.PodUnionArray = nil
		} else {
			s.PodUnionArray = new([]PodUnion)
			len0, err := decoder.StartArray(128)
			if err != nil {
				return err
			}
			(*s.PodUnionArray) = make([]PodUnion, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				var err error
				(*s.PodUnionArray)[i0], err = DecodePodUnion(decoder)
				if err != nil {
					return err
				}
				if (*s.PodUnionArray)[i0] == nil {
					return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.NullablePodUnionArray = nil
		} else {
			s.NullablePodUnionArray = new([]PodUnion)
			len0, err := decoder.StartArray(128)
			if err != nil {
				return err
			}
			(*s.NullablePodUnionArray) = make([]PodUnion, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				var err error
				(*s.NullablePodUnionArray)[i0], err = DecodePodUnion(decoder)
				if err != nil {
					return err
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.SArray = nil
		} else {
			s.SArray = new([]DummyStruct)
			len0, err := decoder.StartArray(64)
			if err != nil {
				return err
			}
			(*s.SArray) = make([]DummyStruct, len0)
			for i0 := uint32(0); i0 < len0; i0++ {
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					if err := (*s.SArray)[i0].Decode(decoder); err != nil {
						return err
					}
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.PodUnionMap = nil
		} else {
			s.PodUnionMap = new(map[string]PodUnion)
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []PodUnion
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(128)
					if err != nil {
						return err
					}
					values0 = make([]PodUnion, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						var err error
						values0[i1], err = DecodePodUnion(decoder)
						if err != nil {
							return err
						}
						if values0[i1] == nil {
							return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string]PodUnion)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			(*s.PodUnionMap) = map0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.NullablePodUnionMap = nil
		} else {
			s.NullablePodUnionMap = new(map[string]PodUnion)
			if err := decoder.StartMap(); err != nil {
				return err
			}
			var keys0 []string
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(64)
					if err != nil {
						return err
					}
					keys0 = make([]string, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						pointer2, err := decoder.ReadPointer()
						if err != nil {
							return err
						}
						if pointer2 == 0 {
							return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
						} else {
							value2, err := decoder.ReadString()
							if err != nil {
								return err
							}
							keys0[i1] = value2
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			var values0 []PodUnion
			{
				pointer1, err := decoder.ReadPointer()
				if err != nil {
					return err
				}
				if pointer1 == 0 {
					return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
				} else {
					len1, err := decoder.StartArray(128)
					if err != nil {
						return err
					}
					values0 = make([]PodUnion, len1)
					for i1 := uint32(0); i1 < len1; i1++ {
						var err error
						values0[i1], err = DecodePodUnion(decoder)
						if err != nil {
							return err
						}
					}
					if err := decoder.Finish(); err != nil {
						return err
					}
				}
			}
			if len(keys0) != len(values0) {
				return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
					fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
				}
			}
			if err := decoder.Finish(); err != nil {
				return err
			}
			len0 := len(keys0)
			map0 := make(map[string]PodUnion)
			for i0 := 0; i0 < len0; i0++ {
				map0[keys0[i0]] = values0[i0]
			}
			(*s.NullablePodUnionMap) = map0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type SmallStructNonNullableUnion struct {
	PodUnion PodUnion
}
// SmallStructNonNullableUnionMojomType returns the UserDefinedType that describes the Mojom
// type of SmallStructNonNullableUnion. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func SmallStructNonNullableUnionMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.SmallStructNonNullableUnion"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*SmallStructNonNullableUnion) MojomType() mojom_types.UserDefinedType {
	return SmallStructNonNullableUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*SmallStructNonNullableUnion) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *SmallStructNonNullableUnion) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.PodUnion == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.PodUnion.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var smallStructNonNullableUnion_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *SmallStructNonNullableUnion) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(smallStructNonNullableUnion_Versions), func(i int) bool {
		return smallStructNonNullableUnion_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(smallStructNonNullableUnion_Versions) {
		if smallStructNonNullableUnion_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := smallStructNonNullableUnion_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.PodUnion, err = DecodePodUnion(decoder)
		if err != nil {
			return err
		}
		if s.PodUnion == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type StructNullObjectUnion struct {
	ObjUnion ObjectOnlyUnion
}
// StructNullObjectUnionMojomType returns the UserDefinedType that describes the Mojom
// type of StructNullObjectUnion. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func StructNullObjectUnionMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.StructNullObjectUnion"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*StructNullObjectUnion) MojomType() mojom_types.UserDefinedType {
	return StructNullObjectUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*StructNullObjectUnion) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *StructNullObjectUnion) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.ObjUnion == nil {
		encoder.WriteNullUnion()
	} else {
		if err := s.ObjUnion.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var structNullObjectUnion_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *StructNullObjectUnion) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(structNullObjectUnion_Versions), func(i int) bool {
		return structNullObjectUnion_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(structNullObjectUnion_Versions) {
		if structNullObjectUnion_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := structNullObjectUnion_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.ObjUnion, err = DecodeObjectOnlyUnion(decoder)
		if err != nil {
			return err
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type SmallObjStruct struct {
	ObjUnion ObjectUnion
	FInt8 int8
}
// SmallObjStructMojomType returns the UserDefinedType that describes the Mojom
// type of SmallObjStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func SmallObjStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.SmallObjStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*SmallObjStruct) MojomType() mojom_types.UserDefinedType {
	return SmallObjStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*SmallObjStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *SmallObjStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(24, 0)
	if s.ObjUnion == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.ObjUnion.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.WriteInt8(s.FInt8); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var smallObjStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{32, 0},
}

func (s *SmallObjStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(smallObjStruct_Versions), func(i int) bool {
		return smallObjStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(smallObjStruct_Versions) {
		if smallObjStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := smallObjStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.ObjUnion, err = DecodeObjectUnion(decoder)
		if err != nil {
			return err
		}
		if s.ObjUnion == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt8()
		if err != nil {
			return err
		}
		s.FInt8 = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type TryNonNullStruct struct {
	Nullable *DummyStruct
	NonNullable DummyStruct
}
// TryNonNullStructMojomType returns the UserDefinedType that describes the Mojom
// type of TryNonNullStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func TryNonNullStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.TryNonNullStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*TryNonNullStruct) MojomType() mojom_types.UserDefinedType {
	return TryNonNullStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*TryNonNullStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *TryNonNullStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.Nullable == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*s.Nullable).Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := s.NonNullable.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var tryNonNullStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *TryNonNullStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(tryNonNullStruct_Versions), func(i int) bool {
		return tryNonNullStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(tryNonNullStruct_Versions) {
		if tryNonNullStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := tryNonNullStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.Nullable = nil
		} else {
			s.Nullable = new(DummyStruct)
			if err := (*s.Nullable).Decode(decoder); err != nil {
				return err
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			if err := s.NonNullable.Decode(decoder); err != nil {
				return err
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type IncludingStruct struct {
	A test_included_unions.IncludedUnion
}
// IncludingStructMojomType returns the UserDefinedType that describes the Mojom
// type of IncludingStruct. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func IncludingStructMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.IncludingStruct"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*IncludingStruct) MojomType() mojom_types.UserDefinedType {
	return IncludingStructMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*IncludingStruct) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


func (s *IncludingStruct) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.A == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := s.A.Encode(encoder); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var includingStruct_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *IncludingStruct) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(includingStruct_Versions), func(i int) bool {
		return includingStruct_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(includingStruct_Versions) {
		if includingStruct_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := includingStruct_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		var err error
		s.A, err = test_included_unions.DecodeIncludedUnion(decoder)
		if err != nil {
			return err
		}
		if s.A == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type PodUnion interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__PodUnionReflect)
	Encode(encoder *bindings.Encoder) error
}


// PodUnionMojomType returns the UserDefinedType that describes the Mojom
// type of PodUnion. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func PodUnionMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.PodUnion"]
}



type __PodUnionReflect struct {
	FInt8 int8
	FInt8Other int8
	FUint8 uint8
	FInt16 int16
	FUint16 uint16
	FInt32 int32
	FUint32 uint32
	FInt64 int64
	FUint64 uint64
	FFloat float32
	FDouble float64
	FBool bool
	FEnum AnEnum
}

func DecodePodUnion(decoder *bindings.Decoder) (PodUnion, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value PodUnionFInt8
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value PodUnionFInt8Other
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 2:
		var value PodUnionFUint8
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 3:
		var value PodUnionFInt16
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 4:
		var value PodUnionFUint16
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 5:
		var value PodUnionFInt32
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 6:
		var value PodUnionFUint32
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 7:
		var value PodUnionFInt64
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 8:
		var value PodUnionFUint64
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 9:
		var value PodUnionFFloat
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 10:
		var value PodUnionFDouble
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 11:
		var value PodUnionFBool
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 12:
		var value PodUnionFEnum
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &PodUnionUnknown{tag: tag}, nil
}

type PodUnionUnknown struct { tag uint32 }
func (u *PodUnionUnknown) Tag() uint32 { return u.tag }
func (u *PodUnionUnknown) Interface() interface{} { return nil }
func (u *PodUnionUnknown) __Reflect(__PodUnionReflect) {}

func (u *PodUnionUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown PodUnion. There is no sane way to do that!");
}

type PodUnionFInt8 struct { Value int8 }
func (u *PodUnionFInt8) Tag() uint32 { return 0 }
func (u *PodUnionFInt8) Interface() interface{} { return u.Value }
func (u *PodUnionFInt8) __Reflect(__PodUnionReflect) {}

func (u *PodUnionFInt8) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt8(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *PodUnionFInt8) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt8()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*PodUnionFInt8) MojomType() mojom_types.UserDefinedType {
	return PodUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*PodUnionFInt8) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type PodUnionFInt8Other struct { Value int8 }
func (u *PodUnionFInt8Other) Tag() uint32 { return 1 }
func (u *PodUnionFInt8Other) Interface() interface{} { return u.Value }
func (u *PodUnionFInt8Other) __Reflect(__PodUnionReflect) {}

func (u *PodUnionFInt8Other) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt8(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *PodUnionFInt8Other) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt8()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*PodUnionFInt8Other) MojomType() mojom_types.UserDefinedType {
	return PodUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*PodUnionFInt8Other) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type PodUnionFUint8 struct { Value uint8 }
func (u *PodUnionFUint8) Tag() uint32 { return 2 }
func (u *PodUnionFUint8) Interface() interface{} { return u.Value }
func (u *PodUnionFUint8) __Reflect(__PodUnionReflect) {}

func (u *PodUnionFUint8) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint8(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *PodUnionFUint8) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint8()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*PodUnionFUint8) MojomType() mojom_types.UserDefinedType {
	return PodUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*PodUnionFUint8) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type PodUnionFInt16 struct { Value int16 }
func (u *PodUnionFInt16) Tag() uint32 { return 3 }
func (u *PodUnionFInt16) Interface() interface{} { return u.Value }
func (u *PodUnionFInt16) __Reflect(__PodUnionReflect) {}

func (u *PodUnionFInt16) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt16(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *PodUnionFInt16) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt16()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*PodUnionFInt16) MojomType() mojom_types.UserDefinedType {
	return PodUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*PodUnionFInt16) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type PodUnionFUint16 struct { Value uint16 }
func (u *PodUnionFUint16) Tag() uint32 { return 4 }
func (u *PodUnionFUint16) Interface() interface{} { return u.Value }
func (u *PodUnionFUint16) __Reflect(__PodUnionReflect) {}

func (u *PodUnionFUint16) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint16(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *PodUnionFUint16) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint16()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*PodUnionFUint16) MojomType() mojom_types.UserDefinedType {
	return PodUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*PodUnionFUint16) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type PodUnionFInt32 struct { Value int32 }
func (u *PodUnionFInt32) Tag() uint32 { return 5 }
func (u *PodUnionFInt32) Interface() interface{} { return u.Value }
func (u *PodUnionFInt32) __Reflect(__PodUnionReflect) {}

func (u *PodUnionFInt32) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt32(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *PodUnionFInt32) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt32()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*PodUnionFInt32) MojomType() mojom_types.UserDefinedType {
	return PodUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*PodUnionFInt32) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type PodUnionFUint32 struct { Value uint32 }
func (u *PodUnionFUint32) Tag() uint32 { return 6 }
func (u *PodUnionFUint32) Interface() interface{} { return u.Value }
func (u *PodUnionFUint32) __Reflect(__PodUnionReflect) {}

func (u *PodUnionFUint32) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint32(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *PodUnionFUint32) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint32()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*PodUnionFUint32) MojomType() mojom_types.UserDefinedType {
	return PodUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*PodUnionFUint32) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type PodUnionFInt64 struct { Value int64 }
func (u *PodUnionFInt64) Tag() uint32 { return 7 }
func (u *PodUnionFInt64) Interface() interface{} { return u.Value }
func (u *PodUnionFInt64) __Reflect(__PodUnionReflect) {}

func (u *PodUnionFInt64) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt64(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *PodUnionFInt64) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt64()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*PodUnionFInt64) MojomType() mojom_types.UserDefinedType {
	return PodUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*PodUnionFInt64) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type PodUnionFUint64 struct { Value uint64 }
func (u *PodUnionFUint64) Tag() uint32 { return 8 }
func (u *PodUnionFUint64) Interface() interface{} { return u.Value }
func (u *PodUnionFUint64) __Reflect(__PodUnionReflect) {}

func (u *PodUnionFUint64) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteUint64(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *PodUnionFUint64) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadUint64()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*PodUnionFUint64) MojomType() mojom_types.UserDefinedType {
	return PodUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*PodUnionFUint64) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type PodUnionFFloat struct { Value float32 }
func (u *PodUnionFFloat) Tag() uint32 { return 9 }
func (u *PodUnionFFloat) Interface() interface{} { return u.Value }
func (u *PodUnionFFloat) __Reflect(__PodUnionReflect) {}

func (u *PodUnionFFloat) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteFloat32(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *PodUnionFFloat) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadFloat32()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*PodUnionFFloat) MojomType() mojom_types.UserDefinedType {
	return PodUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*PodUnionFFloat) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type PodUnionFDouble struct { Value float64 }
func (u *PodUnionFDouble) Tag() uint32 { return 10 }
func (u *PodUnionFDouble) Interface() interface{} { return u.Value }
func (u *PodUnionFDouble) __Reflect(__PodUnionReflect) {}

func (u *PodUnionFDouble) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteFloat64(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *PodUnionFDouble) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadFloat64()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*PodUnionFDouble) MojomType() mojom_types.UserDefinedType {
	return PodUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*PodUnionFDouble) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type PodUnionFBool struct { Value bool }
func (u *PodUnionFBool) Tag() uint32 { return 11 }
func (u *PodUnionFBool) Interface() interface{} { return u.Value }
func (u *PodUnionFBool) __Reflect(__PodUnionReflect) {}

func (u *PodUnionFBool) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteBool(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *PodUnionFBool) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadBool()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*PodUnionFBool) MojomType() mojom_types.UserDefinedType {
	return PodUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*PodUnionFBool) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type PodUnionFEnum struct { Value AnEnum }
func (u *PodUnionFEnum) Tag() uint32 { return 12 }
func (u *PodUnionFEnum) Interface() interface{} { return u.Value }
func (u *PodUnionFEnum) __Reflect(__PodUnionReflect) {}

func (u *PodUnionFEnum) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt32(int32(u.Value)); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *PodUnionFEnum) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt32()
	if err != nil {
		return err
	}
	u.Value = AnEnum(value0)
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*PodUnionFEnum) MojomType() mojom_types.UserDefinedType {
	return PodUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*PodUnionFEnum) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}



type UnionOfUnions interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__UnionOfUnionsReflect)
	Encode(encoder *bindings.Encoder) error
}


// UnionOfUnionsMojomType returns the UserDefinedType that describes the Mojom
// type of UnionOfUnions. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func UnionOfUnionsMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.UnionOfUnions"]
}



type __UnionOfUnionsReflect struct {
	U ObjectUnion
	AOu []ObjectUnion
	AHu []HandleUnion
	MOu map[int64]ObjectUnion
	MHu map[int64]HandleUnion
}

func DecodeUnionOfUnions(decoder *bindings.Decoder) (UnionOfUnions, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value UnionOfUnionsU
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value UnionOfUnionsAOu
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 2:
		var value UnionOfUnionsAHu
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 3:
		var value UnionOfUnionsMOu
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 4:
		var value UnionOfUnionsMHu
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &UnionOfUnionsUnknown{tag: tag}, nil
}

type UnionOfUnionsUnknown struct { tag uint32 }
func (u *UnionOfUnionsUnknown) Tag() uint32 { return u.tag }
func (u *UnionOfUnionsUnknown) Interface() interface{} { return nil }
func (u *UnionOfUnionsUnknown) __Reflect(__UnionOfUnionsReflect) {}

func (u *UnionOfUnionsUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown UnionOfUnions. There is no sane way to do that!");
}

type UnionOfUnionsU struct { Value ObjectUnion }
func (u *UnionOfUnionsU) Tag() uint32 { return 0 }
func (u *UnionOfUnionsU) Interface() interface{} { return u.Value }
func (u *UnionOfUnionsU) __Reflect(__UnionOfUnionsReflect) {}

func (u *UnionOfUnionsU) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	
	encoder.StartNestedUnion()
	if u.Value == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}
	
	encoder.Finish()
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionOfUnionsU) decodeInternal(decoder *bindings.Decoder) error {
	if pointer, err := decoder.ReadPointer(); err != nil || pointer == 0 {
		if err != nil {
			return err
		}
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null union pointer"}
	}
	
	if err := decoder.StartNestedUnion(); err != nil {
		return err
	}
	
	var err error
	u.Value, err = DecodeObjectUnion(decoder)
	if err != nil {
		return err
	}
	if u.Value == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	
	
	decoder.Finish()
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionOfUnionsU) MojomType() mojom_types.UserDefinedType {
	return UnionOfUnionsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionOfUnionsU) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionOfUnionsAOu struct { Value []ObjectUnion }
func (u *UnionOfUnionsAOu) Tag() uint32 { return 1 }
func (u *UnionOfUnionsAOu) Interface() interface{} { return u.Value }
func (u *UnionOfUnionsAOu) __Reflect(__UnionOfUnionsReflect) {}

func (u *UnionOfUnionsAOu) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(u.Value)), 128)
	for _, elem0 := range u.Value {
		if elem0 == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionOfUnionsAOu) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		len0, err := decoder.StartArray(128)
		if err != nil {
			return err
		}
		u.Value = make([]ObjectUnion, len0)
		for i0 := uint32(0); i0 < len0; i0++ {
			var err error
			u.Value[i0], err = DecodeObjectUnion(decoder)
			if err != nil {
				return err
			}
			if u.Value[i0] == nil {
				return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
			}
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionOfUnionsAOu) MojomType() mojom_types.UserDefinedType {
	return UnionOfUnionsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionOfUnionsAOu) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionOfUnionsAHu struct { Value []HandleUnion }
func (u *UnionOfUnionsAHu) Tag() uint32 { return 2 }
func (u *UnionOfUnionsAHu) Interface() interface{} { return u.Value }
func (u *UnionOfUnionsAHu) __Reflect(__UnionOfUnionsReflect) {}

func (u *UnionOfUnionsAHu) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(u.Value)), 128)
	for _, elem0 := range u.Value {
		if elem0 == nil {
			return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
		}
		if err := elem0.Encode(encoder); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionOfUnionsAHu) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		len0, err := decoder.StartArray(128)
		if err != nil {
			return err
		}
		u.Value = make([]HandleUnion, len0)
		for i0 := uint32(0); i0 < len0; i0++ {
			var err error
			u.Value[i0], err = DecodeHandleUnion(decoder)
			if err != nil {
				return err
			}
			if u.Value[i0] == nil {
				return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
			}
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionOfUnionsAHu) MojomType() mojom_types.UserDefinedType {
	return UnionOfUnionsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionOfUnionsAHu) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionOfUnionsMOu struct { Value map[int64]ObjectUnion }
func (u *UnionOfUnionsMOu) Tag() uint32 { return 3 }
func (u *UnionOfUnionsMOu) Interface() interface{} { return u.Value }
func (u *UnionOfUnionsMOu) __Reflect(__UnionOfUnionsReflect) {}

func (u *UnionOfUnionsMOu) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []int64
		var values0 []ObjectUnion
		if encoder.Deterministic() {
		  for key0, _ := range u.Value {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]ObjectUnion, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = u.Value[key]
		  }
		} else {
		  for key0, value0 := range u.Value {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WriteInt64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 128)
		for _, elem1 := range values0 {
			if elem1 == nil {
				return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
			}
			if err := elem1.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionOfUnionsMOu) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := decoder.StartMap(); err != nil {
			return err
		}
		var keys0 []int64
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(64)
				if err != nil {
					return err
				}
				keys0 = make([]int64, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					value2, err := decoder.ReadInt64()
					if err != nil {
						return err
					}
					keys0[i1] = value2
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		var values0 []ObjectUnion
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(128)
				if err != nil {
					return err
				}
				values0 = make([]ObjectUnion, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					var err error
					values0[i1], err = DecodeObjectUnion(decoder)
					if err != nil {
						return err
					}
					if values0[i1] == nil {
						return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
					}
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		if len(keys0) != len(values0) {
			return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
				fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
			}
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
		len0 := len(keys0)
		map0 := make(map[int64]ObjectUnion)
		for i0 := 0; i0 < len0; i0++ {
			map0[keys0[i0]] = values0[i0]
		}
		u.Value = map0
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionOfUnionsMOu) MojomType() mojom_types.UserDefinedType {
	return UnionOfUnionsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionOfUnionsMOu) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type UnionOfUnionsMHu struct { Value map[int64]HandleUnion }
func (u *UnionOfUnionsMHu) Tag() uint32 { return 4 }
func (u *UnionOfUnionsMHu) Interface() interface{} { return u.Value }
func (u *UnionOfUnionsMHu) __Reflect(__UnionOfUnionsReflect) {}

func (u *UnionOfUnionsMHu) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []int64
		var values0 []HandleUnion
		if encoder.Deterministic() {
		  for key0, _ := range u.Value {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]HandleUnion, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = u.Value[key]
		  }
		} else {
		  for key0, value0 := range u.Value {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WriteInt64(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 128)
		for _, elem1 := range values0 {
			if elem1 == nil {
				return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
			}
			if err := elem1.Encode(encoder); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *UnionOfUnionsMHu) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := decoder.StartMap(); err != nil {
			return err
		}
		var keys0 []int64
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(64)
				if err != nil {
					return err
				}
				keys0 = make([]int64, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					value2, err := decoder.ReadInt64()
					if err != nil {
						return err
					}
					keys0[i1] = value2
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		var values0 []HandleUnion
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(128)
				if err != nil {
					return err
				}
				values0 = make([]HandleUnion, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					var err error
					values0[i1], err = DecodeHandleUnion(decoder)
					if err != nil {
						return err
					}
					if values0[i1] == nil {
						return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
					}
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		if len(keys0) != len(values0) {
			return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
				fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
			}
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
		len0 := len(keys0)
		map0 := make(map[int64]HandleUnion)
		for i0 := 0; i0 < len0; i0++ {
			map0[keys0[i0]] = values0[i0]
		}
		u.Value = map0
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*UnionOfUnionsMHu) MojomType() mojom_types.UserDefinedType {
	return UnionOfUnionsMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*UnionOfUnionsMHu) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}



type ObjectUnion interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__ObjectUnionReflect)
	Encode(encoder *bindings.Encoder) error
}


// ObjectUnionMojomType returns the UserDefinedType that describes the Mojom
// type of ObjectUnion. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func ObjectUnionMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.ObjectUnion"]
}



type __ObjectUnionReflect struct {
	FInt8 int8
	FString string
	FDummy DummyStruct
	FNullable *DummyStruct
	FArrayInt8 []int8
	FMapInt8 map[string]int8
	FPodUnion PodUnion
}

func DecodeObjectUnion(decoder *bindings.Decoder) (ObjectUnion, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value ObjectUnionFInt8
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value ObjectUnionFString
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 2:
		var value ObjectUnionFDummy
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 3:
		var value ObjectUnionFNullable
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 4:
		var value ObjectUnionFArrayInt8
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 5:
		var value ObjectUnionFMapInt8
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 6:
		var value ObjectUnionFPodUnion
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &ObjectUnionUnknown{tag: tag}, nil
}

type ObjectUnionUnknown struct { tag uint32 }
func (u *ObjectUnionUnknown) Tag() uint32 { return u.tag }
func (u *ObjectUnionUnknown) Interface() interface{} { return nil }
func (u *ObjectUnionUnknown) __Reflect(__ObjectUnionReflect) {}

func (u *ObjectUnionUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown ObjectUnion. There is no sane way to do that!");
}

type ObjectUnionFInt8 struct { Value int8 }
func (u *ObjectUnionFInt8) Tag() uint32 { return 0 }
func (u *ObjectUnionFInt8) Interface() interface{} { return u.Value }
func (u *ObjectUnionFInt8) __Reflect(__ObjectUnionReflect) {}

func (u *ObjectUnionFInt8) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt8(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *ObjectUnionFInt8) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt8()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ObjectUnionFInt8) MojomType() mojom_types.UserDefinedType {
	return ObjectUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ObjectUnionFInt8) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type ObjectUnionFString struct { Value string }
func (u *ObjectUnionFString) Tag() uint32 { return 1 }
func (u *ObjectUnionFString) Interface() interface{} { return u.Value }
func (u *ObjectUnionFString) __Reflect(__ObjectUnionReflect) {}

func (u *ObjectUnionFString) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *ObjectUnionFString) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		value0, err := decoder.ReadString()
		if err != nil {
			return err
		}
		u.Value = value0
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ObjectUnionFString) MojomType() mojom_types.UserDefinedType {
	return ObjectUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ObjectUnionFString) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type ObjectUnionFDummy struct { Value DummyStruct }
func (u *ObjectUnionFDummy) Tag() uint32 { return 2 }
func (u *ObjectUnionFDummy) Interface() interface{} { return u.Value }
func (u *ObjectUnionFDummy) __Reflect(__ObjectUnionReflect) {}

func (u *ObjectUnionFDummy) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *ObjectUnionFDummy) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ObjectUnionFDummy) MojomType() mojom_types.UserDefinedType {
	return ObjectUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ObjectUnionFDummy) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type ObjectUnionFNullable struct { Value *DummyStruct }
func (u *ObjectUnionFNullable) Tag() uint32 { return 3 }
func (u *ObjectUnionFNullable) Interface() interface{} { return u.Value }
func (u *ObjectUnionFNullable) __Reflect(__ObjectUnionReflect) {}

func (u *ObjectUnionFNullable) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if u.Value == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := (*u.Value).Encode(encoder); err != nil {
			return err
		}
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *ObjectUnionFNullable) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		u.Value = nil
	} else {
		u.Value = new(DummyStruct)
		if err := (*u.Value).Decode(decoder); err != nil {
			return err
		}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ObjectUnionFNullable) MojomType() mojom_types.UserDefinedType {
	return ObjectUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ObjectUnionFNullable) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type ObjectUnionFArrayInt8 struct { Value []int8 }
func (u *ObjectUnionFArrayInt8) Tag() uint32 { return 4 }
func (u *ObjectUnionFArrayInt8) Interface() interface{} { return u.Value }
func (u *ObjectUnionFArrayInt8) __Reflect(__ObjectUnionReflect) {}

func (u *ObjectUnionFArrayInt8) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartArray(uint32(len(u.Value)), 8)
	for _, elem0 := range u.Value {
		if err := encoder.WriteInt8(elem0); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *ObjectUnionFArrayInt8) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		len0, err := decoder.StartArray(8)
		if err != nil {
			return err
		}
		u.Value = make([]int8, len0)
		for i0 := uint32(0); i0 < len0; i0++ {
			value1, err := decoder.ReadInt8()
			if err != nil {
				return err
			}
			u.Value[i0] = value1
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ObjectUnionFArrayInt8) MojomType() mojom_types.UserDefinedType {
	return ObjectUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ObjectUnionFArrayInt8) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type ObjectUnionFMapInt8 struct { Value map[string]int8 }
func (u *ObjectUnionFMapInt8) Tag() uint32 { return 5 }
func (u *ObjectUnionFMapInt8) Interface() interface{} { return u.Value }
func (u *ObjectUnionFMapInt8) __Reflect(__ObjectUnionReflect) {}

func (u *ObjectUnionFMapInt8) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	encoder.StartMap()
	{
		var keys0 []string
		var values0 []int8
		if encoder.Deterministic() {
		  for key0, _ := range u.Value {
			keys0 = append(keys0, key0)
		  }
		  bindings.SortMapKeys(&keys0)
		  values0 = make([]int8, len(keys0))
		  for i, key := range keys0 {
		    values0[i] = u.Value[key]
		  }
		} else {
		  for key0, value0 := range u.Value {
			keys0 = append(keys0, key0)
			values0 = append(values0, value0)
		  }
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(keys0)), 64)
		for _, elem1 := range keys0 {
			if err := encoder.WritePointer(); err != nil {
				return err
			}
			if err := encoder.WriteString(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		encoder.StartArray(uint32(len(values0)), 8)
		for _, elem1 := range values0 {
			if err := encoder.WriteInt8(elem1); err != nil {
				return err
			}
		}
		if err := encoder.Finish(); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *ObjectUnionFMapInt8) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := decoder.StartMap(); err != nil {
			return err
		}
		var keys0 []string
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(64)
				if err != nil {
					return err
				}
				keys0 = make([]string, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					pointer2, err := decoder.ReadPointer()
					if err != nil {
						return err
					}
					if pointer2 == 0 {
						return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
					} else {
						value2, err := decoder.ReadString()
						if err != nil {
							return err
						}
						keys0[i1] = value2
					}
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		var values0 []int8
		{
			pointer1, err := decoder.ReadPointer()
			if err != nil {
				return err
			}
			if pointer1 == 0 {
				return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
			} else {
				len1, err := decoder.StartArray(8)
				if err != nil {
					return err
				}
				values0 = make([]int8, len1)
				for i1 := uint32(0); i1 < len1; i1++ {
					value2, err := decoder.ReadInt8()
					if err != nil {
						return err
					}
					values0[i1] = value2
				}
				if err := decoder.Finish(); err != nil {
					return err
				}
			}
		}
		if len(keys0) != len(values0) {
			return &bindings.ValidationError{bindings.DifferentSizedArraysInMap,
				fmt.Sprintf("Number of keys %d is different from number of values %d", len(keys0), len(values0)),
			}
		}
		if err := decoder.Finish(); err != nil {
			return err
		}
		len0 := len(keys0)
		map0 := make(map[string]int8)
		for i0 := 0; i0 < len0; i0++ {
			map0[keys0[i0]] = values0[i0]
		}
		u.Value = map0
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ObjectUnionFMapInt8) MojomType() mojom_types.UserDefinedType {
	return ObjectUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ObjectUnionFMapInt8) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type ObjectUnionFPodUnion struct { Value PodUnion }
func (u *ObjectUnionFPodUnion) Tag() uint32 { return 6 }
func (u *ObjectUnionFPodUnion) Interface() interface{} { return u.Value }
func (u *ObjectUnionFPodUnion) __Reflect(__ObjectUnionReflect) {}

func (u *ObjectUnionFPodUnion) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	
	encoder.StartNestedUnion()
	if u.Value == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}
	
	encoder.Finish()
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *ObjectUnionFPodUnion) decodeInternal(decoder *bindings.Decoder) error {
	if pointer, err := decoder.ReadPointer(); err != nil || pointer == 0 {
		if err != nil {
			return err
		}
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null union pointer"}
	}
	
	if err := decoder.StartNestedUnion(); err != nil {
		return err
	}
	
	var err error
	u.Value, err = DecodePodUnion(decoder)
	if err != nil {
		return err
	}
	if u.Value == nil {
		return &bindings.ValidationError{bindings.UnexpectedNullUnion, "unexpected null union"}
	}
	
	
	decoder.Finish()
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ObjectUnionFPodUnion) MojomType() mojom_types.UserDefinedType {
	return ObjectUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ObjectUnionFPodUnion) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}



type HandleUnion interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__HandleUnionReflect)
	Encode(encoder *bindings.Encoder) error
}


// HandleUnionMojomType returns the UserDefinedType that describes the Mojom
// type of HandleUnion. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func HandleUnionMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.HandleUnion"]
}



type __HandleUnionReflect struct {
	FHandle system.Handle
	FMessagePipe system.MessagePipeHandle
	FDataPipeConsumer system.ConsumerHandle
	FDataPipeProducer system.ProducerHandle
	FSharedBuffer system.SharedBufferHandle
	FSmallCache SmallCache_Pointer
}

func DecodeHandleUnion(decoder *bindings.Decoder) (HandleUnion, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value HandleUnionFHandle
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value HandleUnionFMessagePipe
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 2:
		var value HandleUnionFDataPipeConsumer
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 3:
		var value HandleUnionFDataPipeProducer
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 4:
		var value HandleUnionFSharedBuffer
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 5:
		var value HandleUnionFSmallCache
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &HandleUnionUnknown{tag: tag}, nil
}

type HandleUnionUnknown struct { tag uint32 }
func (u *HandleUnionUnknown) Tag() uint32 { return u.tag }
func (u *HandleUnionUnknown) Interface() interface{} { return nil }
func (u *HandleUnionUnknown) __Reflect(__HandleUnionReflect) {}

func (u *HandleUnionUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown HandleUnion. There is no sane way to do that!");
}

type HandleUnionFHandle struct { Value system.Handle }
func (u *HandleUnionFHandle) Tag() uint32 { return 0 }
func (u *HandleUnionFHandle) Interface() interface{} { return u.Value }
func (u *HandleUnionFHandle) __Reflect(__HandleUnionReflect) {}

func (u *HandleUnionFHandle) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteHandle(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *HandleUnionFHandle) decodeInternal(decoder *bindings.Decoder) error {
	handle0, err := decoder.ReadHandle()
	if err != nil {
		return err
	}
	if handle0.IsValid() {
		u.Value = handle0
	} else {
		return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*HandleUnionFHandle) MojomType() mojom_types.UserDefinedType {
	return HandleUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*HandleUnionFHandle) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type HandleUnionFMessagePipe struct { Value system.MessagePipeHandle }
func (u *HandleUnionFMessagePipe) Tag() uint32 { return 1 }
func (u *HandleUnionFMessagePipe) Interface() interface{} { return u.Value }
func (u *HandleUnionFMessagePipe) __Reflect(__HandleUnionReflect) {}

func (u *HandleUnionFMessagePipe) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteHandle(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *HandleUnionFMessagePipe) decodeInternal(decoder *bindings.Decoder) error {
	handle0, err := decoder.ReadMessagePipeHandle()
	if err != nil {
		return err
	}
	if handle0.IsValid() {
		u.Value = handle0
	} else {
		return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*HandleUnionFMessagePipe) MojomType() mojom_types.UserDefinedType {
	return HandleUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*HandleUnionFMessagePipe) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type HandleUnionFDataPipeConsumer struct { Value system.ConsumerHandle }
func (u *HandleUnionFDataPipeConsumer) Tag() uint32 { return 2 }
func (u *HandleUnionFDataPipeConsumer) Interface() interface{} { return u.Value }
func (u *HandleUnionFDataPipeConsumer) __Reflect(__HandleUnionReflect) {}

func (u *HandleUnionFDataPipeConsumer) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteHandle(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *HandleUnionFDataPipeConsumer) decodeInternal(decoder *bindings.Decoder) error {
	handle0, err := decoder.ReadConsumerHandle()
	if err != nil {
		return err
	}
	if handle0.IsValid() {
		u.Value = handle0
	} else {
		return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*HandleUnionFDataPipeConsumer) MojomType() mojom_types.UserDefinedType {
	return HandleUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*HandleUnionFDataPipeConsumer) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type HandleUnionFDataPipeProducer struct { Value system.ProducerHandle }
func (u *HandleUnionFDataPipeProducer) Tag() uint32 { return 3 }
func (u *HandleUnionFDataPipeProducer) Interface() interface{} { return u.Value }
func (u *HandleUnionFDataPipeProducer) __Reflect(__HandleUnionReflect) {}

func (u *HandleUnionFDataPipeProducer) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteHandle(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *HandleUnionFDataPipeProducer) decodeInternal(decoder *bindings.Decoder) error {
	handle0, err := decoder.ReadProducerHandle()
	if err != nil {
		return err
	}
	if handle0.IsValid() {
		u.Value = handle0
	} else {
		return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*HandleUnionFDataPipeProducer) MojomType() mojom_types.UserDefinedType {
	return HandleUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*HandleUnionFDataPipeProducer) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type HandleUnionFSharedBuffer struct { Value system.SharedBufferHandle }
func (u *HandleUnionFSharedBuffer) Tag() uint32 { return 4 }
func (u *HandleUnionFSharedBuffer) Interface() interface{} { return u.Value }
func (u *HandleUnionFSharedBuffer) __Reflect(__HandleUnionReflect) {}

func (u *HandleUnionFSharedBuffer) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteHandle(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *HandleUnionFSharedBuffer) decodeInternal(decoder *bindings.Decoder) error {
	handle0, err := decoder.ReadSharedBufferHandle()
	if err != nil {
		return err
	}
	if handle0.IsValid() {
		u.Value = handle0
	} else {
		return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*HandleUnionFSharedBuffer) MojomType() mojom_types.UserDefinedType {
	return HandleUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*HandleUnionFSharedBuffer) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type HandleUnionFSmallCache struct { Value SmallCache_Pointer }
func (u *HandleUnionFSmallCache) Tag() uint32 { return 5 }
func (u *HandleUnionFSmallCache) Interface() interface{} { return u.Value }
func (u *HandleUnionFSmallCache) __Reflect(__HandleUnionReflect) {}

func (u *HandleUnionFSmallCache) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInterface(u.Value.PassMessagePipe()); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *HandleUnionFSmallCache) decodeInternal(decoder *bindings.Decoder) error {
	handle0, err := decoder.ReadInterface()
	if err != nil {
		return err
	}
	if handle0.IsValid() {
		handleOwner := bindings.NewMessagePipeHandleOwner(handle0)
		u.Value = SmallCache_Pointer{handleOwner}
	} else {
		return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*HandleUnionFSmallCache) MojomType() mojom_types.UserDefinedType {
	return HandleUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*HandleUnionFSmallCache) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}



type ObjectOnlyUnion interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__ObjectOnlyUnionReflect)
	Encode(encoder *bindings.Encoder) error
}


// ObjectOnlyUnionMojomType returns the UserDefinedType that describes the Mojom
// type of ObjectOnlyUnion. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func ObjectOnlyUnionMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.ObjectOnlyUnion"]
}



type __ObjectOnlyUnionReflect struct {
	Dummy1 DummyStruct
}

func DecodeObjectOnlyUnion(decoder *bindings.Decoder) (ObjectOnlyUnion, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value ObjectOnlyUnionDummy1
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &ObjectOnlyUnionUnknown{tag: tag}, nil
}

type ObjectOnlyUnionUnknown struct { tag uint32 }
func (u *ObjectOnlyUnionUnknown) Tag() uint32 { return u.tag }
func (u *ObjectOnlyUnionUnknown) Interface() interface{} { return nil }
func (u *ObjectOnlyUnionUnknown) __Reflect(__ObjectOnlyUnionReflect) {}

func (u *ObjectOnlyUnionUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown ObjectOnlyUnion. There is no sane way to do that!");
}

type ObjectOnlyUnionDummy1 struct { Value DummyStruct }
func (u *ObjectOnlyUnionDummy1) Tag() uint32 { return 0 }
func (u *ObjectOnlyUnionDummy1) Interface() interface{} { return u.Value }
func (u *ObjectOnlyUnionDummy1) __Reflect(__ObjectOnlyUnionReflect) {}

func (u *ObjectOnlyUnionDummy1) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := u.Value.Encode(encoder); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *ObjectOnlyUnionDummy1) decodeInternal(decoder *bindings.Decoder) error {
	pointer0, err := decoder.ReadPointer()
	if err != nil {
		return err
	}
	if pointer0 == 0 {
		return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
	} else {
		if err := u.Value.Decode(decoder); err != nil {
			return err
		}
	}
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*ObjectOnlyUnionDummy1) MojomType() mojom_types.UserDefinedType {
	return ObjectOnlyUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*ObjectOnlyUnionDummy1) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}



type OldUnion interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__OldUnionReflect)
	Encode(encoder *bindings.Encoder) error
}


// OldUnionMojomType returns the UserDefinedType that describes the Mojom
// type of OldUnion. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func OldUnionMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.OldUnion"]
}



type __OldUnionReflect struct {
	FInt8 int8
}

func DecodeOldUnion(decoder *bindings.Decoder) (OldUnion, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value OldUnionFInt8
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &OldUnionUnknown{tag: tag}, nil
}

type OldUnionUnknown struct { tag uint32 }
func (u *OldUnionUnknown) Tag() uint32 { return u.tag }
func (u *OldUnionUnknown) Interface() interface{} { return nil }
func (u *OldUnionUnknown) __Reflect(__OldUnionReflect) {}

func (u *OldUnionUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown OldUnion. There is no sane way to do that!");
}

type OldUnionFInt8 struct { Value int8 }
func (u *OldUnionFInt8) Tag() uint32 { return 0 }
func (u *OldUnionFInt8) Interface() interface{} { return u.Value }
func (u *OldUnionFInt8) __Reflect(__OldUnionReflect) {}

func (u *OldUnionFInt8) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt8(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *OldUnionFInt8) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt8()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*OldUnionFInt8) MojomType() mojom_types.UserDefinedType {
	return OldUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*OldUnionFInt8) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}



type NewUnion interface {
	Tag() uint32
	Interface() interface{}
	__Reflect(__NewUnionReflect)
	Encode(encoder *bindings.Encoder) error
}


// NewUnionMojomType returns the UserDefinedType that describes the Mojom
// type of NewUnion. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func NewUnionMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:mojo.test.NewUnion"]
}



type __NewUnionReflect struct {
	FInt8 int8
	FInt16 int16
}

func DecodeNewUnion(decoder *bindings.Decoder) (NewUnion, error) {
	size, tag, err := decoder.ReadUnionHeader()
	if err != nil {
		return nil, err
	}

	if size == 0 {
		decoder.SkipUnionValue()
		return nil, nil
	}

	switch tag {
	case 0:
		var value NewUnionFInt8
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	case 1:
		var value NewUnionFInt16
		if err := value.decodeInternal(decoder); err != nil {
			return nil, err
		}
		decoder.FinishReadingUnionValue()
		return &value, nil
	}

	decoder.SkipUnionValue()
	return &NewUnionUnknown{tag: tag}, nil
}

type NewUnionUnknown struct { tag uint32 }
func (u *NewUnionUnknown) Tag() uint32 { return u.tag }
func (u *NewUnionUnknown) Interface() interface{} { return nil }
func (u *NewUnionUnknown) __Reflect(__NewUnionReflect) {}

func (u *NewUnionUnknown) Encode(encoder *bindings.Encoder) error {
	return fmt.Errorf("Trying to serialize an unknown NewUnion. There is no sane way to do that!");
}

type NewUnionFInt8 struct { Value int8 }
func (u *NewUnionFInt8) Tag() uint32 { return 0 }
func (u *NewUnionFInt8) Interface() interface{} { return u.Value }
func (u *NewUnionFInt8) __Reflect(__NewUnionReflect) {}

func (u *NewUnionFInt8) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt8(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *NewUnionFInt8) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt8()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*NewUnionFInt8) MojomType() mojom_types.UserDefinedType {
	return NewUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*NewUnionFInt8) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type NewUnionFInt16 struct { Value int16 }
func (u *NewUnionFInt16) Tag() uint32 { return 1 }
func (u *NewUnionFInt16) Interface() interface{} { return u.Value }
func (u *NewUnionFInt16) __Reflect(__NewUnionReflect) {}

func (u *NewUnionFInt16) Encode(encoder *bindings.Encoder) error {
	encoder.WriteUnionHeader(u.Tag())
	if err := encoder.WriteInt16(u.Value); err != nil {
		return err
	}
	
	encoder.FinishWritingUnionValue()
	return nil
}

func (u *NewUnionFInt16) decodeInternal(decoder *bindings.Decoder) error {
	value0, err := decoder.ReadInt16()
	if err != nil {
		return err
	}
	u.Value = value0
	
	return nil
}


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*NewUnionFInt16) MojomType() mojom_types.UserDefinedType {
	return NewUnionMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*NewUnionFInt16) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}



