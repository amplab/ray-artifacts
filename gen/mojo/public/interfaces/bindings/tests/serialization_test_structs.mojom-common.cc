// NOTE: This file was generated by the Mojo bindings generator.
#include "mojo/public/interfaces/bindings/tests/serialization_test_structs.mojom-common.h"

#include <math.h>
#include <ostream>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
namespace mojo {
namespace test {

// --- Constants ---

namespace internal {

// --- Struct definitions ---


// static
Struct1_Data* Struct1_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Struct1_Data))) Struct1_Data();
}

// static
mojo::internal::ValidationError Struct1_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Struct1_Data* object = static_cast<const Struct1_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }

  return mojo::internal::ValidationError::NONE;
}

void Struct1_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
}

void Struct1_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
}

Struct1_Data::Struct1_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
Struct2_Data* Struct2_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Struct2_Data))) Struct2_Data();
}

// static
mojo::internal::ValidationError Struct2_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Struct2_Data* object = static_cast<const Struct2_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle hdl_handle = object->hdl;
  if (hdl_handle.value() == mojo::internal::kEncodedInvalidHandleValue) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err)
        << "invalid hdl field in Struct2 struct";
    return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
  }
  if (!bounds_checker->ClaimHandle(hdl_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Struct2_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->hdl, handles);
}

void Struct2_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->hdl, handles);
}

Struct2_Data::Struct2_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
Struct3_Data* Struct3_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Struct3_Data))) Struct3_Data();
}

// static
mojo::internal::ValidationError Struct3_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Struct3_Data* object = static_cast<const Struct3_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->struct_1.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null struct_1 field in Struct3 struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->struct_1.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = Struct1::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->struct_1.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Struct3_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->struct_1, handles);
}

void Struct3_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->struct_1, handles);
}

Struct3_Data::Struct3_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
Struct4_Data* Struct4_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Struct4_Data))) Struct4_Data();
}

// static
mojo::internal::ValidationError Struct4_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Struct4_Data* object = static_cast<const Struct4_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->data.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null data field in Struct4 struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->data.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams data_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::Array<Struct1Ptr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->data.offset),
          bounds_checker, &data_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Struct4_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->data, handles);
}

void Struct4_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->data, handles);
}

Struct4_Data::Struct4_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
Struct5_Data* Struct5_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Struct5_Data))) Struct5_Data();
}

// static
mojo::internal::ValidationError Struct5_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Struct5_Data* object = static_cast<const Struct5_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->pair.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null pair field in Struct5 struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->pair.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams pair_validate_params(
      2, false, nullptr);
  auto validate_retval =
      mojo::Array<Struct1Ptr>::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->pair.offset),
          bounds_checker, &pair_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Struct5_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->pair, handles);
}

void Struct5_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->pair, handles);
}

Struct5_Data::Struct5_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
Struct6_Data* Struct6_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(Struct6_Data))) Struct6_Data();
}

// static
mojo::internal::ValidationError Struct6_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Struct6_Data* object = static_cast<const Struct6_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  if (!object->str.offset) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) <<
        "null str field in Struct6 struct";
    return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
  }
  if (!mojo::internal::ValidateEncodedPointer(&object->str.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams str_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->str.offset),
          bounds_checker, &str_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void Struct6_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::Encode(&this->str, handles);
}

void Struct6_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::Decode(&this->str, handles);
}

Struct6_Data::Struct6_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// static
StructOfNullables_Data* StructOfNullables_Data::New(mojo::internal::Buffer* buf) {
  return new (buf->Allocate(sizeof(StructOfNullables_Data))) StructOfNullables_Data();
}

// static
mojo::internal::ValidationError StructOfNullables_Data::Validate(
    const void* data,
    mojo::internal::BoundsChecker* bounds_checker,
    std::string* err) {
  mojo::internal::ValidationError retval;
  
  if (!data)
    return mojo::internal::ValidationError::NONE;

  retval = ValidateStructHeaderAndClaimMemory(data, bounds_checker, err);
  if (retval != mojo::internal::ValidationError::NONE)
    return retval;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const StructOfNullables_Data* object = static_cast<const StructOfNullables_Data*>(data);

  static const struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = MOJO_ARRAYSIZE(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
        return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[MOJO_ARRAYSIZE(kVersionSizes) - 1].num_bytes) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::UNEXPECTED_STRUCT_HEADER;
  }
  {
    
  const mojo::Handle hdl_handle = object->hdl;
  if (!bounds_checker->ClaimHandle(hdl_handle)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_HANDLE;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->struct_1.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  auto validate_retval = Struct1::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->struct_1.offset),
          bounds_checker, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }
  {
    
  if (!mojo::internal::ValidateEncodedPointer(&object->str.offset)) {
    MOJO_INTERNAL_DEBUG_SET_ERROR_MSG(err) << "";
    return mojo::internal::ValidationError::ILLEGAL_POINTER;
  }
  const mojo::internal::ArrayValidateParams str_validate_params(
      0, false, nullptr);
  auto validate_retval =
      mojo::String::Data_::Validate(
          mojo::internal::DecodePointerRaw(&object->str.offset),
          bounds_checker, &str_validate_params, err);
  if (validate_retval != mojo::internal::ValidationError::NONE) {
    return validate_retval;
  }
  }

  return mojo::internal::ValidationError::NONE;
}

void StructOfNullables_Data::EncodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  MOJO_CHECK(header_.version == 0);
  mojo::internal::EncodeHandle(&this->hdl, handles);
  mojo::internal::Encode(&this->struct_1, handles);
  mojo::internal::Encode(&this->str, handles);
}

void StructOfNullables_Data::DecodePointersAndHandles(
    std::vector<mojo::Handle>* handles) {
  // NOTE: The memory backing |this| may has be smaller than |sizeof(*this)|, if
  // the message comes from an older version.
  mojo::internal::DecodeHandle(&this->hdl, handles);
  mojo::internal::Decode(&this->struct_1, handles);
  mojo::internal::Decode(&this->str, handles);
}

StructOfNullables_Data::StructOfNullables_Data() {
  header_.num_bytes = sizeof(*this);
  header_.version = 0;
}


// --- Union definitions ---


// --- Definitions of the data structs for interface methods ---

}  // namespace internal

// --- Request and response validator definitions for interfaces --- 

// --- Enums ---

// Base interface definitions (Name_, Version_, Constants, Enums)

// Struct Constants

// --- Struct builder definitions ---

// static
Struct1Ptr Struct1::New() {
  Struct1Ptr rv;
  mojo::internal::StructHelper<Struct1>::Initialize(&rv);
  return rv;
}

Struct1::Struct1()
    : i() {
}

Struct1::~Struct1() {
}


Struct1Ptr Struct1::Clone() const {
  Struct1Ptr rv(New());
  rv->i = i;
  return rv;
}


bool Struct1::Equals(const Struct1& other) const {
  if (!mojo::internal::ValueTraits<uint8_t>::Equals(this->i, other.i))
    return false;
  return true;
}


// static
Struct2Ptr Struct2::New() {
  Struct2Ptr rv;
  mojo::internal::StructHelper<Struct2>::Initialize(&rv);
  return rv;
}

Struct2::Struct2()
    : hdl() {
}

Struct2::~Struct2() {
}



bool Struct2::Equals(const Struct2& other) const {
  if (!mojo::internal::ValueTraits<mojo::ScopedHandle>::Equals(this->hdl, other.hdl))
    return false;
  return true;
}


// static
Struct3Ptr Struct3::New() {
  Struct3Ptr rv;
  mojo::internal::StructHelper<Struct3>::Initialize(&rv);
  return rv;
}

Struct3::Struct3()
    : struct_1() {
}

Struct3::~Struct3() {
}


Struct3Ptr Struct3::Clone() const {
  Struct3Ptr rv(New());
  rv->struct_1 = struct_1.Clone();
  return rv;
}


bool Struct3::Equals(const Struct3& other) const {
  if (!mojo::internal::ValueTraits<Struct1Ptr>::Equals(this->struct_1, other.struct_1))
    return false;
  return true;
}


// static
Struct4Ptr Struct4::New() {
  Struct4Ptr rv;
  mojo::internal::StructHelper<Struct4>::Initialize(&rv);
  return rv;
}

Struct4::Struct4()
    : data() {
}

Struct4::~Struct4() {
}


Struct4Ptr Struct4::Clone() const {
  Struct4Ptr rv(New());
  rv->data = data.Clone();
  return rv;
}


bool Struct4::Equals(const Struct4& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<Struct1Ptr>>::Equals(this->data, other.data))
    return false;
  return true;
}


// static
Struct5Ptr Struct5::New() {
  Struct5Ptr rv;
  mojo::internal::StructHelper<Struct5>::Initialize(&rv);
  return rv;
}

Struct5::Struct5()
    : pair() {
}

Struct5::~Struct5() {
}


Struct5Ptr Struct5::Clone() const {
  Struct5Ptr rv(New());
  rv->pair = pair.Clone();
  return rv;
}


bool Struct5::Equals(const Struct5& other) const {
  if (!mojo::internal::ValueTraits<mojo::Array<Struct1Ptr>>::Equals(this->pair, other.pair))
    return false;
  return true;
}


// static
Struct6Ptr Struct6::New() {
  Struct6Ptr rv;
  mojo::internal::StructHelper<Struct6>::Initialize(&rv);
  return rv;
}

Struct6::Struct6()
    : str() {
}

Struct6::~Struct6() {
}


Struct6Ptr Struct6::Clone() const {
  Struct6Ptr rv(New());
  rv->str = str;
  return rv;
}


bool Struct6::Equals(const Struct6& other) const {
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->str, other.str))
    return false;
  return true;
}


// static
StructOfNullablesPtr StructOfNullables::New() {
  StructOfNullablesPtr rv;
  mojo::internal::StructHelper<StructOfNullables>::Initialize(&rv);
  return rv;
}

StructOfNullables::StructOfNullables()
    : hdl(),
      struct_1(),
      str() {
}

StructOfNullables::~StructOfNullables() {
}



bool StructOfNullables::Equals(const StructOfNullables& other) const {
  if (!mojo::internal::ValueTraits<mojo::ScopedHandle>::Equals(this->hdl, other.hdl))
    return false;
  if (!mojo::internal::ValueTraits<Struct1Ptr>::Equals(this->struct_1, other.struct_1))
    return false;
  if (!mojo::internal::ValueTraits<mojo::String>::Equals(this->str, other.str))
    return false;
  return true;
}


// --- Union builder definitions ---

// --- Struct Serialization Helpers ---

size_t Struct1::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Struct1::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Struct1_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Struct1::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Struct1_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Struct1::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Struct1_Data* input =
      static_cast<internal::Struct1_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Struct1& input) {
  size_t size = sizeof(internal::Struct1_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Struct1* input,
    mojo::internal::Buffer* buf,
    internal::Struct1_Data** output) {
  if (input) {
    internal::Struct1_Data* result =
        internal::Struct1_Data::New(buf);
    result->i = input->i;
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Struct1_Data* input,
                  Struct1* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->i = input->i;
    } while (false);
  }
}


size_t Struct2::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Struct2::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Struct2_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Struct2::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Struct2_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Struct2::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Struct2_Data* input =
      static_cast<internal::Struct2_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Struct2& input) {
  size_t size = sizeof(internal::Struct2_Data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Struct2* input,
    mojo::internal::Buffer* buf,
    internal::Struct2_Data** output) {
  if (input) {
    internal::Struct2_Data* result =
        internal::Struct2_Data::New(buf);
    result->hdl = input->hdl.release();
    if (!result->hdl.is_valid()) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE, "invalid hdl in Struct2 struct");
      return mojo::internal::ValidationError::UNEXPECTED_INVALID_HANDLE;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Struct2_Data* input,
                  Struct2* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->hdl.reset(mojo::internal::FetchAndReset(&input->hdl));
    } while (false);
  }
}


size_t Struct3::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Struct3::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Struct3_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Struct3::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Struct3_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Struct3::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Struct3_Data* input =
      static_cast<internal::Struct3_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Struct3& input) {
  size_t size = sizeof(internal::Struct3_Data);
  size += input.struct_1.is_null()
              ? 0
              : GetSerializedSize_(*input.struct_1);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Struct3* input,
    mojo::internal::Buffer* buf,
    internal::Struct3_Data** output) {
  if (input) {
    internal::Struct3_Data* result =
        internal::Struct3_Data::New(buf);
    {auto retval =Serialize_(input->struct_1.get(),
                 buf,
                 &result->struct_1.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->struct_1.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null struct_1 in Struct3 struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Struct3_Data* input,
                  Struct3* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      if (input->struct_1.ptr) {
        result->struct_1 = Struct1::New();
        Deserialize_(input->struct_1.ptr, result->struct_1.get());
      }
    } while (false);
  }
}


size_t Struct4::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Struct4::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Struct4_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Struct4::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Struct4_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Struct4::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Struct4_Data* input =
      static_cast<internal::Struct4_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Struct4& input) {
  size_t size = sizeof(internal::Struct4_Data);
  size += GetSerializedSize_(input.data);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Struct4* input,
    mojo::internal::Buffer* buf,
    internal::Struct4_Data** output) {
  if (input) {
    internal::Struct4_Data* result =
        internal::Struct4_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams data_validate_params(
        0, false, nullptr);auto retval =mojo::SerializeArray_(&input->data, buf, &result->data.ptr,
                            &data_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->data.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null data in Struct4 struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Struct4_Data* input,
                  Struct4* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->data.ptr, &result->data);
    } while (false);
  }
}


size_t Struct5::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Struct5::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Struct5_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Struct5::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Struct5_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Struct5::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Struct5_Data* input =
      static_cast<internal::Struct5_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Struct5& input) {
  size_t size = sizeof(internal::Struct5_Data);
  size += GetSerializedSize_(input.pair);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Struct5* input,
    mojo::internal::Buffer* buf,
    internal::Struct5_Data** output) {
  if (input) {
    internal::Struct5_Data* result =
        internal::Struct5_Data::New(buf);
    {
      const mojo::internal::ArrayValidateParams pair_validate_params(
        2, false, nullptr);auto retval =mojo::SerializeArray_(&input->pair, buf, &result->pair.ptr,
                            &pair_validate_params);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    if (!result->pair.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null pair in Struct5 struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Struct5_Data* input,
                  Struct5* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->pair.ptr, &result->pair);
    } while (false);
  }
}


size_t Struct6::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool Struct6::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::Struct6_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool Struct6::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::Struct6_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void Struct6::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::Struct6_Data* input =
      static_cast<internal::Struct6_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const Struct6& input) {
  size_t size = sizeof(internal::Struct6_Data);
  size += GetSerializedSize_(input.str);
  return size;
}

mojo::internal::ValidationError Serialize_(
    Struct6* input,
    mojo::internal::Buffer* buf,
    internal::Struct6_Data** output) {
  if (input) {
    internal::Struct6_Data* result =
        internal::Struct6_Data::New(buf);
    SerializeString_(input->str, buf, &result->str.ptr);
    if (!result->str.ptr) {
      MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER, "null str in Struct6 struct");
      return mojo::internal::ValidationError::UNEXPECTED_NULL_POINTER;
    }
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::Struct6_Data* input,
                  Struct6* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      Deserialize_(input->str.ptr, &result->str);
    } while (false);
  }
}


size_t StructOfNullables::GetSerializedSize() const {
  return GetSerializedSize_(*this);
}

bool StructOfNullables::Serialize(void* buf,
                                size_t buf_size,
                                size_t* bytes_written) {
  MOJO_DCHECK(buf);

  mojo::internal::FixedBuffer overlay_buf;
  overlay_buf.Initialize(buf, buf_size);

  internal::StructOfNullables_Data* output_ptr;
  auto err = Serialize_(this, &overlay_buf, &output_ptr);
  if (err != mojo::internal::ValidationError::NONE) {
    // TODO(vardhan): Once Serialize_() outputs handles that it serialized
    // (even partially, if there are failures), we should CHECK fail here if
    // handles are non-empty.
    MOJO_DLOG(ERROR) << "Could not serialize: " <<
        mojo::internal::ValidationErrorToString(err);

    if (bytes_written)
      *bytes_written = overlay_buf.BytesUsed();
    return false;
  }

  std::vector<mojo::Handle> handles;
  output_ptr->EncodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Serialize() does not support handles.";

  if (bytes_written)
    *bytes_written = overlay_buf.BytesUsed();
  return true;
}

bool StructOfNullables::Deserialize(void* buf, size_t buf_size) {
  MOJO_DCHECK(buf);

  mojo::internal::BoundsChecker checker(buf, buf_size, 0);

  std::string* err_str = nullptr;
#if !defined(NDEBUG)
  std::string err_str2;
  err_str = &err_str2;
#endif

  mojo::internal::ValidationError err =
      internal::StructOfNullables_Data::Validate(buf, &checker, err_str);
  if (err != mojo::internal::ValidationError::NONE) {
    MOJO_DLOG(ERROR) << "Deserialization error "
                     << mojo::internal::ValidationErrorToString(err)
                     << ": " << *err_str;
    return false;
  }

  DeserializeWithoutValidation(buf);
  return true;
}

// TODO(vardhan): Make this |buf| a |const void*| once deserialization becomes
// immutable.
void StructOfNullables::DeserializeWithoutValidation(void* buf) {
  MOJO_DCHECK(buf);

  internal::StructOfNullables_Data* input =
      static_cast<internal::StructOfNullables_Data*>(buf);
  std::vector<mojo::Handle> handles;
  input->DecodePointersAndHandles(&handles);
  MOJO_CHECK(handles.empty()) << "Deserialization does not support handles.";

  Deserialize_(input, this);
}

size_t GetSerializedSize_(const StructOfNullables& input) {
  size_t size = sizeof(internal::StructOfNullables_Data);
  size += input.struct_1.is_null()
              ? 0
              : GetSerializedSize_(*input.struct_1);
  size += GetSerializedSize_(input.str);
  return size;
}

mojo::internal::ValidationError Serialize_(
    StructOfNullables* input,
    mojo::internal::Buffer* buf,
    internal::StructOfNullables_Data** output) {
  if (input) {
    internal::StructOfNullables_Data* result =
        internal::StructOfNullables_Data::New(buf);
    result->hdl = input->hdl.release();
    {auto retval =Serialize_(input->struct_1.get(),
                 buf,
                 &result->struct_1.ptr);
      if (retval != mojo::internal::ValidationError::NONE)
        return retval;
    }
    SerializeString_(input->str, buf, &result->str.ptr);
    *output = result;
  } else {
    *output = nullptr;
  }
  return mojo::internal::ValidationError::NONE;
}

void Deserialize_(internal::StructOfNullables_Data* input,
                  StructOfNullables* result) {
  if (input) {
    do {
      // NOTE: The memory backing |input| may has be smaller than
      // |sizeof(*input)| if the message comes from an older version.
      result->hdl.reset(mojo::internal::FetchAndReset(&input->hdl));
      if (input->struct_1.ptr) {
        result->struct_1 = Struct1::New();
        Deserialize_(input->struct_1.ptr, result->struct_1.get());
      }
      Deserialize_(input->str.ptr, &result->str);
    } while (false);
  }
}


// --- Union Serialization Helpers ---

// --- Structs for interface method parameters ---
}  // namespace test
}  // namespace mojo
