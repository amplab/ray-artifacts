// NOTE: This file was generated by the Mojo bindings generator.
#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_STRUCTS_MOJOM_COMMON_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_STRUCTS_MOJOM_COMMON_H_

#include <stdint.h>
#include <iosfwd>

#include "mojo/public/cpp/bindings/array.h"
#include "mojo/public/cpp/bindings/callback.h"
#include "mojo/public/cpp/bindings/interface_handle.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/map.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/bindings/string.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/system/buffer.h"
#include "mojo/public/cpp/system/data_pipe.h"
#include "mojo/public/cpp/system/handle.h"
#include "mojo/public/cpp/system/message_pipe.h"
#include "mojo/public/interfaces/bindings/tests/test_structs.mojom-internal.h"
#include "mojo/public/interfaces/bindings/tests/rect.mojom-common.h"
namespace mojo {
namespace test {

// --- Interface Forward Declarations ---
class SomeInterface;
class SomeInterfaceRequestValidator;
class SomeInterfaceResponseValidator;
class SomeInterface_Synchronous;

// --- Struct Forward Declarations ---
class StructOfStructs;

using StructOfStructsPtr = mojo::StructPtr<StructOfStructs>;


class NamedRegion;

using NamedRegionPtr = mojo::StructPtr<NamedRegion>;


class RectPair;

using RectPairPtr = mojo::StructPtr<RectPair>;


class EmptyStruct;

using EmptyStructPtr = mojo::InlinedStructPtr<EmptyStruct>;


class HandleStruct;

using HandleStructPtr = mojo::StructPtr<HandleStruct>;


class NullableHandleStruct;

using NullableHandleStructPtr = mojo::StructPtr<NullableHandleStruct>;


class NoDefaultFieldValues;

using NoDefaultFieldValuesPtr = mojo::StructPtr<NoDefaultFieldValues>;


class DefaultFieldValues;

using DefaultFieldValuesPtr = mojo::StructPtr<DefaultFieldValues>;


class ScopedConstants;

using ScopedConstantsPtr = mojo::StructPtr<ScopedConstants>;


class MapKeyTypes;

using MapKeyTypesPtr = mojo::StructPtr<MapKeyTypes>;


class MapValueTypes;

using MapValueTypesPtr = mojo::StructPtr<MapValueTypes>;


class ArrayValueTypes;

using ArrayValueTypesPtr = mojo::StructPtr<ArrayValueTypes>;


class FloatNumberValues;

using FloatNumberValuesPtr = mojo::StructPtr<FloatNumberValues>;


class IntegerNumberValues;

using IntegerNumberValuesPtr = mojo::StructPtr<IntegerNumberValues>;


class UnsignedNumberValues;

using UnsignedNumberValuesPtr = mojo::StructPtr<UnsignedNumberValues>;


class BitArrayValues;

using BitArrayValuesPtr = mojo::StructPtr<BitArrayValues>;


class MultiVersionStruct;

using MultiVersionStructPtr = mojo::StructPtr<MultiVersionStruct>;


class MultiVersionStructV0;

using MultiVersionStructV0Ptr = mojo::InlinedStructPtr<MultiVersionStructV0>;


class MultiVersionStructV1;

using MultiVersionStructV1Ptr = mojo::StructPtr<MultiVersionStructV1>;


class MultiVersionStructV3;

using MultiVersionStructV3Ptr = mojo::StructPtr<MultiVersionStructV3>;


class MultiVersionStructV5;

using MultiVersionStructV5Ptr = mojo::StructPtr<MultiVersionStructV5>;


class MultiVersionStructV7;

using MultiVersionStructV7Ptr = mojo::StructPtr<MultiVersionStructV7>;


class ContainsInterface;

using ContainsInterfacePtr = mojo::StructPtr<ContainsInterface>;


class ContainsOther;

using ContainsOtherPtr = mojo::InlinedStructPtr<ContainsOther>;


class ContainsInterfaceRequest;

using ContainsInterfaceRequestPtr = mojo::StructPtr<ContainsInterfaceRequest>;


class DartKeywordStruct;

using DartKeywordStructPtr = mojo::InlinedStructPtr<DartKeywordStruct>;



// --- Union Forward Declarations ---
class UnionOfStructs;
typedef mojo::StructPtr<UnionOfStructs> UnionOfStructsPtr;

// --- Enums Declarations ---

// --- Constants ---

// --- Interface declarations ---
namespace internal {
class SomeInterface_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = SomeInterfaceRequestValidator;
  using ResponseValidator_ = SomeInterfaceResponseValidator;
  using Synchronous_ = SomeInterface_Synchronous;
  enum class MessageOrdinals : uint32_t {
    SomeMethod = 0,
  };


  virtual ~SomeInterface_Base() {}
};

}  // namespace internal

// Async interface declaration

class SomeInterfaceProxy;
class SomeInterfaceStub;
class SomeInterface_Synchronous;

class SomeInterfaceRequestValidator;
class SomeInterfaceResponseValidator;

class SomeInterface : public internal::SomeInterface_Base {
 public:
  virtual ~SomeInterface() override {}

  using Proxy_ = SomeInterfaceProxy;
  using Stub_ = SomeInterfaceStub;
  using SomeMethodCallback = mojo::Callback<void(RectPairPtr)>;
  virtual void SomeMethod(RectPairPtr pair, const SomeMethodCallback& callback) = 0;
};

}  // namespace test
}  // namespace mojo

// --- Internal Template Specializations ---

namespace mojo {
namespace internal {
template <>
struct WrapperTraits<mojo::test::StructOfStructsPtr, true, false> {
  using DataType = mojo::test::internal::StructOfStructs_Data*;
};
template <>
struct WrapperTraits<mojo::test::NamedRegionPtr, true, false> {
  using DataType = mojo::test::internal::NamedRegion_Data*;
};
template <>
struct WrapperTraits<mojo::test::RectPairPtr, true, false> {
  using DataType = mojo::test::internal::RectPair_Data*;
};
template <>
struct WrapperTraits<mojo::test::EmptyStructPtr, true, false> {
  using DataType = mojo::test::internal::EmptyStruct_Data*;
};
template <>
struct WrapperTraits<mojo::test::HandleStructPtr, true, false> {
  using DataType = mojo::test::internal::HandleStruct_Data*;
};
template <>
struct WrapperTraits<mojo::test::NullableHandleStructPtr, true, false> {
  using DataType = mojo::test::internal::NullableHandleStruct_Data*;
};
template <>
struct WrapperTraits<mojo::test::NoDefaultFieldValuesPtr, true, false> {
  using DataType = mojo::test::internal::NoDefaultFieldValues_Data*;
};
template <>
struct WrapperTraits<mojo::test::DefaultFieldValuesPtr, true, false> {
  using DataType = mojo::test::internal::DefaultFieldValues_Data*;
};
template <>
struct WrapperTraits<mojo::test::ScopedConstantsPtr, true, false> {
  using DataType = mojo::test::internal::ScopedConstants_Data*;
};
template <>
struct WrapperTraits<mojo::test::MapKeyTypesPtr, true, false> {
  using DataType = mojo::test::internal::MapKeyTypes_Data*;
};
template <>
struct WrapperTraits<mojo::test::MapValueTypesPtr, true, false> {
  using DataType = mojo::test::internal::MapValueTypes_Data*;
};
template <>
struct WrapperTraits<mojo::test::ArrayValueTypesPtr, true, false> {
  using DataType = mojo::test::internal::ArrayValueTypes_Data*;
};
template <>
struct WrapperTraits<mojo::test::FloatNumberValuesPtr, true, false> {
  using DataType = mojo::test::internal::FloatNumberValues_Data*;
};
template <>
struct WrapperTraits<mojo::test::IntegerNumberValuesPtr, true, false> {
  using DataType = mojo::test::internal::IntegerNumberValues_Data*;
};
template <>
struct WrapperTraits<mojo::test::UnsignedNumberValuesPtr, true, false> {
  using DataType = mojo::test::internal::UnsignedNumberValues_Data*;
};
template <>
struct WrapperTraits<mojo::test::BitArrayValuesPtr, true, false> {
  using DataType = mojo::test::internal::BitArrayValues_Data*;
};
template <>
struct WrapperTraits<mojo::test::MultiVersionStructPtr, true, false> {
  using DataType = mojo::test::internal::MultiVersionStruct_Data*;
};
template <>
struct WrapperTraits<mojo::test::MultiVersionStructV0Ptr, true, false> {
  using DataType = mojo::test::internal::MultiVersionStructV0_Data*;
};
template <>
struct WrapperTraits<mojo::test::MultiVersionStructV1Ptr, true, false> {
  using DataType = mojo::test::internal::MultiVersionStructV1_Data*;
};
template <>
struct WrapperTraits<mojo::test::MultiVersionStructV3Ptr, true, false> {
  using DataType = mojo::test::internal::MultiVersionStructV3_Data*;
};
template <>
struct WrapperTraits<mojo::test::MultiVersionStructV5Ptr, true, false> {
  using DataType = mojo::test::internal::MultiVersionStructV5_Data*;
};
template <>
struct WrapperTraits<mojo::test::MultiVersionStructV7Ptr, true, false> {
  using DataType = mojo::test::internal::MultiVersionStructV7_Data*;
};
template <>
struct WrapperTraits<mojo::test::ContainsInterfacePtr, true, false> {
  using DataType = mojo::test::internal::ContainsInterface_Data*;
};
template <>
struct WrapperTraits<mojo::test::ContainsOtherPtr, true, false> {
  using DataType = mojo::test::internal::ContainsOther_Data*;
};
template <>
struct WrapperTraits<mojo::test::ContainsInterfaceRequestPtr, true, false> {
  using DataType = mojo::test::internal::ContainsInterfaceRequest_Data*;
};
template <>
struct WrapperTraits<mojo::test::DartKeywordStructPtr, true, false> {
  using DataType = mojo::test::internal::DartKeywordStruct_Data*;
};

}  // internal
}  // mojo
namespace mojo {
namespace test {

// --- Interface Request Validators ---
class SomeInterfaceRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface Response Validators ---
class SomeInterfaceResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface enum operators ---

// --- Unions ---
// Unions must be declared first because they can be members of structs.
class UnionOfStructs {
 public:
  using Data_ = internal::UnionOfStructs_Data;
  using Tag = Data_::UnionOfStructs_Tag;

  static UnionOfStructsPtr New();

  template <typename U>
  static UnionOfStructsPtr From(const U& u) {
    return mojo::TypeConverter<UnionOfStructsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UnionOfStructs>::Convert(*this);
  }

  UnionOfStructs();
  ~UnionOfStructs();


  bool Equals(const UnionOfStructs& other) const;

  Tag which() const {
    return tag_;
  }


  bool is_nr() const;
  NamedRegionPtr& get_nr() const;
  void set_nr(NamedRegionPtr nr);
  bool is_a_nr() const;
  mojo::Array<NamedRegionPtr>& get_a_nr() const;
  void set_a_nr(mojo::Array<NamedRegionPtr> a_nr);
  bool is_a_rp() const;
  mojo::Array<RectPairPtr>& get_a_rp() const;
  void set_a_rp(mojo::Array<RectPairPtr> a_rp);
  bool is_m_ndfv() const;
  mojo::Map<int64_t, NoDefaultFieldValuesPtr>& get_m_ndfv() const;
  void set_m_ndfv(mojo::Map<int64_t, NoDefaultFieldValuesPtr> m_ndfv);
  bool is_m_hs() const;
  mojo::Map<int64_t, HandleStructPtr>& get_m_hs() const;
  void set_m_hs(mojo::Map<int64_t, HandleStructPtr> m_hs);
  bool has_unknown_tag() const;

 private:
  friend class mojo::internal::UnionAccessor<UnionOfStructs>;
  union Union_ {
    Union_() {}
    ~Union_() {}

NamedRegionPtr* nr;

mojo::Array<NamedRegionPtr>* a_nr;

mojo::Array<RectPairPtr>* a_rp;

mojo::Map<int64_t, NoDefaultFieldValuesPtr>* m_ndfv;

mojo::Map<int64_t, HandleStructPtr>* m_hs;

  };
  void SwitchActive(Tag new_active);
  void SetActive(Tag new_active);
  void DestroyActive();
  Tag tag_;
  Union_ data_;
};


// --- Inlined structs ---
class EmptyStruct {
 public:
  using Data_ = internal::EmptyStruct_Data;

  static EmptyStructPtr New();

  template <typename U>
  static EmptyStructPtr From(const U& u) {
    return mojo::TypeConverter<EmptyStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, EmptyStruct>::Convert(*this);
  }

  EmptyStruct();
  ~EmptyStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  EmptyStructPtr Clone() const;
  bool Equals(const EmptyStruct& other) const;

};


class MultiVersionStructV0 {
 public:
  using Data_ = internal::MultiVersionStructV0_Data;

  static MultiVersionStructV0Ptr New();

  template <typename U>
  static MultiVersionStructV0Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV0Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV0>::Convert(*this);
  }

  MultiVersionStructV0();
  ~MultiVersionStructV0();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  MultiVersionStructV0Ptr Clone() const;
  bool Equals(const MultiVersionStructV0& other) const;

  int32_t f_int32;
};


class ContainsOther {
 public:
  using Data_ = internal::ContainsOther_Data;

  static ContainsOtherPtr New();

  template <typename U>
  static ContainsOtherPtr From(const U& u) {
    return mojo::TypeConverter<ContainsOtherPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ContainsOther>::Convert(*this);
  }

  ContainsOther();
  ~ContainsOther();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ContainsOtherPtr Clone() const;
  bool Equals(const ContainsOther& other) const;

  int32_t other;
};


class DartKeywordStruct {
 public:
  using Data_ = internal::DartKeywordStruct_Data;
  enum class Keywords : int32_t {
    AWAIT,
    IS,
    RETHROW,
  };
  
  static bool Keywords_IsValidValue(Keywords value);

  static DartKeywordStructPtr New();

  template <typename U>
  static DartKeywordStructPtr From(const U& u) {
    return mojo::TypeConverter<DartKeywordStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DartKeywordStruct>::Convert(*this);
  }

  DartKeywordStruct();
  ~DartKeywordStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  DartKeywordStructPtr Clone() const;
  bool Equals(const DartKeywordStruct& other) const;

  DartKeywordStruct::Keywords await;
  DartKeywordStruct::Keywords is;
  DartKeywordStruct::Keywords rethrow;
};

  
std::ostream& operator<<(std::ostream& stream,
                         const DartKeywordStruct::Keywords& val);


// --- Non-inlined structs ---
class StructOfStructs {
 public:
  using Data_ = internal::StructOfStructs_Data;

  static StructOfStructsPtr New();

  template <typename U>
  static StructOfStructsPtr From(const U& u) {
    return mojo::TypeConverter<StructOfStructsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructOfStructs>::Convert(*this);
  }

  StructOfStructs();
  ~StructOfStructs();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const StructOfStructs& other) const;

  NamedRegionPtr nr;
  mojo::Array<NamedRegionPtr> a_nr;
  mojo::Array<RectPairPtr> a_rp;
  mojo::Map<int64_t, NoDefaultFieldValuesPtr> m_ndfv;
  mojo::Map<int64_t, HandleStructPtr> m_hs;
};


class NamedRegion {
 public:
  using Data_ = internal::NamedRegion_Data;

  static NamedRegionPtr New();

  template <typename U>
  static NamedRegionPtr From(const U& u) {
    return mojo::TypeConverter<NamedRegionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NamedRegion>::Convert(*this);
  }

  NamedRegion();
  ~NamedRegion();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  NamedRegionPtr Clone() const;
  bool Equals(const NamedRegion& other) const;

  mojo::String name;
  mojo::Array<mojo::test::RectPtr> rects;
};


class RectPair {
 public:
  using Data_ = internal::RectPair_Data;

  static RectPairPtr New();

  template <typename U>
  static RectPairPtr From(const U& u) {
    return mojo::TypeConverter<RectPairPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, RectPair>::Convert(*this);
  }

  RectPair();
  ~RectPair();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  RectPairPtr Clone() const;
  bool Equals(const RectPair& other) const;

  mojo::test::RectPtr first;
  mojo::test::RectPtr second;
};


class HandleStruct {
 public:
  using Data_ = internal::HandleStruct_Data;

  static HandleStructPtr New();

  template <typename U>
  static HandleStructPtr From(const U& u) {
    return mojo::TypeConverter<HandleStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HandleStruct>::Convert(*this);
  }

  HandleStruct();
  ~HandleStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const HandleStruct& other) const;

  mojo::ScopedMessagePipeHandle h;
  mojo::Array<mojo::ScopedMessagePipeHandle> array_h;
};


class NullableHandleStruct {
 public:
  using Data_ = internal::NullableHandleStruct_Data;

  static NullableHandleStructPtr New();

  template <typename U>
  static NullableHandleStructPtr From(const U& u) {
    return mojo::TypeConverter<NullableHandleStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NullableHandleStruct>::Convert(*this);
  }

  NullableHandleStruct();
  ~NullableHandleStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const NullableHandleStruct& other) const;

  mojo::ScopedMessagePipeHandle h;
  int32_t data;
};


class NoDefaultFieldValues {
 public:
  using Data_ = internal::NoDefaultFieldValues_Data;

  static NoDefaultFieldValuesPtr New();

  template <typename U>
  static NoDefaultFieldValuesPtr From(const U& u) {
    return mojo::TypeConverter<NoDefaultFieldValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NoDefaultFieldValues>::Convert(*this);
  }

  NoDefaultFieldValues();
  ~NoDefaultFieldValues();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const NoDefaultFieldValues& other) const;

  bool f0;
  int8_t f1;
  uint8_t f2;
  int16_t f3;
  uint16_t f4;
  int32_t f5;
  uint32_t f6;
  int64_t f7;
  uint64_t f8;
  float f9;
  double f10;
  mojo::String f11;
  mojo::String f12;
  mojo::ScopedMessagePipeHandle f13;
  mojo::ScopedDataPipeConsumerHandle f14;
  mojo::ScopedDataPipeProducerHandle f15;
  mojo::ScopedMessagePipeHandle f16;
  mojo::ScopedDataPipeConsumerHandle f17;
  mojo::ScopedDataPipeProducerHandle f18;
  mojo::ScopedHandle f19;
  mojo::ScopedHandle f20;
  mojo::ScopedSharedBufferHandle f21;
  mojo::ScopedSharedBufferHandle f22;
  mojo::Array<mojo::String> f23;
  mojo::Array<mojo::String> f24;
  mojo::Array<mojo::String> f25;
  mojo::Array<mojo::String> f26;
  EmptyStructPtr f27;
  EmptyStructPtr f28;
};


class DefaultFieldValues {
 public:
  using Data_ = internal::DefaultFieldValues_Data;
  static const char* kFoo;

  static DefaultFieldValuesPtr New();

  template <typename U>
  static DefaultFieldValuesPtr From(const U& u) {
    return mojo::TypeConverter<DefaultFieldValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DefaultFieldValues>::Convert(*this);
  }

  DefaultFieldValues();
  ~DefaultFieldValues();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  DefaultFieldValuesPtr Clone() const;
  bool Equals(const DefaultFieldValues& other) const;

  bool f0;
  int8_t f1;
  uint8_t f2;
  int16_t f3;
  uint16_t f4;
  int32_t f5;
  uint32_t f6;
  int64_t f7;
  uint64_t f8;
  float f9;
  float f10;
  double f11;
  double f12;
  mojo::String f13;
  mojo::String f14;
  mojo::test::RectPtr f15;
  mojo::test::RectPtr f16;
};


class ScopedConstants {
 public:
  using Data_ = internal::ScopedConstants_Data;
  enum class EType : int32_t {
    E0,
    E1,
    E2 = 10,
    E3 = ScopedConstants::EType::E2,
    E4,
  };
  
  static bool EType_IsValidValue(EType value);
  static const int32_t TEN = 10;
  static const int32_t ALSO_TEN = ScopedConstants::TEN;

  static ScopedConstantsPtr New();

  template <typename U>
  static ScopedConstantsPtr From(const U& u) {
    return mojo::TypeConverter<ScopedConstantsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ScopedConstants>::Convert(*this);
  }

  ScopedConstants();
  ~ScopedConstants();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ScopedConstantsPtr Clone() const;
  bool Equals(const ScopedConstants& other) const;

  ScopedConstants::EType f0;
  ScopedConstants::EType f1;
  ScopedConstants::EType f2;
  ScopedConstants::EType f3;
  ScopedConstants::EType f4;
  int32_t f5;
  int32_t f6;
};

  
std::ostream& operator<<(std::ostream& stream,
                         const ScopedConstants::EType& val);

class MapKeyTypes {
 public:
  using Data_ = internal::MapKeyTypes_Data;

  static MapKeyTypesPtr New();

  template <typename U>
  static MapKeyTypesPtr From(const U& u) {
    return mojo::TypeConverter<MapKeyTypesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MapKeyTypes>::Convert(*this);
  }

  MapKeyTypes();
  ~MapKeyTypes();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  MapKeyTypesPtr Clone() const;
  bool Equals(const MapKeyTypes& other) const;

  mojo::Map<bool, bool> f0;
  mojo::Map<int8_t, int8_t> f1;
  mojo::Map<uint8_t, uint8_t> f2;
  mojo::Map<int16_t, int16_t> f3;
  mojo::Map<uint16_t, uint16_t> f4;
  mojo::Map<int32_t, int32_t> f5;
  mojo::Map<uint32_t, uint32_t> f6;
  mojo::Map<int64_t, int64_t> f7;
  mojo::Map<uint64_t, uint64_t> f8;
  mojo::Map<float, float> f9;
  mojo::Map<double, double> f10;
  mojo::Map<mojo::String, mojo::String> f11;
};


class MapValueTypes {
 public:
  using Data_ = internal::MapValueTypes_Data;

  static MapValueTypesPtr New();

  template <typename U>
  static MapValueTypesPtr From(const U& u) {
    return mojo::TypeConverter<MapValueTypesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MapValueTypes>::Convert(*this);
  }

  MapValueTypes();
  ~MapValueTypes();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const MapValueTypes& other) const;

  mojo::Map<mojo::String, mojo::Array<mojo::String> > f0;
  mojo::Map<mojo::String, mojo::Array<mojo::String> > f1;
  mojo::Map<mojo::String, mojo::Array<mojo::String> > f2;
  mojo::Map<mojo::String, mojo::Array<mojo::String> > f3;
  mojo::Map<mojo::String, mojo::Array<mojo::Array<mojo::String> > > f4;
  mojo::Map<mojo::String, mojo::Array<mojo::Array<mojo::String> > > f5;
  mojo::Map<mojo::String, mojo::test::RectPtr> f6;
  mojo::Map<mojo::String, mojo::Map<mojo::String, mojo::String> > f7;
  mojo::Map<mojo::String, mojo::Array<mojo::Map<mojo::String, mojo::String> > > f8;
  mojo::Map<mojo::String, mojo::ScopedHandle> f9;
  mojo::Map<mojo::String, mojo::Array<mojo::ScopedHandle> > f10;
  mojo::Map<mojo::String, mojo::Map<mojo::String, mojo::ScopedHandle> > f11;
};


class ArrayValueTypes {
 public:
  using Data_ = internal::ArrayValueTypes_Data;

  static ArrayValueTypesPtr New();

  template <typename U>
  static ArrayValueTypesPtr From(const U& u) {
    return mojo::TypeConverter<ArrayValueTypesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ArrayValueTypes>::Convert(*this);
  }

  ArrayValueTypes();
  ~ArrayValueTypes();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ArrayValueTypesPtr Clone() const;
  bool Equals(const ArrayValueTypes& other) const;

  mojo::Array<int8_t> f0;
  mojo::Array<int16_t> f1;
  mojo::Array<int32_t> f2;
  mojo::Array<int64_t> f3;
  mojo::Array<float> f4;
  mojo::Array<double> f5;
};


class FloatNumberValues {
 public:
  using Data_ = internal::FloatNumberValues_Data;
  static const double V0;
  static const double V1;
  static const double V2;
  static const float V3;
  static const float V4;
  static const float V5;
  static const float V6;
  static const double V7;
  static const double V8;
  static const double V9;

  static FloatNumberValuesPtr New();

  template <typename U>
  static FloatNumberValuesPtr From(const U& u) {
    return mojo::TypeConverter<FloatNumberValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FloatNumberValues>::Convert(*this);
  }

  FloatNumberValues();
  ~FloatNumberValues();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  FloatNumberValuesPtr Clone() const;
  bool Equals(const FloatNumberValues& other) const;

  double f0;
  double f1;
  double f2;
  float f3;
  float f4;
  float f5;
  float f6;
  double f7;
  double f8;
  double f9;
};


class IntegerNumberValues {
 public:
  using Data_ = internal::IntegerNumberValues_Data;
  static const int8_t V0 = -128;
  static const int8_t V1 = -1;
  static const int8_t V2 = 0;
  static const int8_t V3 = 42;
  static const int8_t V4 = 127;
  static const int16_t V5 = -32768;
  static const int16_t V6 = -1;
  static const int16_t V7 = 0;
  static const int16_t V8 = 12345;
  static const int16_t V9 = 32767;
  static const int32_t V10 = (-2147483647 - 1) /* Workaround for MSVC bug; see https://crbug.com/445618 */;
  static const int32_t V11 = -1;
  static const int32_t V12 = 0;
  static const int32_t V13 = 1234567890;
  static const int32_t V14 = 2147483647;
  static const int64_t V15 = -9007199254740991;
  static const int64_t V16 = -1;
  static const int64_t V17 = 0;
  static const int64_t V18 = 1234567890123456;
  static const int64_t V19 = 9007199254740991;

  static IntegerNumberValuesPtr New();

  template <typename U>
  static IntegerNumberValuesPtr From(const U& u) {
    return mojo::TypeConverter<IntegerNumberValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, IntegerNumberValues>::Convert(*this);
  }

  IntegerNumberValues();
  ~IntegerNumberValues();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  IntegerNumberValuesPtr Clone() const;
  bool Equals(const IntegerNumberValues& other) const;

  int8_t f0;
  int8_t f1;
  int8_t f2;
  int8_t f3;
  int8_t f4;
  int16_t f5;
  int16_t f6;
  int16_t f7;
  int16_t f8;
  int16_t f9;
  int32_t f10;
  int32_t f11;
  int32_t f12;
  int32_t f13;
  int32_t f14;
  int64_t f15;
  int64_t f16;
  int64_t f17;
  int64_t f18;
  int64_t f19;
};


class UnsignedNumberValues {
 public:
  using Data_ = internal::UnsignedNumberValues_Data;
  static const uint8_t V0 = 0U;
  static const uint8_t V1 = 42U;
  static const uint8_t V2 = 255U;
  static const uint16_t V3 = 0U;
  static const uint16_t V4 = 12345U;
  static const uint16_t V5 = 65535U;
  static const uint32_t V6 = 0U;
  static const uint32_t V7 = 1234567890U;
  static const uint32_t V8 = 4294967295U;
  static const uint64_t V9 = 0ULL;
  static const uint64_t V10 = 1234567890123456ULL;
  static const uint64_t V11 = 9007199254740991ULL;

  static UnsignedNumberValuesPtr New();

  template <typename U>
  static UnsignedNumberValuesPtr From(const U& u) {
    return mojo::TypeConverter<UnsignedNumberValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UnsignedNumberValues>::Convert(*this);
  }

  UnsignedNumberValues();
  ~UnsignedNumberValues();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  UnsignedNumberValuesPtr Clone() const;
  bool Equals(const UnsignedNumberValues& other) const;

  uint8_t f0;
  uint8_t f1;
  uint8_t f2;
  uint16_t f3;
  uint16_t f4;
  uint16_t f5;
  uint32_t f6;
  uint32_t f7;
  uint32_t f8;
  uint64_t f9;
  uint64_t f10;
  uint64_t f11;
};


class BitArrayValues {
 public:
  using Data_ = internal::BitArrayValues_Data;

  static BitArrayValuesPtr New();

  template <typename U>
  static BitArrayValuesPtr From(const U& u) {
    return mojo::TypeConverter<BitArrayValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BitArrayValues>::Convert(*this);
  }

  BitArrayValues();
  ~BitArrayValues();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  BitArrayValuesPtr Clone() const;
  bool Equals(const BitArrayValues& other) const;

  mojo::Array<bool> f0;
  mojo::Array<bool> f1;
  mojo::Array<bool> f2;
  mojo::Array<bool> f3;
  mojo::Array<mojo::Array<bool> > f4;
  mojo::Array<mojo::Array<bool> > f5;
  mojo::Array<mojo::Array<bool> > f6;
};


class MultiVersionStruct {
 public:
  using Data_ = internal::MultiVersionStruct_Data;

  static MultiVersionStructPtr New();

  template <typename U>
  static MultiVersionStructPtr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStruct>::Convert(*this);
  }

  MultiVersionStruct();
  ~MultiVersionStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const MultiVersionStruct& other) const;

  int32_t f_int32;
  mojo::test::RectPtr f_rect;
  mojo::String f_string;
  mojo::Array<int8_t> f_array;
  mojo::ScopedMessagePipeHandle f_message_pipe;
  bool f_bool;
  int16_t f_int16;
};


class MultiVersionStructV1 {
 public:
  using Data_ = internal::MultiVersionStructV1_Data;

  static MultiVersionStructV1Ptr New();

  template <typename U>
  static MultiVersionStructV1Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV1Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV1>::Convert(*this);
  }

  MultiVersionStructV1();
  ~MultiVersionStructV1();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  MultiVersionStructV1Ptr Clone() const;
  bool Equals(const MultiVersionStructV1& other) const;

  int32_t f_int32;
  mojo::test::RectPtr f_rect;
};


class MultiVersionStructV3 {
 public:
  using Data_ = internal::MultiVersionStructV3_Data;

  static MultiVersionStructV3Ptr New();

  template <typename U>
  static MultiVersionStructV3Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV3Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV3>::Convert(*this);
  }

  MultiVersionStructV3();
  ~MultiVersionStructV3();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  MultiVersionStructV3Ptr Clone() const;
  bool Equals(const MultiVersionStructV3& other) const;

  int32_t f_int32;
  mojo::test::RectPtr f_rect;
  mojo::String f_string;
};


class MultiVersionStructV5 {
 public:
  using Data_ = internal::MultiVersionStructV5_Data;

  static MultiVersionStructV5Ptr New();

  template <typename U>
  static MultiVersionStructV5Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV5Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV5>::Convert(*this);
  }

  MultiVersionStructV5();
  ~MultiVersionStructV5();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  MultiVersionStructV5Ptr Clone() const;
  bool Equals(const MultiVersionStructV5& other) const;

  int32_t f_int32;
  mojo::test::RectPtr f_rect;
  mojo::String f_string;
  mojo::Array<int8_t> f_array;
};


class MultiVersionStructV7 {
 public:
  using Data_ = internal::MultiVersionStructV7_Data;

  static MultiVersionStructV7Ptr New();

  template <typename U>
  static MultiVersionStructV7Ptr From(const U& u) {
    return mojo::TypeConverter<MultiVersionStructV7Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MultiVersionStructV7>::Convert(*this);
  }

  MultiVersionStructV7();
  ~MultiVersionStructV7();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const MultiVersionStructV7& other) const;

  int32_t f_int32;
  mojo::test::RectPtr f_rect;
  mojo::String f_string;
  mojo::Array<int8_t> f_array;
  mojo::ScopedMessagePipeHandle f_message_pipe;
  bool f_bool;
};


class ContainsInterface {
 public:
  using Data_ = internal::ContainsInterface_Data;

  static ContainsInterfacePtr New();

  template <typename U>
  static ContainsInterfacePtr From(const U& u) {
    return mojo::TypeConverter<ContainsInterfacePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ContainsInterface>::Convert(*this);
  }

  ContainsInterface();
  ~ContainsInterface();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const ContainsInterface& other) const;

  mojo::InterfaceHandle<SomeInterface> some_interface;
};


class ContainsInterfaceRequest {
 public:
  using Data_ = internal::ContainsInterfaceRequest_Data;

  static ContainsInterfaceRequestPtr New();

  template <typename U>
  static ContainsInterfaceRequestPtr From(const U& u) {
    return mojo::TypeConverter<ContainsInterfaceRequestPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ContainsInterfaceRequest>::Convert(*this);
  }

  ContainsInterfaceRequest();
  ~ContainsInterfaceRequest();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const ContainsInterfaceRequest& other) const;

  mojo::InterfaceRequest<SomeInterface> req;
  mojo::InterfaceRequest<SomeInterface> nullable_req;
};



// --- Struct serialization helpers ---
size_t GetSerializedSize_(const StructOfStructs& input);
mojo::internal::ValidationError Serialize_(
    StructOfStructs* input,
    mojo::internal::Buffer* buffer,
    internal::StructOfStructs_Data** output);
void Deserialize_(internal::StructOfStructs_Data* input,
                  StructOfStructs* output);

size_t GetSerializedSize_(const NamedRegion& input);
mojo::internal::ValidationError Serialize_(
    NamedRegion* input,
    mojo::internal::Buffer* buffer,
    internal::NamedRegion_Data** output);
void Deserialize_(internal::NamedRegion_Data* input,
                  NamedRegion* output);

size_t GetSerializedSize_(const RectPair& input);
mojo::internal::ValidationError Serialize_(
    RectPair* input,
    mojo::internal::Buffer* buffer,
    internal::RectPair_Data** output);
void Deserialize_(internal::RectPair_Data* input,
                  RectPair* output);

size_t GetSerializedSize_(const EmptyStruct& input);
mojo::internal::ValidationError Serialize_(
    EmptyStruct* input,
    mojo::internal::Buffer* buffer,
    internal::EmptyStruct_Data** output);
void Deserialize_(internal::EmptyStruct_Data* input,
                  EmptyStruct* output);

size_t GetSerializedSize_(const HandleStruct& input);
mojo::internal::ValidationError Serialize_(
    HandleStruct* input,
    mojo::internal::Buffer* buffer,
    internal::HandleStruct_Data** output);
void Deserialize_(internal::HandleStruct_Data* input,
                  HandleStruct* output);

size_t GetSerializedSize_(const NullableHandleStruct& input);
mojo::internal::ValidationError Serialize_(
    NullableHandleStruct* input,
    mojo::internal::Buffer* buffer,
    internal::NullableHandleStruct_Data** output);
void Deserialize_(internal::NullableHandleStruct_Data* input,
                  NullableHandleStruct* output);

size_t GetSerializedSize_(const NoDefaultFieldValues& input);
mojo::internal::ValidationError Serialize_(
    NoDefaultFieldValues* input,
    mojo::internal::Buffer* buffer,
    internal::NoDefaultFieldValues_Data** output);
void Deserialize_(internal::NoDefaultFieldValues_Data* input,
                  NoDefaultFieldValues* output);

size_t GetSerializedSize_(const DefaultFieldValues& input);
mojo::internal::ValidationError Serialize_(
    DefaultFieldValues* input,
    mojo::internal::Buffer* buffer,
    internal::DefaultFieldValues_Data** output);
void Deserialize_(internal::DefaultFieldValues_Data* input,
                  DefaultFieldValues* output);

size_t GetSerializedSize_(const ScopedConstants& input);
mojo::internal::ValidationError Serialize_(
    ScopedConstants* input,
    mojo::internal::Buffer* buffer,
    internal::ScopedConstants_Data** output);
void Deserialize_(internal::ScopedConstants_Data* input,
                  ScopedConstants* output);

size_t GetSerializedSize_(const MapKeyTypes& input);
mojo::internal::ValidationError Serialize_(
    MapKeyTypes* input,
    mojo::internal::Buffer* buffer,
    internal::MapKeyTypes_Data** output);
void Deserialize_(internal::MapKeyTypes_Data* input,
                  MapKeyTypes* output);

size_t GetSerializedSize_(const MapValueTypes& input);
mojo::internal::ValidationError Serialize_(
    MapValueTypes* input,
    mojo::internal::Buffer* buffer,
    internal::MapValueTypes_Data** output);
void Deserialize_(internal::MapValueTypes_Data* input,
                  MapValueTypes* output);

size_t GetSerializedSize_(const ArrayValueTypes& input);
mojo::internal::ValidationError Serialize_(
    ArrayValueTypes* input,
    mojo::internal::Buffer* buffer,
    internal::ArrayValueTypes_Data** output);
void Deserialize_(internal::ArrayValueTypes_Data* input,
                  ArrayValueTypes* output);

size_t GetSerializedSize_(const FloatNumberValues& input);
mojo::internal::ValidationError Serialize_(
    FloatNumberValues* input,
    mojo::internal::Buffer* buffer,
    internal::FloatNumberValues_Data** output);
void Deserialize_(internal::FloatNumberValues_Data* input,
                  FloatNumberValues* output);

size_t GetSerializedSize_(const IntegerNumberValues& input);
mojo::internal::ValidationError Serialize_(
    IntegerNumberValues* input,
    mojo::internal::Buffer* buffer,
    internal::IntegerNumberValues_Data** output);
void Deserialize_(internal::IntegerNumberValues_Data* input,
                  IntegerNumberValues* output);

size_t GetSerializedSize_(const UnsignedNumberValues& input);
mojo::internal::ValidationError Serialize_(
    UnsignedNumberValues* input,
    mojo::internal::Buffer* buffer,
    internal::UnsignedNumberValues_Data** output);
void Deserialize_(internal::UnsignedNumberValues_Data* input,
                  UnsignedNumberValues* output);

size_t GetSerializedSize_(const BitArrayValues& input);
mojo::internal::ValidationError Serialize_(
    BitArrayValues* input,
    mojo::internal::Buffer* buffer,
    internal::BitArrayValues_Data** output);
void Deserialize_(internal::BitArrayValues_Data* input,
                  BitArrayValues* output);

size_t GetSerializedSize_(const MultiVersionStruct& input);
mojo::internal::ValidationError Serialize_(
    MultiVersionStruct* input,
    mojo::internal::Buffer* buffer,
    internal::MultiVersionStruct_Data** output);
void Deserialize_(internal::MultiVersionStruct_Data* input,
                  MultiVersionStruct* output);

size_t GetSerializedSize_(const MultiVersionStructV0& input);
mojo::internal::ValidationError Serialize_(
    MultiVersionStructV0* input,
    mojo::internal::Buffer* buffer,
    internal::MultiVersionStructV0_Data** output);
void Deserialize_(internal::MultiVersionStructV0_Data* input,
                  MultiVersionStructV0* output);

size_t GetSerializedSize_(const MultiVersionStructV1& input);
mojo::internal::ValidationError Serialize_(
    MultiVersionStructV1* input,
    mojo::internal::Buffer* buffer,
    internal::MultiVersionStructV1_Data** output);
void Deserialize_(internal::MultiVersionStructV1_Data* input,
                  MultiVersionStructV1* output);

size_t GetSerializedSize_(const MultiVersionStructV3& input);
mojo::internal::ValidationError Serialize_(
    MultiVersionStructV3* input,
    mojo::internal::Buffer* buffer,
    internal::MultiVersionStructV3_Data** output);
void Deserialize_(internal::MultiVersionStructV3_Data* input,
                  MultiVersionStructV3* output);

size_t GetSerializedSize_(const MultiVersionStructV5& input);
mojo::internal::ValidationError Serialize_(
    MultiVersionStructV5* input,
    mojo::internal::Buffer* buffer,
    internal::MultiVersionStructV5_Data** output);
void Deserialize_(internal::MultiVersionStructV5_Data* input,
                  MultiVersionStructV5* output);

size_t GetSerializedSize_(const MultiVersionStructV7& input);
mojo::internal::ValidationError Serialize_(
    MultiVersionStructV7* input,
    mojo::internal::Buffer* buffer,
    internal::MultiVersionStructV7_Data** output);
void Deserialize_(internal::MultiVersionStructV7_Data* input,
                  MultiVersionStructV7* output);

size_t GetSerializedSize_(const ContainsInterface& input);
mojo::internal::ValidationError Serialize_(
    ContainsInterface* input,
    mojo::internal::Buffer* buffer,
    internal::ContainsInterface_Data** output);
void Deserialize_(internal::ContainsInterface_Data* input,
                  ContainsInterface* output);

size_t GetSerializedSize_(const ContainsOther& input);
mojo::internal::ValidationError Serialize_(
    ContainsOther* input,
    mojo::internal::Buffer* buffer,
    internal::ContainsOther_Data** output);
void Deserialize_(internal::ContainsOther_Data* input,
                  ContainsOther* output);

size_t GetSerializedSize_(const ContainsInterfaceRequest& input);
mojo::internal::ValidationError Serialize_(
    ContainsInterfaceRequest* input,
    mojo::internal::Buffer* buffer,
    internal::ContainsInterfaceRequest_Data** output);
void Deserialize_(internal::ContainsInterfaceRequest_Data* input,
                  ContainsInterfaceRequest* output);

size_t GetSerializedSize_(const DartKeywordStruct& input);
mojo::internal::ValidationError Serialize_(
    DartKeywordStruct* input,
    mojo::internal::Buffer* buffer,
    internal::DartKeywordStruct_Data** output);
void Deserialize_(internal::DartKeywordStruct_Data* input,
                  DartKeywordStruct* output);


// --- Union serialization helpers ---
size_t GetSerializedSize_(const UnionOfStructsPtr& input);
mojo::internal::ValidationError SerializeUnion_(
    UnionOfStructs* input,
    mojo::internal::Buffer* buffer,
    internal::UnionOfStructs_Data** output);
void Deserialize_(internal::UnionOfStructs_Data* input,
                  UnionOfStructs* output);


// --- Request and response parameter structs for Interface methods ---
      

class SomeInterface_SomeMethod_Params;

using SomeInterface_SomeMethod_ParamsPtr = mojo::StructPtr<SomeInterface_SomeMethod_Params>;


size_t GetSerializedSize_(const SomeInterface_SomeMethod_Params& input);
mojo::internal::ValidationError Serialize_(
    SomeInterface_SomeMethod_Params* input,
    mojo::internal::Buffer* buffer,
    internal::SomeInterface_SomeMethod_Params_Data** output);
void Deserialize_(internal::SomeInterface_SomeMethod_Params_Data* input,
                  SomeInterface_SomeMethod_Params* output);

class SomeInterface_SomeMethod_Params {
 public:
  using Data_ = internal::SomeInterface_SomeMethod_Params_Data;

  static SomeInterface_SomeMethod_ParamsPtr New();

  template <typename U>
  static SomeInterface_SomeMethod_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<SomeInterface_SomeMethod_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SomeInterface_SomeMethod_Params>::Convert(*this);
  }

  SomeInterface_SomeMethod_Params();
  ~SomeInterface_SomeMethod_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  SomeInterface_SomeMethod_ParamsPtr Clone() const;
  bool Equals(const SomeInterface_SomeMethod_Params& other) const;

  RectPairPtr pair;
};



class SomeInterface_SomeMethod_ResponseParams;

using SomeInterface_SomeMethod_ResponseParamsPtr = mojo::StructPtr<SomeInterface_SomeMethod_ResponseParams>;


size_t GetSerializedSize_(const SomeInterface_SomeMethod_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    SomeInterface_SomeMethod_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::SomeInterface_SomeMethod_ResponseParams_Data** output);
void Deserialize_(internal::SomeInterface_SomeMethod_ResponseParams_Data* input,
                  SomeInterface_SomeMethod_ResponseParams* output);

class SomeInterface_SomeMethod_ResponseParams {
 public:
  using Data_ = internal::SomeInterface_SomeMethod_ResponseParams_Data;

  static SomeInterface_SomeMethod_ResponseParamsPtr New();

  template <typename U>
  static SomeInterface_SomeMethod_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<SomeInterface_SomeMethod_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SomeInterface_SomeMethod_ResponseParams>::Convert(*this);
  }

  SomeInterface_SomeMethod_ResponseParams();
  ~SomeInterface_SomeMethod_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  SomeInterface_SomeMethod_ResponseParamsPtr Clone() const;
  bool Equals(const SomeInterface_SomeMethod_ResponseParams& other) const;

  RectPairPtr other_pair;
};


}  // namespace test
}  // namespace mojo

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_TEST_STRUCTS_MOJOM_COMMON_H_
