// NOTE: This file was generated by the Mojo bindings generator.
#ifndef MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_REGRESSION_TESTS_MOJOM_COMMON_H_
#define MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_REGRESSION_TESTS_MOJOM_COMMON_H_

#include <stdint.h>
#include <iosfwd>

#include "mojo/public/cpp/bindings/array.h"
#include "mojo/public/cpp/bindings/callback.h"
#include "mojo/public/cpp/bindings/interface_handle.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/map.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/bindings/string.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/system/buffer.h"
#include "mojo/public/cpp/system/data_pipe.h"
#include "mojo/public/cpp/system/handle.h"
#include "mojo/public/cpp/system/message_pipe.h"
#include "mojo/public/interfaces/bindings/tests/regression_tests.mojom-internal.h"
namespace regression_tests {

// --- Interface Forward Declarations ---
class CheckMethodWithEmptyResponse;
class CheckMethodWithEmptyResponseRequestValidator;
class CheckMethodWithEmptyResponseResponseValidator;
class CheckMethodWithEmptyResponse_Synchronous;
class CheckNameCollision;
class CheckNameCollisionRequestValidator;
class CheckNameCollisionResponseValidator;
class CheckNameCollision_Synchronous;
class CheckEnumCaps;
class CheckEnumCapsRequestValidator;
class CheckEnumCaps_Synchronous;
class TestInterface;
class TestInterfaceRequestValidator;
class TestInterface_Synchronous;
class Regression551;
class Regression551RequestValidator;
class Regression551ResponseValidator;
class Regression551_Synchronous;
class ServiceName;
class ServiceNameRequestValidator;
class ServiceNameResponseValidator;
class ServiceName_Synchronous;

// --- Struct Forward Declarations ---
class Edge;

using EdgePtr = mojo::StructPtr<Edge>;


class Vertex;

using VertexPtr = mojo::StructPtr<Vertex>;


class EmptyStruct;

using EmptyStructPtr = mojo::InlinedStructPtr<EmptyStruct>;


class A;

using APtr = mojo::StructPtr<A>;


class B;

using BPtr = mojo::StructPtr<B>;


class StructWithHandleCalledHandles;

using StructWithHandleCalledHandlesPtr = mojo::StructPtr<StructWithHandleCalledHandles>;


class StructWithArrayOfHandlesCalledHandles;

using StructWithArrayOfHandlesCalledHandlesPtr = mojo::StructPtr<StructWithArrayOfHandlesCalledHandles>;


class StructWithInterfaceCalledHandles;

using StructWithInterfaceCalledHandlesPtr = mojo::StructPtr<StructWithInterfaceCalledHandles>;


class ContainsArrayOfEnum;

using ContainsArrayOfEnumPtr = mojo::StructPtr<ContainsArrayOfEnum>;



// --- Union Forward Declarations ---

// --- Enums Declarations ---
  
enum class EnumWithReference : int32_t {
  k_STEREO_AND_KEYBOARD_MIC = 30,
  k_MAX = EnumWithReference::k_STEREO_AND_KEYBOARD_MIC,
};

bool EnumWithReference_IsValidValue(EnumWithReference value);
  
std::ostream& operator<<(std::ostream& stream, const EnumWithReference& val);
  
enum class EnumWithLowercase : int32_t {
  PlanarF16,
  PlanarF32,
};

bool EnumWithLowercase_IsValidValue(EnumWithLowercase value);
  
std::ostream& operator<<(std::ostream& stream, const EnumWithLowercase& val);
  
enum class EnumWithNumbers : int32_t {
  k_2_1 = 4,
};

bool EnumWithNumbers_IsValidValue(EnumWithNumbers value);
  
std::ostream& operator<<(std::ostream& stream, const EnumWithNumbers& val);
  
enum class EnumWithK : int32_t {
  K = 0,
};

bool EnumWithK_IsValidValue(EnumWithK value);
  
std::ostream& operator<<(std::ostream& stream, const EnumWithK& val);
  
enum class EnumWithINTERNALAllCaps : int32_t {
  STANDARD,
  FULLSCREEN,
  IMMERSIVE,
};

bool EnumWithINTERNALAllCaps_IsValidValue(EnumWithINTERNALAllCaps value);
  
std::ostream& operator<<(std::ostream& stream, const EnumWithINTERNALAllCaps& val);
  
enum class NormalEnum : int32_t {
  FIRST,
  SECOND,
};

bool NormalEnum_IsValidValue(NormalEnum value);
  
std::ostream& operator<<(std::ostream& stream, const NormalEnum& val);
  
enum class CamelCaseTestEnum : int32_t {
  BOOL_THING,
  DOUBLE_THING,
  FLOAT_THING,
  INT8_THING,
  INT16THING,
  INT32_TH1NG,
  INT64_Th1ng,
  UINT8T_h1ng,
  UINT16t_h1NG,
  UINT32_TH1ng,
  UINT64_TH1NG,
};

bool CamelCaseTestEnum_IsValidValue(CamelCaseTestEnum value);
  
std::ostream& operator<<(std::ostream& stream, const CamelCaseTestEnum& val);

// --- Constants ---

// --- Interface declarations ---
namespace internal {
class CheckMethodWithEmptyResponse_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = CheckMethodWithEmptyResponseRequestValidator;
  using ResponseValidator_ = CheckMethodWithEmptyResponseResponseValidator;
  using Synchronous_ = CheckMethodWithEmptyResponse_Synchronous;
  enum class MessageOrdinals : uint32_t {
    WithoutParameterAndEmptyResponse = 0,
    WithParameterAndEmptyResponse = 1,
  };


  virtual ~CheckMethodWithEmptyResponse_Base() {}
};

}  // namespace internal

// Async interface declaration

class CheckMethodWithEmptyResponseProxy;
class CheckMethodWithEmptyResponseStub;
class CheckMethodWithEmptyResponse_Synchronous;

class CheckMethodWithEmptyResponseRequestValidator;
class CheckMethodWithEmptyResponseResponseValidator;

class CheckMethodWithEmptyResponse : public internal::CheckMethodWithEmptyResponse_Base {
 public:
  virtual ~CheckMethodWithEmptyResponse() override {}

  using Proxy_ = CheckMethodWithEmptyResponseProxy;
  using Stub_ = CheckMethodWithEmptyResponseStub;
  using WithoutParameterAndEmptyResponseCallback = mojo::Callback<void()>;
  virtual void WithoutParameterAndEmptyResponse(const WithoutParameterAndEmptyResponseCallback& callback) = 0;
  using WithParameterAndEmptyResponseCallback = mojo::Callback<void()>;
  virtual void WithParameterAndEmptyResponse(bool b, const WithParameterAndEmptyResponseCallback& callback) = 0;
};

namespace internal {
class CheckNameCollision_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = CheckNameCollisionRequestValidator;
  using ResponseValidator_ = CheckNameCollisionResponseValidator;
  using Synchronous_ = CheckNameCollision_Synchronous;
  enum class MessageOrdinals : uint32_t {
    WithNameCollision = 0,
  };


  virtual ~CheckNameCollision_Base() {}
};

}  // namespace internal

// Async interface declaration

class CheckNameCollisionProxy;
class CheckNameCollisionStub;
class CheckNameCollision_Synchronous;

class CheckNameCollisionRequestValidator;
class CheckNameCollisionResponseValidator;

class CheckNameCollision : public internal::CheckNameCollision_Base {
 public:
  virtual ~CheckNameCollision() override {}

  using Proxy_ = CheckNameCollisionProxy;
  using Stub_ = CheckNameCollisionStub;
  using WithNameCollisionCallback = mojo::Callback<void(bool, bool)>;
  virtual void WithNameCollision(bool message, bool response, const WithNameCollisionCallback& callback) = 0;
};

namespace internal {
class CheckEnumCaps_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = CheckEnumCapsRequestValidator;
  using ResponseValidator_ = mojo::internal::PassThroughValidator;
  using Synchronous_ = CheckEnumCaps_Synchronous;
  enum class MessageOrdinals : uint32_t {
    SetEnumWithINTERNALAllCaps = 0,
  };


  virtual ~CheckEnumCaps_Base() {}
};

}  // namespace internal

// Async interface declaration

class CheckEnumCapsProxy;
class CheckEnumCapsStub;
class CheckEnumCaps_Synchronous;

class CheckEnumCapsRequestValidator;

class CheckEnumCaps : public internal::CheckEnumCaps_Base {
 public:
  virtual ~CheckEnumCaps() override {}

  using Proxy_ = CheckEnumCapsProxy;
  using Stub_ = CheckEnumCapsStub;
  virtual void SetEnumWithINTERNALAllCaps(EnumWithINTERNALAllCaps e) = 0;
};

namespace internal {
class TestInterface_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = TestInterfaceRequestValidator;
  using ResponseValidator_ = mojo::internal::PassThroughValidator;
  using Synchronous_ = TestInterface_Synchronous;
  enum class MessageOrdinals : uint32_t {
    SomeMessage = 0,
  };


  virtual ~TestInterface_Base() {}
};

}  // namespace internal

// Async interface declaration

class TestInterfaceProxy;
class TestInterfaceStub;
class TestInterface_Synchronous;

class TestInterfaceRequestValidator;

class TestInterface : public internal::TestInterface_Base {
 public:
  virtual ~TestInterface() override {}

  using Proxy_ = TestInterfaceProxy;
  using Stub_ = TestInterfaceStub;
  virtual void SomeMessage() = 0;
};

namespace internal {
class Regression551_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = Regression551RequestValidator;
  using ResponseValidator_ = Regression551ResponseValidator;
  using Synchronous_ = Regression551_Synchronous;
  enum class MessageOrdinals : uint32_t {
    Get = 0,
  };


  virtual ~Regression551_Base() {}
};

}  // namespace internal

// Async interface declaration

class Regression551Proxy;
class Regression551Stub;
class Regression551_Synchronous;

class Regression551RequestValidator;
class Regression551ResponseValidator;

class Regression551 : public internal::Regression551_Base {
 public:
  virtual ~Regression551() override {}

  using Proxy_ = Regression551Proxy;
  using Stub_ = Regression551Stub;
  using GetCallback = mojo::Callback<void(int32_t)>;
  virtual void Get(mojo::Array<mojo::String> key_prefixes, const GetCallback& callback) = 0;
};

namespace internal {
class ServiceName_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = ServiceNameRequestValidator;
  using ResponseValidator_ = ServiceNameResponseValidator;
  using Synchronous_ = ServiceName_Synchronous;
  enum class MessageOrdinals : uint32_t {
    serviceName = 0,
  };


  virtual ~ServiceName_Base() {}
};

}  // namespace internal

// Async interface declaration

class ServiceNameProxy;
class ServiceNameStub;
class ServiceName_Synchronous;

class ServiceNameRequestValidator;
class ServiceNameResponseValidator;

class ServiceName : public internal::ServiceName_Base {
 public:
  virtual ~ServiceName() override {}

  using Proxy_ = ServiceNameProxy;
  using Stub_ = ServiceNameStub;
  using serviceNameCallback = mojo::Callback<void(mojo::String)>;
  virtual void serviceName(const serviceNameCallback& callback) = 0;
};

}  // namespace regression_tests

// --- Internal Template Specializations ---

namespace mojo {
namespace internal {
template <>
struct WrapperTraits<regression_tests::EdgePtr, true, false> {
  using DataType = regression_tests::internal::Edge_Data*;
};
template <>
struct WrapperTraits<regression_tests::VertexPtr, true, false> {
  using DataType = regression_tests::internal::Vertex_Data*;
};
template <>
struct WrapperTraits<regression_tests::EmptyStructPtr, true, false> {
  using DataType = regression_tests::internal::EmptyStruct_Data*;
};
template <>
struct WrapperTraits<regression_tests::APtr, true, false> {
  using DataType = regression_tests::internal::A_Data*;
};
template <>
struct WrapperTraits<regression_tests::BPtr, true, false> {
  using DataType = regression_tests::internal::B_Data*;
};
template <>
struct WrapperTraits<regression_tests::StructWithHandleCalledHandlesPtr, true, false> {
  using DataType = regression_tests::internal::StructWithHandleCalledHandles_Data*;
};
template <>
struct WrapperTraits<regression_tests::StructWithArrayOfHandlesCalledHandlesPtr, true, false> {
  using DataType = regression_tests::internal::StructWithArrayOfHandlesCalledHandles_Data*;
};
template <>
struct WrapperTraits<regression_tests::StructWithInterfaceCalledHandlesPtr, true, false> {
  using DataType = regression_tests::internal::StructWithInterfaceCalledHandles_Data*;
};
template <>
struct WrapperTraits<regression_tests::ContainsArrayOfEnumPtr, true, false> {
  using DataType = regression_tests::internal::ContainsArrayOfEnum_Data*;
};

}  // internal
}  // mojo
namespace regression_tests {

// --- Interface Request Validators ---
class CheckMethodWithEmptyResponseRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class CheckNameCollisionRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class CheckEnumCapsRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class TestInterfaceRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class Regression551RequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class ServiceNameRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface Response Validators ---
class CheckMethodWithEmptyResponseResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class CheckNameCollisionResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class Regression551ResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class ServiceNameResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface enum operators ---

// --- Unions ---
// Unions must be declared first because they can be members of structs.

// --- Inlined structs ---
class EmptyStruct {
 public:
  using Data_ = internal::EmptyStruct_Data;

  static EmptyStructPtr New();

  template <typename U>
  static EmptyStructPtr From(const U& u) {
    return mojo::TypeConverter<EmptyStructPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, EmptyStruct>::Convert(*this);
  }

  EmptyStruct();
  ~EmptyStruct();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  EmptyStructPtr Clone() const;
  bool Equals(const EmptyStruct& other) const;

};



// --- Non-inlined structs ---
class Edge {
 public:
  using Data_ = internal::Edge_Data;

  static EdgePtr New();

  template <typename U>
  static EdgePtr From(const U& u) {
    return mojo::TypeConverter<EdgePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Edge>::Convert(*this);
  }

  Edge();
  ~Edge();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  EdgePtr Clone() const;
  bool Equals(const Edge& other) const;

  VertexPtr v;
};


class Vertex {
 public:
  using Data_ = internal::Vertex_Data;

  static VertexPtr New();

  template <typename U>
  static VertexPtr From(const U& u) {
    return mojo::TypeConverter<VertexPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Vertex>::Convert(*this);
  }

  Vertex();
  ~Vertex();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  VertexPtr Clone() const;
  bool Equals(const Vertex& other) const;

  EmptyStructPtr e;
};


class A {
 public:
  using Data_ = internal::A_Data;

  static APtr New();

  template <typename U>
  static APtr From(const U& u) {
    return mojo::TypeConverter<APtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, A>::Convert(*this);
  }

  A();
  ~A();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  APtr Clone() const;
  bool Equals(const A& other) const;

  BPtr b;
};


class B {
 public:
  using Data_ = internal::B_Data;

  static BPtr New();

  template <typename U>
  static BPtr From(const U& u) {
    return mojo::TypeConverter<BPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, B>::Convert(*this);
  }

  B();
  ~B();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  BPtr Clone() const;
  bool Equals(const B& other) const;

  APtr a;
};


class StructWithHandleCalledHandles {
 public:
  using Data_ = internal::StructWithHandleCalledHandles_Data;

  static StructWithHandleCalledHandlesPtr New();

  template <typename U>
  static StructWithHandleCalledHandlesPtr From(const U& u) {
    return mojo::TypeConverter<StructWithHandleCalledHandlesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructWithHandleCalledHandles>::Convert(*this);
  }

  StructWithHandleCalledHandles();
  ~StructWithHandleCalledHandles();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const StructWithHandleCalledHandles& other) const;

  mojo::ScopedHandle handles;
};


class StructWithArrayOfHandlesCalledHandles {
 public:
  using Data_ = internal::StructWithArrayOfHandlesCalledHandles_Data;

  static StructWithArrayOfHandlesCalledHandlesPtr New();

  template <typename U>
  static StructWithArrayOfHandlesCalledHandlesPtr From(const U& u) {
    return mojo::TypeConverter<StructWithArrayOfHandlesCalledHandlesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructWithArrayOfHandlesCalledHandles>::Convert(*this);
  }

  StructWithArrayOfHandlesCalledHandles();
  ~StructWithArrayOfHandlesCalledHandles();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const StructWithArrayOfHandlesCalledHandles& other) const;

  mojo::Array<mojo::ScopedHandle> handles;
};


class StructWithInterfaceCalledHandles {
 public:
  using Data_ = internal::StructWithInterfaceCalledHandles_Data;

  static StructWithInterfaceCalledHandlesPtr New();

  template <typename U>
  static StructWithInterfaceCalledHandlesPtr From(const U& u) {
    return mojo::TypeConverter<StructWithInterfaceCalledHandlesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StructWithInterfaceCalledHandles>::Convert(*this);
  }

  StructWithInterfaceCalledHandles();
  ~StructWithInterfaceCalledHandles();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const StructWithInterfaceCalledHandles& other) const;

  mojo::InterfaceHandle<TestInterface> handles;
};


class ContainsArrayOfEnum {
 public:
  using Data_ = internal::ContainsArrayOfEnum_Data;

  static ContainsArrayOfEnumPtr New();

  template <typename U>
  static ContainsArrayOfEnumPtr From(const U& u) {
    return mojo::TypeConverter<ContainsArrayOfEnumPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ContainsArrayOfEnum>::Convert(*this);
  }

  ContainsArrayOfEnum();
  ~ContainsArrayOfEnum();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ContainsArrayOfEnumPtr Clone() const;
  bool Equals(const ContainsArrayOfEnum& other) const;

  mojo::Array<NormalEnum> array_of_enums;
};



// --- Struct serialization helpers ---
size_t GetSerializedSize_(const Edge& input);
mojo::internal::ValidationError Serialize_(
    Edge* input,
    mojo::internal::Buffer* buffer,
    internal::Edge_Data** output);
void Deserialize_(internal::Edge_Data* input,
                  Edge* output);

size_t GetSerializedSize_(const Vertex& input);
mojo::internal::ValidationError Serialize_(
    Vertex* input,
    mojo::internal::Buffer* buffer,
    internal::Vertex_Data** output);
void Deserialize_(internal::Vertex_Data* input,
                  Vertex* output);

size_t GetSerializedSize_(const EmptyStruct& input);
mojo::internal::ValidationError Serialize_(
    EmptyStruct* input,
    mojo::internal::Buffer* buffer,
    internal::EmptyStruct_Data** output);
void Deserialize_(internal::EmptyStruct_Data* input,
                  EmptyStruct* output);

size_t GetSerializedSize_(const A& input);
mojo::internal::ValidationError Serialize_(
    A* input,
    mojo::internal::Buffer* buffer,
    internal::A_Data** output);
void Deserialize_(internal::A_Data* input,
                  A* output);

size_t GetSerializedSize_(const B& input);
mojo::internal::ValidationError Serialize_(
    B* input,
    mojo::internal::Buffer* buffer,
    internal::B_Data** output);
void Deserialize_(internal::B_Data* input,
                  B* output);

size_t GetSerializedSize_(const StructWithHandleCalledHandles& input);
mojo::internal::ValidationError Serialize_(
    StructWithHandleCalledHandles* input,
    mojo::internal::Buffer* buffer,
    internal::StructWithHandleCalledHandles_Data** output);
void Deserialize_(internal::StructWithHandleCalledHandles_Data* input,
                  StructWithHandleCalledHandles* output);

size_t GetSerializedSize_(const StructWithArrayOfHandlesCalledHandles& input);
mojo::internal::ValidationError Serialize_(
    StructWithArrayOfHandlesCalledHandles* input,
    mojo::internal::Buffer* buffer,
    internal::StructWithArrayOfHandlesCalledHandles_Data** output);
void Deserialize_(internal::StructWithArrayOfHandlesCalledHandles_Data* input,
                  StructWithArrayOfHandlesCalledHandles* output);

size_t GetSerializedSize_(const StructWithInterfaceCalledHandles& input);
mojo::internal::ValidationError Serialize_(
    StructWithInterfaceCalledHandles* input,
    mojo::internal::Buffer* buffer,
    internal::StructWithInterfaceCalledHandles_Data** output);
void Deserialize_(internal::StructWithInterfaceCalledHandles_Data* input,
                  StructWithInterfaceCalledHandles* output);

size_t GetSerializedSize_(const ContainsArrayOfEnum& input);
mojo::internal::ValidationError Serialize_(
    ContainsArrayOfEnum* input,
    mojo::internal::Buffer* buffer,
    internal::ContainsArrayOfEnum_Data** output);
void Deserialize_(internal::ContainsArrayOfEnum_Data* input,
                  ContainsArrayOfEnum* output);


// --- Union serialization helpers ---

// --- Request and response parameter structs for Interface methods ---
      

class CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params;

using CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ParamsPtr = mojo::InlinedStructPtr<CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params>;


size_t GetSerializedSize_(const CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params& input);
mojo::internal::ValidationError Serialize_(
    CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data** output);
void Deserialize_(internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data* input,
                  CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params* output);

class CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params {
 public:
  using Data_ = internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params_Data;

  static CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ParamsPtr New();

  template <typename U>
  static CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params>::Convert(*this);
  }

  CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params();
  ~CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ParamsPtr Clone() const;
  bool Equals(const CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_Params& other) const;

};



class CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams;

using CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParamsPtr = mojo::InlinedStructPtr<CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams>;


size_t GetSerializedSize_(const CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data** output);
void Deserialize_(internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data* input,
                  CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams* output);

class CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams {
 public:
  using Data_ = internal::CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams_Data;

  static CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParamsPtr New();

  template <typename U>
  static CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams>::Convert(*this);
  }

  CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams();
  ~CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParamsPtr Clone() const;
  bool Equals(const CheckMethodWithEmptyResponse_WithoutParameterAndEmptyResponse_ResponseParams& other) const;

};



class CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params;

using CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ParamsPtr = mojo::InlinedStructPtr<CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params>;


size_t GetSerializedSize_(const CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params& input);
mojo::internal::ValidationError Serialize_(
    CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data** output);
void Deserialize_(internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data* input,
                  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params* output);

class CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params {
 public:
  using Data_ = internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params_Data;

  static CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ParamsPtr New();

  template <typename U>
  static CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params>::Convert(*this);
  }

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params();
  ~CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ParamsPtr Clone() const;
  bool Equals(const CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params& other) const;

  bool b;
};



class CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams;

using CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParamsPtr = mojo::InlinedStructPtr<CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams>;


size_t GetSerializedSize_(const CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data** output);
void Deserialize_(internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data* input,
                  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams* output);

class CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams {
 public:
  using Data_ = internal::CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams_Data;

  static CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParamsPtr New();

  template <typename U>
  static CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams>::Convert(*this);
  }

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams();
  ~CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParamsPtr Clone() const;
  bool Equals(const CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams& other) const;

};


      

class CheckNameCollision_WithNameCollision_Params;

using CheckNameCollision_WithNameCollision_ParamsPtr = mojo::InlinedStructPtr<CheckNameCollision_WithNameCollision_Params>;


size_t GetSerializedSize_(const CheckNameCollision_WithNameCollision_Params& input);
mojo::internal::ValidationError Serialize_(
    CheckNameCollision_WithNameCollision_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CheckNameCollision_WithNameCollision_Params_Data** output);
void Deserialize_(internal::CheckNameCollision_WithNameCollision_Params_Data* input,
                  CheckNameCollision_WithNameCollision_Params* output);

class CheckNameCollision_WithNameCollision_Params {
 public:
  using Data_ = internal::CheckNameCollision_WithNameCollision_Params_Data;

  static CheckNameCollision_WithNameCollision_ParamsPtr New();

  template <typename U>
  static CheckNameCollision_WithNameCollision_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CheckNameCollision_WithNameCollision_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CheckNameCollision_WithNameCollision_Params>::Convert(*this);
  }

  CheckNameCollision_WithNameCollision_Params();
  ~CheckNameCollision_WithNameCollision_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CheckNameCollision_WithNameCollision_ParamsPtr Clone() const;
  bool Equals(const CheckNameCollision_WithNameCollision_Params& other) const;

  bool message;
  bool response;
};



class CheckNameCollision_WithNameCollision_ResponseParams;

using CheckNameCollision_WithNameCollision_ResponseParamsPtr = mojo::InlinedStructPtr<CheckNameCollision_WithNameCollision_ResponseParams>;


size_t GetSerializedSize_(const CheckNameCollision_WithNameCollision_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    CheckNameCollision_WithNameCollision_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::CheckNameCollision_WithNameCollision_ResponseParams_Data** output);
void Deserialize_(internal::CheckNameCollision_WithNameCollision_ResponseParams_Data* input,
                  CheckNameCollision_WithNameCollision_ResponseParams* output);

class CheckNameCollision_WithNameCollision_ResponseParams {
 public:
  using Data_ = internal::CheckNameCollision_WithNameCollision_ResponseParams_Data;

  static CheckNameCollision_WithNameCollision_ResponseParamsPtr New();

  template <typename U>
  static CheckNameCollision_WithNameCollision_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<CheckNameCollision_WithNameCollision_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CheckNameCollision_WithNameCollision_ResponseParams>::Convert(*this);
  }

  CheckNameCollision_WithNameCollision_ResponseParams();
  ~CheckNameCollision_WithNameCollision_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CheckNameCollision_WithNameCollision_ResponseParamsPtr Clone() const;
  bool Equals(const CheckNameCollision_WithNameCollision_ResponseParams& other) const;

  bool message;
  bool response;
};


      

class CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params;

using CheckEnumCaps_SetEnumWithINTERNALAllCaps_ParamsPtr = mojo::InlinedStructPtr<CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params>;


size_t GetSerializedSize_(const CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params& input);
mojo::internal::ValidationError Serialize_(
    CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params* input,
    mojo::internal::Buffer* buffer,
    internal::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data** output);
void Deserialize_(internal::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data* input,
                  CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params* output);

class CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params {
 public:
  using Data_ = internal::CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params_Data;

  static CheckEnumCaps_SetEnumWithINTERNALAllCaps_ParamsPtr New();

  template <typename U>
  static CheckEnumCaps_SetEnumWithINTERNALAllCaps_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<CheckEnumCaps_SetEnumWithINTERNALAllCaps_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params>::Convert(*this);
  }

  CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params();
  ~CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  CheckEnumCaps_SetEnumWithINTERNALAllCaps_ParamsPtr Clone() const;
  bool Equals(const CheckEnumCaps_SetEnumWithINTERNALAllCaps_Params& other) const;

  EnumWithINTERNALAllCaps e;
};



      

class TestInterface_SomeMessage_Params;

using TestInterface_SomeMessage_ParamsPtr = mojo::InlinedStructPtr<TestInterface_SomeMessage_Params>;


size_t GetSerializedSize_(const TestInterface_SomeMessage_Params& input);
mojo::internal::ValidationError Serialize_(
    TestInterface_SomeMessage_Params* input,
    mojo::internal::Buffer* buffer,
    internal::TestInterface_SomeMessage_Params_Data** output);
void Deserialize_(internal::TestInterface_SomeMessage_Params_Data* input,
                  TestInterface_SomeMessage_Params* output);

class TestInterface_SomeMessage_Params {
 public:
  using Data_ = internal::TestInterface_SomeMessage_Params_Data;

  static TestInterface_SomeMessage_ParamsPtr New();

  template <typename U>
  static TestInterface_SomeMessage_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<TestInterface_SomeMessage_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, TestInterface_SomeMessage_Params>::Convert(*this);
  }

  TestInterface_SomeMessage_Params();
  ~TestInterface_SomeMessage_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  TestInterface_SomeMessage_ParamsPtr Clone() const;
  bool Equals(const TestInterface_SomeMessage_Params& other) const;

};



      

class Regression551_Get_Params;

using Regression551_Get_ParamsPtr = mojo::StructPtr<Regression551_Get_Params>;


size_t GetSerializedSize_(const Regression551_Get_Params& input);
mojo::internal::ValidationError Serialize_(
    Regression551_Get_Params* input,
    mojo::internal::Buffer* buffer,
    internal::Regression551_Get_Params_Data** output);
void Deserialize_(internal::Regression551_Get_Params_Data* input,
                  Regression551_Get_Params* output);

class Regression551_Get_Params {
 public:
  using Data_ = internal::Regression551_Get_Params_Data;

  static Regression551_Get_ParamsPtr New();

  template <typename U>
  static Regression551_Get_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<Regression551_Get_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Regression551_Get_Params>::Convert(*this);
  }

  Regression551_Get_Params();
  ~Regression551_Get_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  Regression551_Get_ParamsPtr Clone() const;
  bool Equals(const Regression551_Get_Params& other) const;

  mojo::Array<mojo::String> key_prefixes;
};



class Regression551_Get_ResponseParams;

using Regression551_Get_ResponseParamsPtr = mojo::InlinedStructPtr<Regression551_Get_ResponseParams>;


size_t GetSerializedSize_(const Regression551_Get_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    Regression551_Get_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::Regression551_Get_ResponseParams_Data** output);
void Deserialize_(internal::Regression551_Get_ResponseParams_Data* input,
                  Regression551_Get_ResponseParams* output);

class Regression551_Get_ResponseParams {
 public:
  using Data_ = internal::Regression551_Get_ResponseParams_Data;

  static Regression551_Get_ResponseParamsPtr New();

  template <typename U>
  static Regression551_Get_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<Regression551_Get_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Regression551_Get_ResponseParams>::Convert(*this);
  }

  Regression551_Get_ResponseParams();
  ~Regression551_Get_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  Regression551_Get_ResponseParamsPtr Clone() const;
  bool Equals(const Regression551_Get_ResponseParams& other) const;

  int32_t result;
};


      

class ServiceName_serviceName_Params;

using ServiceName_serviceName_ParamsPtr = mojo::InlinedStructPtr<ServiceName_serviceName_Params>;


size_t GetSerializedSize_(const ServiceName_serviceName_Params& input);
mojo::internal::ValidationError Serialize_(
    ServiceName_serviceName_Params* input,
    mojo::internal::Buffer* buffer,
    internal::ServiceName_serviceName_Params_Data** output);
void Deserialize_(internal::ServiceName_serviceName_Params_Data* input,
                  ServiceName_serviceName_Params* output);

class ServiceName_serviceName_Params {
 public:
  using Data_ = internal::ServiceName_serviceName_Params_Data;

  static ServiceName_serviceName_ParamsPtr New();

  template <typename U>
  static ServiceName_serviceName_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<ServiceName_serviceName_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ServiceName_serviceName_Params>::Convert(*this);
  }

  ServiceName_serviceName_Params();
  ~ServiceName_serviceName_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ServiceName_serviceName_ParamsPtr Clone() const;
  bool Equals(const ServiceName_serviceName_Params& other) const;

};



class ServiceName_serviceName_ResponseParams;

using ServiceName_serviceName_ResponseParamsPtr = mojo::InlinedStructPtr<ServiceName_serviceName_ResponseParams>;


size_t GetSerializedSize_(const ServiceName_serviceName_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    ServiceName_serviceName_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::ServiceName_serviceName_ResponseParams_Data** output);
void Deserialize_(internal::ServiceName_serviceName_ResponseParams_Data* input,
                  ServiceName_serviceName_ResponseParams* output);

class ServiceName_serviceName_ResponseParams {
 public:
  using Data_ = internal::ServiceName_serviceName_ResponseParams_Data;

  static ServiceName_serviceName_ResponseParamsPtr New();

  template <typename U>
  static ServiceName_serviceName_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<ServiceName_serviceName_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ServiceName_serviceName_ResponseParams>::Convert(*this);
  }

  ServiceName_serviceName_ResponseParams();
  ~ServiceName_serviceName_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ServiceName_serviceName_ResponseParamsPtr Clone() const;
  bool Equals(const ServiceName_serviceName_ResponseParams& other) const;

  mojo::String serviceName;
};


}  // namespace regression_tests

#endif  // MOJO_PUBLIC_INTERFACES_BINDINGS_TESTS_REGRESSION_TESTS_MOJOM_COMMON_H_
