// NOTE: This file was generated by the Mojo bindings generator.
#ifndef MOJO_SERVICES_ANDROID_INTERFACES_ACTIVITY_MOJOM_COMMON_H_
#define MOJO_SERVICES_ANDROID_INTERFACES_ACTIVITY_MOJOM_COMMON_H_

#include <stdint.h>
#include <iosfwd>

#include "mojo/public/cpp/bindings/array.h"
#include "mojo/public/cpp/bindings/callback.h"
#include "mojo/public/cpp/bindings/interface_handle.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/map.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/bindings/string.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/system/buffer.h"
#include "mojo/public/cpp/system/data_pipe.h"
#include "mojo/public/cpp/system/handle.h"
#include "mojo/public/cpp/system/message_pipe.h"
#include "mojo/services/android/interfaces/activity.mojom-internal.h"
namespace activity {

// --- Interface Forward Declarations ---
class Activity;
class ActivityRequestValidator;
class Activity_Synchronous;
class PathService;
class PathServiceRequestValidator;
class PathServiceResponseValidator;
class PathService_Synchronous;
class UserFeedback;
class UserFeedbackRequestValidator;
class UserFeedback_Synchronous;

// --- Struct Forward Declarations ---
class StringExtra;

using StringExtraPtr = mojo::InlinedStructPtr<StringExtra>;


class ComponentName;

using ComponentNamePtr = mojo::InlinedStructPtr<ComponentName>;


class Intent;

using IntentPtr = mojo::StructPtr<Intent>;


class TaskDescription;

using TaskDescriptionPtr = mojo::InlinedStructPtr<TaskDescription>;



// --- Union Forward Declarations ---

// --- Enums Declarations ---
  
enum class SystemUIVisibility : int32_t {
  STANDARD,
  FULLSCREEN,
  IMMERSIVE,
};

bool SystemUIVisibility_IsValidValue(SystemUIVisibility value);
  
std::ostream& operator<<(std::ostream& stream, const SystemUIVisibility& val);
  
enum class ScreenOrientation : int32_t {
  UNSPECIFIED,
  LANDSCAPE,
  PORTRAIT,
  NOSENSOR,
};

bool ScreenOrientation_IsValidValue(ScreenOrientation value);
  
std::ostream& operator<<(std::ostream& stream, const ScreenOrientation& val);
  
enum class HapticFeedbackType : int32_t {
  LONG_PRESS,
  VIRTUAL_KEY,
  KEYBOARD_TAP,
  CLOCK_TICK,
};

bool HapticFeedbackType_IsValidValue(HapticFeedbackType value);
  
std::ostream& operator<<(std::ostream& stream, const HapticFeedbackType& val);
  
enum class AuralFeedbackType : int32_t {
  CLICK,
  NAVIGATION_LEFT,
  NAVIGATION_UP,
  NAVIGATION_RIGHT,
  NAVIGATION_DOWN,
};

bool AuralFeedbackType_IsValidValue(AuralFeedbackType value);
  
std::ostream& operator<<(std::ostream& stream, const AuralFeedbackType& val);

// --- Constants ---

// --- Interface declarations ---
namespace internal {
class Activity_Base {
 public:
  static const char Name_[];
  static const uint32_t Version_ = 0;

  using RequestValidator_ = ActivityRequestValidator;
  using ResponseValidator_ = mojo::internal::PassThroughValidator;
  using Synchronous_ = Activity_Synchronous;
  enum class MessageOrdinals : uint32_t {
    GetUserFeedback = 0,
    StartActivity = 1,
    FinishCurrentActivity = 2,
    SetTaskDescription = 3,
    SetSystemUIVisibility = 4,
    SetRequestedOrientation = 5,
  };


  virtual ~Activity_Base() {}
};

}  // namespace internal

// Async interface declaration

class ActivityProxy;
class ActivityStub;
class Activity_Synchronous;

class ActivityRequestValidator;

class Activity : public internal::Activity_Base {
 public:
  virtual ~Activity() override {}

  using Proxy_ = ActivityProxy;
  using Stub_ = ActivityStub;
  virtual void GetUserFeedback(mojo::InterfaceRequest<UserFeedback> user_feedback) = 0;
  virtual void StartActivity(IntentPtr intent) = 0;
  virtual void FinishCurrentActivity() = 0;
  virtual void SetTaskDescription(TaskDescriptionPtr description) = 0;
  virtual void SetSystemUIVisibility(SystemUIVisibility visibility) = 0;
  virtual void SetRequestedOrientation(ScreenOrientation orientation) = 0;
};

namespace internal {
class PathService_Base {
 public:
  static const char Name_[];
  static const uint32_t Version_ = 0;

  using RequestValidator_ = PathServiceRequestValidator;
  using ResponseValidator_ = PathServiceResponseValidator;
  using Synchronous_ = PathService_Synchronous;
  enum class MessageOrdinals : uint32_t {
    GetAppDataDir = 0,
    GetFilesDir = 1,
    GetCacheDir = 2,
  };


  virtual ~PathService_Base() {}
};

}  // namespace internal

// Async interface declaration

class PathServiceProxy;
class PathServiceStub;
class PathService_Synchronous;

class PathServiceRequestValidator;
class PathServiceResponseValidator;

class PathService : public internal::PathService_Base {
 public:
  virtual ~PathService() override {}

  using Proxy_ = PathServiceProxy;
  using Stub_ = PathServiceStub;
  using GetAppDataDirCallback = mojo::Callback<void(mojo::String)>;
  virtual void GetAppDataDir(const GetAppDataDirCallback& callback) = 0;
  using GetFilesDirCallback = mojo::Callback<void(mojo::String)>;
  virtual void GetFilesDir(const GetFilesDirCallback& callback) = 0;
  using GetCacheDirCallback = mojo::Callback<void(mojo::String)>;
  virtual void GetCacheDir(const GetCacheDirCallback& callback) = 0;
};

namespace internal {
class UserFeedback_Base {
 public:
  static const uint32_t Version_ = 0;

  using RequestValidator_ = UserFeedbackRequestValidator;
  using ResponseValidator_ = mojo::internal::PassThroughValidator;
  using Synchronous_ = UserFeedback_Synchronous;
  enum class MessageOrdinals : uint32_t {
    PerformHapticFeedback = 0,
    PerformAuralFeedback = 1,
  };


  virtual ~UserFeedback_Base() {}
};

}  // namespace internal

// Async interface declaration

class UserFeedbackProxy;
class UserFeedbackStub;
class UserFeedback_Synchronous;

class UserFeedbackRequestValidator;

class UserFeedback : public internal::UserFeedback_Base {
 public:
  virtual ~UserFeedback() override {}

  using Proxy_ = UserFeedbackProxy;
  using Stub_ = UserFeedbackStub;
  virtual void PerformHapticFeedback(HapticFeedbackType type) = 0;
  virtual void PerformAuralFeedback(AuralFeedbackType type) = 0;
};

}  // namespace activity

// --- Internal Template Specializations ---

namespace mojo {
namespace internal {
template <>
struct WrapperTraits<activity::StringExtraPtr, true, false> {
  using DataType = activity::internal::StringExtra_Data*;
};
template <>
struct WrapperTraits<activity::ComponentNamePtr, true, false> {
  using DataType = activity::internal::ComponentName_Data*;
};
template <>
struct WrapperTraits<activity::IntentPtr, true, false> {
  using DataType = activity::internal::Intent_Data*;
};
template <>
struct WrapperTraits<activity::TaskDescriptionPtr, true, false> {
  using DataType = activity::internal::TaskDescription_Data*;
};

}  // internal
}  // mojo
namespace activity {

// --- Interface Request Validators ---
class ActivityRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class PathServiceRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};

class UserFeedbackRequestValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface Response Validators ---
class PathServiceResponseValidator
    : public mojo::internal::MessageValidator {
 public:
  mojo::internal::ValidationError Validate(const mojo::Message* message,
                                           std::string* err) override;
};


// --- Interface enum operators ---

// --- Unions ---
// Unions must be declared first because they can be members of structs.

// --- Inlined structs ---
class StringExtra {
 public:
  using Data_ = internal::StringExtra_Data;

  static StringExtraPtr New();

  template <typename U>
  static StringExtraPtr From(const U& u) {
    return mojo::TypeConverter<StringExtraPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StringExtra>::Convert(*this);
  }

  StringExtra();
  ~StringExtra();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  StringExtraPtr Clone() const;
  bool Equals(const StringExtra& other) const;

  mojo::String name;
  mojo::String value;
};


class ComponentName {
 public:
  using Data_ = internal::ComponentName_Data;

  static ComponentNamePtr New();

  template <typename U>
  static ComponentNamePtr From(const U& u) {
    return mojo::TypeConverter<ComponentNamePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ComponentName>::Convert(*this);
  }

  ComponentName();
  ~ComponentName();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  ComponentNamePtr Clone() const;
  bool Equals(const ComponentName& other) const;

  mojo::String package_name;
  mojo::String class_name;
};


class TaskDescription {
 public:
  using Data_ = internal::TaskDescription_Data;

  static TaskDescriptionPtr New();

  template <typename U>
  static TaskDescriptionPtr From(const U& u) {
    return mojo::TypeConverter<TaskDescriptionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, TaskDescription>::Convert(*this);
  }

  TaskDescription();
  ~TaskDescription();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  TaskDescriptionPtr Clone() const;
  bool Equals(const TaskDescription& other) const;

  mojo::String label;
  uint32_t primaryColor;
};



// --- Non-inlined structs ---
class Intent {
 public:
  using Data_ = internal::Intent_Data;

  static IntentPtr New();

  template <typename U>
  static IntentPtr From(const U& u) {
    return mojo::TypeConverter<IntentPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Intent>::Convert(*this);
  }

  Intent();
  ~Intent();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  IntentPtr Clone() const;
  bool Equals(const Intent& other) const;

  mojo::String action;
  mojo::String url;
  uint32_t flags;
  ComponentNamePtr component;
  mojo::Array<StringExtraPtr> string_extras;
  mojo::String type;
};



// --- Struct serialization helpers ---
size_t GetSerializedSize_(const StringExtra& input);
mojo::internal::ValidationError Serialize_(
    StringExtra* input,
    mojo::internal::Buffer* buffer,
    internal::StringExtra_Data** output);
void Deserialize_(internal::StringExtra_Data* input,
                  StringExtra* output);

size_t GetSerializedSize_(const ComponentName& input);
mojo::internal::ValidationError Serialize_(
    ComponentName* input,
    mojo::internal::Buffer* buffer,
    internal::ComponentName_Data** output);
void Deserialize_(internal::ComponentName_Data* input,
                  ComponentName* output);

size_t GetSerializedSize_(const Intent& input);
mojo::internal::ValidationError Serialize_(
    Intent* input,
    mojo::internal::Buffer* buffer,
    internal::Intent_Data** output);
void Deserialize_(internal::Intent_Data* input,
                  Intent* output);

size_t GetSerializedSize_(const TaskDescription& input);
mojo::internal::ValidationError Serialize_(
    TaskDescription* input,
    mojo::internal::Buffer* buffer,
    internal::TaskDescription_Data** output);
void Deserialize_(internal::TaskDescription_Data* input,
                  TaskDescription* output);


// --- Union serialization helpers ---

// --- Request and response parameter structs for Interface methods ---
      

class Activity_GetUserFeedback_Params;

using Activity_GetUserFeedback_ParamsPtr = mojo::StructPtr<Activity_GetUserFeedback_Params>;


size_t GetSerializedSize_(const Activity_GetUserFeedback_Params& input);
mojo::internal::ValidationError Serialize_(
    Activity_GetUserFeedback_Params* input,
    mojo::internal::Buffer* buffer,
    internal::Activity_GetUserFeedback_Params_Data** output);
void Deserialize_(internal::Activity_GetUserFeedback_Params_Data* input,
                  Activity_GetUserFeedback_Params* output);

class Activity_GetUserFeedback_Params {
 public:
  using Data_ = internal::Activity_GetUserFeedback_Params_Data;

  static Activity_GetUserFeedback_ParamsPtr New();

  template <typename U>
  static Activity_GetUserFeedback_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<Activity_GetUserFeedback_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Activity_GetUserFeedback_Params>::Convert(*this);
  }

  Activity_GetUserFeedback_Params();
  ~Activity_GetUserFeedback_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  bool Equals(const Activity_GetUserFeedback_Params& other) const;

  mojo::InterfaceRequest<UserFeedback> user_feedback;
};




class Activity_StartActivity_Params;

using Activity_StartActivity_ParamsPtr = mojo::StructPtr<Activity_StartActivity_Params>;


size_t GetSerializedSize_(const Activity_StartActivity_Params& input);
mojo::internal::ValidationError Serialize_(
    Activity_StartActivity_Params* input,
    mojo::internal::Buffer* buffer,
    internal::Activity_StartActivity_Params_Data** output);
void Deserialize_(internal::Activity_StartActivity_Params_Data* input,
                  Activity_StartActivity_Params* output);

class Activity_StartActivity_Params {
 public:
  using Data_ = internal::Activity_StartActivity_Params_Data;

  static Activity_StartActivity_ParamsPtr New();

  template <typename U>
  static Activity_StartActivity_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<Activity_StartActivity_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Activity_StartActivity_Params>::Convert(*this);
  }

  Activity_StartActivity_Params();
  ~Activity_StartActivity_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  Activity_StartActivity_ParamsPtr Clone() const;
  bool Equals(const Activity_StartActivity_Params& other) const;

  IntentPtr intent;
};




class Activity_FinishCurrentActivity_Params;

using Activity_FinishCurrentActivity_ParamsPtr = mojo::InlinedStructPtr<Activity_FinishCurrentActivity_Params>;


size_t GetSerializedSize_(const Activity_FinishCurrentActivity_Params& input);
mojo::internal::ValidationError Serialize_(
    Activity_FinishCurrentActivity_Params* input,
    mojo::internal::Buffer* buffer,
    internal::Activity_FinishCurrentActivity_Params_Data** output);
void Deserialize_(internal::Activity_FinishCurrentActivity_Params_Data* input,
                  Activity_FinishCurrentActivity_Params* output);

class Activity_FinishCurrentActivity_Params {
 public:
  using Data_ = internal::Activity_FinishCurrentActivity_Params_Data;

  static Activity_FinishCurrentActivity_ParamsPtr New();

  template <typename U>
  static Activity_FinishCurrentActivity_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<Activity_FinishCurrentActivity_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Activity_FinishCurrentActivity_Params>::Convert(*this);
  }

  Activity_FinishCurrentActivity_Params();
  ~Activity_FinishCurrentActivity_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  Activity_FinishCurrentActivity_ParamsPtr Clone() const;
  bool Equals(const Activity_FinishCurrentActivity_Params& other) const;

};




class Activity_SetTaskDescription_Params;

using Activity_SetTaskDescription_ParamsPtr = mojo::StructPtr<Activity_SetTaskDescription_Params>;


size_t GetSerializedSize_(const Activity_SetTaskDescription_Params& input);
mojo::internal::ValidationError Serialize_(
    Activity_SetTaskDescription_Params* input,
    mojo::internal::Buffer* buffer,
    internal::Activity_SetTaskDescription_Params_Data** output);
void Deserialize_(internal::Activity_SetTaskDescription_Params_Data* input,
                  Activity_SetTaskDescription_Params* output);

class Activity_SetTaskDescription_Params {
 public:
  using Data_ = internal::Activity_SetTaskDescription_Params_Data;

  static Activity_SetTaskDescription_ParamsPtr New();

  template <typename U>
  static Activity_SetTaskDescription_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<Activity_SetTaskDescription_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Activity_SetTaskDescription_Params>::Convert(*this);
  }

  Activity_SetTaskDescription_Params();
  ~Activity_SetTaskDescription_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  Activity_SetTaskDescription_ParamsPtr Clone() const;
  bool Equals(const Activity_SetTaskDescription_Params& other) const;

  TaskDescriptionPtr description;
};




class Activity_SetSystemUIVisibility_Params;

using Activity_SetSystemUIVisibility_ParamsPtr = mojo::InlinedStructPtr<Activity_SetSystemUIVisibility_Params>;


size_t GetSerializedSize_(const Activity_SetSystemUIVisibility_Params& input);
mojo::internal::ValidationError Serialize_(
    Activity_SetSystemUIVisibility_Params* input,
    mojo::internal::Buffer* buffer,
    internal::Activity_SetSystemUIVisibility_Params_Data** output);
void Deserialize_(internal::Activity_SetSystemUIVisibility_Params_Data* input,
                  Activity_SetSystemUIVisibility_Params* output);

class Activity_SetSystemUIVisibility_Params {
 public:
  using Data_ = internal::Activity_SetSystemUIVisibility_Params_Data;

  static Activity_SetSystemUIVisibility_ParamsPtr New();

  template <typename U>
  static Activity_SetSystemUIVisibility_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<Activity_SetSystemUIVisibility_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Activity_SetSystemUIVisibility_Params>::Convert(*this);
  }

  Activity_SetSystemUIVisibility_Params();
  ~Activity_SetSystemUIVisibility_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  Activity_SetSystemUIVisibility_ParamsPtr Clone() const;
  bool Equals(const Activity_SetSystemUIVisibility_Params& other) const;

  SystemUIVisibility visibility;
};




class Activity_SetRequestedOrientation_Params;

using Activity_SetRequestedOrientation_ParamsPtr = mojo::InlinedStructPtr<Activity_SetRequestedOrientation_Params>;


size_t GetSerializedSize_(const Activity_SetRequestedOrientation_Params& input);
mojo::internal::ValidationError Serialize_(
    Activity_SetRequestedOrientation_Params* input,
    mojo::internal::Buffer* buffer,
    internal::Activity_SetRequestedOrientation_Params_Data** output);
void Deserialize_(internal::Activity_SetRequestedOrientation_Params_Data* input,
                  Activity_SetRequestedOrientation_Params* output);

class Activity_SetRequestedOrientation_Params {
 public:
  using Data_ = internal::Activity_SetRequestedOrientation_Params_Data;

  static Activity_SetRequestedOrientation_ParamsPtr New();

  template <typename U>
  static Activity_SetRequestedOrientation_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<Activity_SetRequestedOrientation_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Activity_SetRequestedOrientation_Params>::Convert(*this);
  }

  Activity_SetRequestedOrientation_Params();
  ~Activity_SetRequestedOrientation_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  Activity_SetRequestedOrientation_ParamsPtr Clone() const;
  bool Equals(const Activity_SetRequestedOrientation_Params& other) const;

  ScreenOrientation orientation;
};



      

class PathService_GetAppDataDir_Params;

using PathService_GetAppDataDir_ParamsPtr = mojo::InlinedStructPtr<PathService_GetAppDataDir_Params>;


size_t GetSerializedSize_(const PathService_GetAppDataDir_Params& input);
mojo::internal::ValidationError Serialize_(
    PathService_GetAppDataDir_Params* input,
    mojo::internal::Buffer* buffer,
    internal::PathService_GetAppDataDir_Params_Data** output);
void Deserialize_(internal::PathService_GetAppDataDir_Params_Data* input,
                  PathService_GetAppDataDir_Params* output);

class PathService_GetAppDataDir_Params {
 public:
  using Data_ = internal::PathService_GetAppDataDir_Params_Data;

  static PathService_GetAppDataDir_ParamsPtr New();

  template <typename U>
  static PathService_GetAppDataDir_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<PathService_GetAppDataDir_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PathService_GetAppDataDir_Params>::Convert(*this);
  }

  PathService_GetAppDataDir_Params();
  ~PathService_GetAppDataDir_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  PathService_GetAppDataDir_ParamsPtr Clone() const;
  bool Equals(const PathService_GetAppDataDir_Params& other) const;

};



class PathService_GetAppDataDir_ResponseParams;

using PathService_GetAppDataDir_ResponseParamsPtr = mojo::InlinedStructPtr<PathService_GetAppDataDir_ResponseParams>;


size_t GetSerializedSize_(const PathService_GetAppDataDir_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    PathService_GetAppDataDir_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::PathService_GetAppDataDir_ResponseParams_Data** output);
void Deserialize_(internal::PathService_GetAppDataDir_ResponseParams_Data* input,
                  PathService_GetAppDataDir_ResponseParams* output);

class PathService_GetAppDataDir_ResponseParams {
 public:
  using Data_ = internal::PathService_GetAppDataDir_ResponseParams_Data;

  static PathService_GetAppDataDir_ResponseParamsPtr New();

  template <typename U>
  static PathService_GetAppDataDir_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<PathService_GetAppDataDir_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PathService_GetAppDataDir_ResponseParams>::Convert(*this);
  }

  PathService_GetAppDataDir_ResponseParams();
  ~PathService_GetAppDataDir_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  PathService_GetAppDataDir_ResponseParamsPtr Clone() const;
  bool Equals(const PathService_GetAppDataDir_ResponseParams& other) const;

  mojo::String path;
};



class PathService_GetFilesDir_Params;

using PathService_GetFilesDir_ParamsPtr = mojo::InlinedStructPtr<PathService_GetFilesDir_Params>;


size_t GetSerializedSize_(const PathService_GetFilesDir_Params& input);
mojo::internal::ValidationError Serialize_(
    PathService_GetFilesDir_Params* input,
    mojo::internal::Buffer* buffer,
    internal::PathService_GetFilesDir_Params_Data** output);
void Deserialize_(internal::PathService_GetFilesDir_Params_Data* input,
                  PathService_GetFilesDir_Params* output);

class PathService_GetFilesDir_Params {
 public:
  using Data_ = internal::PathService_GetFilesDir_Params_Data;

  static PathService_GetFilesDir_ParamsPtr New();

  template <typename U>
  static PathService_GetFilesDir_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<PathService_GetFilesDir_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PathService_GetFilesDir_Params>::Convert(*this);
  }

  PathService_GetFilesDir_Params();
  ~PathService_GetFilesDir_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  PathService_GetFilesDir_ParamsPtr Clone() const;
  bool Equals(const PathService_GetFilesDir_Params& other) const;

};



class PathService_GetFilesDir_ResponseParams;

using PathService_GetFilesDir_ResponseParamsPtr = mojo::InlinedStructPtr<PathService_GetFilesDir_ResponseParams>;


size_t GetSerializedSize_(const PathService_GetFilesDir_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    PathService_GetFilesDir_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::PathService_GetFilesDir_ResponseParams_Data** output);
void Deserialize_(internal::PathService_GetFilesDir_ResponseParams_Data* input,
                  PathService_GetFilesDir_ResponseParams* output);

class PathService_GetFilesDir_ResponseParams {
 public:
  using Data_ = internal::PathService_GetFilesDir_ResponseParams_Data;

  static PathService_GetFilesDir_ResponseParamsPtr New();

  template <typename U>
  static PathService_GetFilesDir_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<PathService_GetFilesDir_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PathService_GetFilesDir_ResponseParams>::Convert(*this);
  }

  PathService_GetFilesDir_ResponseParams();
  ~PathService_GetFilesDir_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  PathService_GetFilesDir_ResponseParamsPtr Clone() const;
  bool Equals(const PathService_GetFilesDir_ResponseParams& other) const;

  mojo::String path;
};



class PathService_GetCacheDir_Params;

using PathService_GetCacheDir_ParamsPtr = mojo::InlinedStructPtr<PathService_GetCacheDir_Params>;


size_t GetSerializedSize_(const PathService_GetCacheDir_Params& input);
mojo::internal::ValidationError Serialize_(
    PathService_GetCacheDir_Params* input,
    mojo::internal::Buffer* buffer,
    internal::PathService_GetCacheDir_Params_Data** output);
void Deserialize_(internal::PathService_GetCacheDir_Params_Data* input,
                  PathService_GetCacheDir_Params* output);

class PathService_GetCacheDir_Params {
 public:
  using Data_ = internal::PathService_GetCacheDir_Params_Data;

  static PathService_GetCacheDir_ParamsPtr New();

  template <typename U>
  static PathService_GetCacheDir_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<PathService_GetCacheDir_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PathService_GetCacheDir_Params>::Convert(*this);
  }

  PathService_GetCacheDir_Params();
  ~PathService_GetCacheDir_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  PathService_GetCacheDir_ParamsPtr Clone() const;
  bool Equals(const PathService_GetCacheDir_Params& other) const;

};



class PathService_GetCacheDir_ResponseParams;

using PathService_GetCacheDir_ResponseParamsPtr = mojo::InlinedStructPtr<PathService_GetCacheDir_ResponseParams>;


size_t GetSerializedSize_(const PathService_GetCacheDir_ResponseParams& input);
mojo::internal::ValidationError Serialize_(
    PathService_GetCacheDir_ResponseParams* input,
    mojo::internal::Buffer* buffer,
    internal::PathService_GetCacheDir_ResponseParams_Data** output);
void Deserialize_(internal::PathService_GetCacheDir_ResponseParams_Data* input,
                  PathService_GetCacheDir_ResponseParams* output);

class PathService_GetCacheDir_ResponseParams {
 public:
  using Data_ = internal::PathService_GetCacheDir_ResponseParams_Data;

  static PathService_GetCacheDir_ResponseParamsPtr New();

  template <typename U>
  static PathService_GetCacheDir_ResponseParamsPtr From(const U& u) {
    return mojo::TypeConverter<PathService_GetCacheDir_ResponseParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PathService_GetCacheDir_ResponseParams>::Convert(*this);
  }

  PathService_GetCacheDir_ResponseParams();
  ~PathService_GetCacheDir_ResponseParams();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  PathService_GetCacheDir_ResponseParamsPtr Clone() const;
  bool Equals(const PathService_GetCacheDir_ResponseParams& other) const;

  mojo::String path;
};


      

class UserFeedback_PerformHapticFeedback_Params;

using UserFeedback_PerformHapticFeedback_ParamsPtr = mojo::InlinedStructPtr<UserFeedback_PerformHapticFeedback_Params>;


size_t GetSerializedSize_(const UserFeedback_PerformHapticFeedback_Params& input);
mojo::internal::ValidationError Serialize_(
    UserFeedback_PerformHapticFeedback_Params* input,
    mojo::internal::Buffer* buffer,
    internal::UserFeedback_PerformHapticFeedback_Params_Data** output);
void Deserialize_(internal::UserFeedback_PerformHapticFeedback_Params_Data* input,
                  UserFeedback_PerformHapticFeedback_Params* output);

class UserFeedback_PerformHapticFeedback_Params {
 public:
  using Data_ = internal::UserFeedback_PerformHapticFeedback_Params_Data;

  static UserFeedback_PerformHapticFeedback_ParamsPtr New();

  template <typename U>
  static UserFeedback_PerformHapticFeedback_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<UserFeedback_PerformHapticFeedback_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UserFeedback_PerformHapticFeedback_Params>::Convert(*this);
  }

  UserFeedback_PerformHapticFeedback_Params();
  ~UserFeedback_PerformHapticFeedback_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  UserFeedback_PerformHapticFeedback_ParamsPtr Clone() const;
  bool Equals(const UserFeedback_PerformHapticFeedback_Params& other) const;

  HapticFeedbackType type;
};




class UserFeedback_PerformAuralFeedback_Params;

using UserFeedback_PerformAuralFeedback_ParamsPtr = mojo::InlinedStructPtr<UserFeedback_PerformAuralFeedback_Params>;


size_t GetSerializedSize_(const UserFeedback_PerformAuralFeedback_Params& input);
mojo::internal::ValidationError Serialize_(
    UserFeedback_PerformAuralFeedback_Params* input,
    mojo::internal::Buffer* buffer,
    internal::UserFeedback_PerformAuralFeedback_Params_Data** output);
void Deserialize_(internal::UserFeedback_PerformAuralFeedback_Params_Data* input,
                  UserFeedback_PerformAuralFeedback_Params* output);

class UserFeedback_PerformAuralFeedback_Params {
 public:
  using Data_ = internal::UserFeedback_PerformAuralFeedback_Params_Data;

  static UserFeedback_PerformAuralFeedback_ParamsPtr New();

  template <typename U>
  static UserFeedback_PerformAuralFeedback_ParamsPtr From(const U& u) {
    return mojo::TypeConverter<UserFeedback_PerformAuralFeedback_ParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UserFeedback_PerformAuralFeedback_Params>::Convert(*this);
  }

  UserFeedback_PerformAuralFeedback_Params();
  ~UserFeedback_PerformAuralFeedback_Params();
  
  // Returns the number of bytes it would take to serialize this struct's data.
  size_t GetSerializedSize() const;

  // Returns true on successful serialization. On failure, part of the data may
  // be serialized, until the point of failure. This API does not support
  // serializing handles. If not null, |bytes_written| is set to the number of
  // bytes written to |buf|, even if this function return false. 
  //
  // TODO(vardhan): For now, we return true for success. Should we define a
  // public error type for serialization? Should we open up
  // internal::ValidationError?
  bool Serialize(void* buf, size_t buf_size, size_t* bytes_written = nullptr);

  // Deserializes the given |buf| of size |buf_size| representing a serialized
  // version of this struct. The buffer is validated before it is deserialized.
  // Returns true on successful deserialization.
  // TODO(vardhan): Recover the validation error if there is one?
  bool Deserialize(void* buf, size_t buf_size);

  // Deserializes the given |buf| representing a serialized version of this
  // struct. The buffer is NOT validated before it is deserialized, so the user
  // must be confident of its validity and that |buf| points to enough data to
  // finish deserializing.
  void DeserializeWithoutValidation(void* buf);


  UserFeedback_PerformAuralFeedback_ParamsPtr Clone() const;
  bool Equals(const UserFeedback_PerformAuralFeedback_Params& other) const;

  AuralFeedbackType type;
};



}  // namespace activity

#endif  // MOJO_SERVICES_ANDROID_INTERFACES_ACTIVITY_MOJOM_COMMON_H_
