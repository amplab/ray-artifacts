// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     mojo/public/interfaces/bindings/tests/sample_interfaces.mojom
//

package sample_interfaces

import (
	sort "sort"
	service_describer "mojo/public/interfaces/bindings/service_describer"
	ioutil "io/ioutil"
	base64 "encoding/base64"
	fmt "fmt"
	bytes "bytes"
	mojom_types "mojo/public/interfaces/bindings/mojom_types"
	bindings "mojo/public/go/bindings"
	system "mojo/public/go/system"
	gzip "compress/gzip"
)

// This global variable contains a mojom_types.RuntimeTypeInfo struct
// describing the types defined in this file and all of its imports as
// well as the top-level interfaces defined in this file.
var runtimeTypeInfo__ = mojom_types.RuntimeTypeInfo{}

func getRuntimeTypeInfo() mojom_types.RuntimeTypeInfo {
  if runtimeTypeInfo__.TypeMap == nil {
    initRuntimeTypeInfo()
  }
  return runtimeTypeInfo__
}

func initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this file.
  // The string contains the base64 encoding of the gzip-compressed bytes.
  serializedRuntimeTypeInfo := "H4sIAAAJbogC/+xbT2/cRBS315sSWiLaJoEN/ecWFfaSOAkSRJw2hxWJINJKgSo5Vc7ukDXK2ovtoJYTRz4GH4Njjxz5GBx75Abj7Hvd8WTGfxKvPU4y0mjifxm/n3/v92bezLa0SbkL7Tq0/Hls57mWv+8NtG1am7SacLwF7QG0Y2gf0rpE6/eHve7Lb7uHXwf2aHxC1rru6Si6/jmtTwTXd92QHBN/u98nQeD5Z/20BPf1fO8XZ0B82f/ZP2ui/+b/aPeJtgPvfZd77+jYoLXXiB/vfBg/fmOJcXkLbUeLl3Wun/+g8Pdh+QDeD/FZpPUOrRxs5/qPnpuj1ab1kFZr6I2INe6PPN8Jf7V8+/Vq3/OJFfh9a+T95Fnj06MTp285iExgHTnuwHGPAyskQRhYkx5fTm9Yi54bMf3qDE/a0JpacsmKz47k+QWw88X2dz90abtC6704Pmt4TYRT9HyjRJxkuMzrk9ZIwaXD4dKT4PIxrRFVeb95TM99NMWHv3wOn+j4don4iPrHY3DFM5614Bjv690S44t+2Gpk453G4Cs6j+U+4PINCQFD8fuvlMwvk8PtbUY90jhebUns/gRsn9q96pOfT+mbie3HUpb98xI9avH+loLXn0YxeD0AzY7hFYw9NyBK4MX7UUuP273Fvd8tLVvJ6l/tlLg3sENb5lcrJeIkwiOKOx1d/P7Ir4bk+VcCPHRmnMQXns+mQB8Npj/Upz3HfUH8wPHcOK7h6zGR4fpFBXqlSXSfH/+kjR95PpsC/9cF/TSgtiRxeov7zjrUrN/11SW/q57yXfH8fko8eqBIPCpKXzEe7Ssaj+qqrxi3VNdXo2R9NS6prxGuq9dQX40UfcXy7wXnh52E7xp9U8wL4LyISxcI8x9VznvaTL5kjsG1AVg2GTzmmPv/hpv/Wpi0vy9O2j9WkudHHWM286Nuf+jthz7FQWznPUXiEc4Pi4pHU7vVike8zol0Vxf44azi0PvQn63J+bFUMj5JcUGmc7PmFcbjGK8UmkfWkVfPasArmV4Pm9N7s+KlJ+g15pWn/AqEuN1XRK87xqz8KogJtmrzh7ZeD/+KeLJcoX/lxWf+AvjoGfA5SsDniaL6w47TZ+1/ON+I+980sN3438X9b/XG/xL976sa+B8f/xG/niHOLyfh1WC+B18egV5HfrhHgsA+Jj1nTHZsd3BCBPgtVjwOQBzMnONrWZ7gOWAgtJ8ZEdRhnN1USIcWK9Qh/RLzt6L59RmtjxP4hRHvhl/5+bVbA37xOv4P7osysu37YPEyEvDCfGfEsyhny+O1VLFuo929nH4lm7e2wDa0F6W6Dn40p5AfLcHfdV2XuGye7qCgPB3uP2P4yGTp6qHvqvHy4TXgpSw+mBAYmjnwbibgHa19vQf83HXDc3gvKxIftILiA673gb3vRvJ18EONWfur2g+XS44PF9XzovnDji8m/JnI+Q1/8vPnkYL8SduPnYZPh+NR2n5s/vcH3H5s/vI5HM2K9yWYTFw2uH0JeN1gnuvAheHt5PWsvHzEfmV+G/Ft4R3eeyQceoN1gT3PtKu1PxvzeDG7Fcpf5d2fLePLQc71Tz2BRzK+bAjweqoIX9aN2fFlQyG+5N0/WVa8uwM657gbQp18Cueq3D9Z5nrLFI9NKR7PK8jT6QWtd/5WkL9hvOf9TZX8r6rrnTjv9k7DDRm/vqyQX3nzKEX7H4PPpgyf7SuaR0laL+XHl1nXS/H3IHnGC5sC3D+9BuPLzRqPL/8PAAD//xIOoRYQPwAA"

  // Deserialize RuntimeTypeInfo
  compressedBytes, err := base64.StdEncoding.DecodeString(serializedRuntimeTypeInfo)
  if err != nil {
    panic(fmt.Sprintf("Error while base64Decoding runtimeTypeInfo: %s", err.Error()))
  }
  reader, err := gzip.NewReader(bytes.NewBuffer(compressedBytes))
  if err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  uncompressedBytes, err := ioutil.ReadAll(reader)
  if err != nil {
     panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  if err = reader.Close(); err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  decoder := bindings.NewDecoder(uncompressedBytes, nil)
  runtimeTypeInfo__.Decode(decoder)

}
func GetAllMojomTypeDefinitions() map[string]mojom_types.UserDefinedType {
  return getRuntimeTypeInfo().TypeMap
}

type Enum int32

const (
	Enum_Value Enum = 0
)
// EnumMojomType returns the UserDefinedType that describes the Mojom
// type of Enum. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func EnumMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.Enum"]
}



// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Enum) MojomType() mojom_types.UserDefinedType {
	return EnumMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Enum) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type Provider interface {
	EchoString(inA string) (outA string, err error)
	EchoStrings(inA string, inB string) (outA string, outB string, err error)
	EchoMessagePipeHandle(inA system.MessagePipeHandle) (outA system.MessagePipeHandle, err error)
	EchoEnum(inA Enum) (outA Enum, err error)
	EchoInt(inA int32) (outA int32, err error)
}


// ProviderMojomType returns the UserDefinedType that describes the Mojom
// type of Provider. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func ProviderMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.Provider"]
}




type Provider_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*Provider_Request) MojomType() mojom_types.UserDefinedType {
	return ProviderMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*Provider_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type Provider_Pointer bindings.InterfacePointer


type Provider_ServiceFactory struct{
	Delegate Provider_Factory
}

type Provider_Factory interface {
	Create(request Provider_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *Provider_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &Provider_ServiceDescription{}
}

func (f *Provider_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := Provider_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForProvider creates a message pipe for use with the
// Provider interface with a Provider_Request on one end and a Provider_Pointer on the other.
func CreateMessagePipeForProvider() (Provider_Request, Provider_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return Provider_Request(r), Provider_Pointer(p)
}

const provider_EchoString_Name uint32 = 0
const provider_EchoStrings_Name uint32 = 1
const provider_EchoMessagePipeHandle_Name uint32 = 2
const provider_EchoEnum_Name uint32 = 3
const provider_EchoInt_Name uint32 = 4

type Provider_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewProviderProxy(p Provider_Pointer, waiter bindings.AsyncWaiter) *Provider_Proxy {
	return &Provider_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *Provider_Proxy) Close_Proxy() {
	p.router.Close()
}

type provider_EchoString_Params struct {
	inA string
}


func (s *provider_EchoString_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inA); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var provider_EchoString_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *provider_EchoString_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(provider_EchoString_Params_Versions), func(i int) bool {
		return provider_EchoString_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(provider_EchoString_Params_Versions) {
		if provider_EchoString_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := provider_EchoString_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inA = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type provider_EchoString_ResponseParams struct {
	outA string
}


func (s *provider_EchoString_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.outA); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var provider_EchoString_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *provider_EchoString_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(provider_EchoString_ResponseParams_Versions), func(i int) bool {
		return provider_EchoString_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(provider_EchoString_ResponseParams_Versions) {
		if provider_EchoString_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := provider_EchoString_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.outA = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Provider_Proxy) EchoString(inA string) (outA string, err error) {
	payload := &provider_EchoString_Params{
		inA,
	}
	header := bindings.MessageHeader{
		Type: provider_EchoString_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, provider_EchoString_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response provider_EchoString_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outA = response.outA
	return
}

type provider_EchoStrings_Params struct {
	inA string
	inB string
}


func (s *provider_EchoStrings_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inA); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.inB); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var provider_EchoStrings_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *provider_EchoStrings_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(provider_EchoStrings_Params_Versions), func(i int) bool {
		return provider_EchoStrings_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(provider_EchoStrings_Params_Versions) {
		if provider_EchoStrings_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := provider_EchoStrings_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inA = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.inB = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type provider_EchoStrings_ResponseParams struct {
	outA string
	outB string
}


func (s *provider_EchoStrings_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.outA); err != nil {
		return err
	}
	if err := encoder.WritePointer(); err != nil {
		return err
	}
	if err := encoder.WriteString(s.outB); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var provider_EchoStrings_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *provider_EchoStrings_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(provider_EchoStrings_ResponseParams_Versions), func(i int) bool {
		return provider_EchoStrings_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(provider_EchoStrings_ResponseParams_Versions) {
		if provider_EchoStrings_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := provider_EchoStrings_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.outA = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			return &bindings.ValidationError{bindings.UnexpectedNullPointer, "unexpected null pointer"}
		} else {
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			s.outB = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Provider_Proxy) EchoStrings(inA string, inB string) (outA string, outB string, err error) {
	payload := &provider_EchoStrings_Params{
		inA,
		inB,
	}
	header := bindings.MessageHeader{
		Type: provider_EchoStrings_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, provider_EchoStrings_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response provider_EchoStrings_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outA = response.outA
	outB = response.outB
	return
}

type provider_EchoMessagePipeHandle_Params struct {
	inA system.MessagePipeHandle
}


func (s *provider_EchoMessagePipeHandle_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteHandle(s.inA); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var provider_EchoMessagePipeHandle_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *provider_EchoMessagePipeHandle_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(provider_EchoMessagePipeHandle_Params_Versions), func(i int) bool {
		return provider_EchoMessagePipeHandle_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(provider_EchoMessagePipeHandle_Params_Versions) {
		if provider_EchoMessagePipeHandle_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := provider_EchoMessagePipeHandle_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.inA = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type provider_EchoMessagePipeHandle_ResponseParams struct {
	outA system.MessagePipeHandle
}


func (s *provider_EchoMessagePipeHandle_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteHandle(s.outA); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var provider_EchoMessagePipeHandle_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *provider_EchoMessagePipeHandle_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(provider_EchoMessagePipeHandle_ResponseParams_Versions), func(i int) bool {
		return provider_EchoMessagePipeHandle_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(provider_EchoMessagePipeHandle_ResponseParams_Versions) {
		if provider_EchoMessagePipeHandle_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := provider_EchoMessagePipeHandle_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		handle0, err := decoder.ReadMessagePipeHandle()
		if err != nil {
			return err
		}
		if handle0.IsValid() {
			s.outA = handle0
		} else {
			return &bindings.ValidationError{bindings.UnexpectedInvalidHandle, "unexpected invalid handle"}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Provider_Proxy) EchoMessagePipeHandle(inA system.MessagePipeHandle) (outA system.MessagePipeHandle, err error) {
	payload := &provider_EchoMessagePipeHandle_Params{
		inA,
	}
	header := bindings.MessageHeader{
		Type: provider_EchoMessagePipeHandle_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, provider_EchoMessagePipeHandle_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response provider_EchoMessagePipeHandle_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outA = response.outA
	return
}

type provider_EchoEnum_Params struct {
	inA Enum
}


func (s *provider_EchoEnum_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.inA)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var provider_EchoEnum_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *provider_EchoEnum_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(provider_EchoEnum_Params_Versions), func(i int) bool {
		return provider_EchoEnum_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(provider_EchoEnum_Params_Versions) {
		if provider_EchoEnum_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := provider_EchoEnum_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inA = Enum(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type provider_EchoEnum_ResponseParams struct {
	outA Enum
}


func (s *provider_EchoEnum_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(int32(s.outA)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var provider_EchoEnum_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *provider_EchoEnum_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(provider_EchoEnum_ResponseParams_Versions), func(i int) bool {
		return provider_EchoEnum_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(provider_EchoEnum_ResponseParams_Versions) {
		if provider_EchoEnum_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := provider_EchoEnum_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outA = Enum(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Provider_Proxy) EchoEnum(inA Enum) (outA Enum, err error) {
	payload := &provider_EchoEnum_Params{
		inA,
	}
	header := bindings.MessageHeader{
		Type: provider_EchoEnum_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, provider_EchoEnum_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response provider_EchoEnum_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outA = response.outA
	return
}

type provider_EchoInt_Params struct {
	inA int32
}


func (s *provider_EchoInt_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.inA); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var provider_EchoInt_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *provider_EchoInt_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(provider_EchoInt_Params_Versions), func(i int) bool {
		return provider_EchoInt_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(provider_EchoInt_Params_Versions) {
		if provider_EchoInt_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := provider_EchoInt_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inA = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type provider_EchoInt_ResponseParams struct {
	outA int32
}


func (s *provider_EchoInt_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(8, 0)
	if err := encoder.WriteInt32(s.outA); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var provider_EchoInt_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
}

func (s *provider_EchoInt_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(provider_EchoInt_ResponseParams_Versions), func(i int) bool {
		return provider_EchoInt_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(provider_EchoInt_ResponseParams_Versions) {
		if provider_EchoInt_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := provider_EchoInt_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outA = value0
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *Provider_Proxy) EchoInt(inA int32) (outA int32, err error) {
	payload := &provider_EchoInt_Params{
		inA,
	}
	header := bindings.MessageHeader{
		Type: provider_EchoInt_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, provider_EchoInt_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response provider_EchoInt_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outA = response.outA
	return
}

type provider_Stub struct {
	connector *bindings.Connector
	impl Provider
}

func NewProviderStub(r Provider_Request, impl Provider, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &provider_Stub{connector, impl})
}


func (f *Provider_Request) ServiceDescription() service_describer.ServiceDescription {
	return &Provider_ServiceDescription{}
}


type Provider_ServiceDescription struct{}

func (sd *Provider_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *Provider_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *Provider_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*Provider_ServiceDescription)(nil)


func (s *provider_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case provider_EchoString_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request provider_EchoString_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response provider_EchoString_ResponseParams
		response.outA, err = s.impl.EchoString(request.inA)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: provider_EchoString_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case provider_EchoStrings_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request provider_EchoStrings_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response provider_EchoStrings_ResponseParams
		response.outA, 		response.outB, err = s.impl.EchoStrings(request.inA, request.inB)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: provider_EchoStrings_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case provider_EchoMessagePipeHandle_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request provider_EchoMessagePipeHandle_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response provider_EchoMessagePipeHandle_ResponseParams
		response.outA, err = s.impl.EchoMessagePipeHandle(request.inA)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: provider_EchoMessagePipeHandle_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case provider_EchoEnum_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request provider_EchoEnum_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response provider_EchoEnum_ResponseParams
		response.outA, err = s.impl.EchoEnum(request.inA)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: provider_EchoEnum_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case provider_EchoInt_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request provider_EchoInt_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response provider_EchoInt_ResponseParams
		response.outA, err = s.impl.EchoInt(request.inA)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: provider_EchoInt_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type IntegerAccessor interface {
	GetInteger() (outData int64, outType Enum, err error)
	SetInteger(inData int64, inType Enum) (err error)
}


// IntegerAccessorMojomType returns the UserDefinedType that describes the Mojom
// type of IntegerAccessor. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func IntegerAccessorMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.IntegerAccessor"]
}




type IntegerAccessor_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*IntegerAccessor_Request) MojomType() mojom_types.UserDefinedType {
	return IntegerAccessorMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*IntegerAccessor_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type IntegerAccessor_Pointer bindings.InterfacePointer


type IntegerAccessor_ServiceFactory struct{
	Delegate IntegerAccessor_Factory
}

type IntegerAccessor_Factory interface {
	Create(request IntegerAccessor_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *IntegerAccessor_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &IntegerAccessor_ServiceDescription{}
}

func (f *IntegerAccessor_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := IntegerAccessor_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForIntegerAccessor creates a message pipe for use with the
// IntegerAccessor interface with a IntegerAccessor_Request on one end and a IntegerAccessor_Pointer on the other.
func CreateMessagePipeForIntegerAccessor() (IntegerAccessor_Request, IntegerAccessor_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return IntegerAccessor_Request(r), IntegerAccessor_Pointer(p)
}

const integerAccessor_GetInteger_Name uint32 = 0
const integerAccessor_SetInteger_Name uint32 = 1

type IntegerAccessor_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewIntegerAccessorProxy(p IntegerAccessor_Pointer, waiter bindings.AsyncWaiter) *IntegerAccessor_Proxy {
	return &IntegerAccessor_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *IntegerAccessor_Proxy) Close_Proxy() {
	p.router.Close()
}

type integerAccessor_GetInteger_Params struct {
}


func (s *integerAccessor_GetInteger_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var integerAccessor_GetInteger_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *integerAccessor_GetInteger_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(integerAccessor_GetInteger_Params_Versions), func(i int) bool {
		return integerAccessor_GetInteger_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(integerAccessor_GetInteger_Params_Versions) {
		if integerAccessor_GetInteger_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := integerAccessor_GetInteger_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type integerAccessor_GetInteger_ResponseParams struct {
	outData int64
	outType Enum
}


func (s *integerAccessor_GetInteger_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 2)
	if err := encoder.WriteInt64(s.outData); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.outType)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var integerAccessor_GetInteger_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
	bindings.DataHeader{24, 2},
}

func (s *integerAccessor_GetInteger_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(integerAccessor_GetInteger_ResponseParams_Versions), func(i int) bool {
		return integerAccessor_GetInteger_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(integerAccessor_GetInteger_ResponseParams_Versions) {
		if integerAccessor_GetInteger_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := integerAccessor_GetInteger_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.outData = value0
	}
	if header.ElementsOrVersion >= 2 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outType = Enum(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *IntegerAccessor_Proxy) GetInteger() (outData int64, outType Enum, err error) {
	payload := &integerAccessor_GetInteger_Params{
	}
	header := bindings.MessageHeader{
		Type: integerAccessor_GetInteger_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, integerAccessor_GetInteger_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response integerAccessor_GetInteger_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outData = response.outData
	outType = response.outType
	return
}

type integerAccessor_SetInteger_Params struct {
	inData int64
	inType Enum
}


func (s *integerAccessor_SetInteger_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 3)
	if err := encoder.WriteInt64(s.inData); err != nil {
		return err
	}
	if err := encoder.WriteInt32(int32(s.inType)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var integerAccessor_SetInteger_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{16, 0},
	bindings.DataHeader{24, 3},
}

func (s *integerAccessor_SetInteger_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(integerAccessor_SetInteger_Params_Versions), func(i int) bool {
		return integerAccessor_SetInteger_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(integerAccessor_SetInteger_Params_Versions) {
		if integerAccessor_SetInteger_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := integerAccessor_SetInteger_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt64()
		if err != nil {
			return err
		}
		s.inData = value0
	}
	if header.ElementsOrVersion >= 3 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inType = Enum(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *IntegerAccessor_Proxy) SetInteger(inData int64, inType Enum) (err error) {
	payload := &integerAccessor_SetInteger_Params{
		inData,
		inType,
	}
	header := bindings.MessageHeader{
		Type: integerAccessor_SetInteger_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type integerAccessor_Stub struct {
	connector *bindings.Connector
	impl IntegerAccessor
}

func NewIntegerAccessorStub(r IntegerAccessor_Request, impl IntegerAccessor, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &integerAccessor_Stub{connector, impl})
}


func (f *IntegerAccessor_Request) ServiceDescription() service_describer.ServiceDescription {
	return &IntegerAccessor_ServiceDescription{}
}


type IntegerAccessor_ServiceDescription struct{}

func (sd *IntegerAccessor_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *IntegerAccessor_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *IntegerAccessor_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*IntegerAccessor_ServiceDescription)(nil)


func (s *integerAccessor_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case integerAccessor_GetInteger_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request integerAccessor_GetInteger_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response integerAccessor_GetInteger_ResponseParams
		response.outData, 		response.outType, err = s.impl.GetInteger()
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: integerAccessor_GetInteger_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case integerAccessor_SetInteger_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request integerAccessor_SetInteger_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SetInteger(request.inData, request.inType)
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

type SampleInterface interface {
	SampleMethod1(inIn1 int32, inIn2 *string) (outOut1 *string, outOut2 Enum, err error)
	SampleMethod0() (err error)
	SampleMethod2() (err error)
}


// SampleInterfaceMojomType returns the UserDefinedType that describes the Mojom
// type of SampleInterface. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function GetAllMojomTypeDefinitions().
func SampleInterfaceMojomType() mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()["TYPE_KEY:sample.SampleInterface"]
}




type SampleInterface_Request bindings.InterfaceRequest


// MojomType returns the UserDefinedType that describes the Mojom
// type of this object. To obtain the UserDefinedType for Mojom types recursively
// contained in the returned UserDefinedType, look in the map returned
// by the function AllMojomTypes().
func (*SampleInterface_Request) MojomType() mojom_types.UserDefinedType {
	return SampleInterfaceMojomType()
}

// AllMojomTypes returns a map that contains the UserDefinedType for
// all Mojom types in the complete type graph of the Mojom type of this object.
func (*SampleInterface_Request) AllMojomTypes() map[string]mojom_types.UserDefinedType {
	return GetAllMojomTypeDefinitions()
}


type SampleInterface_Pointer bindings.InterfacePointer


type SampleInterface_ServiceFactory struct{
	Delegate SampleInterface_Factory
}

type SampleInterface_Factory interface {
	Create(request SampleInterface_Request)
}


// TODO(rudominer) This should only be defined for top-level interfaces.
func (f *SampleInterface_ServiceFactory) ServiceDescription() service_describer.ServiceDescription {
	return &SampleInterface_ServiceDescription{}
}

func (f *SampleInterface_ServiceFactory) Create(messagePipe system.MessagePipeHandle) {
	request := SampleInterface_Request{bindings.NewMessagePipeHandleOwner(messagePipe)}
	f.Delegate.Create(request)
}

// CreateMessagePipeForSampleInterface creates a message pipe for use with the
// SampleInterface interface with a SampleInterface_Request on one end and a SampleInterface_Pointer on the other.
func CreateMessagePipeForSampleInterface() (SampleInterface_Request, SampleInterface_Pointer) {
        r, p := bindings.CreateMessagePipeForMojoInterface()
        return SampleInterface_Request(r), SampleInterface_Pointer(p)
}

const sampleInterface_SampleMethod1_Name uint32 = 1
const sampleInterface_SampleMethod0_Name uint32 = 0
const sampleInterface_SampleMethod2_Name uint32 = 2

type SampleInterface_Proxy struct {
	router *bindings.Router
	ids bindings.Counter
}

func NewSampleInterfaceProxy(p SampleInterface_Pointer, waiter bindings.AsyncWaiter) *SampleInterface_Proxy {
	return &SampleInterface_Proxy{
		bindings.NewRouter(p.PassMessagePipe(), waiter),
		bindings.NewCounter(),
	}
}

func (p *SampleInterface_Proxy) Close_Proxy() {
	p.router.Close()
}

type sampleInterface_SampleMethod1_Params struct {
	inIn1 int32
	inIn2 *string
}


func (s *sampleInterface_SampleMethod1_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if err := encoder.WriteInt32(s.inIn1); err != nil {
		return err
	}
	if s.inIn2 == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.inIn2)); err != nil {
			return err
		}
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var sampleInterface_SampleMethod1_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *sampleInterface_SampleMethod1_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(sampleInterface_SampleMethod1_Params_Versions), func(i int) bool {
		return sampleInterface_SampleMethod1_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(sampleInterface_SampleMethod1_Params_Versions) {
		if sampleInterface_SampleMethod1_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := sampleInterface_SampleMethod1_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.inIn1 = value0
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.inIn2 = nil
		} else {
			s.inIn2 = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.inIn2) = value0
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

type sampleInterface_SampleMethod1_ResponseParams struct {
	outOut1 *string
	outOut2 Enum
}


func (s *sampleInterface_SampleMethod1_ResponseParams) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(16, 0)
	if s.outOut1 == nil {
		encoder.WriteNullPointer()
	} else {
		if err := encoder.WritePointer(); err != nil {
			return err
		}
		if err := encoder.WriteString((*s.outOut1)); err != nil {
			return err
		}
	}
	if err := encoder.WriteInt32(int32(s.outOut2)); err != nil {
		return err
	}
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var sampleInterface_SampleMethod1_ResponseParams_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{24, 0},
}

func (s *sampleInterface_SampleMethod1_ResponseParams) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(sampleInterface_SampleMethod1_ResponseParams_Versions), func(i int) bool {
		return sampleInterface_SampleMethod1_ResponseParams_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(sampleInterface_SampleMethod1_ResponseParams_Versions) {
		if sampleInterface_SampleMethod1_ResponseParams_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := sampleInterface_SampleMethod1_ResponseParams_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if header.ElementsOrVersion >= 0 {
		pointer0, err := decoder.ReadPointer()
		if err != nil {
			return err
		}
		if pointer0 == 0 {
			s.outOut1 = nil
		} else {
			s.outOut1 = new(string)
			value0, err := decoder.ReadString()
			if err != nil {
				return err
			}
			(*s.outOut1) = value0
		}
	}
	if header.ElementsOrVersion >= 0 {
		value0, err := decoder.ReadInt32()
		if err != nil {
			return err
		}
		s.outOut2 = Enum(value0)
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *SampleInterface_Proxy) SampleMethod1(inIn1 int32, inIn2 *string) (outOut1 *string, outOut2 Enum, err error) {
	payload := &sampleInterface_SampleMethod1_Params{
		inIn1,
		inIn2,
	}
	header := bindings.MessageHeader{
		Type: sampleInterface_SampleMethod1_Name,
		Flags: bindings.MessageExpectsResponseFlag,
		RequestId: p.ids.Count(),
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	readResult := <-p.router.AcceptWithResponse(message)
	if err = readResult.Error; err != nil {
		p.Close_Proxy()
		return
	}
	if readResult.Message.Header.Flags != bindings.MessageIsResponseFlag {
		err = &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
			fmt.Sprintf("invalid message header flag: %v", readResult.Message.Header.Flags),
		}
		return
	}
	if got, want := readResult.Message.Header.Type, sampleInterface_SampleMethod1_Name; got != want {
		err = &bindings.ValidationError{bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("invalid method in response: expected %v, got %v", want, got),
		}
		return
	}
	var response sampleInterface_SampleMethod1_ResponseParams
	if err = readResult.Message.DecodePayload(&response); err != nil {
		p.Close_Proxy()
		return
	}
	outOut1 = response.outOut1
	outOut2 = response.outOut2
	return
}

type sampleInterface_SampleMethod0_Params struct {
}


func (s *sampleInterface_SampleMethod0_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var sampleInterface_SampleMethod0_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *sampleInterface_SampleMethod0_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(sampleInterface_SampleMethod0_Params_Versions), func(i int) bool {
		return sampleInterface_SampleMethod0_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(sampleInterface_SampleMethod0_Params_Versions) {
		if sampleInterface_SampleMethod0_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := sampleInterface_SampleMethod0_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *SampleInterface_Proxy) SampleMethod0() (err error) {
	payload := &sampleInterface_SampleMethod0_Params{
	}
	header := bindings.MessageHeader{
		Type: sampleInterface_SampleMethod0_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type sampleInterface_SampleMethod2_Params struct {
}


func (s *sampleInterface_SampleMethod2_Params) Encode(encoder *bindings.Encoder) error {
	encoder.StartStruct(0, 0)
	if err := encoder.Finish(); err != nil {
		return err
	}
	return nil
}

var sampleInterface_SampleMethod2_Params_Versions []bindings.DataHeader = []bindings.DataHeader{
	bindings.DataHeader{8, 0},
}

func (s *sampleInterface_SampleMethod2_Params) Decode(decoder *bindings.Decoder) error {
	header, err := decoder.StartStruct()
	if err != nil {
		return err
	}
	index := sort.Search(len(sampleInterface_SampleMethod2_Params_Versions), func(i int) bool {
		return sampleInterface_SampleMethod2_Params_Versions[i].ElementsOrVersion >= header.ElementsOrVersion
	})
	if index < len(sampleInterface_SampleMethod2_Params_Versions) {
		if sampleInterface_SampleMethod2_Params_Versions[index].ElementsOrVersion > header.ElementsOrVersion {
			index--
		}
		expectedSize := sampleInterface_SampleMethod2_Params_Versions[index].Size
		if expectedSize != header.Size {
			return &bindings.ValidationError{bindings.UnexpectedStructHeader,
				fmt.Sprintf("invalid struct header size: should be %d, but was %d", expectedSize, header.Size),
			}
		}
	}
	if err := decoder.Finish(); err != nil {
		return err
	}
	return nil
}

func (p *SampleInterface_Proxy) SampleMethod2() (err error) {
	payload := &sampleInterface_SampleMethod2_Params{
	}
	header := bindings.MessageHeader{
		Type: sampleInterface_SampleMethod2_Name,
		Flags: bindings.MessageNoFlag,
	}
	var message *bindings.Message
	if message, err = bindings.EncodeMessage(header, payload); err != nil {
		err = fmt.Errorf("can't encode request: %v", err.Error())
		p.Close_Proxy()
		return
	}
	if err = p.router.Accept(message); err != nil {
		p.Close_Proxy()
		return
	}
	return
}

type sampleInterface_Stub struct {
	connector *bindings.Connector
	impl SampleInterface
}

func NewSampleInterfaceStub(r SampleInterface_Request, impl SampleInterface, waiter bindings.AsyncWaiter) *bindings.Stub {
	connector := bindings.NewConnector(r.PassMessagePipe(), waiter)
	return bindings.NewStub(connector, &sampleInterface_Stub{connector, impl})
}


func (f *SampleInterface_Request) ServiceDescription() service_describer.ServiceDescription {
	return &SampleInterface_ServiceDescription{}
}


type SampleInterface_ServiceDescription struct{}

func (sd *SampleInterface_ServiceDescription) GetTopLevelInterface() (outMojomInterface mojom_types.MojomInterface, err error) {
	err = fmt.Errorf("GetTopLevelInterface not implemented")
	return
}

func (sd *SampleInterface_ServiceDescription) GetTypeDefinition(inTypeKey string) (outType mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetTypeDefinition not implemented")
	return
}

func (sd *SampleInterface_ServiceDescription) GetAllTypeDefinitions() (outDefinitions *map[string]mojom_types.UserDefinedType, err error) {
	err = fmt.Errorf("GetAllTypeDefinitions not implemented")
	return
}
var _ service_describer.ServiceDescription = (*SampleInterface_ServiceDescription)(nil)


func (s *sampleInterface_Stub) Accept(message *bindings.Message) (err error) {
	switch message.Header.Type {
	case sampleInterface_SampleMethod1_Name:
		if message.Header.Flags != bindings.MessageExpectsResponseFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request sampleInterface_SampleMethod1_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		var response sampleInterface_SampleMethod1_ResponseParams
		response.outOut1, 		response.outOut2, err = s.impl.SampleMethod1(request.inIn1, request.inIn2)
		if err != nil {
			return
		}
		header := bindings.MessageHeader{
			Type: sampleInterface_SampleMethod1_Name,
			Flags: bindings.MessageIsResponseFlag,
			RequestId: message.Header.RequestId,
		}
		message, err = bindings.EncodeMessage(header, &response)
		if err != nil {
			return err
		}
		return s.connector.WriteMessage(message)
	case sampleInterface_SampleMethod0_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request sampleInterface_SampleMethod0_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SampleMethod0()
		if err != nil {
			return
		}
	case sampleInterface_SampleMethod2_Name:
		if message.Header.Flags != bindings.MessageNoFlag {
			return &bindings.ValidationError{bindings.MessageHeaderInvalidFlags,
				fmt.Sprintf("invalid message header flag: %v", message.Header.Flags),
			}
		}
		var request sampleInterface_SampleMethod2_Params
		if err := message.DecodePayload(&request); err != nil {
			return err
		}
		err = s.impl.SampleMethod2()
		if err != nil {
			return
		}
	default:
		return &bindings.ValidationError{
			bindings.MessageHeaderUnknownMethod,
			fmt.Sprintf("unknown method %v", message.Header.Type),
		}
	}
	return
}

